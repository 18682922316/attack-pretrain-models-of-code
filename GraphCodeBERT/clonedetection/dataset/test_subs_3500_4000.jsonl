{"id1": "14783950", "id2": "4686922", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithoutExt", "composeWithoutzip", "compresswithzip", "compressWithoutFiles", "composeWithZip", "compressByExt", "composeWithoutExt", "compressByFiles", "compressWithzip", "compressWithFiles", "compresswithFiles", "compressByZip", "compressWithoutZip", "composeWithExt", "compresswithExt", "composeWithoutZip", "compressWithoutzip", "compresswithZip", "composeWithoutFiles", "compressByzip", "composeWithFiles", "compressWithExt", "composeWithzip"], "fileList": ["ileL", "fileSet", " FileList", "pagelist", "pageList", "itemLock", "fileLIST", "ileList", "resourceNames", " filelist", " fileNames", "itemList", "filelist", "fileL", "itemNames", " FileSet", "pageSet", "wordIterator", "pageL", "tileLIST", "wordLIST", " fileL", "tileList", " fileCode", "fileIterator", " fileLock", "pageCode", "tileIterator", " FileLIST", "fileLock", "wordSet", "resourceList", "tileSet", " fileLIST", "ileLIST", "wordList", " fileSet", "ilelist", "fileCode", "pageLIST", "resourceLock", "fileNames", " fileIterator", " FileCode"], "zipFileName": ["zipFilenameNames", "zipFilenameName", "zipilename", "zipDirNames", "zipFileFilename", " zipfileFilename", "zipFilename", "zipfilePath", "zipfileNames", "zipFileNames", "zFilenamePath", "zipfilename", " zipfileName", "zipfileName", "zipileFilename", "zFilename", "zFilenameName", " zipFilePath", "zipFilenamePath", "zFilenameFilename", "zipDirName", " zipFileNames", "zFileName", " zipfilePath", "zipDirFilename", "zipileName", "zipFilenamename", "zipFilenameFilename", "zFilenamename", " zipFileFilename", " zipfileNames", "zFileFilename", "zipilePath", "zipFilePath", "zipfileFilename", "zFilePath", "zipDirPath"], "fos": ["Foos", "wos", "foss", "lfoos", " foos", "flis", "lfos", "Foss", "loss", "woss", "lfOS", "FOS", "wOS", "foos", "flos", "fOS", "woos", "loos", "Fos", "flOS", "lOS", "floos", " fOS", "los", "lfis"], "zos": ["sis", "zan", "z", "css", "hz", "zes", "zh", "zag", "enos", "bes", "ze", "hess", "ss", "zero", "zen", "webkit", "js", "rez", "han", "iners", "rys", "zers", "zik", "eros", "zar", "zzle", "ses", "zi", "ess", "ez", "zer", "jas", "enz", "cz", "less", "zip", "oss", "ippers", "zon", "iaz", "es", "os", "zb", "zu", "nz", "Sax", "ossus", "los", "zo", "sbm", "ws", "ps", "za", "zin"], "iter": ["loc", "iv", "el", "ipper", "here", "gener", "exp", "ir", "ger", "where", "er", "list", "Iterator", "cer", "iterator", "order", "user", "ait", "oper", "valid", "orient", "fer", "walker", "maker", "it", "loader", "kit", "li", "re", "ter", "ator", "ser", "iner", "izer", "ver", "ptr", "vis", "tr", "reader", "is", "inter", "train", "loop", "liter", "i", "former", "ner", "inner", "iver", "ip", "coll", "its", "ee", "Iter", "outer"], "fileName": ["shortname", "shortStore", "fBody", "localname", "tableName", " fileBody", "fieldName", "tableSet", "fileSet", "shortSource", "FileString", "fString", " fileNumber", "ileList", "fileString", "ileName", "ileSet", "localName", " fileNames", " fileStore", "fNumber", " fileCurrent", "ileSource", "localList", "Filename", "ileNumber", "getName", "fName", " filename", "fileSource", "ileBody", "tablePath", "fname", "fileBody", "getStore", "fileNAME", " fileSource", "ileCurrent", "ileString", " fileString", "fSource", "FilePath", "fileCurrent", "fieldNAME", "fileStore", "ilePath", "fieldname", " fileSet", "ilename", " filePath", "ileNAME", "filePath", "filename", "fieldList", "localNAME", "FileCurrent", "fileNumber", "fileNames", "FileName", "getSource", "FileNames", "fNames", "getname"], "ind": ["div", "loc", "butt", "num", "bind", "pred", "dj", "inder", "seed", "red", "dial", "nd", "count", "typ", "med", "ent", "inn", "ded", "stick", "cand", "Ind", "mod", "cod", "sign", "j", "req", "md", "roll", "ptr", "pos", "cond", "inc", "IND", "hend", "mind", "d", "i", "pl", "ld", "find", "td", "cd", "wind", "att", "kind", "draw", "index", "n"], "shortName": ["ShortKey", "shortname", "fullName", "ShortName", "recentFilename", "fullString", "shortType", "recentName", "shortCode", "smallname", "shortFilename", "quickString", " shortType", "recentCode", "smallName", "ShortString", "smallFilename", "fullname", "quickname", "shortString", "fullType", "quickKey", "shortKey", " shortString", " shortKey", "smallCode", " shortname", "quickName", "recentname", "ShortType", "ShortFilename", "Shortname", "ShortCode"], "fis": ["FIs", "wi", "pois", "cfris", "sfIs", "sfois", " fris", "sfi", "wois", "wis", "his", "fIs", "pis", "Fis", "wIs", "cfi", "fris", "sfis", "cfis", "hris", "Fris", "ufis", " fIs", "hois", "hi", "ufris", "fi", "fois", "ufIs", "ufi", "ufois", "cfois", "pris", "pi"], "buf": ["arr", "cmd", "bl", "var", "b", "vec", "bed", "uf", "box", "ref", "buffer", "aka", "block", "bin", "pkg", "fb", "bar", "fam", "cap", "cv", "orig", "img", "wb", "bag", "fg", "seq", "Buff", "batch", "msg", "tr", "br", "mem", "bus", "cur", "bc", "conv", "db", "cat", "tab", "Buffer", "rb", "mu", "buff", "bytes", "cb", "temp"], "bytesRead": [" bytesWrite", "blocksRead", "linesRead", "BytesLength", "bytesLoad", " bytesLength", "bytesNeed", "bytesReady", "blocksLoad", "bytesLength", "bytesWritten", "usersRead", " bytesWritten", "secondsRead", "BytesNeed", "secondsLoad", "linesLength", "BytesRead", "usersReady", "bytesFind", "flowsReady", " bytesNeed", "postsFind", "linesWritten", "linesNeed", "flowsFind", "usersFind", "postsReady", "blocksWrite", "postsLoad", "blocksWritten", "BytesWritten", "postsRead", "usersLoad", " bytesLoad", "flowsLoad", "secondsWritten", "bytesWrite", "flowsRead", "secondsWrite"]}}
{"id1": "6190356", "id2": "21063400", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldMD4", " hashPasswordForoldMD5", " hashPasswordForOldSHA5", " hashPasswordForOldSHA1", " hashPasswordForOldMD1", " hashPasswordForoldMDHash", " hashPasswordForOldMBHash", " hashPasswordForOldMDHash", " hashPasswordForOldSHA4", " hashPasswordForoldMD4", " hashPasswordForoldMD1", " hashPasswordForOldSHAHash", " hashPasswordForOldMB4", " hashPasswordForOldMB5", " hashPasswordForOldMB1"], "password": ["value", "words", "Password", "p", "pattern", "data", "message", "sword", "description", "secret", "string", "token", "user", "phrase", "database", "entry", "raw", "text", "login", "attribute", "prefix", "address", "hash", "word", "name", "username", "input", "pass", "wd", "reset", "shadow", "default", "padding", "wordpress", "command"], "md": ["del", "pdf", "cmd", "dd", "dr", "mt", " MD", "der", "mode", "red", "sha", "deep", "dh", "mk", "sd", "od", "ms", "m", "mm", "pm", "pd", "mod", "ds", "down", "and", "add", "de", "dir", "mc", "mn", " Md", "df", "dm", "mand", "det", "ind", "mb", "dig", "cmp", "grad", "ld", "di", "cd", "bd", "ct", "hd", "d", "MD", "sm"], "messageDigest": ["Messagedigist", "messageDigitalested", "messageDesignested", " messagedigested", "messageDrise", " messagedigEST", " messageDigested", "messageDesignist", "messageDigitalest", "messageDigitalEST", "messageDriest", "Messagedigse", "messageDatatest", "messagedigest", "messageDigester", "messagedigse", "messagedigester", "Messagedigester", "messagedigtest", "Messagedigtest", "messageDigested", "messageDigear", "messageDriear", "Messagedigear", "MessagedigEST", "messageDesignEST", "MessageDigtest", "messageDigEST", "messageWithear", "messageWithist", "messageDataester", " messagedigist", "messageDataEST", "messageDriist", "messageWithest", "MessageDigest", "messageDataest", "MessageDigist", "messageDigse", "messagedigEST", "messagedigear", " messageDigEST", "MessageDigear", "messageDigtest", "messageDesignest", "messagedigist", "Messagedigest", "MessageDigester", "messageDigitalist", "MessageDigEST", " messagedigest", " messageDigist", "messageDigist", "messagedigested", "messageWithse", "MessageDigse"], "hexString": [" HexString", " HexChain", "hexRest", "octString", " hexResponse", " hexRest", " hexStr", "hexBuffer", "phpSite", "exString", " hexArray", "hexSet", "hexStr", "hexChain", "octArray", "hexArray", "octResponse", " HexArray", " hexChain", " hexSet", "exStr", " HexResponse", "phpBuffer", "exBuffer", " hexSite", "hexResponse", "phpChain", " HexStr", "hexSite", "phpRest", " HexBuffer", " HexSite", " hexstring", "hexSingle", " HexSet", " hexBuffer", "colorBuffer", "hexstring", "colorSet", "colorStr", " HexRest", " Hexstring", "exSingle", "phpStr", "octstring", " hexSingle", "phpSingle", "colorString", "phpString"], "i": ["mi", "z", "u", "id", "ix", "ini", "I", "ii", "si", "e", "ai", "bi", "chain", "yi", "n", "q", "my", "m", "sim", "set", "in", "ic", "multi", "it", "c", "li", "ti", "a", "j", "ij", "init", "key", "x", "hi", "ji", "ie", "zi", "phi", "y", "ind", "is", "ui", "loop", "gu", "uri", "g", "di", "gi", "conv", "ci", "ip", "ski", "t", "o", "qi", "im", "index", "pi"], "hex": ["mix", "sh", "exp", "cf", "com", "ex", "red", "solid", "alph", "hl", " Hex", "php", "prof", "EX", "form", "print", "percent", "rendered", "raw", "it", "imal", "ph", "tex", "sv", "rex", "dump", "x", "xf", "hi", "none", "flash", "zip", "def", "pex", "check", "h", "br", "full", "serial", "comp", "lit", "json", "row", "prop", "oct", "tx", "sex", "ext", "html", "hello", "cont"]}}
{"id1": "21824901", "id2": "13516684", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyExternalResource": ["copyOptionalresource", "copyexternalResources", "copyInternalResource", "downloadExternalResource", "copyExternalReference", "copyExternalresource", "copyOptionalResource", "downloadexternalResources", "downloadexternalresource", "copyexternalReference", "downloadexternalResource", "downloadExternalresource", "downloadExternalResources", "copyexternalresource", "copyOptionalReference", "downloadexternalReference", "copyOptionalResources", "copyExternalResources", "copyInternalresource", "copyInternalReference", "copyexternalResource", "downloadExternalReference", "copyInternalResources"], "sourceFile": ["sourcePage", "SourceFile", "ourceChain", "ourceFile", " sourceLine", " sourcePath", "srcLine", "destPath", "sourcePath", "sourceLine", "ourceFilename", " sourceFilename", "SourceDir", " sourcePage", " sourceDir", "ourceDir", "srcFile", "srcPage", "SourceChain", "sourceDir", "sourceChain", "destLine", "SourceFilename", "sourceFilename", " sourceChain", "destPage", "srcPath"], "destFile": ["locFILE", "srcDir", "destFilename", " destfile", "destfile", "optPlace", "srcFILE", "DestFilename", "critDir", "destDir", "optDir", "critFilename", "optFiles", "critfile", "srcPlace", "destPath", "DestDir", "destFiles", "destPlace", "DestFiles", "srcfile", " destPlace", "locDir", "optFile", "Destfile", "critFile", " destFilename", "srcFiles", " destDir", "srcFile", "DestFile", "srcPath", " destPath", "destFILE", "locPath", " destFiles", "locFile", " destFILE"], "source": ["image", "update", "scope", "copy", "store", "search", "stream", "shell", "style", "SOURCE", "match", "channel", "archive", "cache", "service", "back", "iterator", "cause", "target", "owner", "origin", "sequence", "ource", "src", "subject", "local", "from", "in", "resource", "table", "load", "score", "init", "session", "sql", "query", "connection", "console", "ie", "body", "proxy", "parent", "address", "none", "less", "reader", "before", "force", "base", "check", "input", "se", "create", "inner", "iter", "start", "Source", "sample", "series", "ce", "use", "pose", "component", "index", "result"], "destination": ["Destuation", "potation", " destinated", "catinator", "compinator", "potination", " destinator", "compinated", "combination", "potociation", "Destination", "notinated", "destociation", "Destinated", "destuation", "Destinator", "catinated", " destuation", "notinator", "catinate", "potinator", "notinate", "catination", "destation", "destinate", "notination", "Destation", " destation", "descinate", "compation", "compination", "descination", "descinated", "combinator", "combinated", "descinator", "combuation", "Destociation", " destociation", "destinated", "destinator"]}}
{"id1": "15799935", "id2": "21488868", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveExtachmentPart", "saveAttachedPart", "saveAttachablebody", "saveAttachableFile", "saveAttachablePart", "saveAttachmentFile", "saveAttentionBody", "saveAttachmentPart", "saveExtachmentbody", "saveAttachedbody", "saveAttachableBody", "saveExtachedbody", "saveAttachmentbody", "saveAttentionPart", "saveAttachedBody", "saveAttentionFile", "saveExtachmentBody", "saveAttentionbody", "saveExtachmentFile", "saveExtachedPart", "saveExtachedFile", "saveExtachedBody"], "context": ["host", "translation", "container", "search", "comments", "present", "cf", "cache", "message", "support", "instance", "service", "cc", "content", "environment", "chain", "stack", "state", "ctx", "subject", "network", "application", "request", "view", "frame", "response", "connection", "document", "course", "parent", "java", "system", "current", "client", "template", "config", "foundation", "null", "center", "version", "tx", "background", "ce", "media", "contact", "command", "component", "history", "Context"], "part": ["host", "top", "reply", "PART", "patch", "p", "work", "zone", "data", "task", "message", "instance", "pair", "thread", "partial", "art", "block", "join", "post", "add", "trans", "Part", "session", "piece", "report", "connection", "file", "component", "body", "tmp", "parent", "base", "sp", "name", "word", "se", "parts", "start", "type", "version", "tx", "bound", "sample", "pod", "and", "job", "temp"], "localAttachment": [" localAttail", "localAssail", "localDetachment", " localDetachment", "localDetignment", " localAttached", "localAssached", "localAppachment", "localAssment", " localAttignment", "localAttachached", "localDetail", "localAttachail", "localAppention", " localAttment", "localAttment", "localAttached", "localATTention", " localAttachignment", " localAttachention", "localAppached", "localAttail", " localAssached", " localDetignment", "localAcached", "localAcignment", "localAttention", "localattention", "localAttachignment", "localattachment", "localAssignment", "localAssention", "localAssachment", " localAttention", " localDetached", "localDetached", "localAppail", "localAcachment", "localAttignment", " localAssention", "localATTignment", "localATTment", "localATTachment", "localAttachachment", "localAttachention", " localAttachached", " localAssail", "localDetention", "localattached", " localDetail", " localAttachachment", " localAssachment", "localAcail"], "accountId": ["accountName", "accS", "objectById", "amountId", "containerID", "objectName", "amountDb", "accountDb", "containerId", "accID", "bankId", "accNum", "containerNum", "accountAnd", " accountInt", " accountNum", "AccountName", "objectId", " accountDb", "containerInt", "accId", "accountS", "accAnd", "accDb", "amountInt", "accountInt", "AccountId", "AccountById", " accountAnd", "bankAnd", "accountNum", "AccountID", "amountID", "accountID", "bankID", " accountID", "bankS", "objectID", "accountById", " accountById", " accountS", "accInt", " accountName"], "attachmentId": ["contachmentId", "attacheId", "attociationid", "Attociationid", "attignmentid", "AttachmentId", "attachedById", "attmentID", "attachedSerial", "AttachmentById", "attignmentId", "attignmentID", "assignmentById", "attachmentById", "attacheid", "attionById", "attionid", "contachedId", "contachmentSerial", "assachmentid", "attionSerial", "contachedSerial", "attachmentid", "attmentid", "attociationById", "contachmentById", "attachmentID", "attachedid", "assachmentById", "assignmentID", "contachedid", "attachedID", "attacheID", "attociationId", "attignmentById", "attacheById", "assachmentId", "AttociationId", "attachedId", "AttociationById", "assachmentID", "AttachmentID", "AttociationID", "attmentById", "attociationSerial", "attociationID", "attachmentSerial", "attionId", "contachedById", "Attachmentid", "contachmentid", "assignmentid", "attmentId", "assignmentId"], "in": ["ins", "din", "inside", "en", "id", "p", "ex", "sum", "IN", "inn", "con", "ai", "inf", "cin", "gin", "m", "on", "bin", "mm", "from", "raw", "it", "vin", "all", "init", "as", "file", "mc", "al", "body", "act", "ch", "per", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "iter", "conf", "l", "isin", "info", "read", "In"], "saveIn": ["storeIn", "getIN", "savAs", "saveIN", "savePath", "storeIN", "secureIN", "sendIN", "aveIN", "secureIns", " saveIns", "aveIn", "aveOut", "sendOut", " saveOut", " saveIN", "savIN", "saveIns", "sendPath", " savePath", "getIns", "sendIn", "secureAs", "saveOut", "storePath", "getOut", "getIn", "secureIn", "savIn", "savIns", "storeOut", "aveIns"], "saveAs": [" saveBy", "submitAS", " saveAS", "aveIn", "SaveAs", "aveAs", "submitBy", " saveTo", " saveAn", "aveAS", "aveas", "submitAs", "dumpAn", "aveAn", "Saveas", "saveAS", "submitIn", "dumpTo", "saveas", "dumpAs", "aveTo", "saveTo", "SaveIn", "SaveAS", "submitas", "saveAn", "saveBy", "SaveBy"], "out": ["cn", "copy", "output", "OUT", "co", "v", "serv", "ex", "sum", "ent", "con", "net", "io", "sys", "outs", "it", "OU", "ou", "inv", "to", "all", "obj", "gc", "res", "auto", "aos", "cos", "name", "can", "up", "oss", "i", "one", "inner", "ao", "os", "null", "conv", "o", "t", "log", "Out", "outer", "n"], "copySize": ["copyPercent", "CopyPercent", " copyCount", "likeFontSize", "copyCount", "likeLength", "msgLength", "pushLength", "opySIZE", "msgPercent", "CopyCount", "opySize", "pushSize", "copyLength", "CopySize", "pushFontSize", "CopyLength", "msgSIZE", "CopyFontSize", "copyFontSize", "opyPercent", "likeCount", "likeSize", "msgSize", " copyFontSize", "copySIZE", "opyLength", "CopySIZE", " copyLength", "pushCount"], "contentUriString": ["contentUrisstring", "contentIriString", "contentUuriNumber", "contentUristring", "contentUistring", "contentUniStr", "contentUnuriNumber", "contentUnistring", "contentUriNumber", "contentUnriString", "contentUiStr", "contentIistring", "contentUnriStr", "contentUiString", "contentUriStr", "contentUicStr", "contentUniNumber", "contentUicStatic", "contentUicString", "contentUrisString", "contentUuriStr", "contentUuriStatic", "contentUniString", "contentUrisStr", "contentIiString", "contentUnriNumber", "contentIristring", "contentUiStatic", "contentUuristring", "contentIiStr", "contentIiStatic", "contentUrisNumber", "contentUnuriString", "contentIriStr", "contentIriStatic", "contentUnristring", "contentUicstring", "contentUnuristring", "contentUuriString", "contentUriStatic", "contentUnuriStr"], "mSize": ["lLength", "mPos", "lSize", "mBytes", "moPos", "nSize", "mLength", "moBytes", "moLength", "moSize", "nLength", "lPos", "nBytes", "lBytes", "nPos"], "mContentUri": ["mResourceUri", "mContent_ris", "mContentIuid", "mContent_uid", "mContentUris", "mResourceUuid", "mContent_ri", "mResourceURI", "mContentIri", "mContentUuid", "mContentIRI", "mResourceUris", "mContentURI", "mContentPRI", "mResourceIRI", "mResourceIri", "mResourceIris", "mContentPri", "mContentIris", "mContentPuid", "mResourceIuid", "mContent_RI", "mContentPris"], "cv": ["cn", "const", "av", "vv", "cf", "v", "cu", "rc", "ov", "cont", "tc", "nc", "buf", "ev", "cc", "vr", "csv", "box", "um", "c", "vp", "cod", "qv", "vol", "nv", "sv", "dc", "cap", "GV", "gc", "act", "vc", "uv", "cp", "qu", "cas", "cmp", "mult", "vm", "ctrl", "conv", "CV", "desc", "vt", "ct", "xc", "cm", "lv", "cb", "lc", "fc", "pb"], "uri": ["folder", "u", "uid", "ri", "id", "du", "doi", " Uri", "bid", "origin", "q", "picture", "uni", "URI", "subject", "term", "resource", "link", "report", "ur", "prefix", " URI", "range", "query", "dir", "uu", "address", "phi", "directory", "iri", "unit", "ui", "ue", "i", " ni", "ip", "url", "qi", "component", "result", "handle"]}}
{"id1": "18731843", "id2": "4750967", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"doBody": ["loadbody", "loadContent", " sendbody", " sendBody", " doHead", " sendHead", " sendContent", " writeBody", " writeContent", "loadHead", " dobody", " writebody", " doContent", "loadBody", " writeHead"], "req": ["hr", "Request", "qq", "cmd", "Requ", "crit", "exec", "gr", "jp", "reg", "rec", "express", "aj", "q", "ctx", "err", "sq", "request", "pkg", "js", "http", "qt", "quick", "inv", "j", "fr", "quest", "urg", "query", "res", "wx", "def", "pro", "proc", "conf", "tx", "ps", "requ"], "resp": ["rel", "output", "exp", "esp", "Resp", "serv", "RES", "rec", "err", "ret", "js", "http", "re", "response", "comm", "vol", "trans", "Res", "res", "sol", "sp", "soc", "wa", "Rep", "pos", "def", "out", "client", "respons", "respond", "Response", "cl", "rep", "next", " res", "wr", "result"], "bis": ["mi", "pins", "lis", "iss", "bits", "bs", "ris", "onis", "pin", "ubis", "bes", "isi", "inet", "nis", "lbs", "bid", "bi", "aus", "cin", "obs", "bil", "iso", "lin", "webkit", "bps", "atis", "avi", "bat", "bh", "ads", "sb", "iris", "ses", "phis", "bt", "mis", "idis", "be", "is", "bie", "oss", "os", "fps", "ais", "rison", "los", "zo", "isin", "oi", "ios"], "bos": ["fs", "oos", "acs", "pins", "stones", "bs", "bits", "ows", "bes", "ubis", "bo", "banks", "asket", "bas", "bi", "ys", "nos", "obs", "asis", "bin", "bil", "vas", "outs", "gs", "dos", "mes", "tis", "bh", "ts", "eros", "aos", "tes", "uts", "fits", "BS", "jas", "oops", "is", "uds", "oss", "os", "zb", "ubs", "its", "ods", "los", "oi", "ols", "ios"]}}
{"id1": "9081749", "id2": "3745402", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"encrypt": ["compress", "comprypted", "cryption", "encrypted", "Encrypt", "crypt", "cress", "Encress", "Encryption", "encress", "Encrypted", "compryption", "crypted", "encryption", "comprypt"], "password": ["value", "Password", "p", "confirmed", "pattern", "message", "sword", "total", "email", "description", "secret", "string", "token", "path", "user", "secure", "chain", "phrase", "hello", "database", "picture", "push", "text", "request", "comment", "attribute", "prefix", "key", "expression", "address", "PASS", "word", "name", "username", "source", "pass", "input", "wd", "account", "reset", "shadow", "default", "padding", "wordpress", "command", "past"], "encryptType": ["encjectClass", "encryptype", "encveytype", "encjectTYPE", "ethjecttype", "escryptionStyle", "escryptionType", "encryptionClass", "ethryptClass", "encribeype", "encryptionStyle", "escryptStyle", "ethryptType", "encribeTy", "encryptClass", "ethjectClass", "ethryptTYPE", "encryptionTy", "encribeType", "encjecttype", "encreatTy", "escryptionTy", "escryptionype", "encryptionTYPE", "encveyClass", "encryptTy", "encveyTYPE", "encryptStyle", "encreatType", "escryptTy", "encryptTYPE", "escryptype", "encryptionype", "encryptiontype", "encreatype", "encveyType", "ethjectTYPE", "encryptionType", "encribeStyle", "escryptType", "encjectType", "encrypttype", "ethrypttype", "ethjectType", "encreatStyle"], "md": ["del", "pdf", "cmd", "dd", "dr", "mt", " MD", "der", "red", "nd", "dh", "mk", "sd", "od", "ms", "m", "mm", "me", "man", "pd", "mod", "ds", "down", "add", "de", "metadata", "dir", "obj", "mc", "mn", "ad", "df", " Md", "nt", "dm", "mand", "det", "ind", "mb", "grad", "ld", "di", "cd", "bd", "ct", "rd", "hd", "d", "MD", "sm"], "hash": ["length", "ashes", "host", "ash", "sh", "hz", "search", "here", "style", "stock", "match", "sha", "cache", "rh", "sum", "show", "total", "char", "where", "window", "color", "esh", "Hash", "how", "box", "print", "test", "stack", "sort", "block", "has", "array", "map", "score", "replace", "all", "oh", "handle", "query", "hex", "address", "shift", "mask", "height", "check", "h", "number", "her", "mac", "square", "filter", "sample", "html", "hello", "dig"], "hexString": [" HexString", "jsonBuffer", "octString", "exArray", " hexStr", "hexBuffer", "xfStatement", "exString", "xfString", " hexArray", " hexList", "jsonString", "hashStr", "jsonArray", "hexStr", "hexResult", "octArray", "hexArray", "hexStatement", "exStr", "hashBuffer", "octStatement", " HexResult", "exBuffer", "pexService", "pexArray", "xfArray", " HexStr", " hexstring", "exList", " hexService", "hashString", "hexList", "hexstring", "exStatement", "xfstring", " Hexstring", "jsonStr", "hashArray", "pexList", "exResult", "octstring", " hexResult", "pexString", "exService", "exstring", "hexService"], "i": ["cli", "mi", "ami", "u", "iq", "id", "exp", "v", "pi", "ix", "ex", "gravity", "list", "ii", "si", "e", "ai", "io", "bi", "n", "my", "m", "sim", "set", "me", "in", "iu", "ki", "multi", "ic", "ei", "it", "c", "li", "major", "ti", "a", "j", "xi", "init", "x", "ji", "ie", "phi", "y", "this", "is", "ui", "gu", "uri", "di", "gi", "oi", "json", "ci", "ip", "ski", "\u0438", "info", "qi", "point", "im", "index", "I"]}}
{"id1": "5760649", "id2": "20519261", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"createFile": ["uploadStream", " createfile", " createFiles", " createStream", "saveStream", "createfile", "createStream", "saveFile", "createFiles", "saveFiles", "savefile", "uploadFiles", "uploadfile", "uploadFile"], "src": ["loc", "stream", "rc", "rs", "SOURCE", "SourceFile", "sc", "dest", "sys", "rect", "str", "from", "st", "sq", "sec", "resource", "inst", "sit", "ser", "sb", "res", "obj", "rx", "is", "comp", "fp", "txt", "ipl", "source", "input", "uri", "config", "cur", "abs", "start", "ctr", "url", "sr", "fc", "pour"], "filename": ["output", "bf", "v", "location", "xxx", "println", "SourceFile", "nm", "string", "fil", "path", "ln", "kl", "ename", "subject", "Filename", "jpg", "FILE", "nl", "prefix", "file", "nil", "fn", "FN", "name", "ren", "family", "txt", "fp", "username", "title", "png", "stem", "n"], "fis": ["fais", "ffos", "fIS", "sfais", " fIS", "ffIS", " fisi", "bfiss", "Fis", "Fisi", " fiss", "sfis", "fiss", "sfiss", "sfios", "ffisi", "fisi", "afios", "bfis", " fais", "afais", "ffis", "Fos", " fios", "Fios", "afis", "bfos", "FIS", "Fiss", "bfios", "fios", "afiss"], "fos": ["wos", "foss", "flis", "wis", "Fis", "floss", "wios", "Foss", "foses", "foes", "woss", " foss", "woses", "boss", "tos", "boes", "bis", "vOS", "tis", "wOS", "tios", "bos", "flos", "fOS", "wor", "Fos", " foses", "toss", "Foes", "voses", "vor", " fOS", "vos", " foes", "flios", "fios"]}}
{"id1": "21995302", "id2": "15580610", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 0, "substitutes": {"open": ["update", "access", "Open", "are", "present", "match", "show", "transfer", "connect", "enter", "process", "un", "on", "set", "error", "load", "add", "alert", "render", "init", "document", "construct", "op", "be", "lock", "check", "write", "get", "create", "close", "find", "reset", "start", "parse", "accept", "save", "o", "download", "t", "use", "release", "read", "handle"], "input": ["image", "initial", "context", "output", "exec", "stream", "p", "channel", "data", "format", "enter", "list", "Input", "pull", "empty", "form", "io", "any", "q", "buffer", "xml", "in", "raw", "from", "text", "view", "request", "it", "entry", "error", "load", "add", "active", "upload", "spec", "attribute", "init", "file", "base", "address", "act", "reader", "client", "out", "check", "up", "get", "source", "feed", "config", "qa", "submit", "reset", "cur", "start", "inner", "PUT", "accept", "media", "local", "read", "cont"], "uri": ["distance", "folder", "nu", "mi", "u", "ri", "id", "description", "http", "link", "range", "prefix", " URI", "address", "cp", "details", "username", "defined", "util", "local", "sky", "domain", "du", "archive", "e", "ve", "form", "term", "multi", "direction", "ur", "uu", "ahi", "cos", "unit", "mail", "ue", "filename", "remote", "qi", "project", "quote", "copy", "die", "char", "basic", "via", "resource", "based", "library", "reference", "iri", "source", "ip", "uno", "component", "image", "country", "queue", "uni", "URI", "frame", "hi", "connection", "nil", "force", "proxy", "phi", "directory", "none", "zip", "ui", "i", "manager", "thus", "requ"], "url": ["rel", "f", "el", "sl", "ssl", "gl", "dl", "il", "window", "char", "external", "bel", "kl", "web", "user", "str", "err", "ll", "http", "rl", "ul", "nl", "link", "browser", "bool", "URL", "sb", "cert", "build", "name", "mb", "client", "mail", "out", "r", "Url", "l", "coll", "log", "html", "job"]}}
{"id1": "8665321", "id2": "4016687", "code1": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getNetworkServersIPs": ["getNetworkServersipAddress", "getNetworkServersListls", "getNetworkServersIPls", "getNetworkServersHosts", "getNetworkServersipes", "getNetworkSeratorsips", "getNetworkServersListAddress", "getNetworkSeratorsIPs", "getNetworkServersIPAddress", "getNetworkServersListes", "getNetworkSeratorsIPAddress", "getNetworkSeratorsIPes", "getNetworkSeratorsipes", "getNetworkSeratorsIPls", "getNetworkSeratorsipls", "getNetworkServersips", "getNetworkServersHostls", "getNetworkServersIPes", "getNetworkServersHostes", "getNetworkServersHostAddress", "getNetworkSeratorsipAddress", "getNetworkServersipls", "getNetworkServersLists"], "netaddress": ["etname", "networkaddress", " netname", "network", "etaddress", "NetAddress", "netaddr", " netAddress", "Netname", "Network", "Netaddress", " network", "networkwork", "netAddress", "netname", " netaddr", "etAddress", "networkaddr", "networkAddress", "etaddr", "Netaddr"], "result": ["folder", "output", "search", "collect", "currency", "match", "cache", "data", "relation", "total", "message", "list", "goal", "dict", "Result", "order", "csv", "front", "complete", "sequence", "print", "buffer", "valid", "set", "block", "term", "ret", "answer", "collection", "trace", "join", "table", "response", "bridge", "expected", "remove", "report", "res", "menu", "this", "current", "found", "vector", "memory", "done", "cur", "create", "created", "results", "success", "make", "primary", "date", "local"], "line": ["column", "cmd", "record", "ine", "store", "stream", " lane", "style", "liner", "channel", "eline", "char", " block", " frame", "detail", "string", "e", "ln", " file", "le", "ice", "chain", " lineage", "cell", "print", "lo", "normal", "section", "block", "lin", "entry", "part", "trace", "frame", "inline", "Line", "link", "nl", "page", "LIN", "label", "comment", "note", "sql", "lane", "lex", "lined", "base", "code", "word", "lock", "no", " lineup", "iter", " inline", "l", " chunk", " linen", "row", " rule", " row", "log", "LINE", "sample", "next", "point", "handle"], "splitline": ["splLine", "splitnode", " spliteline", "spleline", "splline", "splitcell", "splitLINE", " splitnode", "joinLine", " splitLINE", "joinlink", "splnode", " splitcell", " splitlink", "startLine", "startnode", "joincell", "joinline", "Splitline", "splitLine", "SplitLine", "splLINE", "spllink", "splcell", " splitLine", "SplitLINE", "starteline", "startline", "spliteline", "splitlink"], "url": ["f", "loc", "rel", "sl", "ssl", "server", "b", "https", "ls", "hl", "service", "bel", "google", "web", "net", "str", "ll", "conn", "http", "ul", "nl", "link", "socket", "www", "browser", "ur", "URL", "file", "cert", "build", "base", "address", "open", "client", "mount", "mail", "r", "uri", "Url", "l", "job"], "connection": ["context", "stream", "online", "established", "position", "channel", "Connection", "connect", "data", "nc", "communication", "relation", "message", "con", "io", "generation", "database", "network", "conn", "entry", "application", "c", "resource", "writer", "response", "link", "socket", "session", "connected", "directory", "open", "current", "client", "still", "character", "command", "opening"], "reader": ["readable", "stream", "liner", "upper", "er", "iterator", "io", "handler", "buffer", "parser", "loader", "writer", "rl", "resource", "runner", "reading", "ro", "file", "builder", "Reader", "rx", "rar", "river", "client", "older", "ner", "r", "input", "iter", "inner", "cur", "still", "row", "read"], "serverline": ["servingstyle", "enterlines", " serverloop", "erverlink", "serverlink", "verflag", "serverine", "enterserver", "servingline", "servingflag", " serverine", "veronly", "enterlined", " serverflag", "servingloop", "differentline", "differentine", "verline", "erverLine", "verstyle", "serverLine", "erverflag", "erverserver", "differentlayer", "serverflag", "serverlayer", "enterline", " serverlink", " serverlines", "servinglayer", "differentlined", "erverline", "erveronly", "servinglined", "servingonly", "consolelayer", "erverloop", "verLine", "consoleine", "serverlined", " serverserver", "servinglink", "consoleline", "serverserver", " serverLine", "serverstyle", "verlink", "erverine", "servingine", "serverlines", "erverlined", "serverloop", "consolelined", "erverlines", " serverlined", "erverstyle", "serveronly"]}}
{"id1": "13414771", "id2": "937612", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encriptPassword": ["EncriptAuth", " descryptPassword", "EnribePassword", "EncriptKey", " desribeKey", "EnribeKey", " desizeAuth", "EncriptField", " descriptField", "EnribeAuth", " descryptField", " descriptAuth", " descryptAuth", " desribePassword", " desribeField", "EnribeField", " descriptPassword", " desizeField", " descriptKey", "EncriptPassword", " descryptKey", " desizeKey", " desizePassword", " desribeAuth"], "passwd": ["psword", "mailword", "passw", "mailphrase", " passsword", "defphrase", "assphrase", "defword", "pword", "passphrase", "pasw", "defw", "pw", "assw", "passsword", "paswd", "pwd", " password", " passw", "defwd", "mailwd", "mailw", "pasword", "password", "asswd", "assword"], "md": ["pdf", "cmd", "dd", "dr", "mt", " MD", "der", "mo", "red", "mg", "dh", "mk", "sd", "hm", "od", "ms", "mm", "m", "pm", "pd", "mod", "ds", "down", "and", "add", "mc", "mn", "ma", "df", "managed", "nt", "dm", "ind", "mb", "mask", "mail", "td", "ld", "rm", "di", "cd", "desc", "bd", "hd", "d", "at", "MD", "sm"], "hash": ["ash", "sh", "sha", "cache", "rh", "sum", "message", "ssh", "Hash", "checked", "proof", "has", "hidden", "sq", "score", "bh", "ah", "oh", "key", "ashed", "hex", "mass", "mask", "check", "h", "trust", "mac", "her", "shadow", "uh", "hed", "filter", "sample", "hd", "password", "kernel"]}}
{"id1": "2022160", "id2": "16623181", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"write": ["copy", "output", "store", "patch", "port", "scale", "connect", "format", "sync", "process", "walk", "partial", "print", "rite", "network", "set", "wrote", "commit", "writer", "size", "link", "to", "apply", "export", "register", "render", "writ", "run", "cycle", "batch", "code", "execute", "only", "change", "put", "see", "call", "append", "get", "wire", "create", "close", "writing", "fit", "find", "Write", "written", "fail", "flush", "save", "log", "next", "end", "wait", "w", "send", "read", "handle"], "byteBuffers": ["byteBuffainers", "bitEntrs", "bytePacks", " byteBuffines", "bytePackrys", "byteWaiterers", "byteBindodes", "bytePackusters", "bytebuffainers", "bytesBuffs", "bytesHeadters", "byteBindlers", "byteIndexers", "byteHeader", "byteFragers", "byteDefers", "byteHoldiers", "byteBuffrs", "bitEnters", "bytesBuffters", "byteHolderers", " bytebuffers", "byteCombers", "byteDeflers", "byteOrdrs", "bitEntters", "bytesBuffERS", "bytesHeaders", "bytesBuffrs", "byteBuffererers", "bytesHeadered", "byteFraglers", "byteCombrs", "byteBufferered", " byteDefels", "byteBuffators", "byteCountERS", "bytesBufferers", "byteBuffodes", "byteHoldered", " byteNamesines", "byteCorners", "bytesPackerers", "ByteHeadERS", "byteWaitERS", "byteBytesERS", " bytePacklers", "byteOffered", "bytebuffers", " bytePackers", "byteBindERS", "byteIndexators", " byteNamesERS", "bytesbuffrys", "byteBuffer", " byteDefers", " bytebuffters", " byteBufferers", "ByteBuffers", "bytesBufflers", "byteHeaders", "bytebuffiers", "byteBuffines", "bytesHoldters", " byteBuffered", " bytebuffERS", "byteDefels", "bytePackainers", "byteBufferters", "bytesbuffs", " byteBuffs", "bytesbuffers", "byteBinders", "bytePackered", "byteBuffrys", "byteOrdonents", "byteBuffered", " byteBuffiers", "bytesHolders", "bytesbuffERS", "byteNamesers", "byteBuffiers", "bytebuffusters", "bytebuffrys", "byteBufferers", "byteHeadters", "bytebuffodes", "bytesHoldERS", "byteEntonents", "bytePackters", "byteOffters", "byteBuffERS", "bytebuffines", "bitBuffters", "bitBuffrs", " bytebufferers", "byteEnters", "byteBuffters", "byteHeadrs", "bitEntonents", " bytePacks", "bytesHeader", "bytesBuffer", "byteFrags", "bytePackERS", "bytePackers", "bytebufferers", "byteNameserers", "byteWaiters", " byteNameserers", "byteHeadERS", " bytePackERS", "byteBytess", "byteCornerers", "bytebufflers", "byteCountered", "byteBuffs", " byteBuffERS", " byteDefERS", "byteCountters", "byteFragusters", "byteHoldERS", "ByteBuffERS", "byteOffer", "bytesPackators", " bytePackusters", "byteBufferlers", " byteDeflers", "bytesBuffered", " bytebuffiers", "byteBytesrys", "bytesHoldered", "bytesPackrs", "ByteHeadered", "byteHoldters", "byteBufferines", " byteBuffels", "ByteBuffrs", "byteCorniers", "bytebuffs", "byteBuffonents", "byteOrdters", "byteOffers", "byteBufferels", "ByteBuffered", "byteNamesines", " byteBufflers", "bytesPackers", "byteIndexerers", " byteBuffusters", " byteBuffters", "bytebuffters", "ByteHeaders", "byteCounters", "bytesBuffrys", "bytebuffered", "bytePacklers", "bytePackrs", "byteBufflers", "byteIndexrs", "byteEntters", "bytesbufflers", "byteBuffels", "byteEntrs", "byteWaitainers", "byteBuffusters", "byteDefERS", "byteCornters", " bytePackainers", " bytePackerers", "bytesBuffers", "bytesbuffodes", "byteBufferERS", "byteCombters", "bytePackators", "byteOrders", " byteBuffainers", "byteHeadered", "bytesBuffodes", "bytebuffERS", "bitBuffers", "byteCombonents", "byteNamesERS", "bytePackerers", " byteNamesers", "byteHolders", "ByteHeadrs", "bytesBuffators", "bytePacker", "bitBuffonents", "byteBytesers", " bytebuffered"], "m_initialOutBuffer": ["m_initialCheckQueue", "m_InitialOutLength", "m_initialHostbuffer", "m_initialoutCache", "m_firstOutBuff", "m_initialByteWriter", "m_initialNetQueue", "m_initialOutputThread", "m_firstoutBuff", "m_initialInCache", "m_currentOutCache", "m_currentInBuff", "m_initialInBuff", "m_finalOutputThread", "m_InitialoutBuff", "m_initialOutCache", "m_finalOutBuffer", "m_initialCheckBuffer", "m_InitialoutCache", "m_InitialOutBuff", "m_initialByteCache", "m_initialOutChannel", "m_currentoutCache", "m_finalOutBuff", "m_initialEndLength", "m_initialInView", "m_initialNetBuffer", "m_firstOutCache", "m_InitialoutLength", "m_initialOutBuff", "m_initialInWriter", "m_initialInbuffer", "m_initialInQueue", "m_firstoutCache", "m_initialoutQueue", "m_initialNetChannel", "m_firstoutBuffer", "m_currentInChannel", "m_initialEndBuffer", "m_InitialoutBuffer", "m_initialHostView", "m_currentInBuffer", "m_currentoutBuff", "m_initialOutLength", "m_finalOutputQueue", "m_initialCheckBuff", "m_initialOutQueue", "m_initialByteBuff", "m_finalOutputBuffer", "m_initialInThread", "m_initialNetCache", "m_initialOutThread", "m_currentInQueue", "m_InitialOutCache", "m_currentOutQueue", "m_initialCheckChannel", "m_initialOutputBuff", "m_initialHostBuffer", "m_initialoutWriter", "m_initialInChannel", "m_initialOutputBuffer", "m_firstoutWriter", "m_currentOutChannel", "m_finalOutputBuff", "m_initialByteBuffer", "m_finalOutThread", "m_firstOutWriter", "m_currentoutBuffer", "m_finalOutQueue", "m_initialoutBuff", "m_initialOutView", "m_currentOutBuff", "m_initialNetBuff", "m_firstOutBuffer", "m_initialoutBuffer", "m_initialEndBuff", "m_InitialOutBuffer", "m_initialHostBuff", "m_currentoutQueue", "m_initialInLength", "m_initialoutLength", "m_initialOutputQueue", "m_initialInBuffer", "m_currentOutBuffer", "m_initialOutbuffer", "m_initialEndCache", "m_initialNetThread", "m_initialOutWriter"], "buffer": ["stream", "pair", "buf", "empty", "stack", "button", "socket", "page", "comment", "attribute", "address", "flash", "template", "null", "row", "url", "length", "callback", "context", "store", "server", "holder", "match", "cache", "profile", "iterator", "chain", "tree", "table", "bar", "document", "batch", "loop", "memory", "internal", "Buffer", "filter", "background", "command", "timer", "temp", "initial", "container", "engine", "header", "binary", "channel", "bo", "message", "layer", "timeout", "response", "builder", "base", "source", "buff", "processor", "output", "window", "list", "thread", "queue", "sequence", "phrase", "database", "block", "map", "bridge", "connection", "directory", "pool", "iter", "manager"], "buffers": ["bufflers", "offERS", "rendlers", "buffards", "bindters", "comblers", " buffERS", "uflers", "offters", " buffters", "ufERS", "buffors", "binders", "ufards", "ufers", "bufers", "holders", "offers", "bufings", "buffings", "renders", " buffings", "holdters", "buflers", "ufors", "rendters", "bufards", "bindERS", "ufters", "offors", "buffERS", "combards", "bufters", "holdings", "combERS", "buffters", "bindlers", "bufERS", "rendERS", " buffors", "holdERS", "combers"], "result": ["context", "progress", "output", "product", "search", "mate", "other", "match", "cache", "we", "data", "message", "relation", "profile", "pair", "description", "Result", "process", "user", " resulted", "group", "complete", "test", "diff", "valid", "wrapper", "continue", "ret", "request", "answer", "error", "status", "resource", "re", "load", "response", "runner", "reason", "ser", "that", "report", "ver", "comment", "res", "uu", "event", "see", "current", "role", "true", "details", "cur", "r", "done", "iter", "created", "results", "null", "json", "success", "make", "next", "successful"], "encrypted": ["context", "engine", "other", "confirmed", "channel", "selected", "external", "secret", "secure", "chain", "sequence", "checked", "finished", "options", "error", "table", "available", "verified", "locked", "flash", "extra", "armor", "internal", "created", "ended", "password", "temp"]}}
{"id1": "13362846", "id2": "7872659", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setcontenU", "setContensenue", "setContensenu", "setCont\u00ednue", "setContennu", "setcontenux", "setContennux", "setcontenue", "setcontensenU", "setcontensenux", "setContensenU", "setContennU", "setContenue", "setContenux", "setcontensenu", "setContennue", "setContenU", "setCont\u00ednU", "setCont\u00ednux", "setCont\u00ednu", "setcontenu", "setContensenux", "setcontensenue"], "contenuFichier": ["contenuFichtIER", "contenuFamilyichiere", "contenuFachiere", "contenuFigniere", "contenuFochier", "contenuFithorie", "contenuVichyr", "contenuFicheie", "contenuFiverieri", "contenuVechiest", "contenuFamilyichier", "contenuFileichiere", "contenuFrenchire", "contenuMicheer", "contenuFicheorie", "contenuFechiere", "contenuFuffer", "contenuFolfieri", "contenuVichiest", "contenuFuffieri", "contenuFichie", "contenuMichiere", "contenuFicheer", "contenuFrenchaire", "contenuFsechieri", "contenuFsicher", "contenuFamilyachorie", "contenuFignaire", "contenuVechyr", "contenuFiverire", "contenuFicheaire", "contenuFithie", "contenuFithiest", "contenuFechyr", "contenuFsechire", "contenuFochiere", "contenuFichiers", "contenuFchIER", "contenuFsechier", "contenuFuffier", "contenuFolfier", "contenuFochiers", "contenuFsichier", "contenuFCher", "contenuFihier", "contenuFchiere", "contenuMicheiere", "contenuMichier", "contenuVchiere", "contenuFileochiere", "contenuFChiere", "contenuFichIER", "contenuFchier", "contenuFichtie", "contenuFchie", "contenuFsichire", "contenuMichaire", "contenuFileochier", "contenuFileichie", "contenuFsrenchier", "contenuFsichaire", "contenuFichire", "contenuMicheier", "contenuFChaire", "contenuFachier", "contenuFithiere", "contenuFignier", "contenuFachorie", "contenuFechieri", "contenuFechire", "contenuFochie", "contenuFihyr", "contenuFechier", "contenuFicheiers", "contenuFachie", "contenuFechiest", "contenuFichaire", "contenuFamilyachiere", "contenuVichier", "contenuFihiest", "contenuFsrenchieri", "contenuFigner", "contenuFsrenchaire", "contenuFichyr", "contenuFolfire", "contenuFochIER", "contenuMicher", "contenuFichiest", "contenuFolfer", "contenuFsichieri", "contenuFicheiere", "contenuMicheaire", "contenuFileochie", "contenuVchier", "contenuFithier", "contenuFrenchieri", "contenuFamilyachie", "contenuFsrenchire", "contenuFsecher", "contenuFicheire", "contenuFileochiers", "contenuVichiere", "contenuFamilyachier", "contenuFichtier", "contenuFithyr", "contenuFiverier", "contenuFicher", "contenuVchIER", "contenuVechier", "contenuFicheieri", "contenuVechiere", "contenuFichorie", "contenuVichie", "contenuFihiere", "contenuFileichier", "contenuFichtiere", "contenuVchie", "contenuFamilyichie", "contenuFachiers", "contenuFrenchier", "contenuFChier", "contenuFicheier", "contenuFecher", "contenuVichIER", "contenuFiveraire", "contenuFichieri", "contenuFichiere", "contenuFuffire", "contenuFileichiers", "contenuFamilyichorie"], "fichierElectronique": ["fichierAdministroniques", "fichierAdministroniq", "fichierTransferradorie", "fichierTransferradoric", "fichierElectromie", "fichierElectroneoch", "fichierElectradorie", "fichierElectrenaire", "fichierCentronius", "fichierelectrenier", "fichierelectronique", "fichierElectronicy", "fichierElectrenius", "fichierElectrenier", "fichierElectrontipolar", "fichierElectRONius", "fichierElectradorius", "fichierElectronipolar", "fichierelectronier", "fichierElectchronoch", "fichierAdministronique", "fichierelectroniques", "fichierElectronsiq", "fichierElectromius", "fichierElectronic", "fichierElectradorique", "fichierElectronsiques", "fichierElectronaire", "fichierElectroneic", "fichierElectronticity", "fichierElectroneius", "fichierElectroneiques", "fichierElectchronique", "fichierElectroneipolar", "fichierSelectroneique", "fichierCentronique", "fichierElectronicity", "fichierTransferradorius", "fichierAdministroneiq", "fichierElectonique", "fichierElectonier", "fichierElectroneie", "fichierElectreniques", "fichierSelectronicity", "fichierTransferronius", "fichierElectroneique", "fichierElectromique", "fichierElectroneiq", "fichierElectriciq", "fichierAdministroneie", "fichierElectronier", "fichierElectronsique", "fichierElectRONicy", "fichierElectroneaire", "fichierElectronie", "fichierAdministroneique", "fichierElectronsier", "fichierElectrenicy", "fichierElectromicity", "fichierelectrenic", "fichierSelectroneicity", "fichierElectroniq", "fichierElectromaire", "fichierSelectronoch", "fichierElectchroniques", "fichierElectoniques", "fichierTransferronie", "fichierCentRONicy", "fichierElectrenic", "fichierSelectronique", "fichierElectroniques", "fichierTransferradorique", "fichierelectrenique", "fichierElectronsie", "fichierElectrontique", "fichierSelectroneiques", "fichierElectricique", "fichierElectronoch", "fichierElectronius", "fichierElectradoric", "fichierAdministroneiques", "fichierElectrontaire", "fichierSelectroniques", "fichierElectRONique", "fichierAdministronie", "fichierElectroneicity", "fichierelectreniques", "fichierElectchronius", "fichierElectricie", "fichierCentRONaire", "fichierElectRONaire", "fichierElectrenique", "fichierCentRONius", "fichierElectromipolar", "fichierElectronsicity", "fichierCentronaire", "fichierTransferronique", "fichierElectchronicy", "fichierElectronsic", "fichierSelectroneoch", "fichierElectromic", "fichierElectchronaire", "fichierCentronicy", "fichierElectronsoch", "fichierElectchronicity", "fichierTransferronic", "fichierElectonic", "fichierelectronic", "fichierElectriciques", "fichierCentRONique"], "utilisateurCourant": ["utilisateurRepresentant", "utilisateurRepresentante", "utilisateursCourant", "utilisateursGovernante", "utilisateurGovernants", "utilisateursGoverniant", "utilisateurGovernant", "utilisateurCourante", "utilisateurRepresentants", "utilisateursGovernant", "utilisateurCourants", "utilisateursCourante", "utilisateursGovernants", "utilisateurParticipante", "utilisateursCourants", "utilisateurRepresentiant", "utilisateurParticipiant", "utilisateurParticipants", "utilisateurCouriant", "utilisateursCouriant", "utilisateurParticipant", "utilisateurGovernante", "utilisateurGoverniant"], "support": ["context", "cover", "access", "know", "supp", "port", "language", "profile", "format", "feature", "please", "allow", "service", "proof", "pport", "collection", "supported", "Support", "control", "replace", "storage", "install", "cap", "prototype", "document", " Support", "share", "force", "library", "see", "SUP", "system", "trust", "help", "null", "evidence", "success", "accept", "media", "use", "history"], "ficheDocument": ["ficheMatrix", "fitimeMatrix", "facheTree", "FicheDoc", "frenchDoc", "fayeDatabase", "fcheDocument", " frenchDescription", " frenchDatabase", "fayeDoc", "fachedocument", "flicheMatrix", "hicheTransaction", "facheTransaction", "fruitTransaction", "FicheDatabase", "fiqueDescription", "facheDoc", "fruitDocument", "fliciDatabase", "foyerTree", " frenchDocument", "fifaDocuments", "bacheDatabase", "frenchTransaction", "fcheDoc", "fcheDatabase", "facheDocument", "fliciMatrix", "fichedocument", "FayeDocument", "hacheDocument", "hicheDocument", "ficheDescription", "bicheDatabase", "FayeDoc", "ficheDocuments", "facheDatabase", "foyerDoc", "fitimeDocument", "fifaDatabase", "flicheDatabase", "ficheTree", "FicheDocument", "FayeDatabase", "bicheTree", "fiqueDatabase", "ficidocument", "ficheTransaction", "fiqueDocument", "ficiDocument", "foyerDatabase", "ficiJournal", "ficiDatabase", "hichedocument", "fitimeTransaction", "FayeDocuments", "bacheTree", "fifaDocument", "hicheJournal", "fitimeDescription", "bacheDoc", "hacheTransaction", "fayeDocument", "ficiTransaction", "ficheJournal", "bicheDocument", "ficheDoc", "fitimeDatabase", " ficheDescription", "foyerDocument", "flicheTransaction", "fruitJournal", "flicheDocument", "frenchDescription", "facheJournal", "fruitdocument", "hacheJournal", "frenchDocuments", "bicheDoc", "fliciTransaction", "frenchDocument", "fliciDocument", "bacheDocument", "ficheDatabase", " ficheDatabase", "fcheTree", "frenchMatrix", "fayeDocuments", "frenchDatabase", "ficiMatrix", "fifaDoc", "hachedocument", "FicheDocuments"], "nomFichier": ["nomNolfiere", "nomUFachIER", "nomUFachery", "nomPachier", "nomPichier", "nomFilicER", "nomFolfire", "nomPFichiller", "nomPacherer", "nomFicheer", "nomFihier", "nomFicheiner", "nomFiverIER", "nomFilicier", "nomPFoilER", "nomFericanger", "nomFchire", "nomFichiller", "nomFachie", "nomFolfiere", "nomFchomer", "nomFachire", "nomFichoier", "nomUFichier", "nomFichancer", "nomPFoiljer", "nomUFichire", "nomFchiere", "nomFicheiere", "nomPichire", "nomFicheire", "nomUFachier", "nomFacher", "nomFchier", "nomFicher", "nomUFichIER", "nomPFoilier", "nomFihire", "nomFiverire", "nomFolfier", "nomFachanger", "nomFichoancer", "nomUFichery", "nomNichie", "nomFicier", "nomPFoililler", "nomFichanger", "nomFachery", "nomFicerer", "nomFoiljer", "nomPichomer", "nomFachiere", "nomFachancer", "nomPicherer", "nomPachomer", "nomNichier", "nomFichery", "nomPFichER", "nomPFichjer", "nomFicomer", "nomFoililler", "nomNichire", "nomFilicjer", "nomFichiere", "nomFichjer", "nomPFichier", "nomFachiner", "nomFolfie", "nomFachomer", "nomFchiner", "nomFacherer", "nomFihery", "nomUFachire", "nomFcherer", "nomFoilier", "nomFericIER", "nomFiverier", "nomFericancer", "nomFicherer", "nomNolfie", "nomFoilER", "nomNichiere", "nomFichomer", "nomFicire", "nomFicjer", "nomFachier", "nomFichiner", "nomNolfier", "nomFichIER", "nomFichoanger", "nomFicER", "nomFiverery", "nomFericier", "nomFachIER", "nomFichER", "nomFihIER", "nomFiliciller", "nomFiciller", "nomFichoIER", "nomFichire", "nomNolfire", "nomFichie", "nomFcher", "nomPachire", "nomFicheie", "nomFicheier"], "extension": ["protension", "expractor", "Extension", "xtensions", "strension", "xtending", "contention", "protractor", "xtension", "expention", "extention", "extitude", "strensions", "strending", "expension", "Extensions", "Extending", "extractor", "contension", "protention", "contitude", "expitude", "extending", "protitude", "extensions", "contractor"], "fichierElectroniqueExistant": ["fichierElectroniqueExistent", "fichierElectroniquePersister", "fichierElectroniqueAssistant", "fichierElectronogramLocalistent", "fichierElectroniquePersistant", "fichierElectronicityExert", "fichierElectronogramExistant", "fichierElectroniqueExiker", "fichierElectroniquePlusister", "fichierElectronogramExistance", "fichierElectroniqueAssclusive", "fichierElectronicityInert", "fichierElectroniqueExert", "fichierElectronogueExistent", "fichierElectroniqueLocalistent", "fichierElectroniqueExplert", "fichierElectronogramExclusive", "fichierElectroniqueExvant", "fichierElectroniqueLocalistant", "fichierElectroniqueLocalistance", "fichierElectroniquePlusistent", "fichierElectronogueExiker", "fichierElectroniqueInistance", "fichierElectronogueExister", "fichierElectroniqueInert", "fichierElectroniqueExplvant", "fichierElectroniqueInvant", "fichierElectroniquePlusistant", "fichierElectroniquePresentistent", "fichierElectroniqueEXvant", "fichierElectroniqueInistent", "fichierElectroniquePersiker", "fichierElectroniqueExclusive", "fichierElectroniquePersistent", "fichierElectronogramLocalistance", "fichierElectroniqueExister", "fichierElectronicityExvant", "fichierElectroniqueAssistent", "fichierElectronogueExistant", "fichierElectroniqueExplistant", "fichierElectronicityExistant", "fichierElectronogramLocalclusive", "fichierElectroniqueInistant", "fichierElectroniqueInclusive", "fichierElectroniquePresentiker", "fichierElectronicityInistant", "fichierElectroniquePresentistant", "fichierElectronicityInistance", "fichierElectroniqueExplistance", "fichierElectronoguePersistent", "fichierElectroniquePlusiker", "fichierElectroniqueExistance", "fichierElectroniqueEXistant", "fichierElectroniqueAssistance", "fichierElectroniqueEXert", "fichierElectronoguePersistant", "fichierElectronicityExistance", "fichierElectronicityInvant", "fichierElectronogramExistent", "fichierElectronoguePersister", "fichierElectroniqueEXistance", "fichierElectroniqueLocalclusive", "fichierElectronoguePersiker", "fichierElectronogramLocalistant", "fichierElectroniquePresentister"], "idIgid": ["idIgdido", "idIgids", "idIigmaddress", "idIgcido", "idIgcoid", "idIvgkey", "idIIgzido", "idIigmid", "idIigmlimit", "idAgid", "idIgaddress", "idIgzida", "idImglimit", "idAgaddress", "idIegdata", "idIvgdata", "idIvgids", "idIkgis", "idAmgis", "idIegid", "idIgcid", "idImgis", "idIIgido", "idIegkey", "idAmgid", "idImgaddress", "idImgdata", "idIkgaddress", "idIgis", "idIIgid", "idIIgzida", "idIIgida", "idIgoid", "idImgkey", "idIgcida", "idIgzoid", "idAglimit", "idAmgaddress", "idIkglimit", "idIgzid", "idImgids", "idIigmis", "idIgida", "idIgdida", "idIgdid", "idIkgid", "idImgid", "idIvgid", "idIgzido", "idIgkey", "idAgis", "idIgdata", "idIIgzoid", "idIglimit", "idAmglimit", "idIIgzid", "idIgdoid", "idIIgoid", "idIgido", "idIegids"], "inputStream": [" inputThread", "InputTime", "InputThread", "imageSteam", "helloStreamer", "outputThread", "InputSteam", "inputThread", "outputstream", " inputSteam", " inputstream", "inputStreamer", " inputLoop", "inputstream", "inputSteam", "helloStream", "imageTime", "Inputstream", "inputChannel", "outputChannel", "imageLoop", "inputLoop", "InputStream", "helloSteam", "helloChannel", "imageStream", "outputSteam", "InputLoop", " inputChannel", " inputStreamer", "outputStreamer", "inputTime", " inputTime"], "outputStream": [" outputSteam", "inputView", "webView", "sequenceStream", " outputStyle", "outputStyle", "sequenceStreamer", "inputForm", "OutputStyle", "sequenceSteam", "sequenceStyle", "OutputStream", "inputSteam", "webStream", "OutputView", " outputView", "webStreamer", "OutputSteam", "OutputForm", " outputStreamer", "writeView", "writeForm", "writeStream", "outputSteam", "outputForm", "outputView", "webSteam", "OutputStreamer", "outputStreamer", "writeSteam"], "typeMime": ["TypeMIME", "typemime", "typeSmime", "Typemme", "typeRme", "typeMme", "typeRIME", "Typemim", "typeSmIME", "TypeMime", "TypeMme", "Typemime", "typeRime", "TypeMim", "typeSmme", "typeRim", "typeMim", "typemim", "TypemIME", "typemme", "typeSmim", "typeMIME", "typemIME"], "tailleFichier": [" tailleficheie", " tailleFixies", " tailleFuzziers", " taillefichie", " tailleFixiers", " tailleFuzzie", " tailleficheier", " tailleFicheier", " tailleficheiers", " taillefichies", " tailleFixie", " tailleFuzzies", " tailleficheies", " tailleFicheies", " tailleFicheiers", " tailleFichie", " tailleFuzzier", " tailleFichies", " tailleFicheie", " taillefichier", " tailleFixier", " tailleFichiers", " taillefichiers"]}}
{"id1": "23510383", "id2": "23666867", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": [" SaveFile", " savePackage", "createPackage", "saveApp", "createProject", "createApp", " saveApp", " SaveApp", "saveFile", " SaveProject", "createFile", " saveFile", "savePackage", " SavePackage"], "file": ["image", "id", "port", "data", "path", "e", "foo", "io", "complete", "files", "real", "in", "File", "resource", "table", "FILE", "link", "report", "dir", "base", "parent", "open", "ame", "ile", "get", "full", "filename", "create", "db", "log", "use", "info", "local", "project", "handle"], "types": ["assets", "models", "values", "sets", "classes", "events", "features", "items", "packs", "times", "files", "actions", "strings", "packages", "issues", "tests", "options", "apps", "ties", "ypes", "thumbnails", "ts", "otypes", "codes", "styles", "objects", " Types", "pes", "services", "Types", "keys", "resources", "posts", "parts", "scripts", "pages", "sites", "ports", "versions", "projects", "plugins", "ids", "names", "groups", "tags", "views"], "images": ["image", "assets", "models", "videos", "classes", "events", "files", "picture", "links", "boxes", "thumbnails", "Image", "styles", "Images", "scripts", "pages", "uploads", "versions", "tags", "media", "faces", "groups", "frames", "blocks", "photos", "views", "icons"], "trajectories": ["tractories", "Trajors", "trajory", "Trajectors", "Trajables", "tractables", "Trajectables", "tractory", "Trajectory", "tractors", "traceptories", "Trajories", "trajectables", "Trajory", "trajables", "trajories", "traceptors", "trajors", "traceptables", "trajectors", "traceptory", "Trajectories", "trajectory"], "databasesIncluded": ["databasesInglisted", "databasesedIncluded", "datadesInified", "datadesInclusion", "daturesIncluded", "daturesInlisted", "daturesInslisted", "databasesedInified", "databasesINified", "databasesInsclusion", "databasesInified", "databasesInsjected", "databasesINclusion", "databasesedInlisted", "datadesInscluded", "databasesINjected", "datadesInsified", "databasesInclusion", "datadesInsjected", "datadesIncluded", "daturesInsclusions", "databasesIngclusions", "datadesInjected", "databasesInslisted", "daturesInclusions", "databasesedInjected", "databasesInsclusions", "databasesedInclusions", "databasesInlisted", "databasesInsified", "daturesInscluded", "databasesInclusions", "databasesInscluded", "databasesedInclusion", "databasesInjected", "databasesIngcluded", "databasesINcluded", "datadesInsclusion"], "onlyLinks": ["forceLink", "forcelinks", "Onlylinks", " onlyLink", " onlylinks", "forceLinks", "OnlyLinks", "alsoLink", "onlyLink", "onlylinks", " onlyRelations", "alsoRelations", "OnlyLink", "alsoLinks", "onlyRelations", "OnlyRelations"], "index": ["initial", "update", "length", "max", "num", "nn", "loc", " Index", "position", "match", "ex", "connect", "sequence", "offset", "set", "zero", "add", "Index", "all", "x", "amount", "address", "pos", "ind", "open", "ion", "inc", "check", " sidx", "no", "number", "i", "find", "fail", "second", "end", "first", "info", "n"], "name": ["image", "id", "data", "nm", "about", "path", "string", "me", "m", "man", "Name", "table", "NAME", "prefix", "run", "base", "parent", "none", "word", "system", "ame", "full", "title", "filename", "create", "default", "named", "root", "names", "primary", "local", "n"], "format": [" Format", "cal", "mt", "value", "MAT", "style", "v", "scale", "fm", "data", "language", "pattern", "list", "color", "form", "print", "percent", "set", "term", "it", "table", "pretty", "init", "prefix", "layout", "base", "unit", "get", "parse", "default", "printf", "Format", "util", "use"], "count": ["length", "ount", "z", "num", "flag", "mark", "sum", "total", "order", "process", "err", "set", "c", "error", "size", "table", "add", "skip", "code", "amount", "depth", "found", "counter", "reset", "start", "Count"], "version": ["translation", "record", "server", "header", "v", "Version", "video", "VER", "mint", "description", "about", "database", "tree", "xml", "section", "alone", "vers", "major", "j", "page", "ver", "python", "connection", "document", "draft", "build", "parent", "java", "latest", "current", "virtual", "number", "json", "versions", "summary", "journal", "root", "release", "VERSION", "information", "result"], "writer": ["access", "output", "writers", "operator", "stream", "server", "woman", "language", "data", "window", "er", "description", "external", "service", "driver", "iterator", "order", "editor", "handler", "buffer", "print", "sw", "walker", "maker", "entry", "wrapper", "wrote", "author", "to", "creator", "report", "browser", "comment", "writ", "wright", "document", "builder", "console", "caster", "function", "connection", "reader", "client", "counter", "write", "writing", "inner", "written", "variable", "flush", "journal", "Writer", "w", "outer"], "xmlDir": ["mlFile", " xmldir", "xmlFolder", "logDirectory", "mlFolder", " xmlFolder", "imageFolder", "xmlDirectory", "xmldir", "imagedir", "logFolder", "logDir", " xmlFile", "logdir", "logFile", " xmlDirectory", "imageDirectory", "imageDir", "xmlFile", "mlDirectory", "mlDir"], "databases": ["generabase", "Datates", "Datasha", "mutasha", " datates", "Datases", " datases", " database", "baselines", "datures", "basabases", "datates", " datasha", "database", "Database", " datas", "notables", "generabases", "mutabases", "notabases", "generas", "mutables", "Datables", "notures", "notelines", "datasha", "Datas", "basables", "datelines", "mutases", "basures", "Datures", " datables", "Databases", "datas", "Datelines", "datases", "datables", "generates"], "t": ["k", "ot", "mt", "id", "v", "p", "typ", "tc", "te", "s", "e", "q", "str", "pt", "term", "it", "c", "j", "ts", "x", "y", "tr", "txt", "h", "template", "i", "tm", "ct", "o", "temp", "T", "w", "tt", "n"], "type": ["top", "object", "TYPE", "pe", "ty", "style", "p", "other", "id", "match", "class", "typ", "language", "relation", "instance", "te", "test", "rule", "ime", "error", "resource", "single", "ping", "link", "to", "ver", "tag", "key", "shape", "base", "address", "y", "this", "unit", "role", "check", "template", "title", "config", "ype", "null", "Type", "parse", "time", "tool", "root", "site", "kind", "info", "module", "result", "action"], "currentName": [" currentNames", "CurrentNames", "baseName", "currentPort", "currentDir", "baseOrder", " currentParent", "reportedTime", "CurrentLock", "CurrentDir", "updateName", "thisSet", "currentTime", "currentlyPath", "reportedDir", "reportedName", "completeName", "CurrentPath", "currentYear", "basePort", " currentOrder", "currentlySet", "currentlyKey", "currentOrder", "currentParent", "reportedParent", "currentlyName", "completeSet", "currentPath", "currentSet", "CurrentParent", "updateOrder", "currentlyTime", "reportedLock", "currentlyYear", "thisName", "CurrentName", "completeKey", " currentPort", "thisKey", "currentNames", "reportedPath", " currentFace", "currentLock", " currentDir", "currentFace", "thisYear", "baseFace", "updatePort", "currentKey", "currentlyLock", "reportedNames", "CurrentTime", "completeYear", "updateFace"], "baseCopy": ["parentCopy", "baseName", " baseName", " baseStore", "baseStore", "basiccopy", "basicCop", "parentcopy", " basecopy", "buffercopy", "BaseName", "parentCop", "basecopy", "Basecopy", "BaseCop", "baseCop", "basicStore", " baseCop", "basicCopy", "bufferCopy", "BaseCopy", "BaseStore", "bufferCop", "parentName"], "source": ["initial", "original", "scope", "store", "search", "stream", "shell", "scan", "SOURCE", "channel", "data", "select", "service", "ources", "iterator", "owner", "target", "origin", "sequence", "ource", "src", "space", "subject", "from", "resource", "join", "size", "init", "connection", "console", "base", "parent", "reader", "before", "system", "input", "se", "create", "inner", "start", "Source", "sample", "site", "local", "master"], "destination": ["Destuation", " destinated", "declination", " destructure", "destructure", "Destregation", "destregation", "datinator", "datinations", "Destination", "declinations", "Destructure", "Destinated", "destuation", "Destinations", "datination", "Destinator", " destuation", "messination", "declinator", "messinations", "messructure", "destinations", " destinations", "messinated", "messuation", "datregation", "destinated", "declregation", "destinator"], "clefs": [" CleFs", " cleFS", "CleFs", "clefits", "CLEcs", " cleFs", " clebs", "Clefs", "cleFs", " Clecs", "clebs", " Clebs", "CLEFs", " Clefits", "CLEfs", "CleFS", "Clebs", " Clefs", "Clecs", "CLEfits", "cleFS", " CleFS", "clecs", "Clefits"], "st": ["sth", "dd", "sl", "mt", "bl", "std", "sts", "sc", "sn", "str", "irst", "pt", "sw", "it", "St", "inst", "fr", "storage", "ts", "sy", "query", "sb", "sp", "bt", "est", "h", "cr", "se", "ST", "ste", "statement", "cl", "ost", " ST", "start", "ct", "ist", "rest", "stat", "stra", "tt", "sm"], "rs": ["ins", "rt", "mr", " RS", "cs", "rc", "ris", " ms", "ls", "sts", "ers", " ins", " iss", "RS", "Rs", "rys", "ds", "ts", "as", " pts", "res", " ps", " cs", "os", "ks", "rd", " sr", "ps"]}}
{"id1": "11556231", "id2": "23677128", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"ByURL": ["ByHTTP", "byHTTP", "byURL", "createURL", "byUrl", " byURL", "createUrl", " byString", " byHTTP", "ByString", "ByUrl", " byUrl", "createHTTP", "createString", "byString"], "urlstr": ["uriStr", "Urlobj", "lobj", "uriobj", "ulStr", "urlobj", "uristr", "Urlstring", "uristring", "lSTR", "lstring", "ulstring", "ulstr", "lStr", "Urlstr", "UrlStr", "urlStr", "urlstring", "ulSTR", "UrlSTR", "urlSTR", "lstr"], "uri": ["context", "u", "uid", "ri", "id", "https", "du", "doi", "description", "string", "path", "io", "origin", "q", "database", "URI", "subject", "term", "resource", "http", "link", "range", "ur", "prefix", " URI", "init", "query", "URL", "file", "uu", "address", "directory", "reference", "phi", "iri", "system", "ui", "i", "filename", "Url", "href", "html", "pi"], "url": ["loc", "f", "host", "sl", "ssl", "location", "ls", "char", "str", "parser", "ll", "conn", "resource", "http", "li", "ul", "nl", "link", "socket", "browser", "ur", "impl", "URL", "file", "sb", "build", "base", "address", "open", "client", "mail", "mount", "r", "Url", "l", "hub", "parse", "job"], "connection": ["context", "engine", "established", "position", "channel", "Connection", "connect", "relation", "service", "con", "io", "handler", "database", "network", "conn", "application", "c", "resource", "http", "response", "link", "socket", "session", "console", "connected", "directory", "open", "ion", "client", "number", "i", "condition", "using", "command", "opening"], "in": ["f", "ins", "din", "en", "stream", "id", "IN", "sin", "us", "inn", "inf", "cin", "mm", "bin", "from", "mc", "file", "ma", "body", "ind", "client", "out", "rin", "get", "i", "input", "r", "inner", "l", "mat", "isin", "info", " din", "In"], "reader": ["context", "dr", "stream", "ri", "er", "iterator", "io", "handler", "buffer", "parser", "loader", "writer", "resource", "runner", "ator", "reading", "ro", "builder", "body", "Reader", "rar", "rx", "input", "r", "iter", "inner", "ner", "row", "read", "handle"], "is": ["isa", "fs", "sis", "ins", "lis", "ri", "iss", "rs", "ris", "are", "serv", "isi", "nis", "s", "sys", "ms", "sim", "has", "ism", "bis", "as", "IS", "res", "sam", "iris", "mis", "Is", "isc", "i", "input", "se", "es", "os", "ais", "its", "info", "isin", "im", "ios"], "document": ["context", "object", "record", "output", "node", "message", "content", "tree", "m", "xml", "application", "collection", "response", "ocument", "page", "Document", "file", "dom", "library", "element", "template", "doc", " Document", "media", "information", "result"], "source": ["context", "object", "node", "SOURCE", "location", "instance", "select", "content", "dest", "sn", "handler", "ource", "src", "tree", "set", "or", "resource", " src", "event", "element", "out", "number", "input", "se", "Source", "site", "result"], "name": ["param", "object", "value", "id", "node", "location", "class", "format", "description", "string", "path", "attr", "Name", "comment", "attribute", "prefix", "key", "NAME", "tag", "label", "file", "code", "event", "property", "title", "version", "type", "variable", "default", "named", "names"], "namespaceURI": ["nspaceID", "namesplaceID", "namespaceRI", "nsplaceURL", "namesenterRI", "workspaceuri", "namesetURI", "namesetID", "namesenterURI", "namespaceIX", "namespaceuri", "worksystemuri", "nameseturi", "nspaceURI", "namesplaceURL", "namesificationuri", "workspaceRI", "namespaceURL", "namesaceURI", "namesystemRI", "resourcespaceUI", "namesetURL", "resourcespaceIX", "worksystemURI", "namesificationRI", "nspaceuri", "namesystemUID", "workspaceUID", "worksystemRI", "nsplaceuri", "namesificationUID", "nsplaceID", "resourcesacementIX", "namesenterUID", "workspaceURI", "namespaceID", "resourcesacementURI", "resourcespaceURI", "namesacementURI", "namesificationURI", "worksystemUID", "namespaceUID", "resourcesacementUI", "namesenteruri", "namesystemuri", "namesystemURI", "namesaceUI", "namespaceUI", "namesaceIX", "nspaceURL", "namesacementIX", "namesacementUI", "namesplaceuri", "nsplaceURI", "namesplaceURI"], "qualifiedName": ["localname", "fullName", "fullNames", "fullValue", "commonType", "commonname", "relativeName", "friendlyNames", "friendlyname", "relativeValue", "localValue", "fullname", "friendlyName", "relativeNames", "qualifiedname", "commonNames", "friendlyType", "localNames", "qualifiedValue", "localType", "commonName", "qualifiedNames", "qualifiedType", "relativename"], "data": ["image", "DATA", "object", "value", "output", "mode", "ata", "dat", "message", "pattern", "format", "description", "content", "string", "buffer", "str", "xml", "text", "definition", "error", "resource", "response", "comment", "key", "expression", "body", "address", "event", "element", "def", "input", "version", "type", "media", "password", "command", "info", "result", "action"], "tagName": ["TagData", "localname", "Tagname", "localData", "qualifiedValue", "TagName", "qualifiedData", "qualifiedname", "tagData", "tagValue", "localValue", "TagValue"], "target": ["context", "object", "node", "location", "class", "language", "instance", "format", "content", "path", "owner", "ref", "handler", "src", "subject", "error", "alias", "link", "prefix", "role", "binding", "property", "title", "ip", "command", "Target", "result", "action"], "elementId": ["documentid", "elementid", "nodeid", "documentID", "objectIndex", "objectid", "documentIndex", "objectId", "nodeId", "elementID", "objectID", "nodeID", "elementIndex", "documentId", "nodeIndex"], "tagname": ["shortname", "localid", "localnum", "localname", "Tagname", "Tagid", "shortnum", "TagName", "Tagnum", "tagid", "shortName", "tagnum", "shortid"], "localName": ["fixedname", "fixedNAME", "localNAME", "localname", "supportedname", "fixedName", "componentNames", "supportedName", "componentName", "localNames", "fixedNames", "supportedNames", "componentname", "supportedNAME", "componentNAME"]}}
{"id1": "4602568", "id2": "21656668", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"storeImage": [" storeFile", "storeFile", "savePicture", "storePicture", " storePicture", " storeImages", "StoreImages", "saveFile", "saveImage", "StoreFile", "storeImages", "saveImages", "StorePicture", "StoreImage"], "inStream": ["inputView", "fileFile", "cinStream", "inFile", "inSteam", "fileStream", "cinView", "inputSteam", " inView", "outSteam", "inputStream", "fileSteam", " inSteam", "inForm", "fileForm", " inForm", "cinFile", " inFile", "outFile", "inView", "outForm", "cinSteam", "inputFile"], "fileName": ["resourcePath", " fileInfo", "imageName", "fileInfo", "FileType", "FileInfo", "imagePath", "FileTime", "Filename", "fileTime", " filename", "FILEPath", "imageTime", "FilePath", " fileType", "FILEName", "imageInfo", " filePath", "filePath", "imageType", "filename", "imagename", "resourceName", "resourceTime", "FileName", "resourceType", "fileType", "FILEname", "FILEInfo"], "resize": ["renizes", "renized", "Resized", "Resize", "ressize", "rensize", "renize", "Ressize", " resizes", " ressize", "resized", "resizes", "Resizes", " resized"], "rightNow": ["westServer", " RightCurrent", "rightCurrent", "rightToday", " rightServer", "westThen", " rightCurrent", "RightCurrent", " rightFuture", "rServer", " RightNow", "rNow", "correctFuture", " RightThen", "RightNow", "rToday", "RightFuture", "westNow", "correctNow", "rightFuture", "westToday", "westCurrent", "rightNOW", "rightThen", "correctNOW", " rightNOW", " rightToday", "correctToday", "rNOW", " rightThen", "westNOW", "westFuture", "rightServer", " RightNOW", "RightToday"], "dayNamedFolderName": ["dayNamingDirectoryName", "dayNamedFileSize", "dayNamedfolderNames", "dayNamingDirectoryNames", "dayNamedThemeSize", "dayNamedFilename", "dayNamedFolder1", "dayNamedDirectoryName", "dayNamedDirectoryNames", "dayNamedFilePath", "dayNamedAreaNames", "dayNamedfolderPath", "dayNamedFileName", "dayNamedArea1", "dayNamedDirectoryname", "dayNamedFolderSize", "dayNamedFoldername", "dayNamingFileSize", "dayNamingDirectoryname", "dayNamedFolderNames", "dayNamedDirectory1", "dayNamedThemeNames", "dayNamingFoldername", "dayNamingFolderNames", "dayNamedFileNames", "dayNamingFolderSize", "dayNamedAreaname", "dayNamingFolder1", "dayNamingFileName", "dayNamedThemename", "dayNamedAreaName", "dayNamedFolderPath", "dayNamedfolderName", "dayNamingFolderPath", "dayNamingFilename", "dayNamedThemePath", "dayNamingFolderName", "dayNamedfoldername", "dayNamedfolder1", "dayNamingFilePath", "dayNamingDirectory1", "dayNamingFileNames", "dayNamedThemeName"], "uploadDirRoot": ["uploadDbParent", "uploadUrlroot", "UploadDirroot", "UploadDirBase", "uploadDbCover", "uploadNetCover", "uploadDbRoot", "saveDirParent", "saveDirroot", " uploadRelBase", "saveDbroot", "UploadDirCover", "uploadFolderRoot", "uploadRelRoot", "uploaddirCover", "uploadUrlRoot", "uploadRelroot", "uploadUrlPath", "uploadDbroot", "uploadDirectoryRoot", "uploadNetroot", "uploadNetRoot", "uploadDirPath", " uploadRelRoot", " uploadDirPath", "uploadDbBase", "uploadRelPath", "uploadDirectoryParent", "uploadNetBase", " uploadDirBase", "UploadDirRoot", "uploadDirroot", "uploaddirRoot", " uploadRelPath", "uploadDirectoryroot", "uploadDirBase", "uploadFolderroot", "saveDbRoot", "UploadDbRoot", "uploadUrlBase", "saveDirRoot", "uploadFolderPath", " uploadDirroot", "UploadDbBase", "UploadDbroot", " uploadRelroot", "UploadDbCover", "uploadDirParent", "uploadUrlParent", "uploadFolderBase", "uploadDirCover", "uploaddirBase", "uploaddirroot", "uploadRelBase", "saveDbParent"], "file": ["f", "image", "folder", "el", "top", "entity", "node", "port", "work", "channel", "class", "il", "task", "tree", "File", "resource", "table", "FILE", "link", "to", "page", "dir", "key", "run", "op", "force", "base", "parent", "pool", "name", "open", "no", "up", "ile", "get", "source", "full", "h", "null", "type", "time", "t", "local", "project", "handle"], "extension": ["extendant", "exensions", "dimensions", "exension", "xtended", "xtention", "xtension", "EXTended", "exendant", "EXTend", "expention", "EXTention", "extention", "EXTension", "expension", "extended", "dimension", "dimendant", "xtend", "extend", "expended", "expendant", "expensions", "dimention", "extensions", "exention", "expend"], "outFileName": ["outFilenameInfo", "outFilesName", "OutFileName", "outLogPath", "outImagename", "outFilenameType", "outDirPath", "outFilePath", "outFileNames", " outLineNames", "outFilenameNames", "OUTFilename", "OutfileKey", "OUTLogname", "outfileVersion", "OUTFileName", "outFilenameKey", "OUTLogName", "outfileNames", "outLineKey", "outLogKey", "outImageKey", "outfilename", "outFieldName", "outFilesPath", "OUTLogKey", "outImageInfo", "outDirName", " outLineInfo", "OUTFileKey", " outLogNames", "outfileSize", " outFilePath", "outFieldType", "outFileInfo", "OutFilename", "infilename", "outLineName", "outfileType", "outFileSize", "outFilenamePath", "outLinename", "outImageNames", " outFileVersion", "inFilename", "OutfilePath", "outImagePath", "infileName", " outFilename", "outLineInfo", "Outfilename", "inFileType", " outLogVersion", " outFileNames", "outFieldPath", "OUTLogPath", "OutFilePath", "inFileName", "outfilePath", "outLinePath", "outfileKey", "outLogName", "outFilenamename", " outLinePath", "outFilename", "OutFileKey", " outFileInfo", "outLogname", "outFieldSize", "outfileName", " outLineName", "outFilenameSize", "outFileType", "OUTFieldName", "infileSize", "outLineNames", "OUTFilePath", "outFilenameVersion", " outLogName", "outFilesname", "OUTFieldname", "outFilenameName", "outFileKey", "outDirname", "OUTFieldPath", "outImageName", "outFileVersion", "OutfileName", "outLogNames", "outFieldname", " outLogname", "inFileSize", "infileType", "outLogVersion"], "outPathAndName": ["outPathAndSize", "outPathandPath", "outLocationAndSize", "outPathANDName", "outPathOrPath", "outPathButPath", "outPortAndName", "outPathandName", "outTimeAndName", "outLocationandKey", "outPathButName", "outPathANDTime", "outPortButName", "outPathAndTime", "outPathOrSize", "outTimeButPath", "outTimeAndPath", "outPathAndLike", "outPathButLike", "outPathAndNames", "outTimeButLike", "outPathandSize", "outPortAndPath", "outPortButPath", "outLocationAndName", "outPathAndKey", "outPathButKey", "outPathButTime", "outTimeButTime", "outPathOrTime", "outPathandNames", "outLocationandName", "outPathandKey", "outTimeButName", "outPathOrLike", "outPathOrName", "outLocationandNames", "outPathOrNames", "outPortButKey", "outPathANDLike", "outPathAndPath", "outPathOrKey", "outLocationAndKey", "outTimeAndLike", "outLocationandSize", "outPortAndKey", "outPathANDPath", "outTimeAndTime", "outLocationAndNames"], "uploadedFile": ["presentedfile", "uploadededPlace", " uploadedifiedF", "uploadifiedF", "presentedFile", "uploadedFormat", "uploadifiedUnit", "uploadredPlace", "uploadedF", "uploadededFile", " UploadmedGlobal", "uploadifiedLine", "uploadedGlobal", " uploadededUnit", " uploadedifiedFile", "uploadashedFile", "uploadpedLine", "uploadredFormat", " UploadmedFormat", "uploadiedLine", "uploadedField", "uploadedFILE", " UploadedFormat", "uploadredFile", "uploadmedGlobal", " UploadmedPlace", "uploadpedUnit", "uploadtedFile", " uploadededLine", "uploadiedUnit", "uploadpedF", " uploadededF", " uploadedifiedLine", "uploadiedFile", "uploadiedF", " UploadedFile", "uploadtedFILE", "uploadedfile", " uploadededFile", "uploadedPlace", "uploadifiedFile", "uploadmedPlace", "uploaderField", " UploadedPlace", "uploadtedfile", "uploadedLine", " UploadedGlobal", "uploadtedField", "uploadededGlobal", "uploaderFILE", " uploadedifiedUnit", "uploadredGlobal", "uploadedUnit", " UploadmedFile", "presenttedfile", "uploadashedfile", "uploadpedFile", "uploaderfile", "presenttedFILE", "presentedFILE", "uploadmedFile", "uploaderFile", "presenttedFile", "uploadashedField", "uploadashedFILE", "presentedField", "presenttedField", "uploadededFormat", "uploadmedFormat"], "outStream": ["oSteam", " outView", "oView", "inFile", "inSteam", "outSteam", "_", "oFile", "oStream", "outView", " outFile", " outSteam", "outFile", "inView"]}}
{"id1": "4686922", "id2": "13666876", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourcesToStream", "extractResources2File", "extractResourceAsfile", "extractResources2Files", "extractResource2Files", "extractResourceAsStream", "extractResources2Stream", "extractResourceFromStream", "extractResource2Stream", "extractResourceAsFile", "extractResourcesTofile", "extractResourceToFiles", "extractResourceFromFiles", "extractResourceTofile", "extractResourcesToFiles", "extractResourceToStream", "extractResourceAsFiles", "extractResourcesToFile", "extractResourceFromfile", "extractResource2File", "extractResource2file", "extractResourceFromFile", "extractResources2file"], "resourcePath": ["ResourceUrl", "ResourceName", "ResourceLocation", "templateName", "resourceUrl", "templatepath", " resourcepath", "attributePath", "attributeLocation", "uriUrl", "ResourceIn", " resourceIn", "Resourcepath", "resourcepath", "uriLocation", "uriName", "resourceIn", "uriPath", "templateIn", "templatePath", "attributeUrl", " resourceName", "attributeName", "resourceName", "resourceLocation", "ResourcePath"], "dest": ["loc", "output", "Dest", "cont", "dat", "self", "home", "target", "origin", "src", "etc", "dist", "to", "orig", "trans", "dir", "coord", "img", "nom", "des", "tmp", "sp", "parent", "this", "good", "opt", "gov", "mem", "comb", "source", "cat", "lit", "null", "desc", "decl", "prop", "rest", "end", "w", "temp", "result"], "in": ["f", "mi", "ins", "din", "inside", "id", "ini", "IN", "sin", "inn", "con", "ln", "ne", "inf", "cin", "gin", "local", "on", "m", "bin", "from", "raw", "it", "or", "resource", "re", "all", "init", "file", "mc", "al", "none", "ind", "is", "inc", "no", "up", "rin", "i", "input", "source", "r", "inner", "iter", "conf", "l", "isin", " din", "In"], "out": ["f", "cn", "ot", "output", "OUT", "en", "co", "b", "v", "again", "cache", " Out", "stable", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "ou", "col", "note", "to", "obj", "res", "aos", "tmp", "nt", "cos", "pool", "ch", "can", "client", "no", "write", "i", "oss", "conv", "inner", "os", "null", "na", "o", "t", "exit", "Out", "at", "w", "outer", "n"]}}
{"id1": "838844", "id2": "2199604", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["compversion", "CONfer", "converted", "CONvert", "consversion", "converting", "unverted", "converts", "Converted", "Conversion", "compverts", "unvert", "compvert", "CONverting", "Confer", "unversion", "Convert", "Converts", "Converting", "confer", "consVERT", "unprocess", "consverting", "CONverted", "conVERT", "consvert", "unfer", "unverts", "CONVERT", "conversion", "CONversion", "conprocess", "compprocess", "ConVERT", "Conprocess"], "src": ["loc", "host", "iv", "rel", "ins", "stream", "rc", "rs", "SOURCE", "RC", "scan", "scene", "SourceFile", "sc", "ebin", "hl", "sin", "cc", "s", "usr", "path", "addr", "sys", "attr", "ource", "str", "st", "from", "sq", "pkg", "func", "http", "inst", "dist", "sit", "upload", "ser", "orig", "req", "ur", "img", "file", "rx", "buster", "txt", "ipl", "source", "input", "filename", "cur", "config", "uri", "start", "url", "sr", "its", "Source", "rest", "href", "cont"], "dest": [" destination", " Destination", "port", "Dest", "dat", "tif", " orig", "disk", "target", "test", "gin", "table", "dist", "orig", "dir", "img", " dst", " Dest", "est", "write", "txt", "source", " destinations", "foreign", "mat", "rest", "temp", "result"], "in": ["ins", "din", "el", "en", "stream", "b", "serv", "IN", "inn", "io", "inf", "cin", "m", "bin", "from", "st", "ar", "as", "sql", "ad", "file", "res", "reader", "ind", "is", "up", "rin", "d", "source", "input", "i", "r", "inner", "l", "isin", "In"], "p": ["f", "pe", "b", "jp", "php", "er", "pers", "dp", "P", "m", "pm", "parser", "py", "pt", "pp", "pd", "pre", "c", "pkg", "part", "ping", "vp", "post", "it", "ph", "j", "pg", "wp", "op", "sp", "prot", "pc", "per", "cp", "lp", "pa", "pro", "fp", "h", "ap", "pl", "i", "r", "g", "l", "parse", "rep", "t", "d", "at", "tp", "ps", "pb", "pi"], "ds": ["bs", "rs", "drivers", " os", "dl", "yes", "aws", "js", "gs", "ts", "ads", "df", "tes", "eds", "ras", "mys", "di", "nas", "ks", "ports", "its", "ods", "d", "gd", "ats", "xs", "ands", "dds", "sets", "dt", "dh", " dd", "DS", "lists", "vs", "uds", "ags", "scripts", "iffs", "ws", "tags", "els", "dd", "terms", " d", " des", "ls", "sd", "s", "tests", "outs", "posts", "docs", "ils", "os", "Ds", "hs", "hd", "ps", "dp", "cs", "sts", "ys", "ns", "obs", "ss", "pd", "dos", "des", " DS", "workers", "eps", "dates", "loads", "points", " ads", "db", "cks", "edes", "qs", "tp", "amps"], "format": ["f", "feat", "top", " Format", "ats", "mt", "output", "MAT", "id", "style", "cf", "mode", "pattern", "fm", "feature", "path", "form", "set", "it", "sche", "status", "table", "size", "spec", "pretty", "tag", "shape", "file", "layout", "act", "settings", "name", "lat", "unit", "template", "source", "title", "policy", "l", "version", "type", "parse", "ct", "mat", "t", "filter", "Format", "at", "module", "fc", "pi"], "hasPixelData": ["HasPixelDATA", "HasPixelData", "hasixelData", " hasPixeldata", " hasPixelDATA", "hasPixeldata", "hasFramedata", "HaspixelData", "HaspixelDATA", "HasPixeldata", "haspixeldata", "hasPixelDATA", "haspixelData", "haspixelDATA", "hasFrameData", "hasixeldata", "Haspixeldata", "hasFrameDATA", "hasixelDATA"], "inflate": ["incelATE", "infolate", "infolocate", "informat", "Informated", "Informat", "infolat", "Informocate", "incelate", "infolated", "invalidicate", "incelocate", "invalidATE", "inflocate", " invalidate", "informocate", "inFlate", "inflated", " inflATE", " invalidicate", "informate", "invalidocate", "Inflate", "Inflat", "inFLate", " invalidocate", "Inflated", "inFlicate", "Informate", " invalidATE", "inFLated", "inFLocate", "inFlocate", "incelicate", "informated", "Inflocate", "invalidate", " inflicate", "inflATE", " inflocate", "inflat", "inFLat", "inflicate", "inFlATE"], "pxlen": ["mxln", "tmplen", "packfun", "packls", "mxlen", "xylen", "pexln", "xpden", "tmpln", "phplength", "packln", "pexlen", "pexden", "mmlin", "pxlength", "mxdec", "phpln", "pexlength", "xylength", "pxlin", "xyln", "xylin", "pxln", "packlength", "xpln", "cplength", "pixellen", "pxls", "cpden", "cpln", "xplength", "pixelfun", "cplen", "tmplength", "packlen", "pxfun", "pexls", "pixells", "xplen", "mmln", "pxden", "mmlength", "mmlen", "tmplin", "pixellength", "phpdec", "phplen", "packdec", "mxlength", "pxdec", "pexfun"], "out": ["crit", "cmd", "output", "store", "OUT", "gr", "ex", "screen", "sum", "list", "user", "net", "io", "group", "print", "sys", "cfg", "ln", "err", "conn", "outs", "writer", "ou", "inv", "pretty", "prefix", "dir", "init", "obj", "res", "aos", "msg", "name", "client", "gov", "inter", "up", "log", "Out", "temp", "outer"]}}
{"id1": "2022160", "id2": "14758866", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"write": ["copy", "output", "store", "patch", "port", "scale", "connect", "format", "sync", "process", "walk", "partial", "print", "rite", "network", "set", "wrote", "commit", "writer", "size", "link", "to", "apply", "export", "register", "render", "writ", "run", "cycle", "batch", "code", "execute", "only", "change", "put", "see", "call", "append", "get", "wire", "create", "close", "writing", "fit", "find", "Write", "written", "fail", "flush", "save", "log", "next", "end", "wait", "w", "send", "read", "handle"], "byteBuffers": ["byteBuffainers", "bitEntrs", "bytePacks", " byteBuffines", "bytePackrys", "byteWaiterers", "byteBindodes", "bytePackusters", "bytebuffainers", "bytesBuffs", "bytesHeadters", "byteBindlers", "byteIndexers", "byteHeader", "byteFragers", "byteDefers", "byteHoldiers", "byteBuffrs", "bitEnters", "bytesBuffters", "byteHolderers", " bytebuffers", "byteCombers", "byteDeflers", "byteOrdrs", "bitEntters", "bytesBuffERS", "bytesHeaders", "bytesBuffrs", "byteBuffererers", "bytesHeadered", "byteFraglers", "byteCombrs", "byteBufferered", " byteDefels", "byteBuffators", "byteCountERS", "bytesBufferers", "byteBuffodes", "byteHoldered", " byteNamesines", "byteCorners", "bytesPackerers", "ByteHeadERS", "byteWaitERS", "byteBytesERS", " bytePacklers", "byteOffered", "bytebuffers", " bytePackers", "byteBindERS", "byteIndexators", " byteNamesERS", "bytesbuffrys", "byteBuffer", " byteDefers", " bytebuffters", " byteBufferers", "ByteBuffers", "bytesBufflers", "byteHeaders", "bytebuffiers", "byteBuffines", "bytesHoldters", " byteBuffered", " bytebuffERS", "byteDefels", "bytePackainers", "byteBufferters", "bytesbuffs", " byteBuffs", "bytesbuffers", "byteBinders", "bytePackered", "byteBuffrys", "byteOrdonents", "byteBuffered", " byteBuffiers", "bytesHolders", "bytesbuffERS", "byteNamesers", "byteBuffiers", "bytebuffusters", "bytebuffrys", "byteBufferers", "byteHeadters", "bytebuffodes", "bytesHoldERS", "byteEntonents", "bytePackters", "byteOffters", "byteBuffERS", "bytebuffines", "bitBuffters", "bitBuffrs", " bytebufferers", "byteEnters", "byteBuffters", "byteHeadrs", "bitEntonents", " bytePacks", "bytesHeader", "bytesBuffer", "byteFrags", "bytePackERS", "bytePackers", "bytebufferers", "byteNameserers", "byteWaiters", " byteNameserers", "byteHeadERS", " bytePackERS", "byteBytess", "byteCornerers", "bytebufflers", "byteCountered", "byteBuffs", " byteBuffERS", " byteDefERS", "byteCountters", "byteFragusters", "byteHoldERS", "ByteBuffERS", "byteOffer", "bytesPackators", " bytePackusters", "byteBufferlers", " byteDeflers", "bytesBuffered", " bytebuffiers", "byteBytesrys", "bytesHoldered", "bytesPackrs", "ByteHeadered", "byteHoldters", "byteBufferines", " byteBuffels", "ByteBuffrs", "byteCorniers", "bytebuffs", "byteBuffonents", "byteOrdters", "byteOffers", "byteBufferels", "ByteBuffered", "byteNamesines", " byteBufflers", "bytesPackers", "byteIndexerers", " byteBuffusters", " byteBuffters", "bytebuffters", "ByteHeaders", "byteCounters", "bytesBuffrys", "bytebuffered", "bytePacklers", "bytePackrs", "byteBufflers", "byteIndexrs", "byteEntters", "bytesbufflers", "byteBuffels", "byteEntrs", "byteWaitainers", "byteBuffusters", "byteDefERS", "byteCornters", " bytePackainers", " bytePackerers", "bytesBuffers", "bytesbuffodes", "byteBufferERS", "byteCombters", "bytePackators", "byteOrders", " byteBuffainers", "byteHeadered", "bytesBuffodes", "bytebuffERS", "bitBuffers", "byteCombonents", "byteNamesERS", "bytePackerers", " byteNamesers", "byteHolders", "ByteHeadrs", "bytesBuffators", "bytePacker", "bitBuffonents", "byteBytesers", " bytebuffered"], "m_initialOutBuffer": ["m_initialCheckQueue", "m_InitialOutLength", "m_initialHostbuffer", "m_initialoutCache", "m_firstOutBuff", "m_initialByteWriter", "m_initialNetQueue", "m_initialOutputThread", "m_firstoutBuff", "m_initialInCache", "m_currentOutCache", "m_currentInBuff", "m_initialInBuff", "m_finalOutputThread", "m_InitialoutBuff", "m_initialOutCache", "m_finalOutBuffer", "m_initialCheckBuffer", "m_InitialoutCache", "m_InitialOutBuff", "m_initialByteCache", "m_initialOutChannel", "m_currentoutCache", "m_finalOutBuff", "m_initialEndLength", "m_initialInView", "m_initialNetBuffer", "m_firstOutCache", "m_InitialoutLength", "m_initialOutBuff", "m_initialInWriter", "m_initialInbuffer", "m_initialInQueue", "m_firstoutCache", "m_initialoutQueue", "m_initialNetChannel", "m_firstoutBuffer", "m_currentInChannel", "m_initialEndBuffer", "m_InitialoutBuffer", "m_initialHostView", "m_currentInBuffer", "m_currentoutBuff", "m_initialOutLength", "m_finalOutputQueue", "m_initialCheckBuff", "m_initialOutQueue", "m_initialByteBuff", "m_finalOutputBuffer", "m_initialInThread", "m_initialNetCache", "m_initialOutThread", "m_currentInQueue", "m_InitialOutCache", "m_currentOutQueue", "m_initialCheckChannel", "m_initialOutputBuff", "m_initialHostBuffer", "m_initialoutWriter", "m_initialInChannel", "m_initialOutputBuffer", "m_firstoutWriter", "m_currentOutChannel", "m_finalOutputBuff", "m_initialByteBuffer", "m_finalOutThread", "m_firstOutWriter", "m_currentoutBuffer", "m_finalOutQueue", "m_initialoutBuff", "m_initialOutView", "m_currentOutBuff", "m_initialNetBuff", "m_firstOutBuffer", "m_initialoutBuffer", "m_initialEndBuff", "m_InitialOutBuffer", "m_initialHostBuff", "m_currentoutQueue", "m_initialInLength", "m_initialoutLength", "m_initialOutputQueue", "m_initialInBuffer", "m_currentOutBuffer", "m_initialOutbuffer", "m_initialEndCache", "m_initialNetThread", "m_initialOutWriter"], "buffer": ["stream", "pair", "buf", "empty", "stack", "button", "socket", "page", "comment", "attribute", "address", "flash", "template", "null", "row", "url", "length", "callback", "context", "store", "server", "holder", "match", "cache", "profile", "iterator", "chain", "tree", "table", "bar", "document", "batch", "loop", "memory", "internal", "Buffer", "filter", "background", "command", "timer", "temp", "initial", "container", "engine", "header", "binary", "channel", "bo", "message", "layer", "timeout", "response", "builder", "base", "source", "buff", "processor", "output", "window", "list", "thread", "queue", "sequence", "phrase", "database", "block", "map", "bridge", "connection", "directory", "pool", "iter", "manager"], "buffers": ["bufflers", "offERS", "rendlers", "buffards", "bindters", "comblers", " buffERS", "uflers", "offters", " buffters", "ufERS", "buffors", "binders", "ufards", "ufers", "bufers", "holders", "offers", "bufings", "buffings", "renders", " buffings", "holdters", "buflers", "ufors", "rendters", "bufards", "bindERS", "ufters", "offors", "buffERS", "combards", "bufters", "holdings", "combERS", "buffters", "bindlers", "bufERS", "rendERS", " buffors", "holdERS", "combers"], "result": ["context", "progress", "output", "product", "search", "mate", "other", "match", "cache", "we", "data", "message", "relation", "profile", "pair", "description", "Result", "process", "user", " resulted", "group", "complete", "test", "diff", "valid", "wrapper", "continue", "ret", "request", "answer", "error", "status", "resource", "re", "load", "response", "runner", "reason", "ser", "that", "report", "ver", "comment", "res", "uu", "event", "see", "current", "role", "true", "details", "cur", "r", "done", "iter", "created", "results", "null", "json", "success", "make", "next", "successful"], "encrypted": ["context", "engine", "other", "confirmed", "channel", "selected", "external", "secret", "secure", "chain", "sequence", "checked", "finished", "options", "error", "table", "available", "verified", "locked", "flash", "extra", "armor", "internal", "created", "ended", "password", "temp"]}}
{"id1": "2518655", "id2": "5148212", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"fnOut": ["fnOs", " fnNet", "pdfIn", "fnOr", "synIn", " fnOutput", "bfIn", "synOut", "bfOut", "pdfNet", "dnOr", "pdfOut", "dnOutput", " fnIn", "synOutput", "dnOut", "pdfOs", "bfOs", " fnOs", "fnIn", "synOr", "fnOutput", "bfNet", " fnOr", "dnIn", "fnNet"], "writer": ["riter", "operator", "writers", "rator", "println", "window", "format", "external", "service", "driver", "editor", "print", "buffer", "handler", "aster", "parser", "walker", "maker", "zero", "loader", "wrapper", "commit", "table", "worker", "runner", "width", "creator", "report", "comment", "builder", "file", "wright", "caster", "console", "auto", "widget", "writ", "fn", "reader", "master", "client", "write", "writing", "close", "inner", "white", "her", "written", "variable", "flush", "journal", "Writer", "and", "w", "send", "outer"], "i": ["mi", "u", "id", "ri", "v", "ix", "ini", "I", "us", "ii", "si", "ai", "bi", "chain", "q", "my", "m", "me", "sim", "ki", "iu", "ic", "multi", "it", "c", "ei", "li", "ti", "ij", "j", "xi", "ims", "init", "key", "x", "hi", "ma", "batch", "ie", "phi", "y", "ind", "is", "client", "ui", "ogi", "gu", "uri", "g", "di", "gi", "ci", "ip", "ski", "\u0438", "qi", "im", "pi"], "fInput": ["sfInput", "fileinput", "cfOutput", "cfinput", "finput", "fileOutput", "fNew", " finput", "fileInput", "fIn", "lNew", "fileIn", "cfNew", "lInput", " fIn", "linput", "cfInput", "sfinput", "sfIn", "sfOutput", " fNew", "fOutput", " fOutput", "lOutput"], "in": ["ins", "din", "inside", "en", "again", "pin", "serv", "ini", "IN", "sin", "inn", "con", "ln", "inf", "cin", "gin", "kin", "bin", "it", "or", "vin", "re", "all", "thin", "al", "ma", "ind", "is", "inc", "client", "out", "check", "rin", "input", "r", "inner", "conv", "conf", "t", "isin", "info", " din", "In", "n"]}}
{"id1": "12537270", "id2": "6159896", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"parse": ["update", "p", "match", "format", "pair", "php", "process", "delete", "print", "Parser", "parser", "error", "layer", "ping", "resource", "load", "replace", "arse", "build", "slice", "check", "split", "loop", "se", "close", "read", "handle"], "link": ["image", "loc", "rel", "id", "style", "match", "script", "linked", "pattern", "char", "string", "e", "path", "ln", "le", "index", "ink", "links", "block", "entry", "join", "ping", "load", "frame", "add", "page", "label", "tag", "sp", "address", "name", "word", "lock", "element", "line", "Link", "template", "let", "source", "se", "uri", "l", "route", "start", "type", "ip", "log", "html", "local", "action"], "conn": ["loc", "cn", "rel", "ann", "cmd", "org", "cs", "ls", "enc", "connect", "nc", "con", "ln", "ait", "addr", "ns", "ctx", "err", "nav", "resp", "c", "nec", "comm", "socket", "yn", "connection", "res", "Conn", "obj", "nt", "act", "ch", "cp", "open", "client", "txt", "ner", "cr", "ctrl", "cat", "conv", "oss", "ctr", "gn", "ct", "pas", "ws", "cb", "cont"], "rd": ["hr", "rog", "din", "dr", "rt", "dd", "mr", "ri", "rc", "rs", "red", "nd", "rh", "usr", "rand", "vr", "lr", "rid", "rob", "rl", "rn", "fr", "ro", "rw", "rad", "rr", "reader", "rar", "rx", "r", "ld", "raf", "rer", "ird", "rb", "sr", "erd", "ra", "d", "wr"], "kit": ["k", "et", "tk", "iz", "rt", "sky", "cu", "tc", "sc", "iw", "mk", "ang", "boot", "net", "io", "box", "sys", "ctx", "kt", "set", "bot", "maker", "pack", "js", "webkit", "ic", "pkg", "c", "qt", "Kit", "sit", "bh", "init", "cam", "ect", "pot", "base", "ch", "ok", "kat", "h", "shop", "cat", "iter", "jit", "t", "util", "html", "lib", "rot"], "doc": ["div", "pdf", "dr", "Doc", "og", "p", "dat", "data", "dec", "window", "mk", "content", "tree", "xml", "man", "in", "js", "ds", "dc", "page", "dir", "md", "document", "file", "ad", "body", "sp", "nt", "msg", "def", "out", "w", "head", "config", "g", "di", "db", "json", "mu", "tx", "t", "log", "html", "d", "n"], "url": ["loc", "host", "el", "sl", "ssl", "server", "domain", "gl", "org", "https", "git", "ls", "dl", "api", "peer", "bel", "web", "path", "ref", "ln", "addr", "lr", "blog", "user", "ll", "xml", "resource", "http", "rl", "ul", "nl", "ur", "impl", "URL", "cert", "base", "address", "mb", "open", "mount", "mail", "pl", "r", "uri", "Url", "deb", "l", "hub", "t", "log", "util", "html"], "it": ["you", "et", "ot", "iz", "ert", "iw", "io", "It", "in", "ic", "pit", "he", "li", "sit", "ite", "init", "nt", "im", "IT", "ind", "out", "iter", "lit", "l", "ip", "ci", "ct", "its", "t", "wait", "at", "rit"], "elem": [" peom", "telem", " element", "belem", "eleem", "selt", " pelem", "seem", "llem", "tlement", "lelt", "llement", "elect", "belt", " eom", " pelect", "lem", "elelem", "tom", "em", " pelement", " elect", "eelt", "sem", "eem", "selement", "selem", "telt", "tlem", "elelement", "element", "elt", "telement", "tem", "bem", "belement", "eleelt", "tlect", "eom", "seelt"], "s": ["fs", "ins", "sl", "ats", "xs", "cs", "rs", "sts", "ls", "stats", "simple", "sd", "si", "ys", "S", "ns", "ms", "sys", "space", "ss", "set", "st", "sq", "js", "gs", "ds", "sym", "sv", "ts", "spec", "sb", "sam", "sp", "ess", "less", "is", "als", "se", "es", "os", "sg", "ps", "sa", "sm"], "lnk": ["olnik", "lnj", "linak", "olnj", "lnik", "nlck", "linko", "lnak", "dnn", "nltk", "lnko", "olnko", "lintk", "dlck", "nlkt", "lenak", "nlak", "linn", "lnn", "klek", "nlko", "nln", "lnck", "dlik", "lenj", "lenck", "dnk", "olnak", "olnkt", "lnek", "dnck", "linik", "dltk", "linj", "nelek", "dnko", "klko", "lntk", "olnk", "dlk", "klke", "olnn", "lann", "nelke", "klk", "nelko", "lenk", "lanak", "linke", "nelk", "olnck", "lank", "linck", "lnkt", "nlk", "dlak", "dln", "lankt", "lnke", "linek"], "j": ["div", "k", "z", "max", "adj", "dj", "v", "je", "jj", "ng", "bo", "jp", "aj", "n", "q", "Ja", "js", "jump", "ja", "li", "J", "ij", "jl", "obj", "kj", "ji", "y", "pos", "ind", "bj", "br", "off", "h", "uj", "g", "prime", "t", "o", "oj", "jc"], "urlLink": [" urlStart", " urlUrl", "Urllink", "urlMatch", "urlLock", "strLink", "strStart", "UrlLock", "httpLinks", "urlLinks", "urlUrl", "urlRel", "sslLoad", "strRel", "urlStart", " urlSource", "emailSource", " urllink", "objUrl", "UrlSource", "strUrl", " urlLinks", "httpLoad", "httpLink", "urlSource", "emaillink", "emailLock", " urlMatch", "sslMatch", "objStart", " urlRel", "emailLink", "objLink", " urlLock", "sslLinks", "sslLink", "httpMatch", "UrlLink", "urllink", " urlLoad", "objRel", "urlLoad"], "str": ["f", "div", "arr", "dr", "exp", "p", "STR", "char", "stable", "list", "usr", "Str", "string", "chain", "print", "m", "ll", "tree", "st", "raw", "ocr", "text", "js", "pkg", "part", "inst", "vol", "comm", "spec", "fr", "prefix", "res", "hex", "msg", "wr", "tr", "out", "txt", "br", "elt", "r", "stri", "g", "inner", "ctr", "coll", "t", "html", "w", "temp", "n"], "i": ["length", "cli", "mi", "ami", "p", "ix", "ex", "ini", "ity", "I", "area", "ii", "us", "si", "index", "ai", "io", "bi", "chain", "ms", "me", "sim", "m", "ki", "in", "iu", "multi", "ic", "ei", "li", "ti", "a", "xi", "ims", "init", "x", "hi", "ori", "batch", "zi", "ie", "phi", "y", "ui", "iy", "iter", "PI", "di", "gi", "start", "ci", "ip", "\u0438", "o", "info", "qi", "im", "oi", "pi"], "skip": [" bypass", "copy", "strip", "deep", "ips", "fast", "process", " skipping", "complete", "stop", "clip", " skipped", "jump", "kill", "add", "note", "replace", "Skip", "op", "warn", "cmp", "write", "loop", "sk", "pass", "ops", "iter", "ip"]}}
{"id1": "20675046", "id2": "22320592", "code1": "    public Object getContent(ContentProducerContext context, String ctxAttrName, Object ctxAttrValue) {\n        try {\n            URL url = (getURL() != null) ? new URL(getURL().toExternalForm()) : new URL(((URL) ctxAttrValue).toExternalForm());\n            InputStream reader = url.openStream();\n            int available = reader.available();\n            byte contents[] = new byte[available];\n            reader.read(contents, 0, available);\n            reader.close();\n            return new String(contents);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return ex.toString();\n        }\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getContent": [" getBody", "getText", "GetBody", "GetText", "setContents", "GetContents", " getContents", "setContent", "getContents", "GetContent", " getText", "setText", "getBody", "setBody"], "context": ["object", "processor", "value", "output", "channel", "data", "message", "content", "chain", "state", "ctx", "parser", "network", "application", "text", "resource", "document", "base", "event", "template", "TEXT", "input", "config", "type", "tx", "command", "component", "Context"], "ctxAttrName": ["ctxAttrKey", "ctxAttrname", "ctxAddrName", "ctxAttribValue", "ctxAddmname", "ctxAddrname", "ctxAddmValue", "ctxAttribname", "ctxAttribKey", "ctxAttrsKey", "ctxAttribName", "ctxAddmName", "ctxAttmKey", "ctxAttmName", "ctxAttrsValue", "ctxAttmValue", "ctxAttmname", "ctxAttrsName", "ctxAddmKey", "ctxAttrsname", "ctxAddrKey", "ctxAddrValue"], "ctxAttrValue": ["ctxAttribType", "ctxAddrbName", "ctxAttrdName", "ctxAttribVal", "ctxAttuData", "ctxAttrElement", "ctxAttmType", "ctxAddrbvalue", "ctxAttuVal", "ctxAttrData", "ctxAttrbvalue", "ctxAttribValue", "ctxAddrName", "ctxAddrElement", "ctxDetrData", "ctxDetribData", "ctxAttrdElement", "ctxAttmvalue", "ctxAttribData", "ctxAttmData", "ctxAddrValue", "ctxAttrbName", "ctxAttrdValue", "ctxAttuType", "ctxDetrVal", "ctxDetribValue", "ctxAttmElement", "ctxAttmName", "ctxAttrdvalue", "ctxAttrbElement", "ctxAttrType", "ctxAttrVal", "ctxDetribVal", "ctxAddrbElement", "ctxAttmValue", "ctxDetrType", "ctxAttmVal", "ctxAttrvalue", "ctxAddrvalue", "ctxAttrbValue", "ctxAddrbValue", "ctxDetrValue", "ctxAttuValue", "ctxDetribType"], "url": ["loc", "rel", "el", "sl", "ssl", "b", "location", "ls", "dl", "hl", "char", "external", "service", "lr", "path", "ref", "web", "io", "str", "ll", "resource", "rl", "http", "ul", "nl", "link", "browser", "ur", "URL", "sb", "file", "cert", "build", "base", "address", "name", "mount", "client", "uri", "Url", "l", "null", "log", "handle"], "reader": ["image", "length", "readable", "dd", "stream", "ri", "dra", "upper", "data", "er", "peer", "iterator", "driver", "user", "io", "handler", "test", "buffer", "parser", "loader", "volume", "writer", "rl", "resource", "runner", "reading", "ator", "ro", "READ", "shape", "builder", "file", "rr", "rar", "Reader", "rx", "open", "per", "older", "check", "source", "input", "r", "iter", "uri", "inner", "row", "sample", "info", "rot", "read", "handle"], "available": ["length", "max", "readable", "num", "acity", "alloc", "opened", "position", "count", "total", "capacity", "selected", "ed", "checked", "buffer", "valid", "produced", "loaded", "availability", "supported", "visible", "active", "enabled", "ready", "usage", "provided", "all", "locked", " unavailable", "missing", "released", "sp", "played", "usable", "good", "enough", "installed", "used", "current", "no", "out", "i", "len", "required", "ocated", "needed", "created", "allowed", "full", "written", "ap", "end", "bytes", "Available", "free", "bound", "added", "release", "index", "read", "can"], "contents": ["Contars", "mintents", "CONTent", "requours", "mintent", "Contacts", "mintented", " contentials", "Content", "requries", "content", " contContents", "Contries", " contacts", "contours", "contentials", "CONTars", "CONTacts", "contries", "contacts", "contented", "Contours", "ContContents", " content", "requentials", "Contentials", "CONTContents", "CONTented", "requents", "mintars", "contars", " contries", "Contented", " contours", "Contents", "CONTents", "contContents"]}}
{"id1": "16378239", "id2": "755203", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"byReference": ["forRef", "ByReference", "forreference", "byreference", "forReference", " byResource", "byRef", "forResource", "Byreference", "byResource", "ByRef", "ByResource", " byreference", " byRef"], "inputStream": ["inputReader", "readableSteam", "InputSteam", "readableReader", " inputstream", " inputSteam", " inputReader", "inFile", "inSteam", "inStream", "inputSteam", "readableStream", "inputstream", "Inputstream", "InputReader", "instream", " inputFile", "InputStream", "InputFile", "readablestream", "inputFile"], "tempFile": ["poraryUrl", "poraryFile", "tmpPlace", " temporaryfile", "TempDirectory", "tempFiles", "TempFiles", " temporaryChain", "poraryDir", " tempDir", "poraryPlace", "tempfile", " tempfile", "poraryName", "empPlace", "TempPath", "tempDirectory", "tmpfile", "tmpDirectory", "TempDir", "TempUrl", " temporaryFile", "Tempfile", "tempChain", " tempUrl", "empfile", "tempName", "empName", "TempChain", " tempFiles", "empDirectory", "tempDir", "poraryfile", " tempChain", "empFile", "tempUrl", " temporaryFiles", "tmpPath", "empPath", "tmpFile", "TempFile", "tempPlace", "tmpName", "tempPath"], "out": ["ins", "output", "OUT", "co", "gr", "v", "lay", "again", "serv", "ex", "dis", "sum", "ent", "us", "con", "s", "user", "net", "io", "sys", "in", "outs", "OU", "writer", "ou", "to", "all", "as", "file", "auto", "aos", "cos", "msg", "up", "oss", "source", "one", "conv", "ao", "os", "l", "null", "o", "t", "Out", "n"]}}
{"id1": "17791385", "id2": "2221297", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyfile", " cpFile", "cloneFiles", "cloneResource", " copyFiles", " cpfile", " cpFiles", "copyFiles", "copyResource", "cloneFile", " copyfile", " cpResource", "clonefile", " copyResource"], "src": ["rel", "iv", "ins", "rc", "bs", "rs", "sc", "usr", "sin", "ys", "sys", "obs", "via", "st", "sq", "sf", "sec", "from", "rl", "inst", "sit", "ser", "req", "usc", "init", "sb", "rx", "txt", "ipl", "source", "input", "cur", "sel", "start", "sur", "ctr", "sr", "Source", "ux", "ck", "cont"], "dst": ["dnd", " ddest", "wdest", "Dth", "wth", " dth", "Dnd", "Dst", "ddnd", "Ddest", "dddest", "ddst", "dth", " dnd", "dnt", "Dnt", "sdest", "wst", "wnd", "snd", "ddest", "snt", "ddnt", "sst"], "in": ["ins", "inside", "din", "en", "ze", "IN", "rec", "sin", "inn", "con", "ln", "ai", "inf", "cin", "gin", "mm", "on", "bin", "from", "ar", "ic", "st", "it", "init", "al", "ain", "act", "ind", "is", "inc", "up", "rin", "i", "input", "source", "iter", "inner", "oin", "info", "isin", "im", "min", "In"], "out": ["cn", "ot", "output", "OUT", "co", "dis", "ex", "sum", "gt", "con", "net", "io", "ne", "sys", "on", "bin", "st", "outs", "it", "by", "writer", "ou", "and", "to", "obj", "res", "po", "auto", "aos", "nt", "can", "client", "write", "up", "oss", "oe", "g", "os", "inner", "conv", "o", "t", "Out", "at", "outer", "n"], "buf": ["arr", "cmd", "ck", "var", "b", "cf", "vec", "bed", "uf", "norm", "gen", "box", "buffer", "aka", "block", "pkg", "fb", "bar", "stab", "bh", "cv", "cap", "cam", "bag", "seq", "Buff", "batch", "msg", "cp", "good", "br", "pl", "cur", "bus", "cat", "conv", "db", "tab", "Buffer", "prop", "mu", "tx", "buff", "bytes", "log", "cb"], "len": ["length", "L", "loc", "z", "el", "rel", "fun", "num", "en", "exp", "fin", "v", "ls", "lf", "dl", "count", "lic", "il", "lan", "e", "ln", "le", "lim", "str", "val", "ll", "wid", "size", "vol", "Len", "cap", "all", "seq", "nt", "pos", "ren", "no", "cmp", "h", "elt", "ld", "l", "lon", "coll", "fl", "t", "end", "compl", "lib", "n"]}}
{"id1": "23672408", "id2": "3375722", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyIconFiles": ["copyIconImages", " copyiconDocuments", " copyiconImages", "copyIndexfiles", "copyiconDocuments", " copyIconDocuments", "copyiconFiles", "copyIndexDocuments", "copyIndexImages", "copyiconfiles", "copyiconImages", " copyiconfiles", "copyIconDocuments", "copyIndexFiles", " copyIconfiles", " copyIconImages", " copyiconFiles", "copyIconfiles"], "clazz": ["CLbean", "relab", "CLazz", "crus", "clashed", " plub", "classotted", "plaz", " clashed", "cluddy", "pkgazz", "pkgashed", "colluster", " cluster", " plaz", " clbo", "clab", "classazz", "chotted", "chace", "escotted", "cluster", "pkgaz", "escazz", "chazz", "clus", "Claz", " cluddy", "club", "pkgasse", "sclace", "Clace", "crub", "callbo", "callazz", "plazz", " plazz", "relose", "Clab", "classe", "close", "sclazz", "craz", "callaz", " club", " claz", "Clbo", "descose", " clbean", "collazz", " clus", "clojure", "clbean", "clbo", "relaz", "plasse", "clotted", "descazz", " classe", "chojure", "descaz", " clace", " clojure", "plashed", "escace", "colluddy", "callace", " closer", "CLace", " clotted", "Clazz", "CLoser", "escojure", "claz", "closer", "Close", "descab", "classuster", "scloser", "relazz", "classuddy", "clace", " plus", "crazz", "sclbean", "collotted"], "i16": ["iri6", "ami16", "pi150", "ii16", "i63", "i157", "iniShort", "ri16", " i160", " i6", "pi6", "pi63", "amiShort", "ji150", " i157", "i216", "ini216", "i6", "i19", "iri2016", "ini24", "ami6", "i2016", "ami63", "liShort", "iri16", "i160", "ami2016", " i24", "i150", "li16", "li2016", "pi16", "ami19", "ii216", "ii160", "ini160", "ji16", "ami150", "ji63", "ri6", "iri157", "iShort", "ri157", "ji6", "ini19", "i24", "ini2016", " i2016", "ri2016", "ini16", "li19", " i216", "ii24"], "fileType": ["viewTYPE", "ileType", "formatType", "treetype", "webTYPE", "filetype", "coreHandler", "FILEtype", "eventType", "formtype", " filePattern", "iletype", "webTyp", "FILEName", "fieldTyp", "relationHandler", "webList", "viewtype", "treeTime", "filePattern", "fieldDef", "FileType", "fileFamily", "coreTyp", "treeTYPE", "formatTime", "fileTime", "webType", " fileTyp", "eventTYPE", " fileTime", "coreDef", "policyType", "fileTYPE", "fileHandler", "formatTYPE", "coreTYPE", "FileName", " filetype", "issueTyp", "fieldType", "fieldTYPE", " fileFormat", "eventUnit", "fileUnit", "policyTyp", "Filetype", "coreFamily", "resourceFormat", "fileTyp", "formName", "relationType", "fileFormat", "resourceUnit", "formType", "fileName", "treeType", "eventFormat", "webDef", "coreType", "relationFamily", "ileTyp", "ilePattern", "relationTyp", " fileTYPE", "fileValue", "issuetype", " fileValue", "viewType", "policyHandler", "policyFamily", "issuePattern", "eventList", "resourceTYPE", "FILEType", " fileUnit", "formatValue", "fileDef", "fileList", "viewValue", " fileList", "resourceType", "formattype", "issueType"], "desti16": ["destgi216", "destsi160", "destui160", "destsi18", "destui24", "destsi32", "resulti16", "desti2016", "destii216", " destsi18", "desti160", "resultii216", "destsi16", "resulti24", " desti18", "resultii16", "resulti2016", "resultii24", "destii24", "destui18", "destxi160", "destui32", "destxi18", " destsi16", " destsi160", "destgi16", "destxi16", "destgi2016", "destii2016", "desti24", "destui16", "destii16", "destui2016", " desti160", "desti216", "destgi24", "destxi32", " destsi32", "destui216", "desti18", "resulti216", "resultii2016"], "src": ["loc", "rel", "iv", "isl", "ins", "cli", "sl", "ssl", "std", "rc", "rs", "scan", "ls", "sc", "rg", "hl", "usr", "sync", "vr", "ln", "dest", "sn", "addr", "sys", "obs", "ctx", "bin", "rob", "via", "st", "sq", "pkg", "sec", "gs", "rl", "ibl", "etc", "inst", "nl", "sit", "ser", "bh", "bg", "req", "urg", "sub", "img", "sb", "ptr", "sol", "tmp", "sp", "rx", "cmp", "comp", "txt", "source", "syn", "cur", "bc", "inner", "input", "proc", "sel", "iter", "ctr", "rb", "sr", "desc", "rest", "cb", "fc", "cont"], "dst": ["nnd", "rcut", " dest", "derst", "tput", "ndest", "dnd", "dbl", " ddest", "Ddr", " ddr", " dmn", "rbl", "dLcut", "fst", "ddmn", " dmt", "dernd", "dLnet", "dest", "rst", "rdst", "dsnet", "Dnd", "dsot", "ngt", "Dst", "dLot", "ddnd", "ddr", "dput", "dLbl", "dLdest", "Ddest", "dermn", " dput", "dsst", "dddest", " dgt", "dsts", "dLest", "dnet", "ddst", "rdmt", " dnd", "dcut", "fdest", "tst", "dsest", " dot", "dmt", "ndsts", "rdest", " dcut", "dmn", "tgt", " dnet", "rdsts", "nput", "nst", "dot", " dsts", "dgt", "ddest", "dLst", "ndmt", "ndst", "derdest", " dbl", "fdr", "tnd", "fnd"], "i32": ["i22", "pi31", "ip31", "i31", "pi34", "ini31", "xi32", "i64", "ic64", "xi48", " i34", "i342", "isi40", "ip64", "i34", "isi64", "xi31", "ip32", " i28", "isi32", "ii342", "i28", "ic28", " i40", "ini22", "isi86", "ii34", "i86", "ip34", "ini48", "ii28", " i86", "pi32", "i48", "ic40", "ic34", "ic342", "ic32", "pi64", "xi22", "ic22", "ic31", " i64", "i40", " i342", "ii32", "ini32", "ic86", " i31", "ic48"], "desti32": ["destic34", "desti90", "DestI90", "destu90", "Desti32", "destu31", "desti34", "destic32", "destpi34", "destI31", "destI32", "destI90", "Desti256", "targetpi30", "destdi31", "destI256", "targeti31", "destpi32", "DestI256", "Desti31", "destpi31", "targeti30", "targeti32", "targetpi34", "targetpi31", "desti31", "destdi34", "targetpi32", "destpi30", "DestI31", "Desti90", "destdi32", "destic30", "destic31", "destu32", "desti30", "destdi30", "DestI32", "targeti34", "desti256", "destu256"]}}
{"id1": "20924119", "id2": "23370621", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"gzip": ["Gzip", "gZip", "mZip", "mzip", " garchive", " gdef", "marchive", "garchive", "Gdef", "Garchive", "GZip", "gdef", " gZip", "mdef"], "zipout": [" zipconn", "zou", "zOut", "pipein", " zipnet", " zipou", "gzo", "zipop", " zipin", "locko", "zout", "logout", "zouts", "gzin", "zipouts", " zipop", "pipenet", "logOut", "login", "zipconn", "gzconn", "pipeou", "lockconn", "lockop", "zipin", "gzOut", "pipeout", "zipo", "gzout", "gzouts", "logouts", " zipo", "lockout", "zipOut", "znet", "zipou", "gzop", "zipnet", "zin"], "buffer": ["header", "stream", "binary", "seed", "cache", "data", "message", "window", "char", "buf", "string", "device", "sequence", "stack", "queue", "database", "phrase", "block", "button", "limit", "size", "table", "frame", "paste", "attribute", "comment", "document", "batch", "code", "word", "line", "append", "mem", "memory", "number", "row", "variable", "Buffer", "buff", "bytes", "sample", "pad", "password", "command", "history", "result"], "dir": ["rel", "div", " Dir", "folder", "del", "loc", "dr", "dd", "ord", "fin", "ir", "dra", "dl", "dat", "self", "mk", "path", " director", "rect", "tree", "ory", " directory", "pkg", "part", "add", "dist", "vol", "req", "md", "file", "DIR", "df", "tmp", "directory", "parent", "det", "pos", "cond", "ind", "def", "out", "doc", "cur", "iter", "wd", "db", "cd", "desc", "Dir", "root", "direct", "fd", "d", "draw"], "in": ["ins", "inside", "din", "el", "en", "ri", "ex", "ini", "IN", "sin", "inn", "like", "form", "inf", "cin", "gin", "on", "bin", "from", "it", "ic", "and", "init", "al", "ain", "act", "reader", "ind", "is", "inc", "out", "check", "up", "rin", "i", "input", "win", "source", "inner", "iter", "oin", "isin", "im", "read", "In"], "length": ["distance", "frequency", "angle", "position", "port", "match", "count", "data", "message", "capacity", "total", "char", "SIZE", "index", "sequence", "duration", "database", "text", "volume", "join", "load", "size", "available", "impl", "shape", "tail", "ength", "body", "family", "ind", "before", "height", "full", "number", "len", "character", "needed", "l", "row", "type", "start", "time", "padding", "end", "hello", "component", "Length", "history", "read", "ENGTH"]}}
{"id1": "701029", "id2": "9109613", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadSourceCode": ["loadBaseFile", " loadSourceData", "loadSourceFileData", "loadSourceData", " loadsourceData", " loadsourceSource", " loadsourceFile", "loadsourceCode", "loadBaseCode", "loadsourceSource", "loadSourceSource", "loadBaseSource", " loadSourceFile", " loadSourceSource", "loadsourceData", "loadsourceFile", "loadSourceFileFile", "loadBaseData", "loadSourceFileSource", "loadSourceFileCode", "loadSourceFile", " loadsourceCode"], "length": ["max", "maximum", "f", "readable", "position", " Length", "count", "message", "total", "capacity", "SIZE", "description", "format", "string", "path", "sequence", "buffer", "duration", "text", "volume", "limit", "collection", "size", "load", "join", "available", "width", "dump", "shape", "ength", "code", "library", "amount", "family", "name", " lengths", "height", "write", "no", "loop", "number", "len", "title", "filename", "h", "l", "type", "default", "t", "end", "download", "Length", "read", "ENGTH"], "file": ["f", "image", "el", "output", "port", "channel", "il", "format", "list", "path", "e", "le", "io", "ref", "fil", "buffer", "set", "face", "sf", "File", "resource", "table", "size", "frame", "FILE", "page", "connection", "po", "al", "base", "parent", "pool", "name", "fp", "ile", "full", "source", "filename", "db", "remote", "local", "handle"], "buff": ["f", "cmd", "b", "uf", "alph", "buf", "ref", "buffer", "ph", "j", "fr", "Buff", "tmp", "ch", " buffers", "mb", "append", "ob", "mem", "txt", " buffer", "Buffer", "end", "bb", " buf", "font", "read"], "is": ["isa", "isl", "fs", "mi", "ins", "lis", "ri", "iss", "bits", "ris", "are", "rs", "ir", "ists", "ls", "isi", "il", "us", "s", "si", "sys", "sim", "iso", "has", "it", "bis", "ser", "ois", "ims", "IS", "iris", "vis", "Is", "isc", "i", "oss", "iter", "es", "os", "\u00eds", "ip", "ais", "its", "ist", "ios"], "isr": ["oisrs", "Isvr", "isl", " isl", "risl", "isar", "risar", "risrs", "oissr", "rissr", "risr", "issl", "esr", " ispr", " isrs", "oisr", " isvr", "Isr", "esar", "isrs", "issvr", "ispr", "isvr", "isspr", "oisar", "issrs", "Ispr", "Isrs", "esrs", "rispr", "issr", "essr"], "cv": ["cn", "av", "tk", "bm", "cf", "v", "rc", "uf", "sc", "tc", "nc", "cc", "buf", "rev", "vr", "ctx", "c", "vp", "qt", "nv", "sv", "cam", "tv", "vs", "bt", "vc", "uv", "rpm", "cp", "hw", "txt", "vm", "cur", "conv", "cd", "CV", "xc", "cm", "lv", "cb", "fc", "pb"], "url": ["loc", "rel", "el", "sl", "ssl", "gl", "atl", "https", "location", "dl", "il", "bel", "github", "string", "web", "ref", "io", "addr", "str", "ll", "ret", "or", "resource", "http", "rl", "re", "ul", "nl", "link", "browser", "ur", "impl", "key", "URL", "res", "address", "dll", "name", "mount", "mail", "get", "r", "uri", "Url", "l", "abs", "html"], "reader": ["dr", "ipper", "stream", "ri", "rc", "liner", "rs", "dra", "upper", "data", "er", "iterator", "driver", "editor", "handler", "buffer", "parser", "wrapper", "loader", "writer", "rl", "resource", "runner", "reading", "ser", "ro", "fr", "range", "builder", "body", "Reader", "rar", "rx", "older", "ner", "r", "iter", "inner", "rer", "row", "roller", "her", "info", "history", "read"], "sourceCode": ["relationCode", "SourceForce", "sourceComment", "sourceTree", "SourceScript", "sourceCount", " sourceTree", "sourceForce", " sourceComment", "codeMessage", "codeTree", "SourceTree", "componentScript", " sourceLine", "relationLine", "SourceMessage", "codeData", " sourceForce", "componentCode", "sourceLine", "SourceCode", "SourceLine", "SourceComment", "SourceName", "sourceName", " sourceName", "codeCode", " sourceMessage", "SourceData", "relationName", " sourceScript", "componentComment", " sourceCount", "relationForce", " sourceData", "relationData", "sourceData", "relationCount", "sourceScript", "componentLine", "SourceCount", "sourceMessage"], "line": ["ine", "pe", "liner", "online", "port", "eline", "data", "message", "string", "e", "ln", "lo", "le", "ne", "print", "phrase", "cell", "chain", "str", "block", "lin", "entry", "text", "trace", "frame", "nl", "Line", "inline", "stroke", "page", "link", "comment", "label", "range", "key", "code", "body", "lined", "word", "lock", "number", "source", "se", "iter", "l", "lines", "row", "log", "sample", "LINE", "point"]}}
{"id1": "17817568", "id2": "88047", "code1": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"getGETReader_bak": ["getGETReader2bak", "getGETReader_buak", "getGETReader2cak", "getGETReader_buaz", "getGETReader_grief", "getGETReader_cundle", "getGETReader_buundle", "getGETReader2brief", "getGETReader_baz", "getGETReader_gaz", "getGETReader_caz", "getGETReader_bundle", "getGETReader_cak", "getGETReader2caz", "getGETReader_gak", "getGETReader2bundle", "getGETReader2cundle", "getGETReader2crief", "getGETReader_brief", "getGETReader_burief", "getGETReader2baz", "getGETReader_gundle", "getGETReader_crief"], "url": ["loc", "host", "el", "u", "sl", "ssl", "gl", "org", "b", "location", "ls", "uf", "dl", "il", "string", "web", "path", "ref", "user", "rect", "str", "err", "ll", "request", "resource", "http", "rl", "re", "ul", "nl", "link", "browser", "ur", "key", "URL", "build", "base", "address", "name", "mount", "call", "ob", "r", "uri", "Url", "l", "util", "bb", "job"], "reader": ["mr", "holder", "rc", "liner", "relation", "er", "service", "driver", "lr", "handler", "test", "buffer", "parser", "wrapper", "loader", "rank", "writer", "rl", " writer", "runner", "ro", "ler", "builder", " read", " parser", " readers", "rr", "rar", "Reader", " cursor", "ner", "r", "iter", "inner", "rer", "row", " builder", "rot", "read", "ocr"], "contentLength": ["readableLength", " contentDelivery", "contentLanguage", "contentLine", "ContentType", "sequenceSize", "readableDescription", "readableType", "contentLen", "ontentLine", "ontentPosition", "contentSize", "contentLocation", "loadLen", "contentLong", "sequenceLength", "ContentSize", "ContentDescription", " contentLong", " contentType", "sequenceLen", "contentType", "loadLength", "readablelength", "translationDuration", "connectionLength", "codeLine", " contentlength", " contentLocation", "contentlength", " contentPosition", "ontentDelivery", "translationLanguage", " contentDuration", "readableLocation", "codeLength", "ontentlength", "ContentLen", "contentDescription", "codePosition", "loadLocation", "ontentLength", "ontentType", "ontentDescription", "contentPosition", "ContentDelivery", "sequencelength", " contentLen", "translationLength", " contentLine", "translationLong", " contentSize", "connectionLong", " contentDescription", " contentLanguage", "contentDelivery", "connectionDuration", "contentDuration", "ContentLength", "Contentlength", "readableLen", "connectionLanguage", "codeType"], "urlc": ["sslc", "llcur", "httpl", "jsonci", "ssll", "UrlC", " urlh", "nelcs", "httpc", "browserc", "browsercu", "managerdc", "Urllc", " urlC", "strcu", " urllc", "mailc", "llc", " urldc", " urlcu", "urlcm", "mountlc", "voidcb", " urlcur", " urlcity", "urlC", "urll", "urlcur", "nelci", "Urlci", "logci", " urlcm", "Urlcity", "urlcu", "browserlc", " urlf", "llC", "elc", "maillc", "elcu", "Urlc", "urlcb", "sslci", "elci", "jobcb", "implc", "httpcur", "managerc", "urlci", "jobcm", "urlcity", "voidcm", "voidC", "jobcur", "voidcur", "mountC", "implC", "implh", "strc", "implcon", "httpci", " urlcb", "managerC", "urlcon", "urlcs", "Urlcon", "urldc", "Urlco", "urlf", " urlcs", "mailco", " urlci", "logc", "nelc", "nelcall", "methodcur", "implci", "Urldc", "urlh", "strci", "mountco", "strf", "methodl", "jsonC", "methodc", "urllc", "voidc", "jsoncon", "mountc", "elf", "urlco", " urlcall", "methodci", "urlcall", "llci", "managercity", "sslcur", "logcs", "implcu", "jobc", "logcall", "browserh", "mailC", "voidci", "jsonc", "impllc"], "content_type": ["contentproType", "Content_Type", " contentTypeType", "Content_string", " contentTypetype", "contentTypety", " content_info", "content_info", "contentTypetool", " contentTypeinfo", "contentprostring", " content_ty", "content_Type", "content_TYPE", " content_tool", "content_name", "contentprotype", " content_Type", " contentTypetool", "contentTypeTYPE", " contentTypeTYPE", "contentTheinfo", "contentTypetype", "content_tool", "Content_link", "content_language", " contentTypety", "Content_type", "contentTheType", "contentprolanguage", "contentThetool", "key_Type", "content_id", "content_link", "content_string", "contentTypeinfo", "contentTypeType", "contentThetype", "key_id", "Content_language", " content_TYPE", "key_type", "content_ty", " content_name"], "is": ["isa", "isl", "sis", "ins", "xs", "are", "ri", "mos", "bs", "ris", "bits", "iss", "dis", "ls", "ir", "ists", "isi", "nis", "ii", "s", "si", "ai", "ys", "sys", "ms", "iso", "has", "lis", "in", "ar", "js", "ds", "tis", "ics", "IS", "iris", "ses", "eds", "ires", "Is", "mis", "isc", "isd", "i", "es", "os", "\u00eds", "ais", "its", "ist", "ids", "ish", "info", "isin", "im", "was", "ios"], "d": ["del", "dd", "dr", "der", "du", "dx", "dis", "dt", "dra", "nd", "dl", "dn", "dec", "dat", "dal", "dh", "sd", "dict", "ded", "od", "did", "pd", "da", "D", "ds", "dc", "de", "des", "dir", "md", "ad", "df", "dom", "dm", "dL", "done", "ld", "db", "di", "cd", "bd", "rd", "fd", "gd"], "content": ["image", "core", "ontent", "copy", "output", "value", "search", "node", "values", "cont", "cache", "data", "message", "Content", "description", "empty", "path", "sequence", "buffer", "normal", "xml", "example", "scroll", "raw", "text", "array", "load", "reason", "comment", "draft", "code", "body", "address", "current", "good", "txt", "full", "mem", "source", "config", "json", "accept", "bytes", "media", "ext", "html", "cm", "info", "temp", "result"], "bais": ["baIS", "BAis", "Bais", " bai", "BAIS", "Baiu", "boi", "baliu", "Bai", "bali", "BAiu", "bai", " baIs", "boes", " baes", "baiu", "baes", "balIS", "boIs", "BAIs", "balis", "BaIS", "baIs", "BAes", "bois", "BAi"], "bis": ["sis", "pins", "lis", "bs", "mos", "ris", "bits", "onis", "bes", "ubis", " Bis", "nis", "bid", "bi", "ints", "cin", "obs", "bil", "atis", "mes", "tis", "bh", "bos", "iris", "ses", "fits", "idis", "mis", "fps", "ais", "its", "rison", "los", "isin", "ios"], "gis": ["gzisi", "gIs", "gates", "Gis", "gzates", "gris", " giss", " gris", "gmisi", "guris", "guiss", " gisi", "Giss", "gmIs", "gzIs", "gmis", " gates", "guis", "Gris", " gIs", "guIs", "gmates", "GIs", "gzis", "gisi", "giss"], "sb": ["sth", "ssl", "b", "bs", "bf", "SB", "ib", "CB", "nb", "rob", "sf", "bps", "sv", "bh", "stab", "bg", "wb", "xb", "eb", " SB", "ses", "sp", "bt", "erb", "lp", "gb", "lb", "kb", "zb", "pb", "bsp", "rb", "sg", "bb", "cb", "sa"], "zipReader": ["jsonReader", "zipBuffer", "ZipReader", " zipLoader", "zipParser", "ZipBuffer", "zipRead", "jsonParser", "zipLoader", "serialReader", "ZipLoader", "jsonreader", "jsonLoader", "pipeRead", "pipeReader", "Zipreader", "pipeBuffer", "pipeWriter", " zipParser", "zipWriter", "zipreader", "ZipRead", "serialWriter", "ZipParser", " zipreader", "ZipWriter", "serialBuffer", "serialRead"], "chars": ["achcs", "CHARS", "contats", "charnew", "charars", "achas", "chacters", "Chnew", "achamps", "acharts", " ChARS", "Charts", "achars", "chats", "chas", " charters", "CHcs", " champs", "Chats", " chARS", "achats", "Chars", " chacters", "chnew", "ChARS", " Chats", "contarters", "achARS", " Chars", "charrs", "chcs", "champs", "charas", "chARS", "CHars", "chrs", "charters", "contars", "Chrs", " chnew", "charts", " Chrs", "Chas", " chcs", "chararts", " chats", "contacters", "acharters", "CHamps", "achacters", " chrs", "achrs"], "len": ["length", "L", "del", "el", "els", "fun", "num", "en", "exp", "fin", "vec", "ls", "lf", "count", "lic", "il", "lan", "gen", "ln", "un", "lim", "val", "ll", " el", "rot", "wid", "li", "size", "col", "span", "nl", "Len", "all", "late", "seq", "left", "mun", "pos", "cmp", "mem", "elt", "full", "ld", "Length", "l", "lit", "lon", "coll", "t", "ail", "compl", "lib", "min", "n"]}}
{"id1": "22441244", "id2": "344764", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    static HttpURLConnection connect(String url, String method, String contentType, String content, int timeoutMillis) throws ProtocolException, IOException, MalformedURLException, UnsupportedEncodingException {\n        HttpURLConnection conn = (HttpURLConnection) (new URL(url).openConnection());\n        conn.setRequestMethod(method);\n        conn.setConnectTimeout(timeoutMillis);\n        byte[] bContent = null;\n        if (content != null && content.length() > 0) {\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", contentType);\n            bContent = content.getBytes(\"UTF-8\");\n            conn.setFixedLengthStreamingMode(bContent.length);\n        }\n        conn.connect();\n        if (bContent != null) {\n            OutputStream os = conn.getOutputStream();\n            os.write(bContent);\n            os.flush();\n            os.close();\n        }\n        return conn;\n    }\n", "label": 0, "substitutes": {"send": ["sent", "Send", "reply", "security", "transfer", "message", "print", "set", "push", "post", "add", "apply", "export", "report", "init", "build", "msg", "execute", "mail", "write", "get", "submit", "create", "parse", "end", "save"], "hsession": [" HSession", "rssession", "HSessions", "HSess", "hhhip", "hhession", "hsess", "hhsession", "rsess", "hession", "HSpace", " HSess", "hssession", " HSsession", "HSettings", " HSpace", "HShip", "hsessions", "HSsession", "rspace", "hship", "hhip", "hsettings", "hspace", "rsession", "hhessions", "hhettings", "hessions", "HSession", "hettings"], "session": ["context", "object", "store", "cache", "message", "instance", "content", "driver", "state", "set", "view", "Session", "connection", "sid", "document", "parent", "ess", "name", "event", "lock", "client", "ession", "account", "manager", "ip", "password", "job"], "repositoryName": ["repoositoryName", "repositoryData", "repositoryTitle", "repositorTitle", "repoitoryTitle", "reposoryName", "repositorNAME", "reposoryNAME", "reposositoryTitle", "repositoryPath", "repositoryNAME", "reposositoryPath", "repoositoryTitle", "repositableData", "repositionPath", "repositionNAME", "repositoryname", "repoositoryPath", "reposoryname", "repoositoryData", "reposositoryData", "repoositoryname", "repositorPath", "repoitoryname", "repositableName", "repoitoryNAME", "repoositoryNAME", "repositionName", "repositableNAME", "reposoryData", "repoitoryName", "repoitoryData", "reposositoryName", "repositionTitle", "repoitoryPath", "reposositoryname", "reposositoryNAME", "repositablename", "repositorName"], "ideIdint": ["ideIdline", "ideidint", "ideIdentno", "ideThline", "IDEIdint", "ideIDline", "ideInfoint", "IDEIdINT", "IDEidINT", "IDEidint", "ideIdno", "ideThno", "IDEidst", " ideIdline", "ideInfoINT", "ideIdind", "ideIDind", "ideDint", "ideDINT", "ideInfost", " ideThind", "IDEIdst", "ideThind", "ideIdINT", "ideidst", "ideIdentline", "ideIDno", "ideIdentint", "ideIDint", "ideIdentind", " ideThint", "ideDst", "ideIdst", "ideThint", " ideThline", "ideidINT", " ideIdind", " ideIdno", " ideThno"], "to": ["eto", "top", "tp", "co", "too", "tel", "about", "token", "target", "addr", "st", "by", "toc", "range", "phone", "To", "topic", "po", "TO", "auto", "address", "tr", "pos", "no", "client", "pro", "company", "ta", "os", "route", "ato", "o", "t", "site", "contact", "tt"], "cc": ["cn", "cloud", "cmd", "co", "cs", "cf", "rc", "ico", "ec", "sc", "CC", "tc", "cin", "ac", "ic", "toc", "control", "dc", "ca", "cv", "cca", "cb", "cci", "mc", "cp", "cmp", "cy", "company", "cr", "ctrl", "cl", "cd", "ci", "ct", "ce", "cm", "ck", "fc"], "bcc": ["rbce", " bCC", "rbcc", "vcc", "cbcc", " bck", "rbcy", "vce", "rbCC", "vcy", "cbck", "bck", "bce", "bcm", "sbce", "cbcm", "cbCC", "vck", "sbck", "sbcc", "bcy", "bCC", "sbcy", " bcm", "rbck", "rbcm"], "subject": ["host", "header", "id", "security", "message", "description", "content", "form", "face", "text", "author", "note", "metadata", "comment", "prefix", "heading", "topic", "Subject", "name", "mail", "template", "title", "source", "filename", "head", "uri", "html"], "body": ["top", "object", "output", "binary", "b", "shell", "other", "data", "message", "description", "back", "content", "business", "ody", "files", "any", "buffer", "bill", "ODY", "Body", "text", "part", "post", "news", "response", "inline", "note", "bh", "comment", "report", "query", "layout", "hex", "code", "base", "params", "name", "zip", "no", "line", "mail", "h", "template", "title", "source", "parts", "head", "inner", "null", "json", "url", "default", "padding", "summary", "bytes", "background", "html", "handle"], "attachments": ["attachachment", "Attachments", "atttypes", "Attachresses", "Attachtypes", "attachresses", "achmentments", "achmenttypes", "attments", "attresses", "attachtypes", "achmentresses", "Attachachment", "achmentachment"], "isHtml": [" isHHTML", " isWhtml", "ishtml", "isWhtml", "isJap", " isWhhtml", "isVip", "isJtml", "IsHtml", "isVtml", " isHhtml", "isWhHTML", "isWhhtml", "IsHhtml", "isChhtml", "IsHttp", "isChHTML", "isVhtml", "ishhtml", "isHip", "isHHTML", "isWhip", "ishap", "isJhtml", "isJttp", "IsHap", " isWhHTML", " isWhip", "ishttp", " isHip", "isHap", "isChip", "isHttp", "isChtml", "isHhtml", "isVHTML"], "charset": ["Charsetter", "chippetter", "charsets", "chippets", "quatset", "quarset", "charspace", "chARSET", "clerspace", "charsec", "chacterspace", "chARSetter", "CHarsets", "channelsetter", "chARSetic", "ChARSetter", "Charsetic", "chatset", "chersets", "chippET", "cherspace", "CHarset", "quatsale", "chippale", "charsET", "chARSpace", "channelset", "chersetter", "chablesec", "CHippET", "quarsec", "chatsec", "clersets", "chableset", "charsett", "ChARSet", "channelsetic", "CharsET", "charpetter", "charpet", "charsetter", "chablesale", "chactersetter", "clarsetter", "cherset", "CHarsett", "charpET", "CHippets", "charpetic", "chippett", "quarsale", "quatsetter", "CHippett", "charpett", "clerset", "ChARSetic", "channelsET", "quatsec", "clarspace", "chactersets", "clarsets", "chablesetter", "chARSets", "CHippet", "chatsetter", "chippec", "chatsale", "charsetic", "ChARSET", "charsale", "CHarsET", "clarset", "chacterset", "chippet", "charpets", "clersetter", "chARSet", "Charset", "quarsetter"], "headers": ["dr", "header", "comments", "fields", "authors", "types", "ers", " trailers", "files", "ilers", "relations", "users", "limits", "metadata", "codes", "heads", "params", "members", "keys", "ors", "details", "head", " heads", "lines", "names", "ters", "ppers"], "priority": ["context", " urgency", "flags", "comments", "id", " severity", "position", "grade", "security", "profile", "level", "description", "properties", "order", "due", "origin", "state", "status", "phone", "prefix", "pos", "company", "serial", "title", "policy", "primary", "password"], "email": ["initial", "Email", "et", "el", "object", "ssl", "server", "domain", "office", "output", "shell", "search", "liner", "license", "voice", "model", "die", "message", "ome", "instance", "detail", "enter", "il", "er", "external", "description", "e", "fax", "ne", "delete", "print", "test", "database", "xml", "example", "entry", "view", "em", "http", "response", "password", "link", "note", "ell", "ilo", "all", "report", "comment", "label", "document", "gmail", "console", "address", "msg", "event", "element", "line", "mail", "call", "company", "template", "oe", "reset", "echo", "url", "log", "sample", "contact", "html", "ee", "result"], "user": ["entity", "output", "uid", "actor", "id", "person", "match", "student", "profile", "usr", "admin", "owner", "USER", "me", "from", "ident", "author", "by", "use", "users", "usage", "browser", "creator", "login", "connection", "name", "system", "client", "usa", "used", "username", "account", "auth", "manager", "ip", "human", "util", "User", "result"], "identity": ["ententity", "IDENTitate", "personITY", "identicate", "entity", "IDENTiciary", "IDENTator", "presententity", "ethnicentity", "primicate", "equator", "identality", "identitate", "ethnicitate", "personicate", "presentitate", "primity", "identalty", "idententity", "instentity", "IDENTalty", "idality", "personity", "personificate", "identificate", "primificate", "IDENTificate", "equalty", "ethnicularity", "IDENTITY", "IDENTity", "identiciary", "identance", "IDENTularity", "IDENTifier", "solidality", "instifier", "instator", "presentity", "IDENTality", "instularity", "primentity", "recognentity", "solidity", "identularity", "IDENTance", "ethnicity", "personentity", "identITY", "idularity", "primance", "recognicate", "idity", "instalty", "equentity", "idiciary", "presentularity", "entifier", "personiciary", "solidentity", "identator", "entularity", "identifier", "IDENTentity", "idITY", "IDENTicate", "equity", "recognity", "instity", "solidularity", "recognance"], "_returnPath": [" _errorAddress", "_getPath", "_savepath", "_ReturnPath", "_requestName", "_ReturnPoint", "_resultTo", "_getDir", " _returnAddress", "_savePath", "_deleteTo", "_errorTo", " _errorPath", " _returnPoint", "_ReturnName", "_errorAddress", "_errorpath", "_retpath", "setsavepath", "_errorPoint", "_saveTo", "_returnDir", "_returnTo", "_deletePath", "setreturnUrl", "setsaveTo", "setreturnpath", "_returnUrl", "_resultPoint", "_errorName", "_retDir", "_getCode", "_getTo", "setsavePath", "_returnAddress", "_replyCode", "_replyPath", " _errorName", "_returnCode", "_replyDir", "_retPoint", "_deletePoint", "_requestPoint", " _returnName", " _errorPoint", "_retUrl", "_errorPath", "_ReturnAddress", "_errorUrl", "_errorLocation", "_retTo", "_returnpath", "_saveUrl", "_requestAddress", "_deletepath", "_requestPath", "_retLocation", "_retCode", "_retPath", "_resultPath", "_returnLocation", "setreturnPath", "_returnPoint", "_resultLocation", "_returnName", "setsaveUrl", "setreturnTo"], "_from": ["_reset", "longreset", "\tform", "letsource", "_about", " _reset", "\tactor", "longsource", "\tauthor", " _source", "longfrom", "_author", "_source", "_owner", " _actor", "longto", "_actor", "remowner", " _form", " _author", "remaddr", "letabout", "_local", "\tfrom", "_addr", "_form", "letfrom", "letto", "remfrom", " _about", "remlocal"], "_replyTo": ["_responseOf", "_closeTo", "_replyOf", "_backFrom", "_responseTO", "_replyPath", "_replyTO", "_returnFrom", "_ReplyTO", "_ReplyPath", "_commentOf", "_ReplyFrom", "_responseFrom", "_returnTo", "_responseTo", "_backTO", "_respondOnly", "_ReplyTo", "_closeLine", "_closeTO", "_backPath", "_responseLine", "_replyOnly", "_respondFrom", "_commentTO", "_returnOnly", "_commentLine", "_ReplyOnly", "_commentTo", "_returnTO", "_respondTo", "_replyFrom", "_responsePath", "_respondTO", "_closeOf", "_replyLine", "_backTo"], "_to": ["prisite", "successta", "_ta", "successto", "successsite", "successtopic", "prito", "_topic", "prita", "pritopic", "_site"], "_cc": [" _subject", " _cs", "_cs", "_cca", "_subject", " _cca"], "_bcc": ["_bca", "_bacc", "_wacc", "_rbacc", "_rcc", "_racc", "_rbcc", "_rca", "_rbck", "_rck", "_wca", "_wck", "_rbca", "_wcc", "_bck"]}}
{"id1": "17792212", "id2": "3767903", "code1": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createButtonCopyToClipboard": ["createButtonCopyToClippboard", "createButtonCopyToCLippad", "createButtonCopyToClimBoard", "createButtonCopyToCLimBoard", "createButtonCopyToClimboard", "createButtonCopyToClitBoard", "createButtonCopyToClipppad", "createButtonCopyToCLimboard", "createButtonCopyToCLipboard", "createButtonCopyToClippad", "createButtonCopyToCLipBoard", "createButtonCopyToCLimpad", "createButtonCopyToClitpad", "createButtonCopyToClitboard", "createButtonCopyToClippBoard", "createButtonCopyToClipBoard", "createButtonCopyToClimpad"], "buttonCopyToClipboard": ["buttonCopyToClippingBoard", "buttonCopyToClippbox", "buttonCopyToclipboard", "buttonCopyToClimpad", "buttonCopyToCLippingboard", "buttonCopyToClippedpad", "buttonCopyToClappad", "buttonCopyToClimbox", "buttonCopyToClippboard", "buttonCopyToClipback", "buttonCopyToCLimboard", "buttonCopyToCLipboard", "buttonCopyToClippingboard", "buttonCopyToClippback", "buttonCopyToCLimback", "buttonCopyToclimBoard", "buttonCopyToCLipbox", "buttonCopyToCLipBoard", "buttonCopyToClapboard", "buttonCopyToClapBoard", "buttonCopyToclipBoard", "buttonCopyToClippingbox", "buttonCopyToclipbox", "buttonCopyToClimboard", "buttonCopyToClapback", "buttonCopyToClippingback", "buttonCopyToClippad", "buttonCopyToCLimBoard", "buttonCopyToClimback", "buttonCopyToclippad", "buttonCopyToClapbox", "buttonCopyToclimboard", "buttonCopyToCLippingback", "buttonCopyToClimBoard", "buttonCopyToclimpad", "buttonCopyToClippBoard", "buttonCopyToClippedBoard", "buttonCopyToClipBoard", "buttonCopyToCLipback", "buttonCopyToCLippingbox", "buttonCopyToCLippingBoard", "buttonCopyToclimbox", "buttonCopyToClippedboard", "buttonCopyToClipbox", "buttonCopyToClippingpad"], "event": ["value", "style", "v", "ex", "events", "message", "self", "window", "selected", "er", "ev", "e", "ed", "state", " Event", "E", "Event", "in", "ie", " EVENT", "name", "vent", "t", "selection", "ee", "index", "result"]}}
{"id1": "11716816", "id2": "7166270", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 0, "substitutes": {"updateFile": ["UpdateContent", "UpdatePage", "downloadFile", "archiveSourceFile", "updatePage", "archiveContent", "downloadContent", "UpdateSourceFile", "archivePage", "archiveFile", "downloadPage", "UpdateFile", "updateSourceFile", "downloadSourceFile", "updateContent"], "file": ["f", "image", "output", "p", "port", "channel", "data", "message", "format", "issue", "content", "path", "e", "le", "io", "rule", "entry", "File", "resource", "table", "FILE", "link", "page", "report", "attribute", "document", "base", "name", "line", "fp", "h", "ile", "get", "source", "input", "filename", "full", "title", "db", "null", "type", "url", "t", "log", "use", "info", "local", "handle"], "IOException": ["IOProblem", " IOError", "OperationException", " IOProblem", "OperationProblem", "OperationError", "SecurityError", "SecurityException", "SecurityProblem", "IOError"], "destFile": ["destDo", " destinationFile", " destfile", "destfile", "optPlace", "destile", " destEmail", "sourceFolder", "sourceFile", " DestFile", " destile", "destDir", "tempFile", " destFolder", "tempfile", "destFolder", "optFolder", "targetDir", " DestDo", "DestPlace", "destEmail", "destPath", "sourcePath", " DestEmail", "DestDir", "destPlace", "destSourceFile", "targetFile", "DestFolder", "declFile", " destPlace", "DestSourceFile", "declSourceFile", "optFile", "Destfile", "tempDir", " destDo", "DestPath", " destDir", "DestPage", "DestFile", " destinationDo", " destSourceFile", "sourceDir", "declFolder", " destinationEmail", "targetFolder", "targetPath", " destPath", "declile", " DestDir", "destPage", "optPage", " destPage", "Destile", "tempPath", " destinationDir"], "in": ["f", " IN", "mi", "ins", "din", "inside", "en", "ini", "IN", "sin", "inn", "s", "con", "ln", "ai", "io", "inf", "ne", "gin", "cin", "local", "m", "mm", "bin", "on", "from", "raw", "it", "ic", "re", "all", "init", "edIn", "al", "ie", "ain", "act", "ind", "is", "inc", "up", "rin", "i", "input", "r", "iter", "inner", "oin", "pass", "l", "net", "info", "isin", "im", " din", "read", "In", "n"], "out": ["cn", "ot", "cmd", " OUT", "output", "OUT", "en", "co", "b", "v", "again", "ex", "channel", "cache", "jp", "gt", "s", "con", "net", "io", "ne", "outer", "sys", "chain", "conn", "outs", "it", "or", "OU", "ou", "note", "to", "obj", "aos", "nt", "cos", "ch", "msg", "fn", "ion", "client", "write", "up", "can", "no", "oss", "one", "oe", "g", "os", "conv", "null", "flush", "t", "o", "log", "Out", "at", "result", "n"]}}
{"id1": "17111859", "id2": "15500892", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getHash": ["createhash", "gethash", "getSum", "createHash", "GetKey", " gethash", " getKey", "GetHash", "GetSum", " getSum", "createSum", "Gethash", "getKey", "createKey"], "string": ["object", "value", "v", "cache", "pattern", "data", "message", "char", "format", "pair", "list", "instance", "s", "content", "chain", "test", "buffer", "strings", "space", "text", "ident", "array", "status", "comment", "attribute", "prefix", "key", "sql", "dump", "function", "address", "name", "word", "hash", "source", "input", "filename", "null", "ring", "type", "sample", "password"], "hashTime": ["hashTimer", " hashTimeout", "messageTime", "clockTimer", "HashTimer", " hashTimes", " hashLength", "messageTimeout", "messageLock", "hashLock", "hashLength", "HashLock", "hashTimeout", "HashTime", "HashTimes", "clockLength", " hashTimer", "messageTimer", "hashTimes", "clockTimeout", "messageTimes", "clockTime", "messageLength", " hashLock"], "md5": ["md45", "MD1", " MD55", " MD3", "MD2", "md55", " md512", " mdock", "dig45", "det2", "dig1", "md3", "dig5", "MD512", " md2", "MD5", " MDock", " md10", "md512", " md45", "hash512", " md55", " md1", "MD3", " Md55", "mdock", " MD10", "md10", " md3", " Md3", " MD5", "MD10", "hash3", "det5", " MD2", "MD45", "dig2", " Md5", "hash2", "det3", "md1", " Mdock", "md2", "hash5"], "result": ["output", "search", "product", "mate", "currency", "work", "match", "cache", "total", "correct", "pair", "list", "Result", "diff", "chain", "complete", "test", "sequence", "buffer", "valid", "RESULTS", "ret", "answer", "array", "table", "response", "report", "comment", "card", "res", "hex", "params", "cup", "current", "reverse", "comp", "done", "su", "r", "cur", "comb", "results", "row", "success"], "hexString": [" HexString", "alphString", "charArray", "exArray", " hexStr", "exCharacter", "hexBuffer", "exString", " hexArray", "hexStr", "hexChain", "hexResult", "hexArray", " HexArray", "hexCharacter", " hexChain", "exStr", "charBuffer", "exChain", "charString", " HexResult", "exBuffer", "alphArray", " HexStr", " hexCharacter", "alphChain", " hexBuffer", "exResult", "charResult", " hexResult", "alphCharacter"], "i": ["k", "cli", "mi", "z", "u", "id", "v", "ix", "ini", "I", "us", "ii", "si", "e", "ai", "io", "bi", "chain", "sequence", "n", "q", "my", "m", "me", "sim", "in", "ki", "ic", "multi", "ei", "it", "li", "ti", "a", "j", "xi", "to", "x", "hi", "ji", "phi", "y", "ind", "is", "ui", "gu", "uri", "di", "gi", "l", "ip", "ci", "\u0438", "o", "qi", "index", "pi"], "str": ["arr", "dr", "output", "p", "cache", "STR", "enc", "data", "char", "stable", "Str", "chain", "sequence", "buffer", "sw", "st", "text", "ret", "status", "fr", "key", "obj", "res", "hex", "sp", "msg", "tr", "name", "hash", "out", "br", "txt", "cr", "r", "ctr", "t", "n"]}}
{"id1": "9236363", "id2": "11952735", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"unJarStart": ["unJobStart", "unJobEntry", "unjarPart", " unZipEntry", " unZipStop", "unJarEntry", "unZipStop", "unjarEntry", "unjarStop", "unZipPart", " unZipPart", "unZipEntry", "unJobStop", " unJarEntry", " unJarStop", "unJobPart", "unJarStop", "unJarPart", "unjarStart", " unJarPart", "unZipStart", " unZipStart"], "jarPath": ["browserName", "pkgPath", "pkgHome", "jarUrl", "firePath", "jarName", "pkgFile", "jarProject", "certPath", "javaTime", " jarCh", "jPath", "jHost", " jarTime", "javaHost", " jarHost", "jarCh", "javaPath", " jarInfo", "jarHome", " jarProject", "browserPath", "certpath", "jName", " jarCore", "browserUrl", "javaInfo", "javaCore", "jobFile", "fireUrl", "jobHome", "carCh", "carUrl", " jarUrl", " jarFile", "pkgpath", "carpath", "jarTime", "javapath", "jTime", " jarHome", "fireName", "certInfo", "carPath", "javaUrl", "fireCore", "certHost", "browserpath", "javaCh", "javaProject", "browserProject", "jarpath", "jarFile", "javaName", "jarCore", "jobpath", "jarInfo", " jarpath", "jobPath", " jarName", "jarHost"], "jarEntryStart": ["jarPathEnd", "carEntrystart", "jarAddPart", "jarentryBegin", "jarEntryInit", "jarPathInit", "jarNameSize", "jarFileAdd", "jarEntryPart", "jarRowstart", "jarUrlEnd", "jarFilePart", "jarPathStart", "jarNameEnd", "jarEntPart", "carUrlstart", "carEntryEnd", "jarAddAdd", "elementEntryStart", "joEntryStart", "jarNameStart", "jarNameBegin", "joentrySize", "jarRowStart", "jarUrlstart", "jarAddStart", "jarElementFinish", " jarEntryAdd", "jarEntityStart", "jarEntityEnd", " jarFileAdd", "jarEntryEnd", "carUrlEnd", "joentryStart", "carUrlName", "jarentryStart", "jarRowBegin", " jarFilePart", "carEntryName", "jarFileStart", "jarNamestart", "jarEntryAdd", " jarFileStarting", " jarEntryStarting", "jarEntStarting", "jarElementEnd", "jarEntStart", "jarUrlName", "jarRowSize", "elementEntityStart", " jarEntryPart", " jarFileStart", "elementEntryFinish", "joEntrySize", "jarElementInit", "jarPathFinish", "jarPathstart", "jarAddStarting", "jarEntryFinish", "elementEntityFinish", "jarEntrySize", "elementEntryInit", "jarentrySize", "jarFileStarting", "joentrystart", "jarElementStart", "carEntryStart", "jarEntAdd", "jarEntryStarting", "jarentrystart", "jarEntityInit", "elementEntryEnd", "jarPathName", "jarUrlStart", "jarEntryBegin", "jarEntryName", "joEntrystart", "jarNameName", "joEntryBegin", "joentryBegin", "jarEntrystart", "elementEntityEnd", "elementEntityInit", "jarEntityFinish", "carUrlStart"], "path": ["loc", "length", "context", "folder", "core", "host", "cmd", "value", "near", "exp", "p", "port", "position", "location", "pattern", "data", "message", "self", "select", "where", "api", "string", "empty", "dest", "order", "walk", "print", "test", "program", "ref", "chain", "tree", "set", "PATH", "text", "pkg", "trace", "join", "method", "to", "prefix", "dir", "key", "transform", "x", "file", "hex", "relative", "parent", "phi", "name", "system", "mount", "client", "check", "template", "out", "input", "route", "url", "prop", "Path", "root", "log", "point", "kind", "index", "history", "ath", "pi"], "relPath": ["relPort", " relPos", "relatedpath", "relPos", "RELPos", "relatedPort", "RelPos", "relatedPath", "relatedName", "RELpath", "RELPath", "RELName", "RelPort", "relpath", " relpath", "RelPath", "RelName", "Relpath", "relName", " relPort", " relName"], "jar": ["war", "sea", "Jar", "gem", "jj", "archive", "we", "jp", "zone", "ie", "bare", "le", "tar", "pack", "ar", "pkg", "js", "ja", "vol", "bar", "j", "browser", "session", "dir", "report", "bag", "file", "cert", "tmp", "sp", "library", "batch", "be", "cp", "rar", "java", "zip", "true", "cur", "db", "manager", "tab", "keeper", "ctr", "car", "jo", "jet", "lib", "module", "jc"], "entries": ["enries", "enties", "entsrys", "integries", " entencies", "encarts", "encrys", "entarts", "entities", "entires", "contrs", "Enties", "Entarts", "entents", "entencies", "enrees", "entsries", "Entrees", "enires", "encries", "integrys", "Entities", "integarts", "encencies", "contries", "encents", " entrys", "encires", "entsencies", "Entries", "enents", "Entires", "Entrs", "entsities", "entrs", "enrys", "conties", "entrees", "Entencies", "Entrys", "Entents", " entities", "contrees", "enies", "enrs", "integencies", "entrys"], "entry": ["entity", "pe", "record", "office", "ry", "match", "archive", "instance", "char", "enter", "ent", "e", "cell", "member", "resource", "add", "de", "attribute", "key", "component", "ie", "nt", "address", "be", "name", "zip", "event", "word", "element", "ion", "ace", "se", "row", "ce", "Entry", "zo", "jo", "and", "info", "module", "result", "escape"], "jarEntry": ["javaEvent", "joItem", "joEntry", "javaItem", "javaEntry", "fireEntry", "jarItem", "jEntry", "tarEntry", "jamSlot", "tarAdd", "fireAdd", "joAddress", " jarEnt", "jarentry", "searchentry", "jentry", "jEnt", "searchEnt", "jarAdd", "jarEnt", "certElement", "browserEnt", "fireElement", "tarEnt", "jamentry", "jamEntry", "carElement", "javaAddress", "browserentry", "certentry", "searchSlot", "joEvent", " jarEvent", "certEntry", "carEntry", "browserEntry", "jarSlot", "certEnt", "jarElement", "carentry", "jarAddress", "browserElement", " jarAdd", " jarItem", " jarAddress", "searchEntry", "jSlot", "jarEvent", "tarElement", "fireEnt", "carEnt", " jarElement", "jamEnt"], "ze": ["zy", "z", "pe", "zes", "je", "ea", "sle", "zz", "te", "ge", "ae", "e", "le", "cin", "zed", "me", "ode", "ei", "li", "ke", "de", "so", "zi", "ie", "ZE", "be", "zer", "zip", "enz", "sk", "se", "zie", "oe", "ene", "ase", "zing", "ce", "aze", "zo", "ee", "za"], "bin": ["din", "bm", "bl", "binary", "b", "pin", "bed", "fin", "bn", "bo", "sin", "ln", "bi", "cin", "gin", "nb", "bank", "kin", "in", "ic", "bat", "spin", " Bin", "bg", "sam", "pic", "dll", "bu", "lock", "zip", "exe", "win", "skin", "bian", "di", "db", "obin", "pan", "bb", "lib", "ebin"]}}
{"id1": "6304373", "id2": "22479286", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaAndTplates", "uploadOrDeleteMediaAndTemplates", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTplates", "uploadOrDeleteMediaOrTemppl", "uploadOrDeleteMediaOrTempplates", "uploadOrDeleteMediaAndTemTemplate", "uploadOrDeleteMediaOrTempics", "uploadOrDeleteMediaAndTTemplate", "uploadOrDeleteMediaOrTemics", "uploadOrDeleteMediaOrTics", "uploadOrDeleteMediaAndTpl", "uploadOrDeleteMediaOrTpl", "uploadOrDeleteMediaAndTemics", "uploadOrDeleteMediaOrTemTemplate", "uploadOrDeleteMediaOrTTemplate", "uploadOrDeleteMediaAndTempl", "uploadOrDeleteMediaOrTempTemplate", "uploadOrDeleteMediaAndTics"], "action": ["update", "ction", "fun", "operator", "actor", "behavior", "mode", "scene", "exclusive", "instance", "format", "feature", "admin", "process", "activation", "ACTION", "Action", "actions", "on", "acl", "article", "view", "error", "commit", "active", "step", "method", "what", "edit", "expression", "ACT", "op", "function", "wrong", "operation", "change", "act", "controller", "address", "event", "call", "policy", "version", "type", "ase", "go", "now", "verb"], "object": ["image", "entity", "office", "actor", "node", "model", "class", "integer", "relation", "instance", "format", "detail", "information", "subject", "entry", "article", "volume", "resource", "what", "attribute", "item", "oid", "obj", "document", "function", "operation", "address", "act", "objects", "event", "hash", "element", "no", "property", "number", "one", "version", "thing", "unknown", "o", "not", "job", "module", "project"], "numElements": ["numEles", "numElem", "numelements", " numeles", " numElem", " numelements", "numeles", "numNlement", "numElelements", "numelem", " numEles", "numNles", "numElelem", "numNlements", " numelem", " numelement", "numEleles", "numNlem", "numElelement", "numelement"], "req": [" conf", "Request", "Msg", " std", "Requ", " fr", "Resp", " requ", " cmd", "Cmd", " msg", " cred", "q", " cir", "request", " request", " resp", "qt", "quest", "obj", "res", "msg", "txt", " serv", "conf", "tx", " res", "requ"], "session": ["context", "ssl", "store", "search", "cache", "task", "window", "thread", "group", "stack", "state", "subject", "conn", "request", "status", "http", "Session", "response", "socket", "browser", "connection", "sid", "ses", "ess", "parent", "event", "essions", "system", "client", "ession", "config", "manager", "tx", "use", "local"], "ftp": ["FTps", "FTP", " ftP", " ftps", "afp", "FTp", "ftP", "afP", "afps", " fttp", "ftps", "aftp", "fttp", "FTtp"], "user": ["record", "store", "other", "person", "job", "student", "self", "instance", "er", "usr", "order", "owner", "form", "USER", "User", "sys", "group", "basic", "device", "me", "rule", "view", "author", "by", "part", "users", "ter", "ser", "to", "usage", "browser", "ver", "query", "dev", "parent", "per", "event", "word", "current", "system", "client", "usa", "used", "display", "mem", "open", "username", "account", "config", "auth", "db", "manager", "human", "util", "use", "info", "result", "plugin"], "links": ["rel", "blogs", "flags", "Links", "ls", "self", "items", "properties", "types", "actions", "packages", "network", "relations", "js", "link", "dir", "owners", "Link", "details", "scripts", "mails", "pages", "lines", "projects", "groups", "href", "html", "tags"], "folders": ["foldors", "temors", "dirers", "contors", "conters", "contories", "foldes", "temers", "dirors", "temes", "dirories", "temories", "contes", "foldories", "dires"], "folder": ["host", "context", "letter", "container", "old", "location", "zone", "stage", "email", "enter", "area", "lower", "Folder", "path", "box", "device", "sequence", "buffer", "files", "database", "region", "volume", "resource", "collection", "size", "upload", "dir", "card", "sheet", "layout", "topic", "base", "directory", "controller", "family", "zip", "fold", "system", "older", "loop", "feed", "filename", "center", "root", "division", "gallery", "module", "project", "room"], "server": ["host", "engine", "store", "domain", "seed", "port", "computer", "scale", "stage", "instance", "email", "er", "service", "localhost", "area", "peer", "enter", "owner", "device", "handler", "test", "buffer", "database", "mobile", "Server", "resource", "slave", "serving", "erver", "ser", "socket", "browser", "ver", "connection", "console", "directory", "system", "client", "manager", "center", "version", "url", "root", "site", "remote"], "login": ["license", "search", "id", "pin", "match", "computer", "profile", "email", "admin", "secret", "cookie", "token", "owner", "net", "print", "blog", "basic", "cell", "database", "nic", "in", "ident", "author", "ping", "join", "insert", "bridge", "ername", "note", "phone", "connection", "john", "fn", "name", "lock", "nick", "mail", "number", "username", "skin", "pass", "account", "filename", "auth", "submit", "fail", "Login", "ip", "log"], "password": ["encrypted", "value", "Password", "strip", "confirmed", "exclusive", "pattern", "profile", "sword", "ssh", "email", "description", "secret", "token", "path", "device", "restricted", "sudo", "phrase", "picture", "database", "parser", "another", "resource", "worker", "stroke", "pretty", "performance", "comment", "prefix", "attribute", "paste", "python", "command", "power", "pool", "PASS", "hash", "word", "username", "pass", "photo", "auth", "policy", "crypt", "padding", "productive", "wordpress", "hello", "escape"], "fileTransferFolder": ["fileDownloadDirectory", "fileMovefolder", "fileImportLocation", "FileTransferfolder", "fileTransferArea", "FileUploadDirectory", "FileUploadLocation", "fileTransferFile", "fileTransferfolder", "fileUploadLocation", "FileTransferFile", "fileTransferLocation", "fileUploadArea", "FileUploadFolder", "FileUploadFile", "FileTransferDirectory", "fileDownloadFolder", "fileImportfolder", "fileDownloadLocation", "fileUploadFolder", "fileUploadfolder", "fileMoveFolder", "fileImportArea", "fileUploadDirectory", "fileUploadFile", "FileTransferLocation", "FileTransferArea", "FileUploadArea", "FileUploadfolder", "fileDownloadFile", "fileMoveFile", "FileTransferFolder", "fileImportFolder", "fileMoveDirectory", "fileDownloadArea", "fileTransferDirectory", "fileDownloadfolder"], "liveFolder": ["embedDir", "LiveFolder", "LiveDir", " livefolder", "liveDir", " liveDir", "Livefolder", "liveDirectory", "embedfolder", " liveDirectory", "embedFolder", "LiveDirectory", "livefolder", "embedDirectory"], "servers": ["teers", "servvers", "Serctors", "servctors", "serctors", "tectors", "teors", "serors", "tevers", "serers", "servors", "Serors", "Serers", "Servers"], "message": ["mess", "warning", "essage", "show", "data", "language", "window", "description", "content", "say", "string", "sequence", "buffer", "m", "application", "status", "trace", "response", "reason", "Message", "comment", "alert", "report", "browser", "document", "body", "msg", "flash", "mail", "template", "memory", "number", "summary", "media", "log", "contact", "management", "command", "result"]}}
{"id1": "13152325", "id2": "4461350", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"loadExistingAntlibs": ["loadExistingAntlibFiles", "loadExistingantLibz", "loadExistingantlibs", "loadExistingAntLibFiles", "loadExistingantlibz", "loadExistingAntribFiles", "loadExistingAntlibz", "loadExistingAntibz", "loadExistingAntribz", "loadExistingAntribd", "loadExistingAntibd", "loadExistingantlibFiles", "loadExistingAntibs", "loadExistingAntibFiles", "loadExistingAntLibd", "loadExistingAntribs", "loadExistingantLibFiles", "loadExistingantLibd", "loadExistingantlibd", "loadExistingAntlibd", "loadExistingantLibs", "loadExistingAntLibs", "loadExistingAntLibz"], "classLoader": [" classLoad", " classReader", " ClassPath", "classReader", "classLoad", "Classloader", " Classloader", " ClassLoader", " classPath", "ClassPath", "classPath", "classloader", " ClassReader", "ClassReader", "ClassLoader", " classloader", " ClassLoad", "ClassLoad"], "antlibUrl": ["antsliburl", "antLibUr", "antLibStr", "antdbURL", "AntlibURL", "antlabUrl", "antslibUr", "antslibRel", "antdburl", "antsLiburl", "antLibURL", "antsLibUr", "antslibStr", "antappURL", "antLibUrl", "antriburl", "antappUrl", "AntLibUr", "AntLibUrl", "antlibStr", "antliburl", "AntlibUr", "antappUr", "antribUr", "antlibraryURL", "antLibRel", "antsLibUrl", "antlibraryUr", "antsLibURL", "antsLibRel", "antappRel", "antlabStr", "antlaburl", "antlibURL", "antlibraryStr", "antlibUr", "antdbUrl", "AntlibUrl", "antdbUr", "Antliburl", "antlabUr", "antlibraryurl", "antlibraryUrl", "antslibUrl", "antribUrl", "antslibURL", "antribURL", "antLiburl", "antlibraryRel", "antlibRel", "AntLibURL", "AntLiburl", "antsLibStr"], "antlibUri": ["antlibEis", "antLibUtpi", "antlibUtrid", "antLibUtris", "antlibEUris", "antlibraryUne", "antlibIri", "antLibUpi", "antlibEUri", "antlibUtmi", "antlibUsr", "antlibEURI", "antlibEUpi", "antlibUURI", "antlibURris", "antlibIrid", "antlibURRI", "antLibIri", "antLibUtri", "antlibUtRI", "antlibUtris", "antlibUris", "antlibraryUsne", "antlibraryUsmi", "antlibraryUsri", "antlibEri", "antlibraryUmi", "antlibUne", "antlibUr", "antlibUpi", "antLibUis", "antlibURI", "antlibIis", "antlibUsmi", "antLibUris", "antlibUsURI", "antlibURri", "antlibUmi", "antlibUsis", "antlibUtri", "antlibIRI", "antlibraryUsRI", "antlibUsRI", "antlibOr", "antlibOne", "antlibraryUr", "antLibUri", "antlibURmi", "antLibIURI", "antlibIpi", "antlibUis", "antlibUsris", "antlibIURI", "antLibIis", "antlibGerid", "antlibUrid", "antlibIne", "antlibraryUsr", "antlibraryURI", "antlibUsne", "antLibURI", "antLibIrid", "antlibUsri", "antlibraryUris", "antlibOris", "antlibGeris", "antLibUURI", "antlibOri", "antlibraryUri", "antlibUtpi", "antlibGeri", "antLibUrid", "antLibIris", "antlibIr", "antlibEris", "antLibIRI", "antlibraryUsris", "antlibIris", "antlibGeRI"], "resources": ["iers", "checks", "ions", "writers", "models", "values", "rs", "maps", "classes", "events", "Resources", "builders", "ues", "types", "files", "actions", "links", "packages", "issues", "relations", "headers", "ries", "images", "users", "works", "books", "reports", "res", "workers", "seconds", "objects", "dates", "services", "modules", "keys", "archives", "pages", "stores", "states", "ples", "ports", "parents", "bytes", "names", "groups", "roots", "years", "these"], "url": ["loc", "f", "rel", "host", "el", "sl", "ssl", "server", "gl", "location", "ls", "dl", "char", "format", "service", "bel", "github", "string", "path", "web", "ref", "lr", "addr", "str", "ll", "xml", "entry", "request", "resource", "http", "rl", "li", "add", "nl", "link", "browser", "ur", "key", "URL", "file", "base", "address", "name", "mount", "get", "source", "r", "lb", "Url", "l", "abs", "util", "remote", "date"], "stream": ["context", "progress", "Stream", "sl", "store", "channel", "data", "message", "standard", "window", "content", "iterator", "ream", "path", "io", "user", "stack", "buffer", "sw", "loader", "view", "resource", "response", "socket", "file", "console", "body", "pipe", "zip", "open", "system", "client", "out", "source", "feed", "input", "inner", "row", "sample", "history", "read"], "reader": ["length", "readable", "dd", "server", "ri", "liner", "upper", "instance", "er", "review", "iterator", "driver", "handler", "buffer", "parser", "via", "entry", "loader", "layer", "volume", "writer", "rl", "resource", "reads", "runner", "collection", "reading", "socket", "ro", "READ", "range", "query", "file", "console", "reviewed", "per", "Reader", "rr", "rx", "rar", "client", "older", "ner", "r", "input", "iter", "inner", "rer", "row", "roller", "sample", "read"], "line": ["column", "sl", "ine", "pe", "header", "liner", "online", "port", "ls", "lf", "eline", "profile", "message", "string", "ln", "lo", "le", "print", "cell", "n", "buffer", "str", "block", "lin", "entry", "text", "li", "frame", "nl", "Line", "inline", "link", "page", "stay", "comment", "range", "label", "sql", "file", "body", "msg", "pos", "word", "len", "iter", "l", "row", "lines", "next", "log", "sample", "LINE", "point", "handle"], "pkg": ["quote", "patch", "lang", "var", "p", "perm", "port", "dl", "kid", "pair", "Package", "path", "ctx", "packages", "pt", "entry", "pack", "pp", "gp", "imp", "mod", "ppa", "part", "col", "alias", "jar", "req", "dir", "prefix", "fx", "init", "pg", "key", "kg", "msg", "pod", "cp", "rpm", "pid", "zip", "mask", "family", "name", "cmp", "wd", "deb", "ip", "root", "password", "lib", "module", "plugin"], "uri": ["cli", "folder", "mi", "domain", "uid", "ri", "id", "location", "profile", "api", "io", "handler", "URI", "term", "resource", "http", "link", "ur", " URI", "connection", "file", "uu", "proxy", "address", "library", "directory", "reference", "base", "iri", "system", "ui", "i", "source", "ip", "util", "local", "pi"], "resource2antlib": ["resource2AntLib", "resourcetoantconfig", "resource2antloc", "resource2boltlib", "resource2Antli", "resource2ANTloc", "resource2agentib", "resource2Antib", "resource2ntlibrary", "resource2boltib", "resource2agentlibrary", "resource2ANTlib", "resource2antlibrary", "resource2ntli", "resource2antli", "resource1agentlibrary", "resource1agentib", "resource2boltloc", "resource2Antlib", "resource2etlib", "resource2etLib", "resourcetoANTlib", "resource2antsconfig", "resource1antlib", "resourcetoantloc", "resource2ntLib", "resource2ANTib", "resource2ntlib", "resource2agentLib", "resourcetoANTloc", "resource2antsloc", "resource1antib", "resourcetoANTib", "resource2antconfig", "resource2etlibrary", "resource2etli", "resource2Antlibrary", "resource1agentLib", "resource2ANTconfig", "resource1antLib", "resourcetoantlib", "resource2antslib", "resource2agentlib", "resource1agentlib", "resource2antLib", "resource2antib", "resource2ntib", "resource2boltconfig", "resourcetoantib", "resourcetoANTconfig", "resource1antlibrary", "resource2antsib"]}}
{"id1": "6304373", "id2": "21979462", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaAndTplates", "uploadOrDeleteMediaAndTemplates", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTplates", "uploadOrDeleteMediaOrTemppl", "uploadOrDeleteMediaOrTempplates", "uploadOrDeleteMediaAndTemTemplate", "uploadOrDeleteMediaOrTempics", "uploadOrDeleteMediaAndTTemplate", "uploadOrDeleteMediaOrTemics", "uploadOrDeleteMediaOrTics", "uploadOrDeleteMediaAndTpl", "uploadOrDeleteMediaOrTpl", "uploadOrDeleteMediaAndTemics", "uploadOrDeleteMediaOrTemTemplate", "uploadOrDeleteMediaOrTTemplate", "uploadOrDeleteMediaAndTempl", "uploadOrDeleteMediaOrTempTemplate", "uploadOrDeleteMediaAndTics"], "action": ["update", "ction", "fun", "operator", "actor", "behavior", "mode", "scene", "exclusive", "instance", "format", "feature", "admin", "process", "activation", "ACTION", "Action", "actions", "on", "acl", "article", "view", "error", "commit", "active", "step", "method", "what", "edit", "expression", "ACT", "op", "function", "wrong", "operation", "change", "act", "controller", "address", "event", "call", "policy", "version", "type", "ase", "go", "now", "verb"], "object": ["image", "entity", "office", "actor", "node", "model", "class", "integer", "relation", "instance", "format", "detail", "information", "subject", "entry", "article", "volume", "resource", "what", "attribute", "item", "oid", "obj", "document", "function", "operation", "address", "act", "objects", "event", "hash", "element", "no", "property", "number", "one", "version", "thing", "unknown", "o", "not", "job", "module", "project"], "numElements": ["numEles", "numElem", "numelements", " numeles", " numElem", " numelements", "numeles", "numNlement", "numElelements", "numelem", " numEles", "numNles", "numElelem", "numNlements", " numelem", " numelement", "numEleles", "numNlem", "numElelement", "numelement"], "req": [" conf", "Request", "Msg", " std", "Requ", " fr", "Resp", " requ", " cmd", "Cmd", " msg", " cred", "q", " cir", "request", " request", " resp", "qt", "quest", "obj", "res", "msg", "txt", " serv", "conf", "tx", " res", "requ"], "session": ["context", "ssl", "store", "search", "cache", "task", "window", "thread", "group", "stack", "state", "subject", "conn", "request", "status", "http", "Session", "response", "socket", "browser", "connection", "sid", "ses", "ess", "parent", "event", "essions", "system", "client", "ession", "config", "manager", "tx", "use", "local"], "ftp": ["FTps", "FTP", " ftP", " ftps", "afp", "FTp", "ftP", "afP", "afps", " fttp", "ftps", "aftp", "fttp", "FTtp"], "user": ["record", "store", "other", "person", "job", "student", "self", "instance", "er", "usr", "order", "owner", "form", "USER", "User", "sys", "group", "basic", "device", "me", "rule", "view", "author", "by", "part", "users", "ter", "ser", "to", "usage", "browser", "ver", "query", "dev", "parent", "per", "event", "word", "current", "system", "client", "usa", "used", "display", "mem", "open", "username", "account", "config", "auth", "db", "manager", "human", "util", "use", "info", "result", "plugin"], "links": ["rel", "blogs", "flags", "Links", "ls", "self", "items", "properties", "types", "actions", "packages", "network", "relations", "js", "link", "dir", "owners", "Link", "details", "scripts", "mails", "pages", "lines", "projects", "groups", "href", "html", "tags"], "folders": ["foldors", "temors", "dirers", "contors", "conters", "contories", "foldes", "temers", "dirors", "temes", "dirories", "temories", "contes", "foldories", "dires"], "folder": ["host", "context", "letter", "container", "old", "location", "zone", "stage", "email", "enter", "area", "lower", "Folder", "path", "box", "device", "sequence", "buffer", "files", "database", "region", "volume", "resource", "collection", "size", "upload", "dir", "card", "sheet", "layout", "topic", "base", "directory", "controller", "family", "zip", "fold", "system", "older", "loop", "feed", "filename", "center", "root", "division", "gallery", "module", "project", "room"], "server": ["host", "engine", "store", "domain", "seed", "port", "computer", "scale", "stage", "instance", "email", "er", "service", "localhost", "area", "peer", "enter", "owner", "device", "handler", "test", "buffer", "database", "mobile", "Server", "resource", "slave", "serving", "erver", "ser", "socket", "browser", "ver", "connection", "console", "directory", "system", "client", "manager", "center", "version", "url", "root", "site", "remote"], "login": ["license", "search", "id", "pin", "match", "computer", "profile", "email", "admin", "secret", "cookie", "token", "owner", "net", "print", "blog", "basic", "cell", "database", "nic", "in", "ident", "author", "ping", "join", "insert", "bridge", "ername", "note", "phone", "connection", "john", "fn", "name", "lock", "nick", "mail", "number", "username", "skin", "pass", "account", "filename", "auth", "submit", "fail", "Login", "ip", "log"], "password": ["encrypted", "value", "Password", "strip", "confirmed", "exclusive", "pattern", "profile", "sword", "ssh", "email", "description", "secret", "token", "path", "device", "restricted", "sudo", "phrase", "picture", "database", "parser", "another", "resource", "worker", "stroke", "pretty", "performance", "comment", "prefix", "attribute", "paste", "python", "command", "power", "pool", "PASS", "hash", "word", "username", "pass", "photo", "auth", "policy", "crypt", "padding", "productive", "wordpress", "hello", "escape"], "fileTransferFolder": ["fileDownloadDirectory", "fileMovefolder", "fileImportLocation", "FileTransferfolder", "fileTransferArea", "FileUploadDirectory", "FileUploadLocation", "fileTransferFile", "fileTransferfolder", "fileUploadLocation", "FileTransferFile", "fileTransferLocation", "fileUploadArea", "FileUploadFolder", "FileUploadFile", "FileTransferDirectory", "fileDownloadFolder", "fileImportfolder", "fileDownloadLocation", "fileUploadFolder", "fileUploadfolder", "fileMoveFolder", "fileImportArea", "fileUploadDirectory", "fileUploadFile", "FileTransferLocation", "FileTransferArea", "FileUploadArea", "FileUploadfolder", "fileDownloadFile", "fileMoveFile", "FileTransferFolder", "fileImportFolder", "fileMoveDirectory", "fileDownloadArea", "fileTransferDirectory", "fileDownloadfolder"], "liveFolder": ["embedDir", "LiveFolder", "LiveDir", " livefolder", "liveDir", " liveDir", "Livefolder", "liveDirectory", "embedfolder", " liveDirectory", "embedFolder", "LiveDirectory", "livefolder", "embedDirectory"], "servers": ["teers", "servvers", "Serctors", "servctors", "serctors", "tectors", "teors", "serors", "tevers", "serers", "servors", "Serors", "Serers", "Servers"], "message": ["mess", "warning", "essage", "show", "data", "language", "window", "description", "content", "say", "string", "sequence", "buffer", "m", "application", "status", "trace", "response", "reason", "Message", "comment", "alert", "report", "browser", "document", "body", "msg", "flash", "mail", "template", "memory", "number", "summary", "media", "log", "contact", "management", "command", "result"]}}
{"id1": "18202328", "id2": "12417893", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"register": ["update", "callback", "bind", "record", "store", "server", "match", "launch", "email", "reg", "hook", "setup", "insert", "link", "install", "login", "remember", "Register", "create", "account", "submit", "auth", "save", "log", " Register", "password", "hello", "handle"], "session": ["server", "store", "shell", "present", "person", "position", "question", "cache", "message", "task", "window", "instance", "connect", "localhost", "self", "game", "process", "user", "environment", "member", "state", "database", "subject", "set", "network", "application", "sim", "request", "view", "join", "station", "Session", "status", "response", "spin", "to", "usage", "browser", "brain", "connection", "sid", "course", "document", "parent", "settings", "lock", "system", "ion", "client", "current", "activity", "ession", "input", "account", "manager", "condition", "version", "play", "global", "second", "summary", "journal", "site", "remote", "password", "use", "job", "local", "master", "result", "action"], "username": ["cn", "host", "uid", "software", "person", "monitor", "displayText", "profile", "sword", "message", "email", "description", "pty", "approximately", "string", "token", "user", "owner", "sn", "USER", "restricted", "whatever", "rue", "path", "subject", "joining", "term", "steam", "text", "ername", "minecraft", "login", "attribute", "prefix", "key", "NAME", "john", "nil", "pai", "name", "word", "nick", "ame", "title", "filename", "source", "account", "uri", "auth", "character", "wikipedia", "taker", "url", "human", "uno", "minimum", "password", "User", "hello", "artist", "master", "information"], "verificationKey": ["verifyingKey", "verificationKEY", "verifierKey", "veridationkey", "certicationPoint", "verifyingkey", "certicationKEY", "validifyingkey", "validifyingKEY", "certicationKey", "verificationKeys", "verifyingKEY", "certificationKey", "verifierkey", "verationKEY", "verationKey", "certificationkey", "certificationPoint", "validificationKeys", "verifierPoint", "verifyingKeys", "verationkey", "vericationPoint", "validifyingKeys", "verifierKEY", "veridationKeys", "verationKeys", "verificationPoint", "veridationKey", "verifyingPoint", "validificationKEY", "vericationKEY", "certificationKEY", "validifyingKey", "validificationkey", "validificationKey", "veridationKEY", "vericationkey", "vericationKey", "certicationkey", "verificationkey"], "salt": ["thunt", "ssl", "thALT", "sodium", "solt", "ssALT", "thalt", "holt", "hodium", "Ssl", "hALT", "Sodium", "ssalt", "Salt", "tholt", "hunt", "SALT", "Sunt", "sunt", "ssodium", "sALT", "sssl", "hsl", "halt", "Solt"], "hash": ["ash", "search", "sha", "cache", "rh", "sum", "message", "secret", "token", "Hash", "user", "test", "random", "password", "report", "tag", "key", "hex", "build", "name", "flash", "word", "h", "memory", "title", "filename", "mac", "her", "shadow", "version", "crypt", "url", "hed", "log", "sample", "href", "html", "handle"], "digest": ["mdit", " DigEST", "Diger", " diger", " digested", "dighash", "bighash", "Digester", " Digester", "bigests", "Digested", "redit", "decEST", "mdEST", "bigest", "reder", "Digit", "DigEST", "digit", "digested", "decested", "signhash", "redest", "digests", " digEST", "diger", "mder", "signest", " digester", "Digest", "redester", " Digest", "Dighash", "signests", "mdester", "mdest", "decester", "decest", " Diger", "digEST", "Digests", "digester"], "nameChars": ["nameChers", "namechcs", "namechras", "nameCheras", "nameCheats", " nameChears", " nameChecs", "nameChras", "nameCharats", "nameCharars", " nameChrs", "nameChcs", " nameChras", " nameCheras", " nameChARS", "nameChears", "nameChecs", " nameChers", "nameCharrs", " nameCheats", "namechrs", " nameChcs", "nameChARS", "nameCheARS", "nameStrars", "namechars", "nameChrs", "nameChats", "namechats", "namechARS", "nameStrras", " nameChats", " nameCheARS", "nameStrARS", "nameCharcs"], "nameChar": ["NameChar", "ameCh", "nameFix", "ameChar", "caseCharacter", " nameFix", " namechar", "nameCh", "reasonChar", "reasonArc", " nameCharacter", "namechar", "nameArc", "nameschar", "reasonCharacter", " nameCh", "NameCharacter", "charChar", "reasonCh", "ameCharacter", "charFix", "charchar", " nameArc", "Namechar", "caseCh", "namesChar", "nameCharacter", "casechar", "ameArc", "charCh", "namesCh", "namesFix", "caseChar", "NameCh"], "p": ["f", "u", "pe", "v", "par", "perm", "jp", "er", "php", "peer", "bp", "pers", "user", "P", "m", "pm", "pt", "pre", "pp", "pkg", "gp", "vp", "part", "wp", "op", "mp", "pai", "sp", "pc", "per", "cp", "lp", "pa", "pro", "ap", "fp", "pl", "i", "l", "t", "np", "d", "tp", "ps", "pi"], "player": ["winner", "top", "PLAY", "server", "actor", "header", "node", "field", "person", "position", "video", "profile", "er", "peer", "playing", "game", "admin", "user", "owner", "handler", "member", "program", "aster", "wrapper", "steam", "board", "league", "loader", "layer", "part", "vp", "station", "slave", "worker", "Player", "ser", "linger", "ler", "pai", "controller", "address", "played", "name", "master", "lp", "role", "cp", "pro", "party", "taker", "play", "adder", "live", "timer", "slot"], "c": ["u", "co", "cs", "cu", "rc", "cf", "v", "enc", "tc", "sc", "cc", "con", "cfg", "ac", "ic", "C", "toc", "etc", "dc", "ca", "mc", "gc", "cp", "uc", "h", "cr", "r", "config", "g", "conv", "conf", "l", "cd", "ci", "ct", "t", "cm", "cb", "lc", "fc"]}}
{"id1": "15202804", "id2": "6159896", "code1": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"getDigest": ["getDest", " getDigested", "getdigest", "getdigests", "getDester", "getDested", " getdigested", "getDests", "getMDests", " getDigests", "getDigests", "getMDested", "getDigested", " getdigests", "getdigester", "getDigester", "getMDest", " getDigester", " getdigester", "getdigested", "getMDester", " getdigest"], "user": ["host", "actor", "org", "person", "bug", "ome", "usr", "admin", "back", "string", "order", "owner", "device", "USER", "form", "me", "from", "author", "by", "http", "post", "use", "login", "force", "change", "ud", "name", "word", "role", "system", "client", "usa", "username", "account", "manager", "ip", "human", "User", "job", "project"], "realm": ["tenm", "Realmid", "chemn", "realmi", "Realms", "chem", "tenme", "alms", "tenmi", "realme", "Realm", "cheme", "Realme", "tenms", "calmid", "Realmi", "alme", "chemid", "alm", "calm", "Realmn", "realms", "calme", "almi", "realmid", "realmn", "calmn"], "password": ["encrypted", "words", "Password", "port", "confirmed", "data", "sword", "message", "description", "php", "device", "form", "phrase", "database", "post", "paste", "session", "power", "wp", "remember", "PASS", "hash", "word", "property", "username", "pass", "wd", "policy", "reset", "create", "crypt", "productive", "wordpress", "hello"], "method": ["go", "gem", "mode", "class", "message", "select", "where", "format", "service", "api", "process", "path", "form", "Method", "man", "subject", "mod", "view", "eth", "resource", "http", "spec", "function", "force", "op", "hash", "hod", "get", "property", "version", "type", "url", "METHOD", "time", "prop", "util", "command", "module", "verb", "action"], "uri": ["host", "ouri", "ri", "https", "du", "doi", "location", "archive", "web", "path", "database", "URI", "subject", "via", "term", "resource", "http", "direction", "range", "ur", " URI", "query", "connection", "course", "address", "phi", "iri", "unit", "ui", "username", "i", "url", "util", "pi"], "nonce": [" noncer", "Nonces", "nonces", "bonces", "noncer", "vinCE", "vince", "nonCE", "Nonced", "Noncer", "Nonce", " nonced", "nonced", "vincer", "donCE", "bonce", "noncause", "Noncause", "bonced", "NonCE", " nonces", "boncer", "donce", "doncer", "vincause", "doncause"], "digest1": ["digaceone", "Digester0", "Digest1", "digaceOne", "digaceEx", "digistOne", "digist0", "DigesterOne", "digestedone", "DigESTone", "Digester2", "DigestOne", "DigESTEx", "digestedOne", "digester2", "DigEST1", "digESTone", "digist1", "Digest0", "digace1", "digested0", "Digestone", "digested2", "digESTEx", "digESTOne", "digested1", "digester0", "digEST1", "digestedEx", "Digester1", "digestone", "digestEx", "digest0", "digist2", "DigestEx", "Digest2", "digesterOne", "digester1", "DigESTOne"], "digest2": ["Digest1", "diggest3", "digestedTwo", "DigestTwo", "digesttwo", "Digesttwo", "DiggestTwo", "digistTwo", "digesterTwo", "digester2", " digester1", "digist1", "Diggest2", " digesterTwo", "diggest2", "digested2", "digested1", "diggesttwo", "digestertwo", " digester3", "digestedtwo", "digist3", "Diggesttwo", "digist2", " digester2", "Digest2", "diggest1", "diggestTwo", "Diggest1", "digester1", "digester3"], "digestOne": ["Digest1", "digerSingle", "digistOne", "digse1", "digistSingle", "digerOnce", "digestedOnce", "DigesterOne", "digseOnce", "digestSingle", "digestedone", "digesterOnce", "DigestSingle", "DigestOne", "digestedOne", "digerOne", "digist1", "DigestOnce", "Digesterone", "digestOnce", "digseOne", "Digestone", "diger1", "digistOnce", "digested1", "digseSingle", "DigesterSingle", "digesterone", "digistone", "Digester1", "digesterSingle", "digestone", "digestedSingle", "DigesterOnce", "digesterOne", "digester1"], "hexDigestOne": ["hexdigest1", "hexDigestName", "hexDigseInit", "hexDigist1", "hexdigseOne", "hexDigestedOne", "hexDigesterName", "hexdigestOnce", "hexdigestTwo", "hexdigseInit", "hexdigist1", "hexDigest1", "hexDigestOnce", "hexDigester1", "hexdigistTwo", "hexdigistName", "hexDigesterTwo", "hexDigested1", "hexDigistOne", "hexDigseOne", "hexDigseOnce", "hexDigistName", "hexdigseOnce", "hexDigesterOne", "hexDigestInit", "hexdigestOne", "hexDigestedOnce", "hexDigse1", "hexdigestInit", "hexDigestedTwo", "hexDigestedInit", "hexdigse1", "hexDigistInit", "hexDigistOnce", "hexdigistOne", "hexDigestedName", "hexDigistTwo", "hexdigestName"], "digestTwo": ["ddest2", "ddestTwo", "mixesttwo", "digestingtwo", "ddestAnother", "digistThree", "DigestTwo", "digestAnother", "digesterTaylor", "digesttwo", "DigestTaylor", "ddistAnother", "Digesttwo", "digseTw", "digistTwo", "digrateThree", "digrate2", "digistAnother", "digse2", "digistTaylor", "digestingTaylor", "mixestTw", "Digester2", "DigesterTwo", "digesterTwo", "digester2", "Digestertwo", "digrateAnother", "digisticTw", "digseTwo", "digesting2", "ddestThree", "digsetwo", "ddistTwo", "digestTw", "ddistThree", "DigesterTaylor", "mixse2", "digistic2", "diggest2", "digisticTwo", "ddist2", "digestingTwo", "diggesttwo", "digestertwo", "diggestThree", "diggestAnother", "mixest2", "mixsetwo", "digrateTwo", "diggestTw", "mixseTw", "digestTaylor", "mixestTwo", "mixseTwo", "digist2", "Digest2", "digisttwo", "diggestTwo", "digistictwo"], "hexDigestTwo": ["hexdigesterThree", "hexDigestedOne", "hexDigEST2", "hexDigestaTwo", "hexDigESTThree", "hexdigestTwo", "hexDigesterThree", "hexdigestAnd", "hexDigester2", "hexdigesterOne", "hexDigist2", "hexdigesterTwo", "hexDigesterTwo", "hexdigest2", "hexDigestaAnd", "hexDigestaOne", "hexdigesterAnd", "hexDigest2", "hexDigested2", "hexDigESTTwo", "hexDigesterOne", "hexdigestOne", "hexDigestedAnd", "hexDigestedTwo", "hexDigesta2", "hexDigestAnd", "hexDigistThree", "hexdigestThree", "hexDigesterAnd", "hexdigester2", "hexDigistTwo"], "digest3": ["diggestThird", "digetThree", "diggest3", "Digester003", "DigesterThird", "digistThree", "DigestThree", "DigesterThree", "digest003", "Digist3", "diget3", "digESTthree", "digesterThree", "digEST3", "digESTThree", "Digestthree", "digistThird", "diggestthree", "DigestThird", "DigistThree", "digestThird", "DigistThird", "digistthree", "Digistthree", "digestthree", "digESTThird", "digesterThird", "Digest3", "diggestThree", "digester003", "digetThird", "digist3", "diget003", "diggest003", "Digest003", "Digester3", "digester3"], "digestThree": ["diggestThird", "diggest3", "digester5", "digestingThree", "DigesterThird", "digistThree", "ddest3", "DigestThree", "Digest5", "DigesterThree", "DiggestThird", "digse3", "ddgestthree", "digesterthree", "digesterThree", "ddestThird", "digsethree", "ddgestThree", "ddestThree", "Digestthree", "digseThird", "diggestthree", "DigestThird", "digistThird", "digestThird", "diggest5", "digestingThird", "digesting5", "digesting3", "Diggestthree", "digistthree", "ddgest3", "digestthree", "digesterThird", "Digest3", "diggestThree", "ddgestThird", "Digester5", "digest5", "digseThree", "digist3", "Diggest3", "ddestthree", "Digester3", "DiggestThree", "digester3"], "hexDigestThree": ["hexdigestsThird", "hexDigistRight", "hexDigestThird", "hexdigestThird", "hexDigest3", "hexDigestedThird", "hexDigestsThree", "hexDigestingThree", "hexDigist3", "hexdigeststhree", "hexdigests3", "hexDigesterThree", "hexdigist3", "hexDigest4", "hexDigestedThree", "hexdigest4", "hexDigesterthree", "hexdigist4", "hexdigestthree", "hexDigester4", "hexDigestRight", "hexDigestingRight", "hexDigester3", "hexDigestsThird", "hexDigist4", "hexDigested3", "hexdigestsThree", "hexdigestRight", "hexdigest3", "hexDigests3", "hexDigesting4", "hexdigistThree", "hexDigesterRight", "hexDigesterThird", "hexDigistThree", "hexdigestThree", "hexDigestedthree", "hexDigesting3", "hexDigestthree", "hexDigeststhree", "hexdigistRight"]}}
{"id1": "4417943", "id2": "2834524", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 0, "substitutes": {"test": ["server", " benchmark", " sample", "launch", " TEST", "foo", " Test", "Test", "example", "debug", "status", "ping", " check", " tests", "install", "init", "base", "execute", "Example", "testing", "full", " testing", "sample", "evaluate", "hello", "index", "tests"], "query": ["quote", "poll", "search", "field", "question", "pattern", "select", "Query", "string", "form", "sequence", "q", "random", "term", "text", "view", "password", "spec", "Q", "page", "quest", "comment", "prefix", "command", "sql", "body", "menu", "code", "params", "qu", "input", "qa", "condition", "type", "ql", "filter", "qs", "index"], "url": ["u", "sl", "id", "https", "location", "ls", "dl", "pattern", "api", "format", "string", "path", "web", "ref", "print", "q", "str", "xml", "ll", "term", "raw", "http", "ul", "nl", "link", "www", "ur", "sql", "URL", "build", "base", "address", "name", "mount", "pr", "out", "pl", "title", "r", "uri", "Url", "l", "log", "html", "result"], "urlObj": [" urlOb", "nlObj", "Urlobj", "lobj", " urlobj", "httpOb", " urlIt", "httpobj", "nlobj", "httpObj", "urlobj", "urlOb", "nlIt", "UrlObj", "nlOb", "lOb", "urlIt", "lObj", "lIt", "UrlOb"], "con": ["cn", "num", "const", "co", "cf", "fin", "ran", "com", "dial", "connect", "nc", "canon", "sin", "don", "ln", "un", "conn", "in", "c", "pen", "Con", "ver", "win", "obj", "mc", "Conn", "connection", "ain", "fn", "cos", "soc", "pos", "cond", "CON", "open", "cur", "syn", "ctrl", "bc", "conv", "cone", "conf", "len", "cons", "cl", "compl", "fc", "cont", "can"], "model": ["mi", "el", "object", "record", "value", "models", "dl", "data", "message", "fine", "le", "buffer", "cell", "state", "m", "me", "xml", "sim", "man", "set", "tree", "mod", "gp", "table", "map", "response", "re", "frame", "link", "de", "impl", "transform", "body", "base", "controller", "dm", "zip", "vm", "Model", "save", "cm", "job", "module", "sm"]}}
{"id1": "19849797", "id2": "13886238", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", "transferFile", "copyfile", " cpFile", " copyFiles", " cpfile", " cpFiles", "copyFiles", " copyStream", "transferStream", " cpStream", " copyfile", "transferFiles", "transferfile"], "sourceFile": ["sourcePage", " sourceTable", " sourceField", "ourceFile", " sourceLine", " sourcePath", "srcField", "srcLine", "sourcePath", "sourceLine", "srcfile", "ourcePage", "srcTable", " sourcePage", "sourceField", "srcPage", "srcFile", "ourceTable", "srcPath", "sourcefile", "sourceTable", "ourcefile", "ourcePath", "ourceField", " sourcefile", "ourceLine"], "destFile": ["srcDir", "datFiles", "destFilename", "datPlace", "optPath", "restFiles", "DestFilename", "optFilename", "declEntity", "destDir", "optDir", "restFile", "restFilename", "optEntity", "destFolder", "optFolder", "datFile", "restPlace", "destPath", "DestDir", "declDir", "destFiles", "datFilename", "destPlace", "destEntity", "DestFiles", "declFile", " destPlace", "optFile", " destFilename", "DestPath", " destDir", "srcFiles", "srcFile", "srcEntity", "DestFile", "declFolder", " destPath", " destFiles", "srcFolder", "srcPath"], "source": ["image", "update", "scope", "copy", "store", "search", "stream", "shell", "style", "SOURCE", "match", "channel", "scale", "show", "standard", "char", "service", "back", "iterator", "cause", "target", "owner", "origin", "sequence", "ource", "src", "subject", "local", "from", "in", "slave", "resource", "OURCE", "load", "score", "table", "spec", "note", "comment", "attribute", "init", "query", "console", "missing", "ie", "body", "proxy", "parent", "force", "none", "reader", "before", "check", "input", "se", "iter", "inner", "create", "start", "parse", "Source", "sample", "ce", "series", "use", "pose", "component", "index", "send", "result"], "destination": ["destinator", "noninated", "terminined", " destinated", " destinator", "separination", "restinator", "restinated", "noninator", "noninate", " destinate", "descation", "Destination", "terminination", "verinated", "decination", "decined", "verination", "Destinated", "separment", "separinated", "Destinator", "Destment", "destined", " destment", "destinate", "destation", "destificate", "Destation", " destation", "descinate", "decinated", "termininated", "descination", "destment", "nonination", "Destificate", "descinator", "termininate", "restination", "restinate", " destificate", "verificate", "separation", "decinate", "destinated", "veration", " destined", "Destinate"]}}
{"id1": "19307120", "id2": "1508161", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["postPost", " sendText", " sendPOST", "postPOST", "sendText", "doPOST", "doPost", " sendpost", "dopost", "postText", "doText", "sendpost", "postpost", "sendPOST"], "url": ["loc", "host", "u", "sl", "ssl", "https", "location", "ls", "dl", "string", "path", "web", "ref", "addr", "q", "str", "ll", "term", "pp", "ret", "http", "ul", "nl", "link", "ur", "URL", "file", "build", "base", "address", "call", "mail", "mount", "pl", "uri", "Url", "l", "log"], "param": ["cal", "meter", "p", "par", "model", "string", "prom", "Param", "mm", "m", "amp", "term", "block", "commit", "post", "option", "argument", "comment", "dem", "prefix", "tag", "key", "sp", "params", "name", "ram", "rem", "mem", "property", "input", "pass", "proc", "config", "aram", "conf", "start", "row", "prop", "padding", "password", "command", "project"], "result": ["value", "output", "product", "p", "match", "confirmed", "sum", "message", "data", "feature", "description", "Result", "string", "diff", "chain", "complete", "test", "buffer", "valid", "continue", "wrapper", "term", "ret", "request", "answer", "status", "response", "reason", "report", "comment", "query", "res", "code", "current", "true", "found", "memory", "cur", "r", "results", "manager", "default", "success", "command", "date", "temp"], "httpurl": ["httpUrl", "hUrl", " httpURL", "workURL", "httpsUrl", "httpconn", "hconn", "workUrl", "webURL", "workurl", " httpconn", "weburl", "webUrl", "httpsconn", " httpUrl", "httpsURL", "hurl", "workconn", "webconn", "hURL", "httpsurl", "httpURL"], "httpConn": ["hoverConnection", "copConn", "httpCod", "ttpConnection", " httpConnect", "httpObj", " httpCon", "httpconn", "ttpObj", "procCod", "httpCon", "hconn", "httpsConn", "procObj", "hConnect", "ttpconn", " httpConnection", "hConn", "Httpconn", "httpConnect", "httpsCon", "hConnection", "httpsConnect", " httpconn", "HttpConn", " httpCod", " httpObj", "HttpConnect", "httpsConnection", "hoverConn", "httpsconn", "ttpCon", "copCod", "HttpCon", "hoverconn", "hoverConnect", "procConn", "ttpConn", "httpConnection", "procconn", "procConnection", "copCon", "procCon", "copconn"], "out": ["cmd", "output", "OUT", "co", "v", "p", "ex", "screen", "net", "io", "print", "sys", "set", "outs", "it", "by", "writer", "OU", "timeout", "ou", "pretty", "to", "all", "init", "obj", "auto", "aos", "nt", "cos", "ch", "put", "check", "write", "up", "oss", "conv", "inner", "os", "flush", "o", "Out", "w", "outer", "n"], "in": ["mi", "ins", "din", "el", "en", "ri", "IN", "er", "inn", "inf", "cin", "gin", "on", "bin", "from", "it", "ic", "by", "re", "init", "mn", "ma", "al", "per", "reader", "ind", "is", "inc", "rin", "i", "input", "se", "iter", "inner", "oin", "isin", " din", "read", "In"], "line": ["record", "ine", "pe", "header", "field", "liner", "online", "port", "eline", "message", "email", "string", "e", "ln", "ice", "le", "chain", "print", "phrase", "cell", "sequence", "block", "lin", "entry", "continue", "rule", "text", "frame", "stroke", "Line", "inline", "link", "page", "comment", "piece", "file", "lane", "code", "body", "lined", "se", "iter", "l", "row", "ip", "log", "LINE", "point"]}}
{"id1": "7044153", "id2": "19296519", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "        private long getSize(String url) throws ClientProtocolException, IOException {\n            url = normalizeUrl(url);\n            Log.i(LOG_TAG, \"Head \" + url);\n            HttpHead httpGet = new HttpHead(url);\n            HttpResponse response = mHttpClient.execute(httpGet);\n            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n                throw new IOException(\"Unexpected Http status code \" + response.getStatusLine().getStatusCode());\n            }\n            Header[] clHeaders = response.getHeaders(\"Content-Length\");\n            if (clHeaders.length > 0) {\n                Header header = clHeaders[0];\n                return Long.parseLong(header.getValue());\n            }\n            return -1;\n        }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendErrorToClient", "sendExceptionTOHost", "sendExceptionTOServer", "sendErrorToHost", "sendExceptiontoHost", "sendErrortoHost", "sendErrortoClient", "sendExceptionTOClient", "sendErrortoServer", "sendErrorToServer", "sendExceptiontoClient", "sendExceptionToHost", "sendExceptiontoServer", "sendExceptionToClient"], "server": ["host", "store", "value", "v", "port", "serv", "channel", "env", "email", "description", "service", "localhost", "string", "test", "Server", "erver", "ser", "ver", "code", "base", "address", "client", "null", "version", "site", "remote", "password"], "ex": ["el", "ry", "exp", "ix", "com", "exclusive", "aux", "except", "e", "Exception", "EX", "an", "Ex", "any", "test", "err", "example", "ic", "it", "error", "or", "nex", "re", "rex", "x", "obj", "lex", "expl", "hex", "wx", "ox", "ception", "none", "event", "rx", "pex", "exe", "one", "exc", "eas", "fail", "tx", "ext", "xc", "exit", "Exc"], "config": ["context", "param", "rc", "cache", "env", "channel", "figure", "service", "content", "form", "cfg", "Configuration", "debug", "text", "c", "control", "cert", "params", "Config", "settings", "fig", "input", "auth", "conf", "ct", "log", "password"], "prob": [" prbj", "prbe", "Probj", " prbes", "Probes", "probj", "prb", " prb", " prbe", "prbj", "probes", "Prob", "probe", "Probe", "prbes"], "dataSB": [" dataBW", "relationBB", "atasb", "keySB", " dataSI", "keySL", "dataSF", "contentNB", "ataSW", "imageBS", "divSquare", "imageSF", "relSB", " dataSA", "divBS", "ataSN", "valueBB", "joinSF", "resourceSI", "imageBP", "valueBS", "datWB", "dataSw", "imageNB", "nextBS", "dataHB", "dateBu", "cacheBB", "nextSF", "ataBP", "ataMB", "partialSB", "dataSR", "imageSB", "windowBB", " dataNB", "datSL", "defBB", "dataBW", "listsb", "divSF", " dataBP", "cacheSB", "listSI", "listBB", "nextSB", "imageSR", "relationSL", "dataGB", "valueSW", "ataBu", " dataSw", "relationSN", " dataRB", "cacheSF", "imageQB", " dataSN", "imageSN", "relationBS", " dataSL", "datSB", "relationMB", "keyBB", "jsonsb", "dateQB", "DATASB", "ataQB", "jsonSw", "joinMB", "listSF", "partialBB", "divSN", "dataBS", "reasonSW", "mapSL", "partialSL", "ataBB", "mapHB", "reasonSF", "contentSF", "windowSL", "imageBB", " dataHB", "valueSB", "contentSN", "relationBu", "windowBS", "resourceSF", "joinWB", "defGB", "dataEB", "defSB", "mapSB", "dataSquare", "DATABS", "relationSB", "partialGB", "imageSL", "dataSW", "mapBB", "divBW", "dataSN", "dateSB", "ataSA", "keyBS", "nextGB", "relSW", "ataSF", " dataSF", "dataWB", "joinSB", "joinsb", "ataSB", "imagesb", "debugRB", "cacheSA", "cachesb", "contentSR", "nextQB", "ataEB", "windowSB", "jsonSF", "imageSM", "dateBS", "debugBB", "dataSI", "relationSF", "ataSL", "defQB", " dataMB", " dataEB", " dataSW", " dataSM", "dataMB", "datMB", "relBS", "cacheBS", "ataBS", "dataBP", "contentBS", "jsonSB", "DATASW", "joinSL", "dataNB", "relationNB", "relationRB", "cacheSM", "cacheBW", " dataSquare", "dataQB", "listMB", "divNB", "dataBB", " datasb", "mapBS", " dataBB", "ataWB", "resourceSB", "debugSB", "mapSN", "imageHB", "dataSL", "relationQB", "imageSw", "mapGB", "divBB", "ataSR", "ataNB", "listSB", "dataRB", "DATASF", "dataSA", "listEB", " dataQB", "resourcesb", "datasb", "divSB", "reasonBS", "reasonSB", "relBB", "mapSF", " dataBS", "windowSF", "contentSB", "debugSF", "dataBu", "windowSN", " dataGB", "relationSquare", "nextBB", "dataSM"], "trace": ["mt", "store", "th", "stream", "style", "data", "message", "profile", "feature", "detail", "tty", "stable", "te", "list", "thread", "chain", "stack", "buffer", "test", "sequence", "network", "debug", "table", "frame", "tile", "span", "report", "range", "comment", "dump", "transform", "track", "race", "batch", "body", "address", "tr", "be", "role", "true", "ace", "se", "create", "tm", " Trace", "fake", "time", "log", "sample", "temp", "history"]}}
{"id1": "11484416", "id2": "6171406", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"moveFile": ["copyfile", "Movefile", "copyImage", "MoveFile", " movefile", "copyFile", "moveImage", " moveDirectory", "copyDirectory", "movefile", "MoveImage", "MoveDirectory", "moveDirectory", " moveImage"], "orig": ["original", "Original", "copy", "ord", "org", "exp", "rc", "old", "ex", "dest", "origin", "lim", "src", "clip", "imp", "ret", "raw", "or", "inv", "init", "coord", "img", "ori", "dom", "ie", "tmp", "proxy", " original", "Orig", "act", "base", "good", "def", "cur", "create", "created", "iter", "internal", "ip", "existing", "ra", "Origin", "prop", " ORIG", "im", "temp", "was"], "target": ["rel", "top", "copy", "output", "match", "format", "gt", "goal", "dest", "path", "touch", "test", "origin", "sys", "src", "it", "ret", "table", "tile", "replace", "file", "tmp", "build", "parent", "base", "out", "template", "source", "png", "null", "mac", "t", "next", "local", "Target", "arget"], "buffer": ["length", "output", "engine", "header", "stream", "binary", "queue", "cache", "screen", "data", "message", "window", "char", "buf", "chain", "print", "sequence", "stack", "bank", "phrase", "block", "face", "scroll", "button", "limit", "table", "bridge", "bar", "available", "page", "paste", "attribute", "comment", "document", "batch", "base", "line", "display", "memory", "mem", "iter", "variable", "Buffer", "buff", "bytes", "sample", "bb", "filter", "password", "command", "history", "read"], "bread": [" breadth", "rik", "bled", "wei", "level", "give", "billion", "scroll", "READ", "eb", "middle", "corruption", "uckle", "shield", "leen", "log", "bb", " ribs", "knife", "nob", "don", "fine", "web", "print", "crafted", "bad", "bill", "rown", "brew", "brow", "bush", "ig", "neum", "fan", "gear", "wake", "oug", "rain", "bn", "fee", " barely", "rew", "score", "stay", "four", "ble", "robe", "less", "fred", "cake", "blow", "ful", "eric", "bold", " Bread", "jing", "beat", "lf", "bird", "iber", "bel", "inn", "bi", "boat", "bridge", "piece", "spoken", "beck", "bishop", "good", "broken", "bc", "read"], "fis": [" fia", "freis", " fi", "dia", "lis", "liss", "dis", " fris", "fia", "Fis", "fris", " fiss", "bi", "fiss", "ufos", "biss", "Fris", "ufis", "li", "bis", "freia", "bos", "Fos", "ufris", "fi", "di", "ufiss", "Fiss", "los", "frei"], "fos": ["oos", "Foses", "Foos", "eoes", " foos", "oot", "fus", "voos", "Fis", "foses", "foes", "toos", "pus", "tos", "poes", "Fot", "voes", "ooses", "tis", " fot", "foos", "eos", "fot", " fus", "pos", "vus", "Fos", " foses", "Foes", "poos", "eis", "ooes", "vos", "eoos", " foes", "toes"]}}
{"id1": "14567939", "id2": "5951961", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": [" baseKey", " baseSign", "basicSign", "baseSign", "BaseHash", " basehash", "BaseSign", "BaseKey", "basichash", "Basehash", "baseKey", "basicKey", "basicHash", "basehash"], "name": ["initial", "domain", "search", "id", "person", "admin", "order", "user", "term", "Name", "ident", "author", "table", "alias", "NAME", "login", "prefix", "key", "run", "john", "parent", "address", "hash", "word", "current", "family", "ame", "title", "username", "create", "account", "common", "default", "named", "names", "info", "local", "n"], "password": ["value", "Password", "message", "sword", "description", "secret", "token", "user", "restricted", "phrase", "picture", "database", "entry", "login", "command", "attribute", "key", "prefix", "session", "remember", "hash", "word", "username", "pass", "wd", "auth", "reset", "shadow", "crypt", "padding", "hello"], "digest": ["dEST", "displayested", "displayester", "Diger", " diger", " digested", "descest", "Digester", "mdse", " Digester", "Digested", "descested", "digum", "dest", "displayest", "mdgest", "mdested", "mdEST", "decested", "digested", "DigEST", "digend", "descgest", "decgest", "displayum", " digum", "dgest", "descester", "Digend", "diger", "digse", "diggest", " digester", "Digest", " Digend", " Digest", "Digse", " digend", "dested", "Digum", "mdester", "mdest", "Diggest", "decest", "decester", " Diger", "digEST", "digester", "displayEST", "descse"]}}
{"id1": "2017833", "id2": "4168534", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["update", "sha", "sum", "message", "format", "string", "Hash", "print", "test", "str", "sign", " hashing", "replace", "to", "render", "dump", "transform", "tag", "hex", "code", "check", "write", " digest", "parse", " fingerprint", "hello", "read"], "text": ["translation", "value", "output", "v", "pattern", "data", "message", "select", "format", "content", "string", "path", "form", "print", "test", "buffer", "q", "str", "pt", "aut", "comment", "prefix", "document", "code", "nt", "msg", "act", "body", "name", "word", "event", "out", "txt", "TEXT", "title", "input", "source", "config", "url", "ct", "tx", "t", "ext", "log", "password", "command", "now", "Text", "read", "cont"], "UnsupportedEncodingException": ["UnsupportedDecoderException", "UnsupportedEncoderFailure", "UnsupportedDecoderError", "UnsupportedDecoderFailure", "UnsupportedEncensionException", "UnsupportedEncryptionException", "UnsupportedEncensionError", "UnsupportedDecodingError", "UnsupportedDecodingFailure", "UnsupportedEncoderError", "UnsupportedDecodingException", "UnsupportedEncodingError", "UnsupportedEncensionFailure", "UnsupportedEncryptionFailure", "UnsupportedEncryptionError", "UnsupportedEncodingFailure", "UnsupportedEncoderException"], "md": ["pdf", "dr", "cmd", "dd", "mt", "amd", "der", "red", "sha", "mg", "dh", "mk", "sd", "od", "ms", "mm", "m", "pm", "pd", "mod", "and", "add", "dir", "ad", "mc", "mn", " Md", "df", "dm", "mand", "det", "ind", "mb", "h", "grad", "ld", "rm", "di", "cd", "bd", "ct", "hd", "d", "MD", "sm"], "sha1hash": ["sha2key", "sha2dig", "sha1Hash", "sha11h", "ha1sum", "ha1dig", "sha512dig", "sha1hex", "ha3sum", "ha3key", "ha1Hash", "sha5hex", "sha11Hash", "sha3key", "sha5Hash", "haoneHash", "ha1hex", "haonehex", "sha5key", "haonesum", "sha2sum", "sha5hash", "ha1key", "ha2hash", "sha3Hash", "ha2Hash", "ha1h", "sha512h", "sha1dig", "shaonehex", "haonehash", "sha3sum", "sha11hash", "sha2hash", "sha1sum", "ha1hash", "sha5sum", "sha2hex", "shaonehash", "sha2Hash", "ha3hash", "sha1h", "sha512Hash", "sha11dig", "sha512hash", "sha1key", "ha2dig", "ha3Hash", "sha2h", "shaoneHash", "ha2h", "sha3hash", "shaonesum"]}}
{"id1": "11562173", "id2": "10385815", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkContentStream", "checkOutputstream", "assertOutputstream", "checkOutputStream", "checkContentChannel", "checkInputFile", "checkContentstream", "checkAudioFile", "checkAudioStream", "checkInputChannel", "assertOutputStream", "assertOutputFile", "assertInputChannel", "assertOutputChannel", "checkAudiostream", "assertInputFile", "checkInputstream", "checkContentFile", "checkAudioChannel", "assertInputStream", "checkOutputFile", "checkOutputChannel", "assertInputstream"], "in": ["ins", "din", "In", "en", "b", "old", "ex", "IN", "inn", "con", "s", "io", "cin", "gin", "mm", "on", "from", "raw", "it", "c", "st", "or", "file", "mc", "al", "ind", "is", "inc", "up", "get", "input", "source", "doc", "inner", "l", "o", "cont", "n"], "cmp": ["rel", "cn", "same", "different", "cmd", "ck", "pres", "equal", "co", "cs", "cu", "par", "match", "com", "tc", "cc", "dict", "csv", "Comp", "diff", "qual", "ctx", "resp", "pkg", "c", "vp", "cod", "comm", "eq", "cv", "cb", "mc", "mp", "tmp", "msg", "ch", "cp", "cond", "good", "comp", "ctrl", "conv", "cd", "desc", "coll", "omp", "compl", "result"], "all": ["both", "ssl", "bl", "equal", "other", "alpha", "alph", "total", "each", "list", "empty", "test", "any", "valid", "m", "ll", "oll", "and", "kill", "active", "a", "attribute", "always", "All", "al", "only", "none", "call", "full", "also", "l", "null", "app", "default", "first", " ALL", "ALL"], "stream": ["host", "context", "Stream", "dd", "output", "store", "engine", "port", "screen", "channel", "window", "each", "service", "sync", "clean", "ream", "form", "sudo", "stack", "buffer", "sw", "network", "st", "Steam", "view", "collection", "REAM", "sign", "upload", "socket", "shape", "console", "tmp", "our", "parent", "pipe", "event", "zip", "system", "mount", "se", "input", "ST", "row", "ost", "time", "sample", "draw", "local"], "out": ["cn", "ot", "output", "OUT", "b", "exp", "v", "p", "serv", "ex", "data", "external", "list", "ent", "con", "clean", "net", "ne", "io", "sys", "str", "raw", "outs", "pkg", "it", "array", "to", "des", "obj", "res", "aos", "batch", "tmp", "good", "check", "up", "help", "conv", "not", "o", "t", "log", "Out", "at", "outer", "n"], "i": ["cli", "mi", "z", "u", "id", "ri", "v", "ix", "perm", "ini", "I", "ii", "us", "si", "ai", "bi", "chain", "ms", "n", "q", "m", "sim", "me", "iu", "ki", "multi", "ic", "it", "ei", "li", "sym", "ti", "span", "j", "ij", "xi", "ims", "init", "key", "x", "hi", "ji", "batch", "zi", "phi", "y", "ind", "is", "client", "ui", "vi", "gu", "iter", "uri", "di", "gi", "json", "ci", "\u0438", "qi", "point", "info", "index", "pi"]}}
{"id1": "11305840", "id2": "22338097", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"setUpdateCliente": [" setUpdateclientes", " setupdateCliente", " setupdateClientes", " setUpdatecliente", " setUpdatePersones", " setupdateClienta", " setupdateCliento", " setUpdateClienta", " setUpdatePersona", " setUpdatePees", " setUpdatePee", " setupdatecliento", " setUpdatePersono", " setupdatecliente", " setupdateclienta", " setUpdateClientes", " setUpdatePea", " setUpdatePeo", " setupdateclientes", " setUpdateclienta", " setUpdatePersone", " setUpdatecliento", " setUpdateCliento"], "IDcliente": ["IDparente", "idCliente", "IDcelli", "IDclientel", "IDClientee", "IDsClientE", "idClientee", "IDsClienti", "IDcodee", "IDcelle", "idclientE", "IDstai", "IDclientE", "IDcodE", "idclientoe", "IDcodel", "idclientee", "IDactiveel", "IDCliento", "IDsclienti", "IDCliente", "IDcode", "IDscliente", "IDparentee", "idcliente", "IDClientE", "IDparentE", "IDClientel", "IDClientes", "IDactivees", "IDscliento", "IDactivee", "IDClienti", "IDcodes", "idClientes", "IDclientee", "IDstaE", "IDstae", "IDcellE", "IDsCliente", "idClientel", "idclientel", "IDclientes", "IDclientoe", "IDactiveE", "IDstao", "idClientoe", "IDsclientE", "IDclienti", "idClientE", "IDcello", "IDparentoe", "IDcliento", "IDClientoe", "IDsCliento", "idclientes", "IDcodoe"], "nombre": [" nomeren", "nomer", "nometre", "numbr", "nombreb", "nombr", "nometres", " numbreb", "nometren", "nomereb", "nuclere", " nombren", " nombres", "nuclereb", "nombres", "numbreb", " nombreb", " numbren", " nombr", " nomere", "numbren", "nometr", "nomere", "nucleren", " numbre", "nucleres", "nomeres", "nombren", "numbre", "numbres", " numbres", " nomer", " nomeres", "nomeren"], "paterno": ["paterne", "taterna", "tatereno", "pattern", "tattereno", "caterlo", "pATERna", "catterno", "taterno", "catterlo", "tatern", "patterno", "pATERlo", "paterlo", "peterno", "peterlo", "caterna", "patereno", "patern", "pettereno", "petterno", "tatterno", "catterne", "pATEReno", "pattereno", "paterna", "peterna", "catterna", "patterna", "peterne", "pATERno", "pATERne", "patterlo", "petterna", "pATERn", "caterne", "patterne", "caterno", "tatterna", "tattern", "pettern"], "materno": [" matterna", "mATERno", "maternumber", "masernumber", " materNo", "paterNo", "mterNO", "mterna", "materNo", "pATERnumber", "materNO", "pATERna", " materna", "matternumber", "mterno", "matterna", "matterNo", "maserna", "pATERNo", "matterNO", "paterna", "mATERna", " matterno", "maserNo", "mATERnumber", "pATERno", "mATERNo", "matterno", " matterNO", "mterNo", "paternumber", "mATERNO", "maserno", " materNO", "materna", " matterNo"], "ocupacion": ["ocuptaci", "ocuptaton", "icupaton", "ocupanc", "icuptaton", "ocUpacion", "icuptacion", "ocueac", "incuppacion", "ocuparro", "ocuptidad", "icuptaci", "icupacion", "ocUpaton", "ocueacion", "ocupsacion", "incuparro", "icupaci", "ocuppanc", "ocueanc", "ocUpidad", "ocupaci", "ocuptac", "ocupsaton", "ocupsaci", "incuppac", "incupanc", "ocuptarro", "ocuppac", "ocupac", "incupparro", "ocupidad", "incupacion", "ocupaton", "ocupsidad", "ocuearro", "icuptidad", "ocuppacion", "ocuptacion", "ocUpaci", "incupac", "ocuptanc", "ocupparro", "icupidad", "incuppanc"], "rfc": ["trco", "mfl", "rfa", "trfc", "yrtc", "mwic", " rwic", "rfl", " rtc", " rcos", "urwic", " rfa", "rtc", "rcos", " rco", "mcos", "yrfa", "yrco", "urcos", "mfc", "trfa", " rfl", "yrfc", "rco", "trtc", "rwic", "urfc", "urfl"], "stm": ["statm", "Stem", "statM", "STm", "STma", " stmi", "Stmi", "strm", "strmt", "strem", "strmi", "stM", "STM", "statmc", " stem", "sem", "sema", "stmi", "stma", "statma", "stmt", "STmc", "semc", "seM", " stmt", "Stmt", "Stm", "stmc", "stem"], "update": ["initial", "equal", "module", "delete", "complete", "valid", "set", "continue", "it", "commit", "status", "load", "remove", "add", "fill", "replace", "apply", "report", "edit", "layout", "run", "UPDATE", "component", "build", "change", "only", "updated", "ok", "open", "out", "write", "up", "Update", "check", "feed", "append", "create", "submit", "fail", "success", "flush", "accept", "save", "include", "end", "remote", "use", "draw", "local", "send", "result"]}}
{"id1": "5607440", "id2": "19147281", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"updateShoppingBean": ["updateShowshipBein", "updateShowshipBeaning", "updateShoppingBaning", "updateShoppingSpan", "updateShoppingSpaning", "updateShowshipBean", "updateShoppingMein", "updateShoppingMeaning", "updateShoppingMeans", "updateShowshipSpaning", "updateShoppingMean", "updateShowshipSpin", "updateShoppingBan", "updateShoppingSpans", "updateShoppingBans", "updateShowshipSpan", "updateShoppingSpin", "updateShoppingBeaning", "updateShoppingBeans", "updateShoppingBein", "updateShowshipSpans", "updateShowshipBeans", "updateShoppingBin"], "userId": ["USERLog", "userPath", "clientid", "clientName", "UserId", "userName", "USERReference", " userLog", " userPath", " userName", "UserPath", "clientId", "UserReference", "USERId", "UserLog", "clientPath", "UserName", "USERName", "userReference", "Userid", " userReference", "userid", "userLog", " userid"], "connection": ["context", "container", "engine", "license", "output", "office", "server", "computer", "bo", "Connection", "relation", "connect", "communication", "con", "driver", "city", "pointer", "generation", "database", "subject", "network", "conn", "application", "entry", "c", "collection", "resource", "writer", "table", "response", "link", "socket", "creator", "usage", "session", "sql", "query", "document", "function", "library", "directory", "operation", "reference", "settings", "open", "ion", "client", "character", "config", "statement", "close", "manager", "condition", " Connection", "management", "command", "information"], "preparedStatement1": ["preparedStat1", "preparedTransactionOne", "preparedMessage8", "prequalifiedStat2", "prearedStatementOne", "preparedComment4", "preparedQuery1", "preparedQuery8", "preparedTransaction9", "preparedstatement5", "preparedTemplate12", "preprotectedTemplate11", "preparedRequest2", "preparedRequestOne", "preparedQueryONE", "preparedQuery5", "prearedQueryn", "preprotectedStatement11", "preparedStatement5", "preparedStatement6", "preparedStatus12", "prequalifiedStat6", "preparedStatement8", "preparedComment2", "prequalifiedStatement1", "preprotectedStatement1", "preparedStatementn", "preparedTransaction11", "preculatedStatement1", "preparedTransaction2", "preparedstatementOne", "preprotectedStatement9", "prearedQuery2", "preparedQueryOne", "preparedStatement11", "preparedComment8", "preparedTemplate9", "preparedTransaction10", "preparedStatement7", "preparedQuery7", "prearedStatement5", "prearedQuery10", "preparedStat10", "prequalifiedStat1", "prearedStatement4", "preparedComment7", "preculatedStatementOne", "preparedStatn", "preparedQuery4", "preparedMessage7", "preparedStatement10", "prearedQuery5", "preparedStatementOne", "prearedStatementn", "preculatedStatement7", "preparedRequest1", "preculatedComment8", "prequalifiedStatementOne", "prequalifiedStatOne", "preprotectedStatement12", "prearedQueryOne", "preculatedCommentOne", "preculatedStatement8", "preculatedComment7", "preprotectedTemplate12", "preculatedComment1", "prearedStatement2", "preparedTemplate1", "preparedStatus1", "preparedStatus9", "preparedMessage1", "preparedPolicyOne", "preparedCommentOne", "preprotectedTemplate9", "preparedStatement4", "preparedStatONE", "preparedQuery2", "preparedStatement9", "preparedRequest4", "prequalifiedStatement6", "preparedStatus11", "preparedstatement2", "preparedQuery10", "prequalifiedStatement2", "preparedPolicy10", "preparedTemplate11", "prearedQuery4", "preparedPolicyn", "preparedQueryn", "preparedStat2", "preparedstatement4", "preparedStatement12", "preparedstatement1", "preparedTransaction1", "preparedStatementONE", "preparedComment1", "prearedQuery1", "prearedStatement1", "preparedComment5", "preparedTransaction12", "preprotectedTemplate1", "preparedStatOne", "preparedPolicy1", "prearedStatement10", "preparedMessageOne", "preparedStat6"], "preparedStatement2": ["preparedstatement2", "preparedstatementSecond", "preparedSessionTwo", "preparedList2", "preededTransactionSecond", "preededStatementSecond", "preparedListTwo", "preededTransaction4", "prearedStatement2", "preparedListSecond", "preparedSessionSecond", "preparedstatement4", "prearedStatementSecond", "preparedTransaction1", "preededTransaction2", "preparedTransactionSecond", "preededStatementTwo", "preparedStatementSecond", "preparedTransaction4", "preparedSession4", "prearedStatement1", "preparedStatement4", "preededTransactionTwo", "preparedStatementTwo", "preededStatement2", "preparedstatementTwo", "preparedList1", "preparedSession2", "preparedTransactionTwo", "preededStatement4", "prearedStatementTwo", "preparedTransaction2"], "preparedQuery": ["postaredQuery", "preparedStatement", "preferredQL", "prefixedQu", "postparedStatement", "prearedQu", "postparedQL", "preferredQuery", "PrearedSpec", "precedQuery", "premittedQuery", "preferredQu", "premittedStatement", "prearedString", "PrearedQu", "precedQu", "preparedString", "PrearedQ", "preutedQuery", "precedStatement", "prelatedQ", "preparedQL", "postparedQuery", "postaredStatement", "PrearedString", "PreparedStatement", "PreparedSpec", "prefixedQuery", "PrearedQuery", "prearedStatement", "preparedSpec", "prelatedQuery", "prelatedQu", "precedSpec", "preutedStatement", "PreparedQu", "preutedQu", "PreparedQuery", "postaredQL", "preparedQ", "prefixedSpec", "prearedSpec", "premediatedQuery", "premediatedStatement", "preutedString", "prelatedStatement", "prefixedStatement", "premittedQL", "prearedQL", "PrearedStatement", "premediatedQu", "prearedQuery", "preferredStatement", "prearedQ", "PreparedQ", "preferredString", "preparedQu", "PreparedString", "premediatedQ"], "date": ["value", "office", "Date", "when", "today", "dt", "grade", "zone", "dat", "data", "message", "ate", "order", "user", "diff", "month", "state", "duration", "dated", "status", "note", "day", "year", "tag", "render", "query", "document", " day", "late", "draw", "address", "event", "number", "get", "age", "start", "time", "now", "result"], "format": ["f", " Format", "mt", "output", "license", "value", "style", "dt", "scale", "pattern", "data", "api", "service", "string", "process", "form", "handler", "sort", "print", "pre", "atter", "set", "it", "sche", "join", "writer", "add", "spec", "pretty", "apply", "export", "prefix", "render", "transform", "tag", "late", "file", "layout", "function", "at", "fn", "act", "unit", "after", "fix", "call", "write", "append", "template", "get", "cat", "type", "parse", "printf", "Format", "filter", "html", "use"], "orderDate": ["gradeDay", "orderedDay", "OrderNow", "orderDay", " orderYear", "OrderYear", "orderedDate", "orderedYear", "OrderDate", "OrderDeliveryDate", "gradeDate", "OrderDay", "orderedNow", "Orderdate", " orderNow", "orderDeliveryDate", " orderdate", "orderYear", "orderdate", " orderDeliveryDate", "orderNow", "gradedate", "gradeDeliveryDate", " orderDay"], "iterator": ["processor", "udder", "sequ", "operator", "stream", "chest", "values", "liner", "video", "integer", "cache", "upper", "data", "later", "instance", "list", "Iterator", "pointer", "chain", "sequence", "pee", "database", "set", "network", "walker", "wrapper", "ippy", "loader", "collection", "trace", "writer", "size", "runner", "internet", "ter", "ator", "storage", "creator", "dump", "race", "directory", "era", "reader", "river", "starter", "consider", "counter", "older", "vector", "loop", "former", "rounder", "filename", "iter", "inner", "pie", "finder", "versions", "next", "ater", "sample", "info", "history", "information", "outer"], "shoppingInfo": ["shoppingData", "ShoppingInfo", "choppingData", "shoutingData", "shippingInf", "shootingData", "shppingInfo", "sharingInfo", "shillingData", "ShoppingInformation", "shoppingInf", "ShoppingInf", "ShoppingData", "shippingDetails", "sharingInformation", "shillingInfo", "shoutingDetails", "ShoppingDetails", "shootingInf", "shoutingInfo", "ShippingInformation", "shippingInfo", "shillingInf", "shppingINFO", "shoutingInf", "shoppingInformation", "shippingData", "shitchingInf", "ShippingInfo", "shoppingDetails", "chootingData", "chootingInfo", "shppingInf", "chootingInf", "ShippingInf", "ShippingDetails", "shippingINFO", "shillingDetails", "ShippingData", "sharingData", "shppingData", "chootingINFO", "choppingInf", "shippingInformation", "choppingInfo", "choppingINFO", "sharingInf", "shitchingData", "shitchingInfo", "shoppingINFO", "shootingINFO", "shppingInformation", "shootingInfo"], "product": ["image", "translation", "qualified", "top", "object", "processor", "operator", "node", "id", "position", "relation", "service", "process", "order", "device", "print", "program", "application", "article", "collection", "resource", "prototype", "cart", "category", "attribute", "products", "document", "base", "per", "name", "system", "client", "material", "template", "property", "shop", "production", "source", "brand", "common", "Product", "pixel", "division", "media", "contact", "command", "module", "project", "result", "pi"], "quantity": ["pari", "quantularity", "severity", "parify", " quantify", "quality", "percentify", "Quantency", "Quantularity", "materialication", "qualicity", "quantitude", " quantularity", "Quantity", "percentularity", "severitude", "parularity", "percenticity", "qualularity", "severency", " quanti", "quantency", "qualitude", "severication", "Quantication", "severicity", "severularity", "quanti", "materialularity", "percenti", "quantication", "percentitude", "parity", "materiality", "percentity", "quanticity", "quantify", "materialency"], "cartInfo": [" cartInformation", "commerceINFO", "cotData", "chipCheck", " cartNote", "artData", "cartINFO", "armInfo", " cartINFO", "cartInformation", "CartInf", "cotInfo", "artInf", "chipInfo", " cartData", "armInf", "chipNote", "cartCheck", "cartNote", "cotNote", " cartCheck", "cartNotice", "chipData", "commerceData", "armINFO", "commerceInfo", "commerceNotice", "artInformation", "cotCheck", "chantNotice", "CartINFO", "chantData", "armData", " cartNotice", "chantINFO", "CartInfo", "artInfo", "CartInformation", "cartData", "cartInf", " cartInf", "CartData", "chantInfo"], "i": ["cli", "mi", "ami", "u", "v", "p", "ix", "ini", "I", "ii", "s", "ice", "si", "ai", "io", "bi", "m", "me", "iu", "it", "ic", "multi", "li", "ti", "ij", "xi", "ite", "init", "ims", "hi", "ori", "im", "phi", "y", "is", "ui", "fi", "h", "di", "gi", "l", "ci", "ip", "t", "o", "info", "pi"], "productList": ["currentLibrary", "cartLibrary", "productLIST", "cartlist", "processList", " productOrder", " productlist", "productOrder", "cartList", "productlist", "cartOrder", "currentlist", "processOrder", "currentLIST", "cartLIST", "processlist", " productLibrary", "currentList", " productLIST", "productLibrary"], "components": ["commonent", " Compresses", " compositories", "commonents", "producers", "ompresses", "proonents", "condonents", "condresses", "commorts", "supports", " compresses", "omponents", "ompositories", "ompducers", "compositories", "computes", "supponent", "coponent", "condositories", "Compresses", " Compcomponent", "comports", "coputes", "coponents", "Compcomponent", "commutes", "Components", "coports", "supponents", " Compositories", " Components", "supputes", "proresses", "Compositories", "compcomponent", "condducers", " compcomponent", "proositories", "compducers", "compresses"], "j": ["k", "z", " ii", "v", "p", "jj", "jp", "connect", "select", "aj", "n", "q", "m", "Connect", "Database", "js", "ja", "insert", "J", "ij", "Insert", "SELECT", "item", "sql", "jl", "obj", "kj", "query", "ji", "this", "g", "l", "json", "jo", "oj", "jc"]}}
{"id1": "3266833", "id2": "338852", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "label": 0, "substitutes": {"is": ["isa", "isl", "sis", "fs", "lis", "iss", "bits", "bs", "ris", "serv", "ists", "isi", "us", "s", "sys", "any", "iso", "has", "in", "bis", "ois", "init", "as", "IS", "iris", "Is", "isc", "get", "i", "parts", "isf", "os", "ais", "its", "isin", "info", "was", "ios"], "name": ["image", "length", "value", "search", "id", "position", "location", "class", "data", "self", "format", "description", "admin", "string", "path", "order", "sequence", "normal", "term", "in", "Name", "part", "size", "alias", "NAME", "prefix", "key", "handle", "file", "body", "base", "parent", "code", "word", "family", "current", "this", "ame", "template", "number", "title", "source", "filename", "create", "get", "i", "null", "version", "type", "default", "url", "named", "names", "info", "local", "n"], "contentType": ["mediaControl", "ContentType", "ContentTypes", "messageTypes", "fileQuery", " contentLength", " contenttype", "messageQuery", " contentUnit", "mediaUnit", "contentQuery", " contentControl", "mediatype", "messageControl", "messageType", "mediaType", "contentLength", "fileTypes", "fileLength", "contentUnit", "messageUnit", " contentTypes", "messagetype", "contentTypes", "contentControl", "messageLength", "mediaLength", "ContentLength", "mediaTypes", "fileType", "Contenttype", "mediaQuery", "contenttype"], "index": ["image", "max", "length", "update", "num", "access", "value", "id", "position", "dx", "count", "exclusive", "level", "instance", "list", "content", "si", "path", "test", "sequence", "sort", "offset", "fee", "error", "timeout", "size", "Index", "prefix", "key", "x", "batch", "code", "address", "pos", "axis", "ind", "slice", "open", "lock", "depth", "height", "number", "i", "create", "find", "start", "type", "row", "success", "action", "info", "n"], "extension": ["protension", "xtend", "extend", "extention", "extitude", "contension", "protention", "protitude", "xtention", "xtension", "contention", "contitude", "protend", "contend", "xtitude"], "isImage": ["isMedia", "isItemImage", "hasMedia", "areFile", " isFile", "areItemImage", "isaImage", "needsImage", "needsPhoto", "isPhoto", "isoFile", "ISPicture", "needsFile", "hasImage", "isoImage", "isoMedia", "wasimage", "isoItemImage", "ISImage", "hasFile", "isaimage", "wasFile", "isimage", "areImage", "needsMedia", "needsimage", "isFile", "isPicture", " isItemImage", "areMedia", "isaPhoto", "needsPicture", "ISimage", "isaPicture", "hasimage", "wasMedia", "wasImage", "ISPhoto", " isMedia"], "isAux": ["isaux", "isAndaux", "isinPaux", "isAaux", "isAcux", "isNAUX", "isauxe", "isiAuxe", "isAuxe", "isAiox", "isinAUX", "isAult", "isAUX", "isAcx", "isiOAaux", "isOAxx", "isiAux", "isiAaux", "isinPaUX", "isAmp", "isPaUX", "wasAUX", "isiAiox", " isCAUX", " isCAux", "isaiox", "isCAiox", "isNAux", "isAx", " isAx", "isCAUX", "isinPaaux", "isAAult", "isSAaux", "isSAux", "isPaux", "wasAult", "isAAUX", "isNAmp", "isiOAiox", "isOAUX", "wasAAux", "isOAiox", " isAUX", "isPaaux", "isCAaux", "isSAmp", " isCAx", "isiOAux", "isAxx", "isNAaux", "wasAux", "isiOAuxe", "isOAult", "isAAxx", "isAAux", "wasAAxx", "isAndux", "isAndx", "isinAaux", "isaaux", "wasAAult", "isPamp", "isinAux", "isOAux", "wasAAUX", "isOAuxe", " isCAaux", "isAcaux", "isinPamp", "wasAxx", "isCAux", "isCAx", "isAndUX", "isOAaux", "isAcUX", "isinAmp", " isAaux", "isSAUX", "isCAuxe"], "out": ["cn", " OUT", "output", "go", "OUT", "co", "b", "p", "v", "port", "ex", "cache", "we", "sum", " Out", "list", "ent", "boot", "con", "order", "user", "net", "io", "chain", "sys", "in", "conn", "outs", "it", "by", "timeout", "OU", "vol", "to", "all", "gc", "res", "result", "auto", "batch", "tmp", "nt", "aos", "pool", "cos", "pos", "lock", "this", "ion", "up", "oss", "conv", "os", "null", " output", "o", "t", "log", "Out", "at", "w", "outer", "n"], "bufferedImage": ["renderingImages", "bufferredImage", "buffererImages", "buffererVideo", "bufferredImages", "renderedImage", "bufferingImages", "bufferredimage", "buffererimage", "renderingimage", "bufferedimage", "bufferingimage", "bufferingVideo", "bufferedImages", "renderedimage", "bufferingImage", "renderedImages", "bufferedVideo", "renderedVideo", "bufferredVideo", "renderingImage", "buffererImage", "renderingVideo"], "inputStream": ["InputView", "outputStream", "inputView", "outputSteam", "inputSteam", "outputstream", "Inputstream", "currentstream", "outputView", "InputSteam", "currentView", "currentStream", "currentSteam", "inputstream", "InputStream"]}}
{"id1": "20855053", "id2": "20602651", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 1, "substitutes": {"init": [" abort", " deploy", " initiation", " initiate", "launch", " initialization", " construct", " bind", "activate", "Init", " refresh", "register", "construct", "run", " authorize", "execute", " Init", " restart", " initialized", "config", " login", "start", " service", " reset", " dispatch", " prepare", "initialized", "action"], "context": ["ex", "sc", "self", " contexts", "web", "chain", "state", "ctx", "application", "c", "X", "x", "res", "event", "this", "txt", "h", "config", "bc", "exc", "null", "tx", "component", "w", "Context"], "classLoader": [" classParser", "classManager", "urlLoader", "taskLoader", " classReader", "classReader", "taskBuilder", "Classloader", "ClassBuilder", " classElf", " classBuilder", "classElf", "taskElf", " classPath", " classLess", "urlReader", "classLess", "ClassPath", "classPath", "fileManager", "classloader", " classManager", "fileReader", "ClassLess", "taskLess", "ClassManager", "ClassParser", "classBuilder", "urlloader", "classParser", "ClassReader", "ClassElf", "ClassLoader", "fileParser", " classloader", "fileLoader", "urlPath"], "urls": ["urlps", "urlies", "norms", "urlists", "normists", "ls", " urlms", "limxs", "lxs", "longs", "urlgs", "longports", "lls", "lps", "limms", "urlms", "slies", "urps", "urlxs", " urlgs", "slports", "lims", "limlets", "normports", "sls", "slists", "limps", " urllets", "URLgs", "URLs", "urxs", "longists", "normies", "longies", "URLlets", "limls", "urllets", "URLms", "urs", "urlports", "limgs", "urlls"], "url": ["f", "rel", "loc", "el", "sl", "ssl", "org", "b", "location", "ls", "dl", "channel", "char", "email", "bel", "web", "lr", "ref", "path", "user", "str", "ll", "entry", "ret", "resource", "http", "li", "rl", "re", "ul", "nl", "link", "page", "browser", "ur", "req", "URL", "res", "file", "uu", "base", "address", "name", "mount", "mail", "ob", "r", "uri", "Url", "l", "row", "log", "util", "job"], "reader": ["dd", "stream", "er", "peer", "iterator", "driver", "handler", "buffer", " Reader", "parser", "entry", "loader", "layer", "writer", "rl", "resource", "runner", "reading", "ro", "range", "file", "per", "Reader", "rx", "rar", "rr", "older", "ner", "r", "input", "iter", "inner", "rer", "row", "roller", "iper", "rot", "read"], "className": ["moduleName", "logname", "packagename", "cellName", " classNAME", "completeName", "CLASSFull", "cellToken", "partName", " classPath", "classStart", "clNo", "ClassToken", " classname", " classBody", "Classname", " classString", "stringStart", "clRel", "moduleStart", "partNAME", "packageData", " classNot", "classBody", " classStart", " ClassNames", "playString", "classRel", "stringType", "classNAME", " classType", "completePath", " classToken", "stringName", "classPath", "titleNot", "ClassString", "clString", "ClassNot", "titleName", "titleString", "moduleType", "classLine", "packageName", " classData", "classString", "logNAME", "logValue", " classFull", " ClassTitle", "classTitle", "ClassData", "cellRel", "classValue", "ClassRel", "playBody", " ClassName", "cellString", "partValue", "classNo", "partname", " ClassFull", "CLASSName", " classNo", "completeRel", "playName", "classNames", " classNames", "ClassName", "classToken", "classFull", " classValue", "playNo", "classname", "CLASSTitle", " classLine", " classRel", "titleLine", "clBody", "classData", "packagePath", "ClassPath", "moduleString", "clName", "classType", "CLASSNames", "ClassLine", "stringString", " classTitle", "clPath", "classNot", "logName"], "clazz": ["shazz", "glade", "laz", " clade", "class", "classass", "classclass", "claz", "glazz", "classaz", "clclass", "shuster", " cluster", "glaz", "shade", "glass", "lclass", "clace", "classazz", "clade", "glclass", " clace", "lass", "cluster", "gluster", "shace", "glace", "lazz"]}}
{"id1": "1180878", "id2": "3184073", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrlStream", "fetchUrlData", "fectURLdata", "fetchGETdata", "fectURLStream", "fectUrldata", "fetchStringdata", "fetchStringData", "fetchUrlFrame", "fetchURLFrame", "fectUrlData", "fetchStringFrame", "fetchGETStream", "fectUrlFrame", "fetchURLStream", "fetchGETData", "fetchURLdata", "fectURLFrame", "fetchUrldata", "fectUrlStream", "fectURLData", "fetchStringStream", "fetchGETFrame"], "url": ["loc", "host", "rel", "el", "sl", "ssl", "domain", "gl", "b", "https", "location", "ls", "dl", "pattern", "string", "path", "web", "ref", "print", "lim", "ll", "xml", "resource", "http", "ul", "nl", "link", "ur", "sql", "URL", "file", "base", "address", "name", "mount", "mail", "full", "pl", "uri", "Url", "l", "cl", "null", "default", "log", "html"], "proxyHost": ["slavehost", " proxyCheck", "proxyName", "slaveLabel", "slaveHost", "ProxyLabel", "ProxyUrl", "ProxyName", " proxyAddress", "roxyOver", "roxyLabel", "roxyhost", "proxyLabel", "proxyAddress", "slaveAddress", "roxyAddress", "proxyOver", "proxyhost", "serverHost", "slaveUrl", "roxyHost", "proxyUrl", " proxyName", "serverhost", "ProxyPort", "serverPort", "slaveOver", "serverName", "Proxyhost", " proxyhost", "roxyUrl", "proxyCheck", " proxyOver", "roxyCheck", "slaveCheck", "ProxyHost"], "proxyPort": ["aliasport", " proxyport", " proxyAddress", "aliasPort", "proxyAddress", "serverport", "serverHost", "proxyport", "aliasAddress", "ProxyPORT", "aliasHost", "serverPort", "ProxyPort", "Proxyport", " proxyPORT", "serverPORT", "ProxyHost", "proxyPORT", "serverAddress"], "con": ["cn", "cover", "cal", "const", "cmd", "en", "co", "cs", "ran", "fin", "cf", "mo", "ex", "dial", "com", "bo", "connect", "nc", "canon", "rec", "cc", "don", "ln", "un", "cgi", "conn", "func", "c", "pen", "col", "Con", "comm", "gate", "trans", "sub", "ver", "ocon", "connection", "mc", "Conn", "po", "cos", "pc", "ain", "cp", "cond", "act", "non", "CON", "fac", "client", "open", "call", "lock", "cur", "syn", "ctrl", "bc", "conv", "cone", "conf", "cat", "cons", "proc", "close", "pan", "xc", "go", "fc", "cont", "can"], "is": ["isa", "fs", "sis", "isl", "ins", "xs", "lis", "iss", "bits", "are", "ris", "ri", "rs", "dis", "ists", "bs", "cs", "isi", "us", "s", "si", "gets", "ys", "sys", "ms", "iso", "has", "in", "ains", "ps", "bis", "ts", "ois", "ims", "init", "as", "IS", "iris", "eps", "mis", "Is", "isc", "isp", "i", "oss", "iter", "isf", "es", "os", "abs", "ip", "ais", "its", "ist", "isin", "im", "was", "ios"], "u": ["nu", "pu", "uid", "cu", "uf", "yu", "us", "lu", "eu", "user", "un", "uni", "tu", "iu", "au", "c", " nu", "ou", "ul", "hu", "ru", "ur", "U", "fu", "uu", "bu", "uv", "ud", "ui", "up", "ue", "i", "su", "uj", "uri", "g", "mu", "o", "ut"], "proxy": ["host", "translation", "pe", "PRO", "domain", "server", "ssl", "pin", "pi", "port", "https", "cache", "bo", "profile", "jp", "friend", "token", "web", "pointer", "xy", "pre", "py", "embed", "via", "gp", "timeout", "slave", "http", "map", "ping", "alias", "link", "socket", "browser", "phone", "x", "connection", "po", " prox", "base", "pipe", "library", "pool", "cp", "zip", "Proxy", "address", "cas", "client", "pro", "pse", "aco", "policy", "prime", "null", "roxy", "version", "ip", "echo", "shadow", "cone", " proxies", "password", "go", "project", "XY"], "baos": ["vaoS", "aois", "aoos", "baose", "naoss", " baoS", "BAos", " bais", "vaOS", "poo", "poOs", "baoS", "aoOS", "vais", "BAOs", " baOs", " baose", " bao", "baows", "naos", "BAows", "bao", "bais", "naows", " baOS", "nao", "baOS", "baoss", "poos", "poose", " baoss", "baOs", "BAo", " baows", "vaos", "BAoss", "BAose", "aooS"]}}
{"id1": "20247400", "id2": "22264586", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["ins", "din", "isin", "ze", "IN", "inn", "con", "ai", "net", "io", "inf", "gin", "cin", "on", "bin", "from", "it", "init", "file", "ind", "is", "inc", "check", "up", "rin", "i", "input", "source", "inner", "and", "info", " din", "In"], "out": ["ins", "ot", "cmd", "output", "OUT", "b", "other", "ex", "screen", "println", "we", "list", "gt", "con", "ln", "net", "io", "ne", "print", "sys", "str", "err", "outs", "it", "or", "writer", "OU", "ou", "to", "report", "dir", "obj", "auto", "msg", "name", "line", "write", "client", "check", "oss", "r", "os", "null", "t", "log", "o", "exit", "Out", "at", "w", "outer", "n"], "buffer": ["length", "processor", "output", "header", "b", "binary", "position", "match", "cache", "channel", "data", "message", "total", "window", "buf", "queue", "stack", "phrase", "sequence", "database", "block", "view", "limit", "trace", "table", "size", "bridge", "bar", "available", "comment", "attribute", "key", "shape", "document", "function", "batch", "library", "address", "event", "history", "append", "template", "memory", "source", "display", "se", "iter", "clear", "db", "variable", "Buffer", "flush", "buff", "filter", "sample", "pause", "command", "component", "index", "temp", "result"]}}
{"id1": "5543349", "id2": "324679", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"loadMFileViaWeb": ["loadMFileviaweb", "loadMFileviaWe", "loadMFileViaweb", "loadMFileByWe", "loadMFilesViaWeb", "loadMFileByWeb", "loadMFileUsingWeb", "loadMFilesViaweb", "loadMFilesviaweb", "loadMFilesviaWeb", "loadMFileviaWeb", "loadMFilesviaWe", "loadMFileUsingWe", "loadMFileViaWe", "loadMFileByweb", "loadMFileUsingweb", "loadMFilesViaWe"], "codeBase": ["codebase", " codeMark", "codeRoot", "uriBased", "CodeBase", "fileBase", " codeBased", "uriBase", "uribase", "codeMark", "Codebase", "uriMark", "codeBased", "fileRoot", "CodeBased", "fileBased", "CodeRoot", " codeRoot", "filebase", "CodeMark", " codebase"], "directoryAndFile": ["DirectoryAndPath", " directoryAndDirectory", "DirectoryandFile", "DirectoryandPath", "directoryAndModel", "directoryOrfile", "directoryOrType", "DirectoryAndFile", "directoryandType", "directoryButfile", " directoryAndType", "directoryandFile", "directoryandModel", "DirectoryandModel", "directoryButDirectory", "directoryButType", "directoryandPath", "directoryButFile", "directoryAndfile", "directoryAndType", "directoryOrPath", "directoryandDirectory", "directoryAndDirectory", "directoryandfile", " directoryOrFile", "DirectoryAndModel", "DirectoryAndfile", " directoryOrDirectory", "Directoryandfile", "directoryOrModel", " directoryOrfile", " directoryOrType", "directoryAndPath", "directoryOrDirectory", "directoryOrFile", " directoryAndfile"], "mFileName": ["mFolderPart", "mSourceFileSource", "mFilenamename", "mFileBody", "mFileNames", "mFilePart", "MFilePart", " mfileFile", "mSourceFileSize", "mFilenamePart", "mFolderPath", "mFolderName", "mfileSource", "mfileNames", "mFilePath", "mFilenamePath", "mFilenameBody", "MFileBody", "MFilenamename", "mTablePart", "mFileType", "mSourceFilePath", " mfilePath", "MFilenameName", " mfileType", "MFilenameSize", "MFilenamePart", "mFilename", " mfileName", "MFilenameNames", "MFilenameBody", "mFilenameNames", "mTablename", "mFoldername", "mFileSource", "mSourceFileName", " mFileType", "MFileSize", "mTableName", "mTablePath", "mFilenameName", "mfileBody", "MFilenamePath", " mFileFile", " mFilePath", "MFilename", "mfileName", "mfilePath", "mFileFile", "mfileSize", "mFilenameSize", "MFileName", "MFileNames", "mSourceFileNames", "MFilenameSource", "mFilenameType", "mfileType", "mFileSize", "mFilenameFile", "MFileSource", "MFilePath", "mSourceFileBody", "mFilenameSource", "mSourceFileFile", "mSourceFileType", "mfileFile"], "code": ["core", "Code", "node", "scene", "buffer", " coding", "reason", "comment", " to", "expression", " content", "template", "done", "module", "length", "value", "cache", "string", "e", "form", "cod", "to", "body", "coded", "l", "json", "time", "command", "result", "copy", "data", "message", "content", "test", "coe", "ode", "c", "stroke", "x", "query", "source", "input", "create", " data", "t", "component", "func", "action", "output", "script", " Code", "sequence", "program", "cell", "text", "frame", "codes", "hex", "event", "zip", "ce", "html", "hello", "n"], "function": ["f", "callback", "object", "fun", "value", " computation", "job", "class", "Function", "relation", "feature", " Function", "instance", "service", "process", "user", "lambda", "partial", "form", "handler", "program", " functions", "normal", "func", "from", "closure", "resource", "and", "method", " func", "functional", "python", "expression", "document", "file", "connection", " program", "library", " functionality", "fn", "FUN", "event", "family", "role", "false", "full", "production", "foreign", "foundation", " command", "command", "component", "module", "result", "action"], "url": ["loc", "rel", "el", "sl", "ssl", "gl", "b", "p", "location", "dl", "il", "hl", "char", "bel", "web", "io", "str", "ll", "resource", "rl", "http", "li", "re", "nl", "link", "browser", "ur", "URL", "file", "build", "base", "address", "open", "mount", "out", "mail", "get", "r", "Url", "l", "log", "job"], "in": ["f", "ins", "din", "stream", "p", "IN", "sin", "inn", "inf", "cin", "gin", "bin", "from", "it", "ic", "file", "body", "reader", "ind", "is", "inc", "out", "rin", "i", "input", "r", "source", "inner", "l", "null", "isin", "info", " din", "In", "n"], "inReader": ["cinRunner", "innerReader", "cinReader", " inWriter", "fromLoader", "innerRunner", "InStream", " inStream", "fromReader", "cinWriter", "inBuilder", "innerR", "inStream", "innStream", " inLoader", "fromR", " inRunner", "inRead", "innReader", "inLoader", "InRead", "innLine", "fromBuilder", "InReader", " inR", " inRead", " inBuilder", "fromWriter", "cinLoader", "inWriter", "innRead", "inRunner", "innerBuilder", "fromRunner", " inLine", "inLine", "InLine", "inR"], "line": ["column", "entity", "ine", "record", "header", "liner", "port", "online", "eline", "zone", "message", "char", "email", "string", "e", "ln", "le", "print", "sequence", "cell", "section", "block", "lin", "entry", "rule", "ode", "text", "error", "frame", "stroke", "Line", "link", "inline", "page", "stay", "comment", "key", "file", "lane", "lined", "change", "element", "number", "l", "row", "LINE", "sample", "point"], "end": ["length", "id", "class", "data", "begin", "list", "e", "ed", "stop", "block", "End", "load", "export", "run", "open", "close", "END", "reset", "start", "ended", "log", "next", "info"]}}
{"id1": "18374478", "id2": "10158738", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 1, "substitutes": {"updateUser": [" updateByte", " updateMe", "putUser", "updateUse", "uploadMe", " updateCommon", "insertUser", "setUser", " updateAccount", "putCommon", "insertGroup", "geUse", "uploadUser", " updateUsers", "setUse", "uploadUsers", "updateMe", "putuser", "makeUser", " updateuser", " updateUSER", "putUse", "geUser", "updateOne", "geuser", "uploadUse", "updateAccount", "insertUsers", "updateUsers", "setuser", "insertAccount", "updateuser", "putUsers", "putByte", "uploadCommon", "putOne", "UpdateUsers", "uploadUSER", "updateGroup", "makeOne", "putUSER", "makeByte", "UpdateGroup", "UpdateAccount", "gePer", "makeUsers", " updatePer", " updateOne", "updateUSER", "updateCommon", " updateGroup", "uploaduser", "UpdateUser", "updateByte", " updateUse", "updatePer", "putMe", "setPer"], "user": ["update", "host", "u", "object", "record", "uid", "other", "v", "job", "sum", "message", "profile", "char", "data", "instance", "usr", "admin", "content", "token", "owner", "form", "USER", "device", "order", "valid", "me", "rule", "by", "author", "part", "post", "use", "users", "add", "re", "table", "resource", "usage", "ver", "report", "item", "key", "connection", "file", "base", "ud", "per", "name", "word", "this", "used", "client", "usa", "up", "display", "get", "username", "account", "config", "row", "version", "util", "password", "User", "info", "module", "result", "plugin"], "conn": ["ann", "cmd", "org", "port", "enc", "cc", "gen", "err", "pkg", "Con", "link", "socket", "dc", "pg", "obj", "res", "Conn", "wp", "nt", "cp", "oss", "cat", "wd", "log", "info", "wr", "ssl", "co", "com", "dt", "typ", "jp", "addr", "ctx", "pt", "yn", "oc", "gc", "ch", "close", "conv", "conf", "cons", "pas", "cm", "cb", "cn", "bind", "quote", "mt", "exec", "bo", "die", "connect", "nc", "con", "cfg", "apt", "resp", "c", "priv", "mc", "out", "t", "handle", "rel", "lang", "cf", "Connection", "iw", "net", "ns", "pub", "col", "comm", "gate", " con", "req", "connection", "cert", "pool", "act", "open", "client", "cur", "db", "ctr", "wn", "coll", "ct", "ce", "tp", "cont", "n"], "autoCommit": ["autoComit", "autoCollcommit", "autoRemend", "AutoDebit", "AutoDebort", "autoQue", "anoActivmit", "autoCompe", "anoCommort", "autoRemmit", "autoDebcommit", "autoCommcommit", "autoCompmit", " autoCompit", "anoCommlate", "autoCommort", "autoDebit", "autoComort", "autoCommmit", "autoDebort", "autoQuit", "autoCollmit", "autoReme", "AutoDebmit", "autoComcommit", "autoCompend", " autoCompe", "AutoCommmit", "anoCommit", "autoDeblate", "AutoDebcommit", "autoComlate", "anoActivit", " autoCompmit", " autoCommend", "autoCollort", "autoActivort", "AutoCommit", "autoRemit", "autoQuend", "autoActivlate", "autoCollit", "anoActivort", "AutoCommort", "autoCompit", " autoCommmit", " autoCompend", "autoQumit", "autoActivmit", "autoComme", "autoCommlate", " autoComme", "autoDebmit", "anoCommmit", "AutoCommcommit", "autoActivit", "anoActivlate", "autoCommend"], "deleteRoles": ["deleteResroups", "detailRroups", "deleteResles", "deleteTanguages", "deleteGroups", " deleteResols", "deleteRadoids", "detailRoles", "deleteEroles", "deleteGoles", "detailCorroups", "deleteRles", "deleteranguages", "deleteGles", "deleteRadols", "deleteResoids", "deleterroups", "deleteRroups", " deleteResroups", "detailCoroles", "deleterules", " deleteRroups", "deleteCorules", "detailRules", "deleteToles", "deleteRoids", " deleteRles", "detailCorules", "deleteCorroups", " deleteRols", "deleteCoroles", "deleteRanguages", "deleteResoles", "deleteNroups", "deleteNles", "deleteResols", "deleteTules", "deleteCoranguages", "deleteErles", " deleteResoids", "deleteEroids", "deleteRadles", "detailCoranguages", " deleteRoids", "deleteGols", "deleteRules", "deleteTroups", "deleteroles", " deleteResoles", "deleteRols", "deleteNols", "deleteErols", " deleteResles", "detailRanguages", "deleteNoles", "deleteRadoles"], "insertRoles": ["insertRepliders", "insertCodes", "deletePows", "stepReploles", "insertPights", "insertRobrots", "insertRobels", "insertGodes", "insertPows", "InsertRodes", "stepReplroups", "insertReploles", "insertRodes", "insertNodes", "insertResodes", "insertRsles", "insertRles", "insertRiders", "insertLoles", "insertNhips", "insertReships", "insertColes", "stepRodes", "sequenceRrots", "insertRels", "insertNoles", "insertCights", "deletePights", "insertLroups", "insertRhips", "deleteRights", "insertRrots", "InsertRoles", "sequenceRobrots", "sequenceRobels", "insertRsrots", "insertNles", "deletePodes", "stepRepliders", "InsertRhips", "insertResles", "insertReplroups", "InsertRles", "insertRows", "insertGiders", "deleteRodes", "insertRights", "stepReplodes", "insertRobles", "insertPoles", "deletePoles", "insertRroups", "insertPodes", "stepRiders", "deleteRows", "insertGoles", "insertRsels", "sequenceRles", "sequenceRoles", "sequenceRels", "stepRroups", "insertResoles", "insertCows", "insertLiders", "stepRoles", "insertReplodes", "sequenceRobles", "insertLodes", "insertRsoles", "sequenceRoboles", "insertRoboles", "insertGroups"], "role": ["rel", "hole", "pe", "ole", "office", "node", "country", "zone", "rol", "relation", "profile", "char", "feature", "te", "peer", "rice", "le", "cell", "block", "rule", "entry", "part", "resource", "rl", "slave", "hero", "col", "ro", "range", "label", "tag", "oval", "family", "right", "tro", "word", "def", "r", "aco", "Role", "row", "type", "ule", "ce", "password"]}}
{"id1": "3266833", "id2": "823074", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"is": ["isa", "isl", "sis", "fs", "lis", "iss", "bits", "bs", "ris", "serv", "ists", "isi", "us", "s", "sys", "any", "iso", "has", "in", "bis", "ois", "init", "as", "IS", "iris", "Is", "isc", "get", "i", "parts", "isf", "os", "ais", "its", "isin", "info", "was", "ios"], "name": ["image", "length", "value", "search", "id", "position", "location", "class", "data", "self", "format", "description", "admin", "string", "path", "order", "sequence", "normal", "term", "in", "Name", "part", "size", "alias", "NAME", "prefix", "key", "handle", "file", "body", "base", "parent", "code", "word", "family", "current", "this", "ame", "template", "number", "title", "source", "filename", "create", "get", "i", "null", "version", "type", "default", "url", "named", "names", "info", "local", "n"], "contentType": ["mediaControl", "ContentType", "ContentTypes", "messageTypes", "fileQuery", " contentLength", " contenttype", "messageQuery", " contentUnit", "mediaUnit", "contentQuery", " contentControl", "mediatype", "messageControl", "messageType", "mediaType", "contentLength", "fileTypes", "fileLength", "contentUnit", "messageUnit", " contentTypes", "messagetype", "contentTypes", "contentControl", "messageLength", "mediaLength", "ContentLength", "mediaTypes", "fileType", "Contenttype", "mediaQuery", "contenttype"], "index": ["image", "max", "length", "update", "num", "access", "value", "id", "position", "dx", "count", "exclusive", "level", "instance", "list", "content", "si", "path", "test", "sequence", "sort", "offset", "fee", "error", "timeout", "size", "Index", "prefix", "key", "x", "batch", "code", "address", "pos", "axis", "ind", "slice", "open", "lock", "depth", "height", "number", "i", "create", "find", "start", "type", "row", "success", "action", "info", "n"], "extension": ["protension", "xtend", "extend", "extention", "extitude", "contension", "protention", "protitude", "xtention", "xtension", "contention", "contitude", "protend", "contend", "xtitude"], "isImage": ["isMedia", "isItemImage", "hasMedia", "areFile", " isFile", "areItemImage", "isaImage", "needsImage", "needsPhoto", "isPhoto", "isoFile", "ISPicture", "needsFile", "hasImage", "isoImage", "isoMedia", "wasimage", "isoItemImage", "ISImage", "hasFile", "isaimage", "wasFile", "isimage", "areImage", "needsMedia", "needsimage", "isFile", "isPicture", " isItemImage", "areMedia", "isaPhoto", "needsPicture", "ISimage", "isaPicture", "hasimage", "wasMedia", "wasImage", "ISPhoto", " isMedia"], "isAux": ["isaux", "isAndaux", "isinPaux", "isAaux", "isAcux", "isNAUX", "isauxe", "isiAuxe", "isAuxe", "isAiox", "isinAUX", "isAult", "isAUX", "isAcx", "isiOAaux", "isOAxx", "isiAux", "isiAaux", "isinPaUX", "isAmp", "isPaUX", "wasAUX", "isiAiox", " isCAUX", " isCAux", "isaiox", "isCAiox", "isNAux", "isAx", " isAx", "isCAUX", "isinPaaux", "isAAult", "isSAaux", "isSAux", "isPaux", "wasAult", "isAAUX", "isNAmp", "isiOAiox", "isOAUX", "wasAAux", "isOAiox", " isAUX", "isPaaux", "isCAaux", "isSAmp", " isCAx", "isiOAux", "isAxx", "isNAaux", "wasAux", "isiOAuxe", "isOAult", "isAAxx", "isAAux", "wasAAxx", "isAndux", "isAndx", "isinAaux", "isaaux", "wasAAult", "isPamp", "isinAux", "isOAux", "wasAAUX", "isOAuxe", " isCAaux", "isAcaux", "isinPamp", "wasAxx", "isCAux", "isCAx", "isAndUX", "isOAaux", "isAcUX", "isinAmp", " isAaux", "isSAUX", "isCAuxe"], "out": ["cn", " OUT", "output", "go", "OUT", "co", "b", "p", "v", "port", "ex", "cache", "we", "sum", " Out", "list", "ent", "boot", "con", "order", "user", "net", "io", "chain", "sys", "in", "conn", "outs", "it", "by", "timeout", "OU", "vol", "to", "all", "gc", "res", "result", "auto", "batch", "tmp", "nt", "aos", "pool", "cos", "pos", "lock", "this", "ion", "up", "oss", "conv", "os", "null", " output", "o", "t", "log", "Out", "at", "w", "outer", "n"], "bufferedImage": ["renderingImages", "bufferredImage", "buffererImages", "buffererVideo", "bufferredImages", "renderedImage", "bufferingImages", "bufferredimage", "buffererimage", "renderingimage", "bufferedimage", "bufferingimage", "bufferingVideo", "bufferedImages", "renderedimage", "bufferingImage", "renderedImages", "bufferedVideo", "renderedVideo", "bufferredVideo", "renderingImage", "buffererImage", "renderingVideo"], "inputStream": ["InputView", "outputStream", "inputView", "outputSteam", "inputSteam", "outputstream", "Inputstream", "currentstream", "outputView", "InputSteam", "currentView", "currentStream", "currentSteam", "inputstream", "InputStream"]}}
{"id1": "19868933", "id2": "4272289", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public static int[] sortstring(int[] a1) {\n        int temp;\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        return a1;\n    }\n", "label": 0, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingMFile", "copyFromFileToFileUsingNIF", "copyFromFileToFileusingNIE", "copyFromFileToFileUsingNHIO", "copyFromFileToFileUsingMIO", "copyFromFileToFileUsingRIE", "copyFromFileToFileusingNIO", "copyFromFileToFileUsingMIF", "copyFromFileToFileUsingNHFile", "copyFromFileToFileusingRIE", "copyFromFileToFileUsingNHIE", "copyFromFileToFileusingRIO", "copyFromFileToFileUsingMIE", "copyFromFileToFileUsingNHIF", "copyFromFileToFileUsingRIF", "copyFromFileToFileusingRFile", "copyFromFileToFileusingNIF", "copyFromFileToFileUsingNIE", "copyFromFileToFileUsingRIO", "copyFromFileToFileusingNFile", "copyFromFileToFileUsingNFile", "copyFromFileToFileusingRIF", "copyFromFileToFileUsingRFile"], "inputFile": ["outputStream", "openfile", "openLe", "outputByte", "inputPath", "inputfile", "outputPage", " inputPage", "importStream", " inputPath", "loadFile", "loadfile", "inputStream", " inputfile", "importByte", "inputPage", "importFile", "inputLe", "inputByte", " inputStream", " inputLe", "loadLe", "loadPath", "importPage", "openPath", "openFile", " inputByte"], "outputFile": ["outputFiles", "outputStream", " outputFiles", "outputDirectory", " outputDir", "putDir", " outputfile", "inputfile", "resultFiles", "outputDir", "resultStream", "putFile", "toPlace", "outputPlace", "toFile", " outputPlace", "inputDirectory", "toStream", "putDirectory", "resultPlace", "outputfile", " outputDirectory", "inputDir", " outputStream", "putfile", "toFiles", "resultFile"], "inputChannel": [" inputChuck", "httpChannel", " inputBuffer", "outputStream", "rawFile", "rawChan", "inputChan", "importChannel", "InputBuffer", "rawConnection", "internalScope", "internalChannel", "openChannel", "internalListener", " inputManager", "outputChan", "importManager", "openConnection", "outputchannel", "inputChuck", "openChan", " inputchannel", "httpChan", "internalBlock", " inputConnection", "httpFile", "inputBuffer", "tableChannel", "tableBlock", "inputScope", " inputScope", "inputStream", "importCategory", "inputManager", "InputChannel", " inputBlock", "outputBuffer", " inputStream", "inputCategory", "InputStream", "loadChannel", "inputBlock", "loadCategory", "loadChuck", " inputCategory", "rawChannel", "httpConnection", " inputListener", "tableListener", "inputConnection", "importChuck", "loadManager", "tableScope", "inputchannel", "outputConnection", " inputChan", "inputListener", "openchannel", "InputConnection"], "outputChannel": ["putButton", "outputClient", "outputStream", "consoleCow", "languageClient", "consoleFile", "outputCategory", "outputChan", "consoleStream", " outputCamera", "consoleChannel", "OutputFile", "outputchannel", "OutputChannel", "outputCow", "removeChannel", "OutputChan", "publicCow", " outputCategory", " outputButton", "OutputStream", "languageChannel", "putChan", " outputchannel", "outputCamera", "hiddenButton", "removeCow", "consolechannel", "putCamera", " outputClient", "hiddenChan", "displayCategory", "hiddenChannel", "hiddenCamera", "displaychannel", " outputChan", " outputStream", "publicchannel", "publicChannel", "languageCategory", "displayClient", "consoleChan", "displayChannel", "putChannel", "outputButton", "removechannel", "languagechannel"]}}
{"id1": "5951610", "id2": "16215393", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testNetHTML", "testNetworkURL", "TestNetHTTP", "TestNetworkHTTP", "TestNetHTML", "testApplicationHTML", "testNetworkHTML", "TestNetworkURL", "testApplicationURL", "testNetURL", "TestNetURL", "testNetHTTP", "testApplicationHTTP", "TestNetworkHTML"], "url": ["loc", "rel", "host", "el", "u", "sl", "ssl", "bl", "gl", "org", "b", "https", "location", "ls", "norm", "dl", "channel", "il", "hl", "email", "back", "pull", "github", "path", "web", "ref", "ml", "lr", "print", "blog", "m", "acl", "ll", "str", "term", "conn", "ret", "resource", "rl", "http", "ul", "nl", "link", "www", "all", "ur", "impl", "URL", "obj", "console", "cert", "base", "address", "mount", "mail", "lt", "pl", "get", "r", "lb", "uri", "Url", "l", "cl", "fl", "t", "log", "util", "html", "ocl"], "urlConnection": ["urlCon", "dbConn", "methodConnector", "urlPosition", "utilConnect", "emailConnection", "consoleConnection", "methodConn", "urlService", "lsConnection", "mlCon", " urlDiscussion", " urlService", "resourceConnection", "emailConnector", " urlHandler", "urlSet", "urlDiscussion", "fileConnection", "httpHandler", "emailConnect", "managerInfo", "utilConnection", "sslConnection", " urlResponse", "consoleConn", "httpConnector", "urlResponse", "sslPosition", "consoleMachine", " urlConnect", " urlListener", "urlMachine", "resourceConnector", "dbPosition", "emailConn", " urlSet", "httpListener", "nameConnector", "httpSet", "methodConnection", "managerConnect", "dbConnect", "dbConnection", "railHandler", "lrConnection", "nameConnect", "httpService", "lrResponse", "managerConnector", " urlConn", "lsConnector", "utilService", "sslDiscussion", "utilConnector", "urlConnect", "httpConnection", "mlConnection", "fileDiscussion", "urlConn", "implConnect", "lsConnect", "consoleCon", "urlConnector", "httpConn", "mlConn", "browserConn", " urlInfo", "methodConnect", "urlListener", " urlCon", "fileConn", "managerConnection", "railConnect", "urlHandler", "railListener", "fileConnect", " urlConnector", "lrConnector", "railConnection", "browserConnector", "implConnection", "lrConn", "sslConnect", "sslConn", "nameConnection", "utilSet", "httpConnect", "urlInfo", "resourceConn", "resourceResponse", "utilListener", " urlPosition", "sslConnector", " urlMachine", "browserConnection", "implConnector", "httpInfo", "lsConn", "nameConn", "browserConnect", "utilConn", "implConn", "mlMachine"], "rd": ["hr", "din", "dr", "rt", "dd", "mr", "std", "ord", "ck", "ri", "rc", "rs", "red", "nd", "dra", "rh", "rg", "RD", "adr", "usr", "rand", "ded", "repl", "lr", "drm", "rid", "art", "rob", "rend", "rez", "rl", "rn", "rown", "rax", "fr", "dir", "rw", "ptr", "rr", "ered", "ind", "rx", "dig", "r", "ld", "grad", "rm", "ined", "rer", "ird", "rb", "rod", "erd", "ra", "bd", "nder", "fd", "ped", "rus", "d", "gd", "wr", "xd"], "line": ["length", "column", "record", "ine", "node", "liner", "port", "online", "channel", "eline", "zone", "message", "where", "email", "string", "ice", "ln", "lo", "le", "side", "buffer", "cell", "block", "lin", "entry", "continue", "set", "error", "part", "status", "load", "frame", "nl", "Line", "inline", "link", "page", "LIN", "comment", "stay", "range", "file", "pipe", "none", "lock", "check", "loop", "number", " LINE", "len", "iter", "l", "cl", "row", "lines", "time", "next", "log", "LINE", "edge", "point"]}}
{"id1": "22057083", "id2": "13233761", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"Connect": ["Log", "Open", "New", "Connection", "connect", "Construct", "Error", "Bind", "Close", "Init", "Interface", " Close", "Sync", "Dial", "Start", "Setup", "Conn", " Init", "Auth", "Create", "Connector", " Open", "Login", "Ping", " Connection", "Client", " Dial", "Check"], "client": ["cli", "core", "cmd", "product", "node", "port", "buffer", "http", "control", "phone", "obj", "controller", "cp", "reader", "null", "row", "url", "log", "util", "local", "lib", "module", "pb", "context", "ssl", "server", "store", "co", "cache", "pattern", "form", "chain", "entry", "conn", "wrapper", "table", "to", "browser", "key", "batch", "ch", "name", "call", "mail", "close", "version", "type", "remote", "command", "patch", "channel", "bo", "connect", "api", "service", "con", "user", "c", "resource", "response", "builder", "pc", "create", "config", "one", "cl", "component", "handle", "window", "list", "google", "secure", "net", "handler", "cgi", "cell", "man", "collection", "writer", "session", "connection", "force", "proxy", "open", "manager", "Client", "plugin"], "reply": ["translation", "mi", "flag", "rc", "shell", "match", "message", "repl", "user", "notice", "print", "vote", "state", "nb", "py", "bill", "entry", "resp", "ret", "error", "answer", "status", "response", "link", "comment", "ply", "prefix", "report", "query", "code", "address", "no", "line", "Reply", "write", "close", "type", "echo", "success", "next", "command", "job", "result"]}}
{"id1": "18339787", "id2": "10176678", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"reload": ["Reload", "Replay", "rebuild", "overload", "disbuild", "disload", "ReLoad", "disLoad", "Rebuild", "overbuild", "replay", "overLoad", "reLoad", "overplay", "display"], "currentDate": ["reportedTime", "reportedYear", "currentTime", " currentDoc", " currentTime", "currentYear", " CurrentTime", "CurrentYear", " CurrentData", " currentYear", " CurrentDoc", "reportedData", "reportedDoc", "currentData", "CurrentDate", "currentDoc", "CurrentTime", "reportedDate", " CurrentDate", " currentData"], "xpath": ["dxPath", "expr", "xgraph", "expath", "xwhere", "exPath", "ixpointer", "axpath", " xprop", "axwhere", "xxath", "dxwhere", "rxpr", "dxpath", "wwhere", "xpt", "ixpath", "axgraph", " xwhere", "xprop", "ixath", "xxpointer", "txpath", "expointer", " xpt", "ixpt", "axPath", "xxpt", "wprop", "txPath", "dxprop", "xxwhere", " xPath", "rxPath", " xpr", "rxpointer", "txgraph", "wpath", "xxpath", "xtrace", " xtrace", "rxpath", " xgraph", "xpr", " xath", "xath", " xpointer", "axtrace", "xpointer", "wPath", "axpointer", "xxtrace", "xPath", "txpointer"], "docBuilderFactory": ["docBuilderFact", " docBuilderFact", " docBuilderFactor", " docBuilderClass", "docPathFactory", "docMakerFact", "docBuildInterface", "docMakerFactory", " docBuilderInterface", "docMakerInterface", "docPathFact", "docPathFactor", "docBuildClass", "docBuilderFactor", "docBuildFact", "docPathClass", "docBuildFactor", "docBuilderClass", "docMakerFactor", "docBuilderInterface", "docBuildFactory"], "docBuilder": ["DocBuild", "DocBu", "DocumentBu", " DOCBu", " docBuild", " DOCBuild", "documentbuilder", "DocBuilder", " docParser", "docbuilder", "DocumentParser", "DocumentBuild", " docbuilder", " docBu", "documentBuild", "documentBu", "docBu", "documentBuilder", "DocumentBuilder", " DOCBuilder", " DOCParser", "Docbuilder", "docParser", "docBuild"], "conn": ["loc", "cn", "ann", "cmd", "ssl", "lang", "ls", "Connection", "connect", "nc", "jp", "iw", "enc", "ws", "con", "opens", "addr", "ctx", "resp", "c", "comm", "link", "socket", "gate", "handle", "connection", "obj", "Conn", "res", "cert", "nt", "ch", "cp", "open", "client", "out", "oss", "syn", "close", "conv", "db", "ct", "cm", "cb", "n"], "url": ["f", "rel", "u", "sl", "ssl", "gl", "b", "https", "ls", "dl", "window", "char", "bel", "con", "web", "net", "ref", "str", "ll", "http", "rl", "ul", "nl", "link", "socket", "browser", "ur", "sql", "URL", "obj", "sb", "connection", "cert", "base", "cp", "mb", "open", "client", "mount", "lb", "r", "Url", "l", "abs", "util", "n"], "xml": ["image", "context", "wt", "pdf", "el", "output", "node", "p", "model", "dl", "data", "format", "php", "email", "list", "content", "path", "ml", "print", "str", "tree", "tml", "raw", "text", "http", "news", "response", "xp", "px", "page", "item", "x", "document", "xf", "file", "dom", "eps", "cert", "body", "event", "zip", "element", "mail", "txt", "full", "doc", "template", "input", "details", "config", "feed", "tm", "json", "rss", "parse", "log", "html", "ws", "date"], "exchangeRateDate": ["exactionRateDays", "excelrateMessage", "exchangeRangeDay", "exchangeCountTime", "exchangeCountDay", "exchangerateTime", "excelRateMessage", "exchangeCountDate", "exchangeRuleTime", "exchangeCountMessage", "exactionRateTime", "exchangeRangeDate", "exchangeRuleDate", "exchangerateDay", "excelrateTime", "exchangeRateDay", "exactionRateDay", "exactionRateDate", "exchangeTimeDay", "exactionrateDay", "exactionrateDate", "exchangeRangeTime", "exchangerateMessage", "excelrateDay", "exactionrateDays", "excelRateDay", "exchangeTimeDate", "exactionrateTime", "exchangeRuleDay", "exchangerateDays", "exchangeRateDays", "exchangeRateMessage", "excelRateTime", "exchangeRateTime", "exchangeRuleMessage", "exchangeRangeDays", "excelRateDate", "excelrateDate", "exchangerateDate", "exchangeTimeDays", "exchangeTimeTime"], "currenciesNode": ["curreditsN", "curriersCard", "CurrenciesN", "curthsN", "currenciesChan", "curriersN", " curriesCard", "CurriesNode", "curriesN", "curthsNode", "CurrenciesCard", "cururrenciesChan", "currenciesEvent", "currsNode", " currenciesChan", "currsList", "currenciesList", "currenciesCard", "CurrenciesList", "currencyChan", "cururrenciesNode", "currsEvent", "cururrenciesCard", "CurrenciesEvent", "CurrenciesNode", " curriesNode", "CurriesList", "CurriesEvent", "curriesEvent", "curreditsNode", " curriesChan", " currenciesCard", "CurriesN", "curriesCard", "curriersList", "curreditsList", "curriersNode", "curriesChan", "curthsCard", "curreditsEvent", "CurriesCard", "curthsList", "curriesNode", "curriesList", "currsN", "currencyCard", "currencyNode", "currenciesN"], "currencies": [" curries", "cururrencies", "constries", "correncies", "constrencies", "charurrencies", "charrates", "corables", "Curarters", "carries", "curractions", "carrencies", "crates", "corarters", "Cururrencies", "chpora", "cables", "currates", "curarters", "corrates", " curarters", "chractions", "Currencies", "curries", "carpora", "carractions", "crencies", "charrencies", "curpora", "corurrencies", "chries", "chrencies", "Curries", "constractions", "constpora", " cururrencies", "corries", "charables", "curables"], "i": ["cli", "mi", "ami", "u", "iq", "id", "ri", "ix", "ini", "I", "ii", "si", "e", "ai", "io", "bi", "sequence", "n", "ms", "m", "sim", "me", "yi", "ki", "in", "multi", "c", "it", "ic", "status", "li", "ti", "a", "j", "span", "xi", "init", "key", "x", "ji", "batch", "ie", "phi", "y", "is", "ui", "gu", "uri", "di", "oi", "gi", "ci", "ip", "\u0438", "o", "qi", "index", "pi"]}}
{"id1": "822452", "id2": "3756429", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndRewWrite", "readAndResend", "readAndRepWrite", "readAndrewrites", "readAndrewrite", "readAndRewend", "readAndRepend", "readAndResWrite", "readAndResrites", "readAndRewrites", "readAndReprites", "readAndrewend", "readAndrewWrite", "readAndReprite"], "inFile": ["initFile", " infile", "inputPlace", "inFILE", "inPlace", "inFace", "iTime", "docFilename", "iFilename", "INFILE", "INFilename", "iFILE", "INFace", "inputFace", "inTime", "initFace", "INFile", "outfile", "initFilename", "INPlace", "INTime", "infile", "docFILE", "InFilename", "docTime", "outFilename", "inFilename", "initPlace", "inputFilename", " inFilename", "InFile", "docFile", "Infile", "iFile", "inputFile"], "outFile": ["reportFILE", " outFilename", "inFILE", "reportfile", "reportFile", " outfile", "checkfile", "checkFilename", "namefile", "toFILE", "nameFilename", "checkFILE", "toFilename", "outfile", "toFile", "reportFilename", "infile", "nameFILE", "outFILE", " outFILE", "checkFile", "outFilename", "nameFile", "inFilename", "tofile"], "iis": ["Iis", " iiss", "liisc", " iris", " ii", "iiris", "iiisc", "Iiss", "iIs", "eIs", "Ii", "diis", "ii", "iiis", "iiss", " iisc", "liIs", "aiis", "iisc", "liris", "liis", "eIS", "diiss", " iIS", "iris", "aiIs", "dii", "diIs", "iiIs", " iIs", "eis", "aiIS", "iIS", "IIs"], "dcmParser": ["dgrPar", "dcmAdapter", "dfmReader", "deromReader", "dpmPrivate", "dromReader", "dmoduleAssistant", "drumPar", "dgrStatement", "dcrBuilder", "DpmPar", " dcmPar", "dpmParser", "dcfReader", "dpmLoader", "DcmAdapter", "dromAssistant", "dpmBuilder", " dpmListener", "drumParser", "dpmarser", "dmmmParser", "dmParser", "dpmPar", "dromListener", "dmmparser", "dpcAssistant", "dcrReader", "dromparser", "dcomLoader", "DpmAdapter", "dpmListener", " dcmListener", "dpmStatement", " dcmparser", "dpcReader", "dcmPar", " dpmparser", "dromParser", "decmParser", "dfmBuilder", "deromparser", "dcommParser", "dcfStatement", "dcrParser", "dpcPrivate", " dpmReader", "dcfParser", "deromParser", " dcmPrivate", "dmparser", "dmReader", "dcmReader", "dmodulePrivate", "dpmAdapter", "dmmmAdapter", "dcommListener", "dcfPar", "dcmListener", "dmarser", "dcmPrivate", "dcommAssistant", " dpmPrivate", "dmmAdapter", "dmmmReader", "DpmReader", "dmmReader", "dcmLoader", " dpmBuilder", " dcmAssistant", "dcmStatement", "dfmParser", " dpmParser", "decmReader", "dcomParser", "dmmarser", "dcmAssistant", " dcmReader", "decmarser", "DcmParser", "dfmLoader", "dmmmparser", "DpmParser", " dpmAssistant", "DpmBuilder", "DcmPar", " dcmarser", "DcmBuilder", "dcmarser", "deromarser", " dpmLoader", " dpmPar", " dcmBuilder", " dcmLoader", "dmoduleParser", " dpmStatement", "dmoduleReader", "dpcParser", "DcmReader", "dcomReader", "dromarser", "dpmReader", " dpmarser", "Dpmparser", " dcmStatement", "dpmparser", "drumBuilder", "dcmBuilder", "dmmParser", "dpmAssistant", "dgrParser", "dcrparser", "dcmparser", "decmparser", "dcommReader", "dgrReader", "dcomBuilder", "Dcmparser", "drumReader"], "ds": ["fs", "ins", "dd", "xs", "cs", "rs", "dds", " des", "dx", "ls", "dt", "der", "dl", "bs", "sets", "data", "qs", "dat", "dh", "sd", "s", "pers", "drivers", "ys", "sys", "ns", "obs", "ss", "in", "pd", "outs", "js", "gs", "da", "dos", "DS", "sv", "ads", "ims", "des", "as", " DS", "df", "eps", "vs", "tes", "eds", "aos", "services", "uds", "details", "dq", "db", "os", "es", "ils", "Ds", "bd", "hs", "ks", "its", "ods", "hd", "ws", "d", "gd", "ps"], "pdReader": ["xdHelper", "vdWriter", "ddHelper", "pdParser", "pdRead", "pedReader", "pedLoader", "dpLoader", "xdReader", "vdReader", "pdHelper", "ddParser", "hdRead", "vdHelper", "xdWriter", "pdRunner", "tdRead", "ddRead", "ddCar", "xdLoader", "pedRunner", "dpCar", "tdWriter", "ddRunner", "pdLoader", "dpRunner", "hdReader", "hdWriter", "vdLoader", "dpReader", "tdParser", "pedCar", "ddReader", "ddLoader", "ddWriter", "pdCar", "hdParser", "tdReader"], "out": ["ins", "cmd", "id", "serv", "gt", "gen", "err", "js", "status", "obj", "res", "nt", "pos", "inter", "oss", "null", "log", "OUT", "co", "cache", "ent", "io", "conn", "it", "ou", "inv", "to", "auto", "aos", "ch", " err", "name", "conv", "o", "end", "cb", "at", "w", "cn", "en", "p", "v", "ex", "screen", "data", "sum", "s", "con", "cfg", "str", "in", "raw", "outs", "c", "all", "tmp", "msg", "opt", "up", "full", "one", "os", "desc", "flush", "t", "go", "output", "gr", "we", "list", "over", "net", "sys", "on", "sw", "writer", "pool", "nr", "client", "txt", "inner", "Out", "outer", "n"], "dcmEncParam": ["dcmDecNum", "dcmEscNum", "dmmEnPar", "dcmencCmd", "dmmencParam", "dcmEncVal", "dcmEncCmd", "dmmEncMsg", "dmmEncParam", "dcmencNum", "dcmDecMsg", "dmmEncVal", "dmmEnNum", "dmmEnParam", "dmmEncNum", "dcmEnVal", "dcmEscPar", "dcmEscParam", "dcmEscVal", "dcmencPar", "dmmEncCmd", "dcmDecCmd", "dmmencMsg", "dcmEnNum", "dmmencNum", "dcmEnPar", "dmmencCmd", "dcmEncMsg", "dcmencMsg", "dcmEncPar", "dmmEncPar", "dcmencParam", "dcmEncNum", "dcmDecParam", "dcmEnParam"], "pdWriter": ["tdWrite", "PDWriter", "pidWriting", "pdWriting", "pdWrite", "pcWriting", "tdwriter", "pcWriter", "PDEditor", "pidwriter", "dpWrite", "pidWriter", "pdEditor", "pcwriter", "pcWrite", "tdWriter", "PDReader", "dpEditor", "tdEditor", "dpReader", "tdWriting", "pidWrite", "PDWrite", "pdwriter", "dpWriter", "tdReader"]}}
{"id1": "15797402", "id2": "15409512", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"parse": ["pe", "patch", "p", "scale", "format", "php", "process", "print", "parser", "xml", "resource", "ping", "map", "load", "add", "apply", "render", "dump", "transform", "shape", "tag", "build", "execute", "interpret", "slice", "split", "write", "se", "create", "close", "save", "filter", "use", "read", "handle"], "stream": ["length", "image", "Stream", "output", "channel", "archive", "data", "message", "window", "instance", "sync", "content", "iterator", "ream", "clean", "form", "chain", "sequence", "buffer", "stack", "test", "in", "resource", "http", "response", "upload", "document", "file", "console", "reader", "event", "zip", "open", "source", "input", "url", "sample", "download", "read", "cont", "handle"], "handler": ["callback", "host", "processor", "server", "message", "service", "hander", "ctx", "parser", "wrapper", "application", "loader", "writer", "resource", "worker", "storage", "shape", "management", "connection", "function", "address", "controller", "pool", "reader", "event", "h", "hand", "policy", "Handler", "password", "handle"], "metadata": ["image", "pdf", "dd", "mt", "header", "adata", "general", "data", "message", "detail", "properties", "content", "iterator", "google", "tar", "basic", "ctx", "m", "xml", "definition", "hold", "dirty", "md", "document", "MD", "managed", "java", "still", "met", "material", "template", "property", "meta", "details", "parts", "config", "memory", "policy", "td", "mem", "json", "manager", "common", "unknown", "management", "info", "module", "handle"], "context": ["translation", "location", "sc", "instance", "cc", "dict", "content", "environment", "chain", "sequence", "state", "stack", "ctx", "set", "network", "options", "collection", "resource", "frame", "response", "reason", "usage", "document", "connection", "event", "system", "current", "template", "config", "null", "condition", "ce", "command", "component", "local", "module", "Context"], "name": ["image", "pass", "value", "id", "old", "channel", "data", "nm", "description", "service", "lower", "string", "path", "on", "term", "Name", "part", "resource", "size", "nl", "alias", "reason", "comment", "NAME", "prefix", "key", "all", "label", "file", "body", "base", "none", "family", "system", "no", "client", "current", "ame", "title", "source", "filename", "common", "create", "len", "null", "l", "version", "type", "url", "time", "default", "named", "names", "local", "n"], "out": ["cn", "cmd", "output", "OUT", "co", "lay", "v", "serv", "ex", "sum", "external", "list", "gen", "con", "us", "user", "net", "io", "print", "sys", "in", "outs", "it", "OU", "writer", "table", "ou", "col", "to", "all", "obj", "file", "res", "po", "auto", "aos", "cos", "up", "oss", "one", "conv", "conf", "null", "url", "flush", "o", "Out", "outer", "n"]}}
{"id1": "22268798", "id2": "21999120", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 0, "substitutes": {"getContent": [" getObject", "GetContents", "createContent", " getContents", "createEntity", "createContents", "getContents", "GetContent", "getEntity", "createObject", " getEntity", "GetEntity", "GetObject", "getObject"], "principal": ["pricipiple", "pricipity", " prPrincipal", "princicate", "prPrincity", "princity", "prPrincipal", "pricity", "principle", " princity", " princicate", " prPrinciple", "prPrinciple", "pricipal", " prPrincity", " prPrincicate", " principle", "pricipicate", "prPrincicate", "priciple", "pricicate", "pricipipal"], "path": ["image", "context", "object", "cmd", "p", "location", "pattern", "format", "form", "ref", "chain", "entry", "PATH", "resource", "link", "alias", "usage", "prefix", "key", "transform", "query", "file", "address", "parent", "reference", "name", "template", "full", "parts", "uri", "config", "policy", "route", "type", "Path", "log", "kind", "info", "ath", "cont"], "version": ["object", "v", "Version", "channel", "VER", "format", "generation", "sequence", " Version", "part", "ver", "document", "draft", "name", "hash", "unit", "serial", "virtual", "json", "versions", " versions", "release", "date", "index", "VERSION", "n"], "properties": ["values", "features", "fields", "items", "beans", "packages", "options", "images", "metadata", "owners", "reports", "params", "settings", "objects", "resources", "property", "details", "parts", "policy", "children", "sites", " props", "prop", "perties", "media", "groups", "tags", "ps"], "uniqueName": ["uniqueLength", "sampleCase", " uniqueNames", "iqAnn", "newCase", "sampleNum", "uniqueKey", "randomKey", " uniqueTime", "iqName", "UniqueName", "iqNum", " uniqueId", " uniqueLength", "uniqueNum", " uniqueKey", "newName", "uniqueAnn", "sampleName", "UniqueId", "newKey", "iqKey", "UniqueTime", "UniqueKey", "uniqueTime", "newLength", "randomId", "iqId", "iqTime", "newNum", "randomTime", "sampleAnn", "UniqueNames", "uniqueCase", "newNames", "uniqueId", "UniqueLength", "uniqueNames", "iqCase", "newAnn", "randomName"], "url": ["loc", "host", "rel", "el", "u", "sl", "ssl", "server", "domain", "gl", "https", "location", "ls", "dl", "pattern", "char", "bel", "web", "str", "ll", "xml", "resource", "http", "rl", "nl", "link", "page", "browser", "ur", "URL", "res", "file", "auto", "cert", "base", "address", "name", "this", "mount", "mail", "r", "uri", "Url", "db", "l", "null", "abs", "util", "html", "result", "handle"], "content": ["image", "update", "core", "context", "access", "object", "ontent", "output", "value", "search", "header", "license", "cache", "data", "message", "relation", "Content", "format", "description", "instance", "section", "claim", "continue", "wrapper", "raw", "article", "text", "entry", "resource", "status", "load", "response", "control", "metadata", "page", "comment", "report", "label", "key", "item", "document", "file", "layout", "result", "obj", "address", "parent", "current", "client", "compliance", "write", "display", "get", "title", "create", "config", "inner", "condition", "type", "ct", "time", "summary", "contact", "remote", "cm", "cont", "action"], "connection": ["position", "channel", "Connection", "relation", "connect", "communication", "description", "pointer", "io", "generation", "database", "network", "application", "entry", "conn", "closure", "c", "collection", "resource", "response", "link", "socket", "category", "session", "document", "directory", "reference", "connected", "open", "system", "client", "ion", "number", "character", "uri", "close", "cone", "condition", "associated", "command", "index", "opening"], "mimeType": ["mIMEType", "mgeIndex", "mgeTypes", "cmimeType", "mimesIndex", "cmimesType", "MimeIndex", "mixedHandler", "MIMEIndex", "cmimeHandler", "cmimeTypes", "mgeLength", "MIMEType", "mimesType", "mimeLength", "mIMEIndex", "cmimetype", "MimeTypes", "mimeTypes", "mimeIndex", "mixedType", "MimeType", "cmimestype", "mimeHandler", "MIMELength", "mimesLength", "mixedtype", "cmimesTypes", "cmimesHandler", "mixedTypes", "MimeLength", "mIMETypes", "mimetype", "MIMETypes", "mIMEtype", "mgeType", "mIMELength", "mimesHandler", "mimesTypes", "mimestype", "mIMEHandler"]}}
{"id1": "20247400", "id2": "2642914", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"in": ["ins", "din", "isin", "ze", "IN", "inn", "con", "ai", "net", "io", "inf", "gin", "cin", "on", "bin", "from", "it", "init", "file", "ind", "is", "inc", "check", "up", "rin", "i", "input", "source", "inner", "and", "info", " din", "In"], "out": ["ins", "ot", "cmd", "output", "OUT", "b", "other", "ex", "screen", "println", "we", "list", "gt", "con", "ln", "net", "io", "ne", "print", "sys", "str", "err", "outs", "it", "or", "writer", "OU", "ou", "to", "report", "dir", "obj", "auto", "msg", "name", "line", "write", "client", "check", "oss", "r", "os", "null", "t", "log", "o", "exit", "Out", "at", "w", "outer", "n"], "buffer": ["length", "processor", "output", "header", "b", "binary", "position", "match", "cache", "channel", "data", "message", "total", "window", "buf", "queue", "stack", "phrase", "sequence", "database", "block", "view", "limit", "trace", "table", "size", "bridge", "bar", "available", "comment", "attribute", "key", "shape", "document", "function", "batch", "library", "address", "event", "history", "append", "template", "memory", "source", "display", "se", "iter", "clear", "db", "variable", "Buffer", "flush", "buff", "filter", "sample", "pause", "command", "component", "index", "temp", "result"]}}
{"id1": "22366505", "id2": "22411381", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 1, "substitutes": {"incluir": ["incluiir", "inclUator", "inCLUir", "inclouator", "incluar", "inCLUar", "inCLuier", "inclouir", "inCLUier", "inCLuir", "incluiier", "inclUier", "inCLUator", "incluier", "inclUar", "incluiar", "incluator", "incluiator", "inclouier", "inCLuar", "inclouar", "inCLuator", "inclUir"], "igreja": ["igopenji", "iggrej", " iggreva", "igreji", "iggreja", " iggreji", " iggrej", " igrej", " igreva", " iggreja", "igopenj", " igreji", " iggreje", " igcrej", "iggreje", "igcreJa", " igreJa", "igopenva", " igcreji", "iggreJa", "igarreja", "igarreji", "igvrej", "igarreva", "igarrejas", "igrejas", "igopenja", "iggreva", "igrej", "igcreji", "iggrejas", "igreje", "igcreja", "igreva", " iggrejas", "igarreJa", "igarreje", "igcrej", " igcreja", "igreJa", "igvreje", " igreje", "iggreji", "igarrej", "igvrejas", " igrejas", "igvreja", " igcreJa"], "connection": ["context", "container", "engine", "server", "established", "position", "computer", "language", "Connection", "connect", "relation", "communication", "instance", "description", "message", "setup", "con", "user", "city", "generation", "database", "section", "network", "conn", "application", "which", "c", "collection", "resource", "response", "link", "socket", "to", "creator", "gate", "session", "query", "document", "function", "library", "connected", "pool", "directory", "settings", "reference", "operation", "open", "ion", "client", "system", "current", "config", "created", "db", "close", "manager", "condition", "statement", " Connection", "management", "command", "component", "n"], "sql": ["cmd", "shell", "seed", "plan", "dl", "select", "description", "sd", "string", "csv", "ln", "form", "sys", "normal", "q", "pel", "xml", "sq", "sf", "san", "scl", "table", "inv", "nl", "sv", "spec", "install", "login", "query", "expression", "sol", "zip", "lock", "serial", "template", "sk", "title", "pl", "statement", "url", "ql", "SQL", "log", "spr", "series", "command"], "sql2": ["sql3", "SQL4", "SQL1", "ql02", "sql1", "SQL02", "sd02", " sql3", "sd2", "sd4", " sql02", "ql2", " sql4", " sql1", "sql4", "SQL2", "ql3", "SQL3", "ql1", "sd3", "sql02"], "stmt": [" stMT", " stmm", "statm", "Stmb", "statmn", "stMT", "restm", "tMT", " stmn", "STm", "strmb", "tmm", "StMT", "strm", "strmt", "stmb", "stmm", "tmt", "estmb", "strMT", "statmt", "STmb", "STMT", "stm", " ststat", "Stmm", "restmt", "reststat", "STmm", "estm", "stmn", " stmb", " stm", "ststat", "estmt", "estMT", "tmb", "Stmn", "STmt", "statMT", "Stmt", "STmn", "Stm", "Ststat", "restmm"], "stmt2": ["Stmem3", "sttmTwo", "Stmt3", "stMTTwo", " stmt02", " stmp3", "stMT4", "stmt1", " stmp2", "stmttwo", "stmTwo", "sttx2", "stmem3", " stmt3", " stMT02", "stm3", "stm02", " stmp4", "stmr4", "stmem2", "StmemTwo", "stmt4", " stmttwo", "sttm3", "stmt3", "stMT3", "stmemTwo", "stmem1", "Stmem2", "Stmem1", " stmt4", "StmtTwo", "sttm2", " stMT3", "stmptwo", "stMT1", "stmr1", "stMT02", "stm2", " stMT1", " stMT2", "stm1", "stmtTwo", "stmp4", "stmrtwo", "sttx3", " stmptwo", "stmp2", "stMT2", "Stmt2", " stmp1", "sttm4", " stmt1", " stmpTwo", "sttx02", "stmp3", "stmpTwo", "sttx1", "stmp1", "Stmt1", "stmr2", " stmtTwo", "stmt02", "stMTtwo"], "rs": ["fs", "rows", "ins", "ars", "rt", "ats", "mr", "xs", "rc", "ris", "cs", "bs", "ls", "ros", "sts", "ows", "usr", "s", "pers", "ys", "ms", "ns", "ss", "RS", "Rs", "js", "vers", "gs", "ds", "rys", "rates", "ts", "ims", "res", "eps", "vs", "ras", "r", "results", "rss", "ks", "hs", "sr", "its", "rd", "qs", "ws", "ps"], "retorno": ["montora", "altorno", "retora", "retorne", "gotorno", "eltorn", " retorn", "retrero", "montrero", " retogo", "eltorno", "eltogo", "montorne", "retano", "altorn", " retano", " retrero", "montorno", "gotrero", " retora", "eltano", "retorn", "gotorne", "gotora", "altogo", " retorne", "altano", "retogo"]}}
{"id1": "18097962", "id2": "19147281", "code1": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"getVersion": ["getVersions", " getVERSION", "GetVersion", " getVersions", "getVERSION", " getServer", "GetVERSION", "GetVersions", "formatVersion", "formatVERSION", "getServer", "formatVersions", "formatServer", "GetServer"], "version": ["update", "translation", "value", "license", "software", "v", "Version", "video", "language", "VER", "feature", "format", "description", "about", "string", "print", "sequence", "program", "xml", "lease", "vers", "volume", "status", "usage", "ver", "command", "browser", "comment", "python", "expression", "label", "tag", "key", "address", "hash", "history", "latest", "current", "installed", "ion", "name", "serial", "vector", "number", "title", "required", "filename", "release", "json", "versions", "human", "summary", "log", "tested", "info", "VERSION", "project", "result"], "version_url": ["version_Url", " version_service", "ver_Url", "ver2url", "version2url", "ver_uri", " version_file", "version_http", "ver2uri", "ver_url", "version_ur", "version2uri", "version_uri", "version2Url", "ver2Url", "version_file", "ver2ur", "ver_ur", "version_service", "version2ur", " version_http"], "url": ["loc", "rel", "f", "sl", "cal", "ssl", "gl", "https", "atl", "ls", "dl", "hl", "bel", "github", "web", "ref", "str", "ll", "conn", "ret", "pkg", "http", "ul", "nl", "link", "www", "browser", "ur", "URL", "cert", "base", "open", "client", "mail", "mount", "pl", "lb", "r", "Url", "l", "cl", "log"], "con": ["cn", "co", "cf", "com", "dial", "connect", "nc", "sin", "ln", "cin", "conn", "c", "pen", "re", "Con", "login", "connection", "cert", "ain", "cos", "soc", "ch", "CON", "open", "client", "cur", "ctrl", "bc", "conv", "conf", "cl", "cons", "cm", "fc", "can"], "in": ["ins", "din", "el", "en", "again", "sum", "IN", "er", "inn", "ln", "form", "inf", "io", "cin", "gin", "on", "err", "bin", "from", "ic", "re", "login", "all", "mc", "mn", "ma", "al", "reader", "is", "inc", "out", "rin", "i", "input", "r", "inner", "oin", "conf", "asin", "ill", "isin", " din", "read", "In"], "inputLine": ["commandline", "feedNet", "fromLine", " inputRow", " inputline", "clientLINE", "inputNet", "inputData", "commandRow", "httpLine", "inputString", "inputRow", "clientNet", "httpLINE", "commandLine", "httpData", " inputData", "httpString", "fromLINE", "InputBlock", "inputLINE", "inputStream", "fromData", "commandBlock", "feedStream", "InputLine", " inputBlock", "Inputline", "feedLine", " inputStream", "clientStream", " inputString", "inputBlock", "InputRow", "inputline", "feedLINE", " inputLINE", " inputNet", "fromString", "clientLine"]}}
{"id1": "4417943", "id2": "21013026", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "label": 0, "substitutes": {"test": ["server", " benchmark", " sample", "launch", " TEST", "foo", " Test", "Test", "example", "debug", "status", "ping", " check", " tests", "install", "init", "base", "execute", "Example", "testing", "full", " testing", "sample", "evaluate", "hello", "index", "tests"], "query": ["quote", "poll", "search", "field", "question", "pattern", "select", "Query", "string", "form", "sequence", "q", "random", "term", "text", "view", "password", "spec", "Q", "page", "quest", "comment", "prefix", "command", "sql", "body", "menu", "code", "params", "qu", "input", "qa", "condition", "type", "ql", "filter", "qs", "index"], "url": ["u", "sl", "id", "https", "location", "ls", "dl", "pattern", "api", "format", "string", "path", "web", "ref", "print", "q", "str", "xml", "ll", "term", "raw", "http", "ul", "nl", "link", "www", "ur", "sql", "URL", "build", "base", "address", "name", "mount", "pr", "out", "pl", "title", "r", "uri", "Url", "l", "log", "html", "result"], "urlObj": [" urlOb", "nlObj", "Urlobj", "lobj", " urlobj", "httpOb", " urlIt", "httpobj", "nlobj", "httpObj", "urlobj", "urlOb", "nlIt", "UrlObj", "nlOb", "lOb", "urlIt", "lObj", "lIt", "UrlOb"], "con": ["cn", "num", "const", "co", "cf", "fin", "ran", "com", "dial", "connect", "nc", "canon", "sin", "don", "ln", "un", "conn", "in", "c", "pen", "Con", "ver", "win", "obj", "mc", "Conn", "connection", "ain", "fn", "cos", "soc", "pos", "cond", "CON", "open", "cur", "syn", "ctrl", "bc", "conv", "cone", "conf", "len", "cons", "cl", "compl", "fc", "cont", "can"], "model": ["mi", "el", "object", "record", "value", "models", "dl", "data", "message", "fine", "le", "buffer", "cell", "state", "m", "me", "xml", "sim", "man", "set", "tree", "mod", "gp", "table", "map", "response", "re", "frame", "link", "de", "impl", "transform", "body", "base", "controller", "dm", "zip", "vm", "Model", "save", "cm", "job", "module", "sm"]}}
{"id1": "17791385", "id2": "19134229", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", " cpFile", "cloneFiles", "cloneResource", " copyFiles", " cpfile", " cpFiles", "copyFiles", "copyResource", "cloneFile", " copyfile", " cpResource", "clonefile", " copyResource"], "src": ["rel", "iv", "ins", "rc", "bs", "rs", "sc", "usr", "sin", "ys", "sys", "obs", "via", "st", "sq", "sf", "sec", "from", "rl", "inst", "sit", "ser", "req", "usc", "init", "sb", "rx", "txt", "ipl", "source", "input", "cur", "sel", "start", "sur", "ctr", "sr", "Source", "ux", "ck", "cont"], "dst": ["dnd", " ddest", "wdest", "Dth", "wth", " dth", "Dnd", "Dst", "ddnd", "Ddest", "dddest", "ddst", "dth", " dnd", "dnt", "Dnt", "sdest", "wst", "wnd", "snd", "ddest", "snt", "ddnt", "sst"], "in": ["ins", "inside", "din", "en", "ze", "IN", "rec", "sin", "inn", "con", "ln", "ai", "inf", "cin", "gin", "mm", "on", "bin", "from", "ar", "ic", "st", "it", "init", "al", "ain", "act", "ind", "is", "inc", "up", "rin", "i", "input", "source", "iter", "inner", "oin", "info", "isin", "im", "min", "In"], "out": ["cn", "ot", "output", "OUT", "co", "dis", "ex", "sum", "gt", "con", "net", "io", "ne", "sys", "on", "bin", "st", "outs", "it", "by", "writer", "ou", "and", "to", "obj", "res", "po", "auto", "aos", "nt", "can", "client", "write", "up", "oss", "oe", "g", "os", "inner", "conv", "o", "t", "Out", "at", "outer", "n"], "buf": ["arr", "cmd", "ck", "var", "b", "cf", "vec", "bed", "uf", "norm", "gen", "box", "buffer", "aka", "block", "pkg", "fb", "bar", "stab", "bh", "cv", "cap", "cam", "bag", "seq", "Buff", "batch", "msg", "cp", "good", "br", "pl", "cur", "bus", "cat", "conv", "db", "tab", "Buffer", "prop", "mu", "tx", "buff", "bytes", "log", "cb"], "len": ["length", "L", "loc", "z", "el", "rel", "fun", "num", "en", "exp", "fin", "v", "ls", "lf", "dl", "count", "lic", "il", "lan", "e", "ln", "le", "lim", "str", "val", "ll", "wid", "size", "vol", "Len", "cap", "all", "seq", "nt", "pos", "ren", "no", "cmp", "h", "elt", "ld", "l", "lon", "coll", "fl", "t", "end", "compl", "lib", "n"]}}
{"id1": "646016", "id2": "9236363", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"elimina": ["allimino", "elitino", "alimisa", "ellimina", "alimino", "elimisa", "eligine", "ellimino", "alimina", "eligino", "allimisa", "eligisa", "eligina", "elitina", "elimine", "elimino", "ellimine", "elitine", "ellimisa", "alimine", "allimina", "allimine", "elitisa"], "cli": ["cmd", "clus", "cu", "udi", "dial", "dl", "grid", "aci", "lu", "e", "ln", "cfg", "gui", "cgi", "idi", "coe", " cl", "conn", "GUI", "multi", "c", "coni", "Cl", "li", "uci", "gil", "ctl", "cci", " CLI", "console", "prot", "client", "ui", "exe", "i", "ctrl", "l", "cl", "ci", "cho", "eric", "util", "Client", "lc", "pi"], "id": ["f", "del", "num", "iden", "ida", "value", "uid", "with", "Id", "kid", "mid", "sd", "rand", "e", " fid", "bid", "ref", "did", "rid", "in", "ident", "wid", "it", "status", "and", "aid", "key", "oid", "md", "ad", "sid", "res", "code", "name", "pid", "ID", "hash", "no", "is", "out", "mail", "vid", "h", "ide", "i", "db", "null", "start", "ip", "url", "type", "end", "ids", "d", "info", "index"], "sql": ["sl", "ssl", "xs", "shell", "software", "https", "ls", "dl", "security", "ips", "format", "sd", " SQL", "s", "string", "csv", "ln", "wal", "sys", "ms", "ns", "pel", "lua", "xml", "ll", "pp", "sq", "owl", "js", "pkg", "ds", "scl", "sal", "ping", "nl", "spec", "sv", "socket", "what", "inv", "query", "sb", "expression", "sol", "lex", "ship", "eps", "sp", "msg", "fn", "QL", "lock", "services", "mail", "sk", "details", "db", "json", "url", "ql", "SQL", "util", "spr", "html", "ps"], "stmt": [" stMT", " stmm", "scm", "Stmb", "stMT", " stmn", "STm", "strmb", "Sttm", "tmm", "StMT", "strm", "strmt", "stmb", "stmm", "tmt", "strMT", "STMT", "stm", "scmm", "ttm", "scmt", "Stmm", "stmn", "STmm", " stmb", " stm", "Stmn", "tm", "STmt", "sttm", " sttm", "Stmt", "STmn", "Stm", "sctm"]}}
{"id1": "16760971", "id2": "23118425", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"generateHash": ["generateIndex", "generatehash", " GeneratesHash", " Generateshash", "generificateIndex", "generateshash", "generificateKey", " GeneratesKey", "generificateHash", " GenerateIndex", "generatedKey", "generatedhash", " Generatehash", "generatesKey", "generatesHash", " GenerateHash", "generatesIndex", " GeneratesIndex", "generificatehash", "generatedHash", "generatedIndex", "generateKey", " GenerateKey"], "key": ["k", "context", "value", "KEY", "id", "seed", "node", "sum", "message", "data", "char", "service", "Key", "secret", "string", "token", "path", "e", "phrase", "my", "text", "sign", "link", "prefix", "x", "hex", "code", "base", "y", "hash", "name", "keys", "client", "template", "sk", "username", "input", "source", "policy", "prime", "mac", "json", "type", "crypt", "password", "command"], "md": ["cmd", "dd", "mt", "dr", "exec", " MD", " ms", "der", "mo", "red", " cmd", " mc", "nd", "mg", " rm", "dh", "mk", "sd", " dd", "od", "ms", "m", "mm", "pd", "mod", " cd", "ds", "add", "de", "metadata", "ad", "mc", "mn", " Md", " mo", " mm", "mp", "df", "msg", "nt", "dm", "mand", "det", "dig", "mb", "ind", "def", "comp", "h", "grad", "ld", "td", "rm", "di", "cd", "desc", "bd", " mac", "hd", "d", "MD", "sm"], "bytes": ["fs", "bys", "ashes", "ions", "terms", "xs", "words", "binary", "b", "bs", "bits", "values", "ls", "bes", "classes", "clips", "cells", "s", "bles", "gets", "nets", "ms", "files", "buffer", "strings", "Bytes", "gs", "bps", "bis", "pieces", "some", "bos", "tes", "seconds", "vs", "ies", "loads", "gb", "keys", "steps", "ings", "es", "lines", "its", "frames", "blocks", "ones", "ebin", "ios"], "buff": ["butt", "pdf", "qq", "cmd", "supp", "b", "bs", "uff", "bed", "uf", "prep", "bo", "alf", "alph", "aux", "zz", "buf", "prof", "grow", "ary", "obb", "buffer", "ff", "nb", "pp", "tf", "fb", "fr", "backed", "bg", " Buff", "Buff", "df", "font", "eb", "cond", "zip", "mb", "bj", "comp", "txt", "quit", "ob", "append", "agg", "conv", "tab", "Buffer", "wind", "printf", "bound", "bb", "np", "frames", "ust", "cb", "pb"], "l": ["k", "L", "loc", "z", "el", "yl", "sl", "length", "lang", " Li", "b", "lay", "v", "ls", "dl", "il", "hl", "list", "kl", "like", "lo", "ml", "le", "ln", "q", "m", "ll", "c", "li", "ul", "nl", "j", "ell", "x", "jl", "la", "al", "left", "lv", "lp", "dL", "loop", "pl", "i", "lb", "ld", "g", "lit", "cl", "fl", "tl", "coll", "t", "ly", "d", "lc", "n"], "hx": ["hrxe", "HX", "hX", "hxf", "Hpx", "ohX", " hix", "ohxe", "Hex", "Hxf", "hrex", "hix", "Hxe", "Hix", "ohx", "rxf", "handlexf", "hrx", " hpx", "handlex", "rex", "hex", "handleex", " hxf", "rx", "hxe", "Hx", "ohex", "handleix", "hpx", " hex", "hrX", "rpx"]}}
{"id1": "13852596", "id2": "13783549", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"execute": [" sweep", "exec", " deploy", " benchmark", " scan", "launch", " assemble", " proceed", "process", " inherit", " executed", " eval", " execution", " executable", " resolve", " exec", "init", " perform", "construct", "run", " chain", " test", " launch", " replay", " release", " evaluate", "evaluate"], "resources": ["rows", "ions", "writers", "models", "rs", "ris", "classes", "banks", "ifiers", "Resources", "builders", "lets", "items", "types", "files", "actions", "flows", "packages", "issues", "apps", "relations", "they", "artifacts", "images", "resource", "users", "reports", "res", "workers", "objects", "services", " Resources", "modules", "rooms", "archives", "accessible", "pointers", "scripts", "results", "stores", "uploads", "locks", "ports", "projects", "bytes", "ids", "names", "groups", "faces", "roots", "blocks", "these"], "i": ["cli", "ia", "mi", "ami", "ri", "pi", "v", "ir", "ex", "ini", "ali", "list", "I", "ii", "si", "e", "ai", "io", "bi", "q", "in", "iu", "ki", "multi", "abi", "li", "ij", "ti", "j", "bis", "xi", "ims", "hi", "ori", "ji", "im", "phi", "iri", "ui", "h", "g", "di", "gi", "l", "ip", "ci", "mu", "\u0438", "t", "info", "oi", "ios"], "classFile": ["classFolder", "cellClass", "attributeChain", "ClassFilename", "fastFile", "connectionFile", "sourceFile", "attributeFile", "clfile", "classifiedFile", "classifiedfile", "attributeFiles", " classFiles", "sourceFILE", "fastFiles", "targetSourceFile", " classTree", "parentfile", "ClassChain", " classfile", "typeFILE", "clFiles", "classifiedFiles", "parentFile", "connectionFILE", "classFiles", " classClass", "classfile", " classResource", "classFilename", "classEntry", "ClassFiles", " classEntry", "instanceFiles", "targetFile", "attributeFILE", "fastFILE", "instanceFilename", "ClassClass", " classSourceFile", "parentSourceFile", "connectionfile", "clTree", "cellFile", "ClassSourceFile", "classLine", "classFILE", "targetFILE", "clFile", "recordFile", "typeLine", "ClassTree", "recordfile", " classChain", "objectFile", " classDirectory", "ClassFILE", "ClassDirectory", "classDirectory", "sourceClass", "classChain", "sourceFiles", "classResource", "attributeResource", " classFILE", "userFile", "objectFolder", "targetFiles", "classTree", "Classfile", "classifiedSourceFile", "userFILE", "userFiles", " classLine", "recordFilename", "userfile", "ClassFile", "fastfile", "objectClass", "classSourceFile", " classFolder", "recordFiles", "instanceDirectory", "typeFiles", "typeFile", "parentFILE", "connectionSourceFile", "attributeEntry", "ClassLine", "classClass", "ClassResource", "cellFolder", "ClassEntry", "instanceFile", " classFilename", "classifiedFILE"], "inputStream": ["audioStream", " inputSource", "ipStream", "InputTime", " inputSt", "outputPort", "thisFile", "audioSteam", "jsonStreamer", "ipFile", "outStreamer", "InputSteam", "familyStyle", "ipSteam", "outputStyle", "familySource", "InputMode", "inputMode", "innerSteam", "inSet", "familySteam", "familyFile", "ipStyle", "jsonSteam", "outputstream", " inputSteam", "inputStreamer", "thisSource", " inputstream", "inSteam", "innerStream", "inStream", " inputTime", "inputSteam", "inStreamer", "thisSteam", "outSteam", "audioStreamer", "inputstream", "thisStream", "inputSt", "inputPort", "familyStream", "innerSet", "Inputstream", " inputPort", "outputFile", "errorStream", "instream", "inPort", "inputStyle", " inputFile", "InputStream", "inputSource", "errorstream", "errorSteam", " inputMode", "jsonStream", "outputTime", "outStream", "innerStreamer", "outputSteam", "outSt", "errorMode", "inputSet", "audioSt", " inputStreamer", "jsonSet", "inputTime", "inputFile"], "reader": ["image", "readable", "dr", "dd", "mr", "operator", "field", "actor", "stream", "red", "ger", "instance", "er", "service", "peer", "oder", "review", "driver", "user", "owner", "iterator", "handler", "editor", "test", "parser", "penter", "rule", "entry", "wrapper", "loader", "definition", "layer", "author", "rl", "runner", "worker", "reading", "prototype", "key", "ler", "builder", "query", "document", "draft", "per", "rar", "Reader", "client", "older", "write", "ner", "r", "inner", "manager", "rer", "row", "variable", "Writer", "finder", "master", "read"], "oldSize": [" oldsize", "oldersize", "oldsize", "olderFontSize", "olderSize", "oldFontSize", "OLDLength", "oldLength", "OLDSize", "OLDFontSize", " oldFontSize", " oldLength", "OLDsize", "olderLength"], "writer": ["riter", "writers", "actor", "node", "message", "format", "er", "service", "buf", "review", "driver", "owner", "player", "editor", "handler", "buffer", "test", "parser", "penter", "weight", "walker", "entry", "wrapper", "loader", "wrote", "definition", "author", "worker", "runner", "method", "ter", "storage", "key", "wb", "ler", "builder", "document", "rw", "draft", "Reader", "word", "write", "vector", "ner", "r", "writing", "inner", "manager", "written", "row", "variable", "finder", "adder", "Writer", "draw", "w", "read"], "b": ["f", "u", "bs", "v", "p", "bf", "bits", "binary", "ib", "bp", "nb", "m", "bin", "c", "ab", "fb", "bis", "a", "wb", "B", "sb", "emb", "batch", "base", "erb", "mb", "gb", "bit", "br", "ob", "h", "r", "g", "db", "l", "rb", "t", "bound", "bb", "d", "w", "n"], "outputStream": [" outputSteam", "inputView", "outputString", "resultstream", "Outputstream", " outputForm", "inputForm", "inputPoint", "writePoint", "outputstream", "resultStream", " outputString", "OutputStream", "inputstream", "inputSteam", " outputView", "OutputSteam", "OutputForm", "resultForm", "writeView", "OutputString", "outputPoint", "resultString", " outputPoint", "writeStream", "outputForm", "outputSteam", "outputView", "resultSteam", "writeSteam"], "injectedClasses": ["injectedCountes", "injectedClassets", "injectedClassBytes", "injectClassES", "injectedSuccessets", "injectClassets", "injectedSuccesses", "injectClassBytes", "injectUses", "injectedUsBytes", "injectedClassES", "injectedUsets", "injectedCountBytes", "injectUsets", "injectedCountES", "injectClasses", "injectUsBytes", "injectUsES", "injectedUsES", "injectedCountets", "injectedUses", "injectedSuccessES", "injectedSuccessBytes"], "newSize": ["NewName", "oldMax", "newName", "oldName", "NewFontSize", "newFontSize", "oldFontSize", "NewSize", "NewMax", "newMax", " newMax", " newFontSize", " newName"]}}
{"id1": "16931472", "id2": "8942491", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "label": 0, "substitutes": {"handler": ["callback", "update", "processor", "output", "forward", "Handle", "hook", "adapt", "processing", "received", "request", "handle", "render", "init", "transform", "controller", "execute", "done", "proc", "handled", "Handler", "success", "accept", "end", "index", "read", "action"], "result": ["output", "product", "mate", "cache", "data", "profile", "total", "list", "Result", "complete", "sequence", "buffer", "valid", "RESULTS", "ret", "status", "map", "table", "response", "page", "report", "all", "res", "hash", "current", "met", "found", "out", "full", "done", "source", "memory", "details", "created", "results", "success", "make", "successful", "master"], "target": ["object", "cmd", "node", "style", "detail", "gt", "dest", "complete", "buffer", "pkg", "http", "link", "alias", "page", "that", "report", "controller", "template", "info", "local", "arget", "translation", "scope", "match", "jp", "external", "goal", "e", "tree", "term", "it", "view", "trace", "table", "to", "layout", "name", "internal", "version", "type", "remote", "project", "task", "self", "format", "service", "test", "valid", "subject", "closure", "expected", "prototype", "base", "parent", "arg", "source", "tool", "t", "component", "history", "Target", "master", "handle", "top", "output", "window", "tif", "thread", "peer", "bolt", "transform", "proxy", "this", "iter", "manager", "next", "primary", "trigger"], "url": ["loc", "rel", "f", "el", "sl", "ssl", "git", "ls", "dl", "hl", "char", "service", "bel", "lr", "web", "ll", "loader", "rl", "http", "ul", "nl", "link", "browser", "ur", "impl", "URL", "connection", "file", "cert", "build", "base", "address", "mount", "client", "mail", "uri", "Url", "l", "hub", "html"], "reader": ["context", "readable", "operator", "stream", "liner", "upper", "er", "review", "iterator", "driver", "buffer", "parser", "loader", "layer", "writer", "rl", "resource", "runner", "reading", "ro", "linger", "redo", "file", "builder", "rr", "rar", "Reader", "older", "ner", "cur", "iter", "inner", "uri", "row", "and", "rot", "read"], "line": ["entity", "ine", "store", "node", "style", "liner", "online", "port", "eline", "zone", "message", "level", "email", "detail", "string", "ln", "lo", "le", "chain", "queue", "sequence", "cell", "buffer", "state", "print", "section", "block", "lin", "continue", "network", "text", "rule", "trace", "limit", "status", "frame", "inline", "Line", "nl", "stay", "link", "page", "range", "comment", "file", "body", "base", "code", "lock", "word", "no", "out", "loop", "source", "user", "iter", "l", "row", "ip", "lines", "next", "log", "LINE", "sample", "point", "date", "now"], "entry": ["object", "record", "search", "ry", "field", "office", "match", "ex", "deep", "instance", "char", "pair", "list", "ent", "enter", "e", "ary", "cell", "member", "term", "it", "or", "part", "add", "quick", "comment", "key", "ie", "element", "ace", "def", "check", "se", "inner", "row", "pixel", "Entry", "exit", "job", "escape"], "fromIndex": ["leftInd", "FromInd", "fromPosition", "fromindex", " fromPosition", " fromInt", "leftindex", "fromInt", "FromLink", "normalIndex", " fromAlpha", "fromInd", "oldIndex", " fromInd", "oldAlpha", "oldInd", "normalindex", "oldLink", " fromindex", "forIndex", "fromLink", "FromAlpha", "minIndex", "minInd", "normalInd", "minindex", "FromIndex", "leftIndex", "forPosition", "leftPosition", "normalInt", "minInt", "forindex", "fromAlpha", "forInd", " fromLink"], "r": ["u", "dr", "rt", "mr", "b", "rc", "rs", "v", "p", "rg", "er", "e", "vr", "q", "rect", "m", "R", "err", "str", "ar", "kr", "re", "fr", "range", "render", "res", "rr", "rar", "nr", "cr", "g", "l", "rb", "sr", "rate", "rd", "w", "n"]}}
{"id1": "17580775", "id2": "4016687", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"runInternal": ["loadIntern", "loadImpl", "processInternal", "runImpl", "processIntern", "runinternal", "mainIntern", "processinternal", "loadInternal", "mainInternal", "mainImpl", "runIntern", "maininternal", "loadinternal", "processImpl"], "connection": ["description", "setup", "application", "government", "method", "link", "socket", "page", "controller", "address", "statement", "creation", "context", "translation", "server", "encrypted", "relation", "entry", "table", "to", "document", "console", "current", "no", "number", "close", "version", "associated", "default", "command", "information", "initial", "engine", "established", "general", "channel", "bo", "connect", "message", "con", "subject", "network", "c", "resource", "creator", "reference", "create", "condition", "component", "position", "computer", "language", "Connection", "communication", "device", "pointer", "generation", "database", "collection", "writer", "machine", "session", "function", "operation", "directory", "pool", "connected", "event", "open", "ion", "client", "character", "created", "reset"], "visited": ["Vised", "visitted", "comed", "VISited", "comitialized", "visITED", "visitialized", "shownited", "Visitialized", "shownITED", "VisITED", "viting", "vitted", "vITED", "vited", "VISitialized", "comited", "showniting", "visiting", "comitted", "VISitted", "Visitted", "vised", "VISed", "Visited", "Visiting", "shownitted"], "startTimeStamp": ["startTimStis", "startTimeMillamps", "startTimeStramps", "startTimeStamps", "startTimStamp", "startTimeStrAMP", "startTimeStris", "startTimestis", "startTimestAMP", "startTimestamps", "startTimestamp", "startTimstis", "startTimeStis", "startTimeStramp", "startTimeMillAMP", "startTimstamp", "startTimstamps", "startTimstAMP", "startTimStamps", "startTimeMillis", "startTimeMillamp", "startTimStAMP", "startTimeStAMP"], "delayedProgress": ["dayContent", "delayedContent", "dayedprogress", "deliverprogress", "delayingProgress", "delayingprogress", "delayprogress", "deliverProgress", "delayContent", "delayedprogress", "delayProgress", "dayedContent", "dayedProgress", "dayProgress", "delayingContent", "deliverContent", "dayprogress"], "conn": ["loc", "cn", "cmd", "alloc", "exec", "adj", "org", "ht", "dl", "Connection", "connect", "nc", "jp", "enc", "cc", "con", "nw", "addr", "cfg", "cell", "ctx", "err", "resp", "c", "js", "col", "comm", "j", "pg", "obj", "Conn", "res", "mc", "cert", "nt", "act", "ch", "cp", "open", "hw", "client", "cmp", "txt", "cur", "bc", "conv", "conf", "l", "ct", "att", "cb", "cont", "n"], "fileName": ["resourcePath", "displayname", "fileValue", "FileType", " fileValue", "Filename", "resourcename", " filename", "displayValue", "FilePath", " fileType", "displayPath", " filePath", "filePath", "filename", "resourceName", "FileValue", "displayName", "FileName", "resourceType", "fileType"], "disp": ["defp", "Dispat", "defr", "dispat", "desp", "desP", "DISpol", "dispi", "nlpo", "defP", "dispend", "serpi", "laypol", "lyn", "dispol", "DIScp", "DISpend", " dispa", "despi", "dispa", "sern", "nlP", "discp", "laycp", "DISp", "Disp", "nlp", "Dispi", "disccp", "lypi", "lyp", "serpa", "lypa", "wordp", "defpi", "laypend", " disn", "discpend", "DisP", "disP", "discpol", "wordpo", "layp", "wordP", "Dispo", "disr", "disn", "wordpat", "serp", " dispi", "nlpat", "desr", "Disr", "dispo"], "p": ["f", "v", "par", "pi", "perm", "jp", "php", "pat", "bp", "pers", "P", "pointer", "m", "pre", "pp", "pkg", "c", "part", "ping", "vp", "ph", "j", "pg", "wp", "op", "sp", "change", "pc", "pos", "cp", "pid", "lp", "pa", "pro", "h", "i", "r", "conv", "padding", "t", "pad", "np", "primary", "point", "d", "tp", "ps", "dp", "n"], "response": ["length", "image", "roads", "onse", "reply", "value", "server", "position", "more", "yes", "message", "relation", "description", "total", "ne", "environment", "sequence", "duration", "tree", "escription", "block", "resp", "application", "continue", "network", "zero", "error", "timeout", "status", "example", "entry", "request", "frame", "page", "res", "function", "code", "amount", "relative", "none", "pos", "no", "number", "respons", "reset", "Response", "version", "type", "json", "success", "time", "next", "bytes", "exit", "remote", "index", "result"], "contentType": ["ContentType", "messageTYPE", "ContentTypes", "contentTy", "commandType", " contentLength", "cellLen", "documentLength", "documentTYPE", "cellLength", "ContentTy", "commandTy", "messageType", "contentLength", "documentType", " contentTypes", "commandTypes", "commandLength", " contentTy", "cellTYPE", "contentTypes", "documentLen", "cellType", "ContentLength", "messageLen", "messageLength", "contentTYPE"], "contentEncoding": [" contentEncoring", "contentencryption", "contentDecoding", "contentDecryption", "contentEvLength", "contentEvoder", "contentEncoded", "contentEncoring", "contentEvoding", " contentEncryption", "contentDecoring", "contentDecLength", " contentEncoder", "contentEnoder", "contentEnLength", "contentEnoding", "contentencoder", "contentEncLength", " contentEnoding", "contentDecoder", " contentEnryption", "contentencoding", "contentEvoded", " contentEnLength", " contentEncLength", "contentEncoder", " contentEncoded", "contentencoring", " contentEnoring", "contentEnryption", "contentEnoring", "contentEncryption", "contentEnoded", "contentDecoded", " contentEnoded", " contentEnoder"], "contentLen": ["messageSize", " contentColl", "componentColl", " contentLength", "componentSize", "componentlen", "contentSize", "ontentLen", "ContentSize", " contentNet", "ontentSize", "ContentNet", "ontentNet", "ContentLen", "contentLength", "ontentLength", "contentNet", "messagelen", "contentlen", "contentColl", " contentSize", "componentLen", "messageColl", "ContentLength", " contentlen", "messageLen"], "is": ["iz", "are", "iss", "id", "ists", "ize", "ii", "ice", "ss", "ism", "network", "http", "ims", "IS", "ie", "Is", "isd", "isc", "does", "i", "es", "version", "ip", "ist", "its", "ih", "im", "pi"], "url": ["host", "ssl", "server", "domain", "org", "id", "https", "git", "location", "ls", "dl", "channel", "pattern", "char", "bel", "string", "web", "path", "ref", "str", "ll", "xml", "http", "link", "www", "page", "browser", "ur", "URL", "build", "base", "address", "name", "client", "mount", "uri", "Url", "l", "version", "site", "html"], "loadNext": [" loadMore", " loadedNext", "loadedFirst", "loadMore", " loadnext", " loadFirst", "loadnext", "loadedMore", "loadednext", "loadedNext", " loadedFirst", " loadedMore", " loadednext", "loadFirst"], "itemsLoadedPartially": ["itemsLoadedPosially", "itemsLoadsPosially", "itemsLoadsPartully", "itemsLoadedPosully", "itemsLoadedpartully", "itemsLoadedpartially", "itemsLoadedPartfully", "itemsLoadedPartully", "itemsLoadsPosfully", "itemsLoadsPartial", "itemsLoadedPartial", "itemsLoadedPosial", "itemsLoadsPartially", "itemsLoadsPartfully", "itemsLoadedpartfully", "itemsLoadedpartial", "itemsLoadedPosfully", "itemsLoadedOnlyial", "itemsLoadsPosully", "itemsLoadsPosial", "itemsLoadedOnlyially", "itemsLoadedOnlyfully", "itemsLoadedOnlyully"]}}
{"id1": "19739421", "id2": "19868933", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownCommandException", "UnknownFormatError", " UnknownOptionError", "UnknownParameterException", " UnknownCommandClass", "UnknownCommandHandler", "UnknownCommandClass", "UnknownOptionHandler", " UnknownCommandException", "UnknownFormatHandler", "UnknownParameterHandler", "UnknownOptionError", " UnknownOptionClass", "UnknownCommandError", "UnknownParameterError", "UnknownOptionClass", " UnknownCommandError", " UnknownOptionHandler", "UnknownFormatException", " UnknownCommandHandler", "UnknownParameterClass", "UnknownFormatClass"], "cmdLineParser": ["cmdlineReader", "cmdLParser", "CmdlineProvider", "mdlinearser", "mdLineparser", "commandLineReader", "commandlineParser", "mdLineReader", "commandlinePers", "cmdFramePers", "cmdNetParser", "cmdlineBuilder", "mdLineLoader", "commandLineParser", "commandLineBuilder", "cmdFrameRunner", "cmdLineOptions", "CmdLineReader", " cmdLineReader", "cmdListparser", "cmdSetParser", " cmdPageBuilder", "cmdBlockHandler", "cmdSetparser", "cmdlineHandler", "mdlineHandler", "cmdlineOptions", "cmdNetStreamer", "cmdLineRunner", "mdLineHandler", "CmdlineBuilder", "commandlineRunner", "mdlineBuilder", "mdLineOptions", "cmdListReader", "mdLineParser", "cmdLinePers", "cmdLineReader", "cmdLineparser", "cmdlinearser", " cmdPageParser", "cmdLinearser", "cmdlineProvider", "cmdPageBuilder", "commandlineProvider", "cmdLOptions", "cmdlinePers", "cmdChainarser", "cmdChainLoader", "cmdPageReader", "cmdSetReader", "CmdlineReader", "cmdNetReader", "cmdlineLoader", "cmdLineLoader", "cmdLineBuilder", "CmdLineBuilder", "mdlineStreamer", "cmdlineRunner", "cmdChainReader", "commandlineBuilder", "cmdLineHandler", "cmdBlockReader", "cmdLineProvider", "cmdBlockProvider", "CmdLineProvider", "cmdlineParser", "cmdLineStreamer", "cmdBlockBuilder", "CmdLineParser", "mdlineParser", "commandLineProvider", "cmdFrameParser", "commandLineRunner", "cmdlineStreamer", "cmdLBuilder", "cmdPageParser", "commandLinePers", "cmdFrameReader", "mdlineOptions", "commandlineReader", "cmdChainParser", "mdLinearser", " cmdLineBuilder", "cmdListParser", "mdlineparser", "mdlineLoader", " cmdPageReader", "cmdBlockParser", "cmdPageProvider", "cmdNetHandler", "mdlineReader", "CmdlineParser", "cmdLHandler", "mdLineStreamer", "mdLineBuilder", "cmdlineparser", "cmdSetBuilder", "cmdListBuilder", "cmdBlockOptions"], "formatOption": [" formatEntry", " formatOptions", "transformEntry", "filterEntry", " formatOperation", "FormatOperation", "formatEntry", "transformOption", "FormatOptions", "transformOperation", "FormatOption", "filterOption", "transformOptions", "formatOperation", "formatOptions"], "outputEncodingOption": ["outputencodingOptional", "outputencappingoption", "outputEncgingOption", "outputEncodingoption", "outputEncodingOptional", "outputEncamingOptional", "outputencappingOption", "outputencachingOptions", "outputEncachingOptional", "outputEncappingoption", "outputEncachingOptions", "outputEncamingoption", "outputencodingoption", "outputEncappingOptional", "outputEncamingOptions", "outputencodingOptions", "outputEncodingOptions", "outputEncgingOptional", "outputEncamingOption", "outputEncgingoption", "outputencodingOption", "outputEncappingOption", "outputEncachingOption", "outputencachingOption", "outputEncappingOptions", "outputencappingOptional", "outputencachingOptional"], "inputEncodingOption": ["inputEncendingOption", "inputenclingAttribute", "inputencodingOptions", "inputCodingOption", "inputCodingOptions", "inputencodingAttribute", "inputEncordingAttribute", "inputEncodingOptions", "inputEncodingoption", "inputencodingoption", "inputEncordingOptions", "inputenclingOptions", "inputCachingOption", "inputEncappingOptions", "inputEncachingOption", "inputEncachingOptional", "inputEncappingOption", "inputEncappingoption", "inputEnclingAttribute", "inputEncappingAttribute", "inputEncendingOptional", "inputEncachingOptions", "inputEncendingOptions", "inputenclingOption", "inputCachingOptions", "inputCodingOptional", "inputencodingOption", "inputCachingOptional", "inputEncodingOptional", "inputEncodingAttribute", "inputEnclingOption", "inputEncappingOptional", "inputenclingoption", "inputEnclingoption", "inputEnclingOptions", "inputEncordingOption", "inputEncordingoption"], "format": ["f", "output", "license", "style", "with", "scale", "language", "pattern", "api", "tif", "string", "form", "print", "sort", "set", "term", "it", "error", "status", "join", "option", "table", "method", "pretty", "note", "what", "export", "prefix", "transform", "file", "layout", "force", "name", "unit", "fix", "display", "template", "get", "title", "source", "filename", "config", "policy", "version", "type", "parse", "accept", "filter", "Format", "printf", "use", "command", "at", "module", "pi"], "outputEncoding": ["currentEncling", "outputEngging", "outputCompryption", "outputEnryption", "responseEncryption", "outputEncoder", "currentEnoding", "outputEngacing", " outputEncacing", " outputEncaming", "responseEncling", "outputEnoder", "outputencaching", "outputDecaming", "outputEngoding", "outputEngaching", "outputencling", "outputDecryption", "publicEncling", " outputDecaming", "outputEnaching", " outputEngoding", "outputMessining", "outputMessaming", "outputEncacing", " outputDecryption", "outputEnacing", "outputEnaging", " outputEngoder", "outputEnalling", "responseEncoding", "outputEngaling", " outputEncoder", "outputDecoding", "outputEnling", "outputEncalling", "outputCompining", "outputEncaching", "outputEncaling", "outputEnording", "outputencaging", "outputencording", "outputEncaging", "currentEnaching", " outputDecoding", "outputDecalling", " outputEncryption", "currentEnging", " outputDecining", "outputencging", "outputMessryption", "outputMessoding", "publicEncaging", "currentEncging", "outputCompaming", "outputEncording", "publicEncording", "responseEncalling", "outputEncryption", "outputEnoding", "outputEngoder", "outputDecining", "outputencoding", "outputDecling", "currentEncaching", "outputEngling", " outputEngacing", " outputEncining", "outputEncging", "publicEncoding", "outputEnaling", "currentEncoding", "currentEnling", "outputEnging", " outputEngaling", "outputEncining", "outputCompoding", "outputEncling", "outputEncaming", " outputEncaling"], "inputEncoding": ["inputEnacing", "inputEncale", "inputEngoding", "inputPackale", "inputEnale", "contextEnacing", "inputEncacing", "outputEncoder", "outputEncging", "sourceEncacing", "inputencale", "contextEncacing", "outputEncale", "contextEncoder", "inputencoding", "inputEning", "inputEncing", "inputPackoder", "contextEncoding", "inputChacing", "sourceEnoding", "outputEnoder", "outputEnging", "inputChoding", "sourceEnacing", "inputCodling", "inputEncling", "inputCododing", "inputEngale", "sourceEncoding", "inputencling", "inputPackging", "inputEnging", "inputEncoder", "inputencacing", "sourceEncing", "inputEngging", "inputEnoder", "sourceEning", "inputCoding", "sourceEnling", "inputEngoder", "outputEnale", "inputCodacing", "contextEnale", "inputChale", "inputChoder", "outputEnoding", "inputPackoding", "sourceEncling", "inputEnoding", "contextEncale", "inputencing", "contextEnoder", "contextEnoding", "inputEncging", "inputencoder", "inputEnling"], "remainingArgs": ["mainingGS", "remgoingGS", "resainingParameters", "remendingItems", "resainedArgs", "remainedArgs", "trainingArgs", "mainedParts", "remainingParts", "trainFrames", "remainingLinks", "remainingItems", "remainArgs", "remistingGS", "resainingargs", "remgoingJs", "remainedBlocks", "resainingGS", "trainingFrames", "resainedLinks", "trainingGS", "remainedParameters", "mainedJs", "resainedBlocks", "mainedArgs", "remainedFrames", "trainItems", "remgoingArgs", "remainBlocks", "trainingItems", "remainFrames", "remainedargs", "remainedItems", "removalBlocks", "remainedLinks", "removalParameters", "resainedargs", "resainedItems", "remainedGS", "trainGS", "remendingArgs", "mainingJs", "remainedJs", "mainedGS", "remainingJs", "remgoingParts", "remgoingItems", "remainedParts", "remainsBlocks", "mainingParts", "remainJs", "resainingLinks", "resainingArgs", "remainGS", "remendingGS", "trainArgs", "remainsParameters", "remainLinks", "removalGS", "removalArgs", "remainsGS", "remainingBlocks", "remistingLinks", "remainItems", "resainingItems", "remainingFrames", "remistingArgs", "remgoingargs", "resainedGS", "remainsArgs", "remainingargs", "remainingParameters", "remendingFrames", "remistingBlocks", "mainingArgs", "resainedParameters", "resainingBlocks", "remainingGS", "remainParts", "remainargs"], "inputFile": [" inputFILE", "inputLine", "Inputfile", "inputPlace", "requestFile", "outputLike", "inputLike", "outputPath", "InputFILE", "hiddenPath", "InputPlace", "inputfile", "inputPath", "hiddenfile", "acceptPlace", "InputPath", " inputLine", "requestPath", " inputPath", " inputLike", "requestFILE", "hiddenLike", " inputfile", "hiddenFile", " inputPlace", "inputFILE", "acceptLine", "InputLine", "outputfile", "InputFile", "acceptfile", "requestfile", "acceptFile"], "outputFile": ["outputFiles", " outputFiles", " outputDir", " outputfile", "clientDir", "writefile", "coinfile", "inputfile", "OutputDir", "cacheFile", "OutputFile", "outputDir", "OutputDo", "clientFiles", "clientDo", "writeFile", "coinFile", "outputFolder", "cacheFilename", "writeFolder", "Outputfile", "outputfile", "coinFolder", "OutputFiles", "writeDo", "outputFilename", "inputDir", "cacheDir", "outputDo", " outputDo", "OutputFilename", "clientFile", "cachefile", "inputFilename", " outputFolder", "coinDo"], "out": ["ins", "output", "OUT", "gr", "ex", "screen", "list", "gen", "con", "ln", "net", "io", "inf", "print", "cfg", "sys", "user", "on", "err", "in", "conn", "outs", "error", "writer", "ou", "inv", "pretty", "ser", "all", "report", "session", "init", "dir", "obj", "res", "aos", "msg", "inter", "up", "inner", "manager", "null", "log", "Out", "temp", "outer", "n"]}}
{"id1": "14794404", "id2": "16820041", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["decryptSecret", "decryptedPass", "encipherSecret", "encryptedPass", "decryptpassword", "decryptedSecret", "decryptedpassword", "decryptPass", "encryptedSecret", "encipherpassword", "encryptionPass", "encryptionpassword", "decryptedPassword", "encryptPass", "encryptionSecret", "encryptionPassword", "encryptedpassword", "encryptSecret", "decryptPassword", "encipherPassword", "encryptpassword", "encipherPass"], "password": ["value", "Password", "pattern", "data", "message", "sword", "email", "description", "secret", "string", "token", "path", "content", "user", "phrase", "database", "entry", "text", "past", "login", "attribute", "prefix", "key", "address", "directory", "name", "word", "hash", "number", "username", "input", "pass", "filename", "reset", "shadow", "padding", "wordpress", "command", "w"], "encryptedPassword": ["updatedPassword", " encryptedpassword", "installedDirectory", "ryptedpassword", "confirmedPassword", "encryptedStatement", "coloredPassword", " encryptedGuest", "updatedpassword", "encryptedDatabase", "coloredStatement", " encryptedDirectory", "ryptedDatabase", "encryptedDirectory", "updatedAttribute", " encryptedDatabase", "confirmedpassword", "ryptedDirectory", " encryptedStatement", "coloredDatabase", "finishedpassword", "encryptedGuest", "installedPassword", "encryptedConnection", " encryptedAttribute", "initializedStatement", "initializedConnection", "installedDatabase", "initializedDatabase", "initializedPassword", "updatedGuest", "finishedPassword", "coloredConnection", "encryptedpassword", "installedAttribute", "finishedGuest", "encryptedAttribute", "confirmedDatabase", "updatedDirectory", " encryptedConnection", "confirmedDirectory", "finishedDatabase", "updatedDatabase", "ryptedPassword"], "md5": ["dig3", "md8", " md8", " mdle", "dig25", " MD3", "sha5", "MD2", " md512", " Md8", "md3", "dig5", " MDle", "MD512", " md2", "mdle", "sha2", "MD5", "sha7", "md512", "md25", " md25", "MD7", "MD3", " Mdle", " md7", " md3", " Md3", " MD5", "md7", "sha512", " MD2", " Md5", "dig2", " MD8", "MD25", "md2"], "digest": ["Digness", "hexested", "Digester", "mdse", "digum", "Digested", "hashEST", "hexness", "mdests", "hashum", "mdested", "mdEST", "digested", "DigEST", "hashester", "digests", "mdum", " digEST", "digse", "digness", " digse", "hexEST", "Digest", "hexest", "Digse", "hashest", "mdness", "Digum", "mdester", "mdest", "Digests", "hashested", "digEST", "digester", " digests"], "i": ["mi", "z", "u", "iq", "id", "b", "pi", "ri", "ix", "ii", "si", "ai", "io", "bi", "yi", "n", "q", "my", "m", "err", "sim", "me", "in", "multi", "ic", "c", "it", "ei", "li", "major", "ij", "a", "j", "span", "ti", "xi", "init", "key", "x", "hi", "ji", "ie", "zi", "phi", "y", "ind", "is", "ui", "gu", "iter", "conv", "di", "gi", "uri", "ci", "ip", "ski", "\u0438", "t", "o", "qi", "point", "im", "index", "I"], "hex": ["mix", "cmd", "sh", "exp", "cf", "com", "ex", "alpha", "solid", "rh", "hl", " Hex", "color", "ne", "form", "print", "percent", "str", "rendered", "term", "raw", "ph", "tex", "sv", "des", "dump", "rex", "x", "xf", "cert", "ch", "none", "hash", "zip", "flash", "def", "kw", "comp", "h", "check", "uint", "full", "br", "txt", "pex", "serial", "unsigned", "iter", "json", "lit", "oct", "tx", "sex", "html", "temp"]}}
{"id1": "7468827", "id2": "10158738", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"run": ["running", "f", "invoke", "poll", "exec", "fin", "Run", "work", "task", "launch", "begin", "process", "test", "hello", "block", "runner", "login", "execute", "unit", "call", "loop", "submit", "uri", "start", "download", " Run", "go", "func"], "con": ["cn", "const", "cal", "en", "co", "cf", "mos", "ran", "rc", "com", "dial", "connect", "nc", "canon", "sin", "don", "cc", "ln", "un", "cgi", "conn", "ic", "c", "pen", "re", "Con", "comm", "acon", "bon", "connection", "gc", "Conn", "ain", "cos", "act", "ch", "cp", "pc", "CON", "open", "out", "ob", "pl", "cur", "syn", "ctrl", "win", "conv", "create", "conf", "cone", "cons", "cl", "ct", "xc", "cm", "go", "fc", "cont", "can"], "encodedPassword": [" encodedEmail", " encodedpassword", "encodingPassword", "encodingpassword", "ecodedPass", "encodingSecret", " encressedPassword", "encryptedPass", "ecodingPassword", "encressedEmail", "encryptedEmail", "encressedPassword", "ecodedpassword", " encressedSecret", "encodedpassword", "encodingPass", "encodedPass", " encressedpassword", "enccodedPassword", "ecodedPassword", "encressedSecret", "ecodingPass", "encryptedSecret", "encodedEmail", " encodedSecret", "enccodedPass", "encodingEmail", "encryptedpassword", "encressedpassword", "encryptedPassword", "ecodingpassword", "encodedSecret", "enccodedpassword", " encressedEmail"], "encoder": [" encoding", "decoded", "Encaser", "ecODE", "decODE", "decoder", "Encoder", "encoding", " encaser", "encaser", "ecoding", "enODE", "Encater", "enoding", "encoded", "ecoded", "enoded", "encODE", "ecoder", "Encoding", "enoder", "enater", "encater", "enaser", " encater", "decoding"], "in": ["ins", "din", "inside", "en", "ri", "p", "ex", "IN", "sin", "inn", "ai", "io", "inf", "un", "cin", "gin", "on", "bin", "from", "it", "ic", "init", "ain", "per", "ind", "is", "inc", "out", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "asin", "isin", "info", "read", "In"], "fos": [" fres", "ffos", "foss", "fres", " fout", "floss", "Foss", "ffoes", "foes", " foss", "boss", "Fout", "poes", "boes", "ffout", "ffOS", "FOS", "bios", "bres", "bos", "flos", "fOS", "pos", "floes", "poss", "Fos", " fios", "Foes", "flres", "fout", " fOS", " foes", "pios", "flios", "fios"], "bout": ["bouter", "backOut", " bcan", "sboe", "nbout", "sbOut", "Bcan", "nbouter", "boe", "Binner", "obout", "bco", " bouter", " bouts", "binner", "sbouts", " binner", "sbout", "obex", "bcache", " bco", " bcache", " boe", "bbout", "bex", "nbcache", "wbex", "bbco", "BOut", "Bout", "bbouts", "wbout", "bouts", "wbcache", "bboe", "bbex", " bOut", " bex", "bbOut", "obouts", "nbex", "backcan", "bOut", "wbouter", "bcan", "obco", "backinner", "backout"], "data": ["image", "DATA", "rel", "value", "video", "ata", "dl", "dat", "message", "window", "content", "chain", "sequence", "buffer", "normal", "valid", "block", "zero", "raw", "entry", "rew", "size", "table", " DATA", "step", "what", "all", "al", "batch", "body", "word", "good", "def", "extra", "out", "done", "row", "default", "mu", "bytes", "log", "sample", "next", "mat", "d", "info", "result", "n"], "x": ["k", "z", "pe", "xs", "v", "p", "ix", "dx", "xes", "ex", "xxx", "mx", "index", "xa", "xy", "xx", "ax", "xxxx", "X", "step", "xp", "j", "xi", "px", "fx", "xf", "lex", "ox", "wx", "xxxxxxxx", "y", "act", "rx", "no", "d", "i", "l", "tx", "t", "ux", "xc", " i", "w", "inx", "n"], "lastIteraction": [" lastiterative", "lastiteration", "lastiteraction", "lastiterative", "lastinterval", " lastiteraction", "lastInterval", "lastinteraction", " lastIteration", "lastinteration", "lastIterative", "lastIteration", " lastiteration", "lastInteraction", " lastIterative", "lastinterative", "lastiterval", "lastInteration", " lastIterval", "lastInterative", "lastIterval", " lastiterval"], "e": ["f", "u", "pe", "ine", "en", "exp", "p", "v", "ex", "ec", "er", "ent", "te", "ev", "ae", "s", "ate", "ne", "le", "eu", "ed", "E", "err", "m", "me", "c", "error", "ei", "or", "re", "a", "de", "note", "ie", "y", "be", "event", "element", "h", "se", "r", "i", "oe", "es", "g", "l", "o", "eeee", "t", "d", "ee", "w", "n"]}}
{"id1": "15472181", "id2": "15500892", "code1": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getInputstream", "getStreamSource", "createInputstream", "getContentSteam", "getErrorSteam", "getItemStream", "getStreamFile", "createInputStream", "getErrorChannel", "createOutputSource", "getStreamStream", "createInputSource", "createOutputFile", "getContentChannel", " getInputSteam", "getInputFile", "getInputSource", "getInputView", "getErrorView", "getOutputstream", " getOutputSteam", " getOutputChannel", "getItemFile", "getErrorStream", "getStreamstream", " getOutputStream", " getInputView", "getOutputChannel", "getOutputSource", "getItemstream", "createInputFile", "getContentStream", "getContentView", "getOutputFile", "getOutputSteam", "getInputSteam", "getInputChannel", "createOutputStream", "getOutputView", "getItemSource", "createOutputstream", " getOutputView", " getInputChannel", "getOutputStream"], "item": ["el", "object", "value", "server", "store", "id", "Item", "p", "question", "match", "pattern", "items", "string", "token", "path", "test", "m", "val", "claim", "it", "status", "spec", "link", "what", "prefix", "key", "name", "event", "this", "template", "source", "title", "iter", "row", "ip", "stuff", "remote", "info", "local"], "is": ["isa", "sis", "fs", "isl", "ins", "lis", "iss", "bs", "bits", "ris", "serv", "ists", "isi", "us", "si", "ai", "ms", "iso", "ism", "in", "ic", " cis", "bis", "tis", "ims", "as", "IS", "iris", "mis", "Is", "isc", "source", "isu", "es", "os", "ip", "ais", "its", "ist", "isin", "im", "ios"], "urlc": ["sslc", "urlcache", "urlC", "Urlcache", "urll", "httpci", "sslcor", "nlc", "Urll", "rlcu", "rlC", "nlci", "UrlC", "urlcon", "urltc", "urlcs", " urltc", "sslcu", "sslcache", "Urlcon", "sslC", " urla", "sslcon", "httpcache", "rlcor", "zipcu", "urlcu", "nlcs", "zipcor", "httpcon", "httpc", "urlbc", "httpcs", "sslcs", "zipC", "llC", "rlc", "urlac", " urlbc", "Urlc", "httpC", "lll", "httpbc", "lla", "sslci", "urla", " urll", "urlci", "llc", "Urltc", "nlC", " urlac", "httptc", " urlcache", "httpac", "Urlac", "urlcor", "Urlbc", "zipc", " urlC", "Urla"], "url": ["loc", "rel", "f", "host", "sl", "cmd", "ssl", "gl", "b", "git", "ls", "dl", "il", "hl", "char", "bel", "google", "github", "web", "ref", "str", "ll", "xml", "raw", "http", "rl", "li", "re", "ul", "nl", "link", "comm", "www", "browser", "ur", "impl", "URL", "builder", "build", "mount", "call", "lt", "client", "full", "get", "r", "uri", "Url", "l", "null", "cl", "tool", "download", "util", "html", "history", "handle"], "current_source": ["local_name", "current__source", "current__name", "current__format", "current_name", "current__site", "local_source", "local_format", "current_site", "local_site", "current_format"], "i": [" j", "cli", "mi", "z", " ii", "b", "p", "ix", "ini", "I", "ii", "si", "e", "ai", "bi", "chain", "yi", "n", "set", "iu", "ic", "multi", "ei", "c", "it", "li", "ti", "j", "xi", "init", "x", "hi", "zi", "menu", "phi", "y", "ind", "slice", "ui", "gu", "conv", "di", "gi", "ci", "ip", "index", "pi"], "udp_port": ["udP_port", "udpThePORT", "udpTheport", "udP_ort", "udpTheaddress", "udcp_device", "udp_p", "udP_p", "udpThedevice", "udP_ports", "udp_device", "udcp_address", "udp_ort", "udp_address", "udcp_port", "udp_PORT", "udcp_PORT", "udp_ports"], "udp_baddress": ["udp_Battribute", "udp_pbconnection", "udp_rbaddress", "udp_BAddress", "udp_pbaddress", "udp_daddress", "udp_dcontroller", "udp_nbaddress", "udp_rbAddress", "udp_nbcontroller", "udp_rbattribute", "udp_bcontroller", "udp_nbAddress", "udp_pbAddress", "udp_dAddress", "udp_dattribute", "udp_Baddress", "udp_battribute", "udp_nbconnection", "udp_pbcontroller", "udp_bconnection", "udp_dconnection", "udp_bAddress"], "s": ["fs", "f", "ins", "ats", "search", "bs", "cs", "p", "rs", "sts", "ls", "e", "string", "ys", "ms", "S", "ns", "str", "ss", "set", "sq", "js", "gs", "ds", "sym", "was", "a", "spec", "sv", "ts", "socket", "des", "sql", "sam", "sb", "less", "h", "full", "se", "g", "es", "os", "l", "abs", "hs", "its", "qs", "ws", "ps", "n"], "t": ["wt", "et", "ot", "rt", "mt", "ty", "p", "ant", "typ", "tc", "te", "ent", "e", "token", "test", "pt", "kt", "term", "tf", "it", "st", "text", "c", "j", "ts", "tag", "y", "tr", "word", "T", "txt", "ta", "template", "title", "td", "tm", "g", "l", "vt", "type", "ct", "o", "att", "not", "at", "tt"]}}
{"id1": "4686922", "id2": "19147281", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesToStream", "extractResources2File", "extractResourceAsfile", "extractResources2Files", "extractResource2Files", "extractResourceAsStream", "extractResources2Stream", "extractResourceFromStream", "extractResource2Stream", "extractResourceAsFile", "extractResourcesTofile", "extractResourceToFiles", "extractResourceFromFiles", "extractResourceTofile", "extractResourcesToFiles", "extractResourceToStream", "extractResourceAsFiles", "extractResourcesToFile", "extractResourceFromfile", "extractResource2File", "extractResource2file", "extractResourceFromFile", "extractResources2file"], "resourcePath": ["ResourceUrl", "ResourceName", "ResourceLocation", "templateName", "resourceUrl", "templatepath", " resourcepath", "attributePath", "attributeLocation", "uriUrl", "ResourceIn", " resourceIn", "Resourcepath", "resourcepath", "uriLocation", "uriName", "resourceIn", "uriPath", "templateIn", "templatePath", "attributeUrl", " resourceName", "attributeName", "resourceName", "resourceLocation", "ResourcePath"], "dest": ["loc", "output", "Dest", "cont", "dat", "self", "home", "target", "origin", "src", "etc", "dist", "to", "orig", "trans", "dir", "coord", "img", "nom", "des", "tmp", "sp", "parent", "this", "good", "opt", "gov", "mem", "comb", "source", "cat", "lit", "null", "desc", "decl", "prop", "rest", "end", "w", "temp", "result"], "in": ["f", "mi", "ins", "din", "inside", "id", "ini", "IN", "sin", "inn", "con", "ln", "ne", "inf", "cin", "gin", "local", "on", "m", "bin", "from", "raw", "it", "or", "resource", "re", "all", "init", "file", "mc", "al", "none", "ind", "is", "inc", "no", "up", "rin", "i", "input", "source", "r", "inner", "iter", "conf", "l", "isin", " din", "In"], "out": ["f", "cn", "ot", "output", "OUT", "en", "co", "b", "v", "again", "cache", " Out", "stable", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "ou", "col", "note", "to", "obj", "res", "aos", "tmp", "nt", "cos", "pool", "ch", "can", "client", "no", "write", "i", "oss", "conv", "inner", "os", "null", "na", "o", "t", "exit", "Out", "at", "w", "outer", "n"]}}
{"id1": "22441244", "id2": "8216539", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"send": ["sent", "Send", "reply", "security", "transfer", "message", "print", "set", "push", "post", "add", "apply", "export", "report", "init", "build", "msg", "execute", "mail", "write", "get", "submit", "create", "parse", "end", "save"], "hsession": [" HSession", "rssession", "HSessions", "HSess", "hhhip", "hhession", "hsess", "hhsession", "rsess", "hession", "HSpace", " HSess", "hssession", " HSsession", "HSettings", " HSpace", "HShip", "hsessions", "HSsession", "rspace", "hship", "hhip", "hsettings", "hspace", "rsession", "hhessions", "hhettings", "hessions", "HSession", "hettings"], "session": ["context", "object", "store", "cache", "message", "instance", "content", "driver", "state", "set", "view", "Session", "connection", "sid", "document", "parent", "ess", "name", "event", "lock", "client", "ession", "account", "manager", "ip", "password", "job"], "repositoryName": ["repoositoryName", "repositoryData", "repositoryTitle", "repositorTitle", "repoitoryTitle", "reposoryName", "repositorNAME", "reposoryNAME", "reposositoryTitle", "repositoryPath", "repositoryNAME", "reposositoryPath", "repoositoryTitle", "repositableData", "repositionPath", "repositionNAME", "repositoryname", "repoositoryPath", "reposoryname", "repoositoryData", "reposositoryData", "repoositoryname", "repositorPath", "repoitoryname", "repositableName", "repoitoryNAME", "repoositoryNAME", "repositionName", "repositableNAME", "reposoryData", "repoitoryName", "repoitoryData", "reposositoryName", "repositionTitle", "repoitoryPath", "reposositoryname", "reposositoryNAME", "repositablename", "repositorName"], "ideIdint": ["ideIdline", "ideidint", "ideIdentno", "ideThline", "IDEIdint", "ideIDline", "ideInfoint", "IDEIdINT", "IDEidINT", "IDEidint", "ideIdno", "ideThno", "IDEidst", " ideIdline", "ideInfoINT", "ideIdind", "ideIDind", "ideDint", "ideDINT", "ideInfost", " ideThind", "IDEIdst", "ideThind", "ideIdINT", "ideidst", "ideIdentline", "ideIDno", "ideIdentint", "ideIDint", "ideIdentind", " ideThint", "ideDst", "ideIdst", "ideThint", " ideThline", "ideidINT", " ideIdind", " ideIdno", " ideThno"], "to": ["eto", "top", "tp", "co", "too", "tel", "about", "token", "target", "addr", "st", "by", "toc", "range", "phone", "To", "topic", "po", "TO", "auto", "address", "tr", "pos", "no", "client", "pro", "company", "ta", "os", "route", "ato", "o", "t", "site", "contact", "tt"], "cc": ["cn", "cloud", "cmd", "co", "cs", "cf", "rc", "ico", "ec", "sc", "CC", "tc", "cin", "ac", "ic", "toc", "control", "dc", "ca", "cv", "cca", "cb", "cci", "mc", "cp", "cmp", "cy", "company", "cr", "ctrl", "cl", "cd", "ci", "ct", "ce", "cm", "ck", "fc"], "bcc": ["rbce", " bCC", "rbcc", "vcc", "cbcc", " bck", "rbcy", "vce", "rbCC", "vcy", "cbck", "bck", "bce", "bcm", "sbce", "cbcm", "cbCC", "vck", "sbck", "sbcc", "bcy", "bCC", "sbcy", " bcm", "rbck", "rbcm"], "subject": ["host", "header", "id", "security", "message", "description", "content", "form", "face", "text", "author", "note", "metadata", "comment", "prefix", "heading", "topic", "Subject", "name", "mail", "template", "title", "source", "filename", "head", "uri", "html"], "body": ["top", "object", "output", "binary", "b", "shell", "other", "data", "message", "description", "back", "content", "business", "ody", "files", "any", "buffer", "bill", "ODY", "Body", "text", "part", "post", "news", "response", "inline", "note", "bh", "comment", "report", "query", "layout", "hex", "code", "base", "params", "name", "zip", "no", "line", "mail", "h", "template", "title", "source", "parts", "head", "inner", "null", "json", "url", "default", "padding", "summary", "bytes", "background", "html", "handle"], "attachments": ["attachachment", "Attachments", "atttypes", "Attachresses", "Attachtypes", "attachresses", "achmentments", "achmenttypes", "attments", "attresses", "attachtypes", "achmentresses", "Attachachment", "achmentachment"], "isHtml": [" isHHTML", " isWhtml", "ishtml", "isWhtml", "isJap", " isWhhtml", "isVip", "isJtml", "IsHtml", "isVtml", " isHhtml", "isWhHTML", "isWhhtml", "IsHhtml", "isChhtml", "IsHttp", "isChHTML", "isVhtml", "ishhtml", "isHip", "isHHTML", "isWhip", "ishap", "isJhtml", "isJttp", "IsHap", " isWhHTML", " isWhip", "ishttp", " isHip", "isHap", "isChip", "isHttp", "isChtml", "isHhtml", "isVHTML"], "charset": ["Charsetter", "chippetter", "charsets", "chippets", "quatset", "quarset", "charspace", "chARSET", "clerspace", "charsec", "chacterspace", "chARSetter", "CHarsets", "channelsetter", "chARSetic", "ChARSetter", "Charsetic", "chatset", "chersets", "chippET", "cherspace", "CHarset", "quatsale", "chippale", "charsET", "chARSpace", "channelset", "chersetter", "chablesec", "CHippET", "quarsec", "chatsec", "clersets", "chableset", "charsett", "ChARSet", "channelsetic", "CharsET", "charpetter", "charpet", "charsetter", "chablesale", "chactersetter", "clarsetter", "cherset", "CHarsett", "charpET", "CHippets", "charpetic", "chippett", "quarsale", "quatsetter", "CHippett", "charpett", "clerset", "ChARSetic", "channelsET", "quatsec", "clarspace", "chactersets", "clarsets", "chablesetter", "chARSets", "CHippet", "chatsetter", "chippec", "chatsale", "charsetic", "ChARSET", "charsale", "CHarsET", "clarset", "chacterset", "chippet", "charpets", "clersetter", "chARSet", "Charset", "quarsetter"], "headers": ["dr", "header", "comments", "fields", "authors", "types", "ers", " trailers", "files", "ilers", "relations", "users", "limits", "metadata", "codes", "heads", "params", "members", "keys", "ors", "details", "head", " heads", "lines", "names", "ters", "ppers"], "priority": ["context", " urgency", "flags", "comments", "id", " severity", "position", "grade", "security", "profile", "level", "description", "properties", "order", "due", "origin", "state", "status", "phone", "prefix", "pos", "company", "serial", "title", "policy", "primary", "password"], "email": ["initial", "Email", "et", "el", "object", "ssl", "server", "domain", "office", "output", "shell", "search", "liner", "license", "voice", "model", "die", "message", "ome", "instance", "detail", "enter", "il", "er", "external", "description", "e", "fax", "ne", "delete", "print", "test", "database", "xml", "example", "entry", "view", "em", "http", "response", "password", "link", "note", "ell", "ilo", "all", "report", "comment", "label", "document", "gmail", "console", "address", "msg", "event", "element", "line", "mail", "call", "company", "template", "oe", "reset", "echo", "url", "log", "sample", "contact", "html", "ee", "result"], "user": ["entity", "output", "uid", "actor", "id", "person", "match", "student", "profile", "usr", "admin", "owner", "USER", "me", "from", "ident", "author", "by", "use", "users", "usage", "browser", "creator", "login", "connection", "name", "system", "client", "usa", "used", "username", "account", "auth", "manager", "ip", "human", "util", "User", "result"], "identity": ["ententity", "IDENTitate", "personITY", "identicate", "entity", "IDENTiciary", "IDENTator", "presententity", "ethnicentity", "primicate", "equator", "identality", "identitate", "ethnicitate", "personicate", "presentitate", "primity", "identalty", "idententity", "instentity", "IDENTalty", "idality", "personity", "personificate", "identificate", "primificate", "IDENTificate", "equalty", "ethnicularity", "IDENTITY", "IDENTity", "identiciary", "identance", "IDENTularity", "IDENTifier", "solidality", "instifier", "instator", "presentity", "IDENTality", "instularity", "primentity", "recognentity", "solidity", "identularity", "IDENTance", "ethnicity", "personentity", "identITY", "idularity", "primance", "recognicate", "idity", "instalty", "equentity", "idiciary", "presentularity", "entifier", "personiciary", "solidentity", "identator", "entularity", "identifier", "IDENTentity", "idITY", "IDENTicate", "equity", "recognity", "instity", "solidularity", "recognance"], "_returnPath": [" _errorAddress", "_getPath", "_savepath", "_ReturnPath", "_requestName", "_ReturnPoint", "_resultTo", "_getDir", " _returnAddress", "_savePath", "_deleteTo", "_errorTo", " _errorPath", " _returnPoint", "_ReturnName", "_errorAddress", "_errorpath", "_retpath", "setsavepath", "_errorPoint", "_saveTo", "_returnDir", "_returnTo", "_deletePath", "setreturnUrl", "setsaveTo", "setreturnpath", "_returnUrl", "_resultPoint", "_errorName", "_retDir", "_getCode", "_getTo", "setsavePath", "_returnAddress", "_replyCode", "_replyPath", " _errorName", "_returnCode", "_replyDir", "_retPoint", "_deletePoint", "_requestPoint", " _returnName", " _errorPoint", "_retUrl", "_errorPath", "_ReturnAddress", "_errorUrl", "_errorLocation", "_retTo", "_returnpath", "_saveUrl", "_requestAddress", "_deletepath", "_requestPath", "_retLocation", "_retCode", "_retPath", "_resultPath", "_returnLocation", "setreturnPath", "_returnPoint", "_resultLocation", "_returnName", "setsaveUrl", "setreturnTo"], "_from": ["_reset", "longreset", "\tform", "letsource", "_about", " _reset", "\tactor", "longsource", "\tauthor", " _source", "longfrom", "_author", "_source", "_owner", " _actor", "longto", "_actor", "remowner", " _form", " _author", "remaddr", "letabout", "_local", "\tfrom", "_addr", "_form", "letfrom", "letto", "remfrom", " _about", "remlocal"], "_replyTo": ["_responseOf", "_closeTo", "_replyOf", "_backFrom", "_responseTO", "_replyPath", "_replyTO", "_returnFrom", "_ReplyTO", "_ReplyPath", "_commentOf", "_ReplyFrom", "_responseFrom", "_returnTo", "_responseTo", "_backTO", "_respondOnly", "_ReplyTo", "_closeLine", "_closeTO", "_backPath", "_responseLine", "_replyOnly", "_respondFrom", "_commentTO", "_returnOnly", "_commentLine", "_ReplyOnly", "_commentTo", "_returnTO", "_respondTo", "_replyFrom", "_responsePath", "_respondTO", "_closeOf", "_replyLine", "_backTo"], "_to": ["prisite", "successta", "_ta", "successto", "successsite", "successtopic", "prito", "_topic", "prita", "pritopic", "_site"], "_cc": [" _subject", " _cs", "_cs", "_cca", "_subject", " _cca"], "_bcc": ["_bca", "_bacc", "_wacc", "_rbacc", "_rcc", "_racc", "_rbcc", "_rca", "_rbck", "_rck", "_wca", "_wck", "_rbca", "_wcc", "_bck"]}}
{"id1": "9096319", "id2": "14819747", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "label": 0, "substitutes": {"handleNodeRegainedService": ["handleNodeRegalledService", "handleNoderegainedServices", "handleNodeRegalledSite", "handleNoderegainedSite", "handleNoderegainsSite", "handleNodeRegalledServices", "handleNodeRegainsSite", "handleNoderegainsServices", "handleNodeRegifiedService", "handleNodeRegainedSite", "handleNodeRegifiedServices", "handleNodeRegainsServices", "handleNodeRegainedServices", "handleNoderegainsService", "handleNodeRegainsService", "handleNoderegainedService", "handleNodeRegifiedSite"], "eventID": ["serviceKey", "EventId", "eventUID", "eventId", "EventUID", "nodeType", "EventID", "nodeKey", "nodeId", " eventName", " eventType", "eventKey", "serviceTime", "nodeUID", " eventUID", "serviceId", "eventType", "serviceUID", " eventId", "EventType", "EventTime", " eventKey", "EventName", "nodeName", "nodeTime", "eventName"], "nodeID": ["NodeIT", "localJS", " nodeIT", "serverID", "moduleid", " nodeJS", "odeIDE", "odeID", "moduleIDE", "serverInfo", "nodeInfo", " nodeName", " nodeIDs", "NodeName", "moduleID", "entityId", "nodeId", " nodeId", "nodeIT", "resourceId", "serverId", "serverIDs", "instanceInfo", "NodeIDs", "localID", "volumeName", "NodeID", "moduleId", "entityJS", "volumeId", " nodeInfo", "instanceID", " nodeid", "instanceIDs", " nodeIDE", "localId", "nodeIDE", "serverName", "volumeIT", "moduleIT", "nodeJS", "instanceId", "volumeID", "entityID", "nodeid", "resourceName", "Nodeid", "resourceID", "nodeIDs", "nodeName", "NodeId", "odeId"], "ipAddr": ["ipSender", "ipAddaddr", "ipaddrt", "ipAddrt", "ipAndr", "epAddri", "ipAdder", "ipReshr", "ipAddressrar", "epAddrs", "ipAcr", " ipAddressp", "ipSendr", "epAddressl", " ipAddhr", " ipAddressrs", "ipAddl", "ipAcrs", "ipStorehr", "ipAddressp", "ipAddressri", "ipIntr", "ipAttp", "epAddr", " ipAddaddr", "ipStorer", "ipAddhr", "ipAddsn", " ipAdder", "ipIntaddr", " ipaddrs", " ipAddp", " ipAddn", "ipResrs", "ipAttr", "ipAddp", "ipAddsrs", "ipAddressrs", "ipStorers", "ipIntrs", "ipaddrs", "epAddressri", "ipSendp", "ipAndl", "ipAddresser", "ipAndp", " ipAddrt", "ipaddr", "ipAddri", " ipAttrar", " ipAddressaddr", "epAddressr", "ipAddrar", " ipAddrs", " ipAttr", " ipaddrt", " ipAddrar", " ipAddl", "ipIntp", "ipaddl", "ipResr", "ipAddressr", "ipResrt", " ipAtter", "ipAddrs", "ipAddsr", "ipAndri", "epAddressrs", "ipAddn", "ipAndrs", "ipaddp", "ipAddressaddr", "ipAcn", " ipaddp", "ipAndrt", "ipAttrar", " ipAddrb", "epAddl", " ipAttp", " ipaddr", "ipAddsrb", "ipAddressl", "ipAtter", "ipAddrb", "ipSendrar", "ipStorert", "ipAcrb", " ipAddressr"], "serviceID": [" serviceType", "serviceKey", " serviceKey", "servID", "servName", "ServiceName", "sourceId", " serviceNAME", "sourceJO", " serviceNOTE", " serviceid", "sourceID", "servId", "securityId", " serviceName", "ServiceId", "resourceId", "componentID", "servKey", "serviceLAN", "serviceNAME", " serviceLAN", "securityid", "serviceid", "serviceId", "ServiceNAME", "Serviceid", "sourceName", "serviceType", "componentName", " serviceId", "securityID", "serviceJO", "servLAN", "serviceNOTE", "servid", "componentNOTE", "serviceName", "ServiceNOTE", "componentId", "resourceName", "ServiceLAN", "securityName", "ServiceType", "ServiceID", "resourceID", "servNAME", "ServiceJO", "resourceType", "ServiceKey", " serviceJO"], "eventTime": ["ageType", "Eventtime", " eventTimes", "eventTIME", "eventtime", " eventtime", "attributeTIME", "attributeType", "attributeTime", "ventTimes", " eventType", "ventTime", "agetime", "eventType", "eventTimes", "EventType", "EventTime", "ageTime", "ventType", "EventTIME", "ventTIME", "ageTIME", "attributeTimes", " eventTIME"], "log": [" logger", "ger", "lo", "le", "pel", "err", "set", "link", "note", "de", "report", "tag", "sql", "file", "be", "lock", "pl", "se", "cat", "row", "url", "util", "use", "Log", "cal", "store", "og", "iam", "com", "enter", "ge", "entry", "ar", "it", "error", "or", "prot", "call", "mail", "conf", "l", "tab", "json", "at", "w", "en", "bug", "ex", "channel", "message", "email", "user", "blog", "debug", "base", "msg", "out", "full", "config", "t", "crit", "low", "scale", "ome", "net", "cell", "xml", "gob", "category", "LOG", "event", "zip", "db", "ext", "and", "cont"], "dbConn": ["tableObj", "sbCon", "fbConn", "Dbconn", "tableConn", " dbObj", "DbConn", " dbConnect", "DBCon", "sbObj", "dbCons", "dbconn", "bdConnect", " dbCons", "sbConnect", "bdCon", "sbConnection", "bdObj", "DBCons", " dbconn", "DBConn", "DbConnect", "cbConnection", "dbCon", "gbCon", "dbObj", "dbConnect", "dbConnection", "userCon", "gbConn", "bConn", "bCons", "gbConnect", "cbCon", "gbConnection", "fbCon", "tableCon", "userConn", "cbConn", "fbObj", "userObj", " dbCon", "bdConn", "DBConnect", "bConnect", "userConnect", "DbObj", "sbConn", "fbConnect", "cbConnect", "tableconn", "DbCon", "bCon"], "outageUpdater": ["outageUpdatedager", "outageUpnomer", "outageUpdatater", "outageUpnater", "outageUPtoder", "outageUndter", "outageUtDrer", "outageUppoder", "outageUptatter", "outageUpdatedATER", "outageUPdarer", "outageUpndATER", "outageUpnarer", "outageUpdATER", "outageUplitter", "outageUdataser", "outageUpddater", "outageUplaters", "outageUprater", "outageUpdataser", "outageUpmomer", "outageUpDarer", "outageUPtatter", "outageUdatoder", "outageUpmetter", "outageUpDaser", "outageUpmrer", "outageUPtter", "outageUpDaters", "outageUplater", "outageUpdatedarer", "outageUpmATER", "outageUPdter", "outageUpDrer", "outageUpdetter", "outageUpmaser", "outageUpDager", "outageUpdter", "outageUpdatemaser", "outageUtdater", "outageUptaser", "outageUplarer", "outageUpmter", "outageUpmater", "outageUpndater", "outageUpnditter", "outageUdetter", "outageUtdrer", "outageUPdaters", "outageUpdatedaser", "outageUpnoder", "outageUpdrer", "outageUpdager", "outageUpdomer", "outageUppater", "outageUPdATER", "outageUpdatemomer", "outageUpDatter", "outageUtDaser", "outageUptager", "outageUpdaterager", "outageUpdoder", "outageUtdaser", "outageUPdatter", "outageUptoder", "outageUptter", "outageUPdaser", "outageUptaters", "outageUpdaser", "outageUpdatemater", "outageUpnitter", "outageUdatater", "outageUprager", "outageUpDATER", "outageUndater", "outageUplATER", "outageUpDater", "outageUplter", "outageUpdaterater", "outageUpraters", "outageUptitter", "outageUPtitter", "outageUpmitter", "outageUnndter", "outageUdaser", "outageUpdatetter", "outageUpprer", "outageUPnATER", "outageUprarer", "outageUtdoder", "outageUpDoder", "outageUpdatter", "outageUptarer", "outageUPnaters", "outageUpnaser", "outageUpdatedaters", "outageUpdboder", "outageUpdbetter", "outageUdatetter", "outageUPtaser", "outageUtDoder", "outageUppaser", "outageUpnter", "outageUpnATER", "outageUndATER", "outageUdoder", "outageUnndATER", "outageUpddaser", "outageUpdaterarer", "outageUpdarer", "outageUpdatemATER", "outageUPnater", "outageUpdateraters", "outageUPdater", "outageUdater", "outageUtDater", "outageUptater", "outageUpdbater", "outageUnndater", "outageUpnatter", "outageUnditter", "outageUpdbaser", "outageUpdaters", "outageUpdatedomer", "outageUpdatedater", "outageUPditter", "outageUPdoder", "outageUpnaters", "outageUPtater", "outageUPnarer", "outageUnnditter", "outageUPtaters", "outageUploder", "outageUpdatoder", "outageUpditter", "outageUpmoder", "outageUpndter", "outageUpddomer", "outageUpddATER"]}}
{"id1": "16804988", "id2": "13565787", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"init": ["initial", "update", " reload", "launch", " initialization", " construct", " startup", "icon", "Init", "load", " refresh", " constructor", "render", "file", "layout", "construct", " Init", "open", "ui", "create", "close", "uri", "start", " reset", " gui", "index"], "filename": ["f", "original", "bf", "doi", "location", "xxx", "jj", "println", "nm", "description", "string", "fil", "csv", "path", "kl", "fax", "lua", "ename", "origin", "src", "subject", "Filename", "jpg", "FILE", "nl", "fle", "metadata", "prefix", "sql", "jl", "document", "file", "kj", "nil", "fn", "directory", "name", "java", "word", "ren", "slice", "fp", "txt", "ame", "username", "source", "title", "png", "wikipedia", "uri", "json", "fps", "mson", "summary", "journal", "mpeg", "download", "sbm", "tp", "stem"], "dim": ["div", "mi", "wh", "dr", "cal", "du", "mode", "dx", "dat", "sum", "vals", "lim", "m", "val", "gm", "wid", "ds", "size", "dimension", "fam", "ims", "dem", " dimension", "shape", "dir", "sam", "nom", "mn", "late", "coord", "dimensional", "dm", "depth", "height", "def", "mem", "nam", "rm", "tm", "di", "prop", "Dim", "mat", "ext", "d", "im", "xd"], "w": ["wt", "wh", "ew", "v", "fw", "work", "we", "window", "iw", "wal", "nw", "wl", "sw", "m", "weight", "wid", "a", "W", "width", "wb", "x", "rw", "wp", "wa", "word", "hw", "height", "kw", "wo", "win", "wd", " dw", "g", "l", "\u0142", "aw", "ws", "d", "wr", "wk", "n"], "h": ["hr", "k", "f", "z", "ih", "wh", "hz", "th", "en", "sh", "b", "ht", "v", "p", "hang", "rh", "ha", "e", "m", "c", "hh", "he", "ah", "oh", "x", "ho", "H", "hi", "y", "ch", "height", "hw", "kh", "r", "g", "l", "t", "hd", "d"], "in": ["f", "mi", "ins", "din", "en", "pin", "serv", "IN", "inn", "con", "ln", "ai", "io", "inf", "gin", "cin", "on", "kin", "bin", "mm", "from", "conn", "st", "raw", "or", "vin", "and", "a", "nin", "mc", "file", "al", "ma", "body", "ain", "ind", "is", "inc", "out", "rin", "mem", "i", "input", "source", "r", "inner", "l", "include", "o", "isin", "In", "n"], "ff": ["f", "pdf", "ft", "cf", "bf", "fw", "iff", "uf", "lf", "nd", "fm", "alf", "af", "fo", "fe", "FF", "tf", "sf", "xff", "eff", "aft", "ph", "ef", "fx", "df", "fn", "fig", "fp", "fi", "off", "ld", "fl", "buff", "fd", "fed", "fc", "ffer"], "url": ["f", "rel", "sl", "ssl", "gl", "b", "p", "ls", "dl", "gif", "hl", "char", "external", "bel", "kl", "lr", "web", "ref", "str", "ll", "resource", "rl", "http", "ul", "nl", "link", "www", "ur", "URL", "file", "mb", "mount", "mail", "large", "pl", "r", "uri", "Url", "l", "cl", "abs", "fl", "log"]}}
{"id1": "19050432", "id2": "21152728", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openNamedStream", "openNestedRes", "opennamingStream", "opennamingRes", "opennamedClass", "opennamingResource", "openNamingResource", "opennamingClass", "openNamingRes", "openNamedRes", "openNestedResource", "opennamedStream", "openNamedClass", "openNumberedClass", "opennamedResource", "opennamedRes", "openNestedClass", "openNumberedRes", "openNumberedResource", "openNumberedStream", "openNamingClass", "openNamingStream", "openNestedStream"], "name": ["initial", "value", "search", "id", "p", "message", "nm", "description", "string", "path", "ref", "str", "Name", "part", "resource", "size", "link", "alias", "NAME", "prefix", "key", "file", "missing", "address", "word", "ame", "template", "full", "title", "filename", "uri", "null", "type", "url", "named", "names", "password", "use", "local", "n"], "in": ["f", "mi", "ins", "din", "isin", "en", "stream", "pin", "serv", "ini", "IN", "inn", "con", "inf", "gin", "cin", "on", "m", "bin", "from", "conn", "tin", "to", "login", " out", "impl", "as", "mc", "body", "ain", "reader", "pid", "ind", "is", "out", "up", "rin", "i", "input", "inner", "oin", "conf", "asin", "o", "vin", " din", "In", "n"], "propsURL": ["PropsUrl", "proPSUR", "PropsCL", "proprurl", "proppsCH", "propertiesUR", "probsurl", "projsUR", "protsurl", "propertiesCH", "projsURL", "ProPSurl", "proprsURL", "protsURL", "ProPSURI", "Propsurl", "PropsSSL", "ProrsUrl", "proprURL", "proprsUR", "protsUrl", "probsURI", "probsURL", "PropsUR", "projsEL", "propsURI", "progsUR", "prorsEL", "ProPSSSL", "prorsCL", "ProPSUrl", "progsEL", "protsNR", "PropsEL", "propertiesURL", "propertiesCL", "propsEL", "propertiesURI", "propsCL", "proPSSSL", "propsNR", "progsUrl", "PropsURI", "proprUrl", "proPSUrl", "propsurl", "proprNR", "propsSSL", "proPSCL", "propertiesUrl", "prorsUrl", "ProPSNR", "ProPSCH", "proppsCL", "prorsURL", "proprsUrl", "progsURI", "ProPSCL", "ProrsUR", "proprsCL", "propertiesurl", "proppsUR", "progsurl", "propertiesSSL", "propsCH", "prorsUR", "protsURI", "ProrsEL", "proPSURL", "progsURL", "propsUR", "PropsCH", "proPSCH", "ProrsURL", "progsCL", "PropsURL", "proppsSSL", "ProPSURL", "proPSURI", "propsUrl", "proPSurl", "proPSNR", "ProPSUR", "PropsNR", "projsUrl", "probsUrl", "proppsURL", "proppsUrl"], "urlConn": [" urlconn", "urlCon", "slCons", " urlConnect", "urlMem", "webConnect", "urlCons", "lsInit", "handleConn", "urlInit", "httpObj", "UrlConn", "handleConnect", "httpCons", "URLConnect", "lsConnect", "UrlConnect", "slMem", "slConn", "fileCons", "URLConnection", "webInit", "urlconn", "URLConn", "handleCon", "UrlConnection", "httpConn", " urlInit", "httpMem", "fileObj", "handleConnection", "urlObj", "fileConn", "slObj", "urlConnection", "urlConnect", "webconn", "webConn", "lsConn", "fileMem", "URLCon", "lsconn", "UrlCon"], "httpURL": ["ttpURL", "httpUrl", "HTTPDB", "healthurl", "httpsUrl", "hoverURL", "HttpUrl", "HTTPUrl", " httpURI", "httpUR", "httpDB", "httpsUR", "healthUR", "ttpurl", "hoverurl", "healthUrl", "ttpDB", " httpUrl", " httpDB", "httpsURL", "Httpurl", "hoverUR", "httpSSL", "httpURI", " httpurl", "healthURL", "hoverUrl", "HttpURL", "HttpSSL", "httpurl", " httpSSL", "ttpSSL", "httpsurl", "HTTPURL", "HTTPURI", "ttpUrl", "ttpURI"], "hdrVal": [" hdrLen", "hdrEl", "hDRVal", "hlrVal", "hstrValue", "ohdrEl", "hlrval", "hheaderEl", "httpVal", " hheaderValue", "hDRval", "HheaderVal", "hdrval", " hdrval", "ohDRValue", "hDREl", "ohdrVal", "hheaderval", "ohDREl", "HheaderVAL", "ohdrValue", "httpEl", "HdrVAL", "httpValue", "HdrValue", "hDRVAL", "hdrLen", "hdrValue", "HdrEl", " hheaderLen", "ohDRVal", "hdrVAL", "hstrEl", "HheaderEl", "HheaderValue", "hDRLen", "hheaderLen", " hheaderval", "hstrVal", "hheaderVAL", " hdrValue", "hheaderValue", "hheaderVal", "hDRValue", "hlrLen", "httpVAL", "hlrValue", " hheaderVal", "HdrVal"], "code": ["length", "ck", "Code", "value", "header", "id", "rc", "country", "currency", "mode", "xxx", "count", "cont", "message", "level", "description", "color", "cc", "content", "string", "city", "xx", "state", "coe", "magic", "zero", "ode", "text", "c", "error", "sec", "cod", "status", "size", "response", "reason", "comment", "key", "codes", "ack", "cycle", "body", "msg", "ch", "coded", "event", "zip", "no", "ace", "cue", "check", "number", "se", "one", "close", "age", "type", "desc", "ct", "url", "ce", "go", "component", "index", "result"]}}
{"id1": "8490710", "id2": "11484416", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "label": 0, "substitutes": {"actualizar": [" actualisar", " actualizaiar", "ualizAR", " actualizaar", " actualiziar", " actualiser", "ualizaer", " actualizer", "ualizaAR", " actualizeer", "ualizer", "ualizaiar", " actualizeiar", "ualizaar", "ualizar", "ualiziar", " actualisiar", " actualizeAR", " actualisAR", " actualizaAR", " actualizear", " actualizaer", " actualizAR"], "ClassNotFoundException": ["ClassNotfoundException", "ClassNotPresentError", "ClassNotFoundError", "ClassNotPresentException", "ClassNotfoundError"], "Exception": ["Warning", "Exit", "None", "Null", " exception", "Connection", "Option", "Class", "Result", "EX", "Error", "Ex", "Configuration", "E", "Event", "End", "Interface", "File", "Index", "Transaction", "Message", "Instance", "ception", "Example", "ION", "Throw", "Response", "Un", "Type", "Handler", "Time", "Application", "Exc", "Status", "Operation", "T", "Context", "I"], "conn": ["cn", "ann", "cmd", "mt", "exec", "en", "org", "rc", "rs", "ens", "yes", "die", "Connection", "connect", "jp", "nc", "sc", "enc", "ec", "cc", "con", "ln", "sys", "ns", "ctx", "Connect", "ont", "js", "c", "pen", "Con", "comm", "socket", "yn", "gate", " con", "session", "init", "pg", "sql", "connection", "mc", "Conn", "obj", "cert", "nt", "act", "ch", "cp", "pool", "open", "client", "oss", "ctrl", "config", "close", "db", "conf", "ks", "pas", "ct", "ws", "cb", "n"], "ms": ["fs", "uns", "mi", "ins", "terms", "mt", "ats", "xs", "ents", "mos", "rs", "cs", "bs", "arms", "mx", "s", "pers", "Ms", "ml", "windows", "ys", "ns", "sys", "m", "mm", "pm", "mod", "js", "ants", "mes", "cms", "inv", "ts", "ems", "mill", "ims", "md", "mc", "mic", "mn", "ma", "eps", "vs", "mp", "uts", "eds", "res", "ies", "MS", "is", "posts", "ces", "mys", "os", "ks", "ocks", "cus", "qs", "ws", "ps", "sm"], "fechaSystem": ["fetaSystem", "fechiSys", "fechasystem", "fechoasystem", "feshoSystem", "fechisystem", "fechoaSystem", "feshasystem", "fechiSystem", "fechaSys", "fechaeSys", "fochtaServer", "fechoServer", "fochaSTEM", "fechaServer", "fetaSys", "fechoSystem", "fetaesystem", "fechtaSystem", "fetisystem", "fechtaServer", "fechtaSTEM", "fechlaSystem", "fechaesystem", "fechoaSys", "fochtaSystem", "fechaeSTEM", "fetiSys", "feshosystem", "feshaServer", "fetasystem", "fechlaSys", "fechoSTEM", "fechoaServer", "fochaServer", "fochaSystem", "fetaeSystem", "fetaeSys", "fechosystem", "fechaeSystem", "feshaSystem", "fetiSystem", "fechlasystem", "feshoServer", "fechaeServer", "fochtaSTEM", "fechaSTEM", "fechoSys"], "aaaammdd": ["aaaaammd", "aaaamd", "aaaamld", "aaaaammdd", "aaaammds", "aammdd", "aammd", "aaaammmm", "aaaammm", "aaaaammmm", "aaaaumdd", "aaaamdd", "aaaaumd", "aaaaumds", "aaaaummd", "aaammd", "aaaaammm", "aaaaamd", "aammmd", "aaaamds", "aaammdd", "aaaaamdd", "aaammmd", "aaaamlmm", "aaaammmd", "aaammds", "aaammmm", "aammds", "aaaammd", "aaaamldd"], "fzafsis": ["fzajesi", "fzeajsi", "fzeajesi", "fzahsi", "fzeajses", "fzafesi", "fzamsis", "fzamsi", "fzahesi", "fzajses", "fzahses", "fzamesi", "fzeajsis", "fzafses", "fzafsi", "fzajsis", "fzeafesi", "fzeafsis", "fzamses", "fzajsi", "fzeafsi", "fzeafses"], "hhmmss": ["hhMMms", "hmmmss", "hhMMps", "hhmbse", "hhmbss", "hhmbess", "hhmmmps", "hhMMess", "HHmmps", "HHMMss", "hmmbess", "hhmss", "HHmmms", "hmmbs", "hmmbss", "hhmmmse", "hhmmse", "HHmms", "hhms", "hmmbse", "HHmmss", "hmmmse", "HHMMms", "hhMMss", "HHMMps", "HHMMs", "hhmbs", "hmmms", "hhMMse", "hhmms", "hhmmmms", "hhMMs", "hhmmmess", "hhmmms", "hhmmmss", "hhmps", "hhmmess", "hhmmps", "hmmmess"], "sss": ["ossn", "ssl", "sses", "issl", "essjs", "ssjs", "esss", "rssss", "ossss", "rsses", "ssss", "rssl", "essss", "issss", "essl", " ssjs", "essn", " ssss", "esses", "osss", " ssn", "isses", "ssn", "isss", "rsss", "ossjs"], "ss": ["sl", "ssl", "sh", "pres", "iss", "cs", "bs", "rs", "https", "SS", "sd", "lower", "s", "string", "si", "ius", "hess", "ys", "sys", "ns", "xx", "str", "pps", "ress", "ass", "sq", "sf", "js", "ds", "sv", "ts", "tz", "sql", "sb", "ses", "ess", "styles", "less", "good", "\u00df", "txt", "pse", "se", "su", "oss", "pass", "rss", "hs", "tx", "css", "ws", "tt", "ps", "stats"], "fzahsis": ["fizafses", "fzahsi", "fizahsi", "fizahsis", "fizahses", "fizahorus", "fzabses", "fzaqses", "fzahses", "fzaborus", "fizaforus", "fizafsis", "fzaqorus", "fzahorus", "fzafses", "fzaqsi", "fzafsi", "fzabsi", "fzaqsis", "fizafsi", "fzabsis", "fzaforus"], "afectados": ["afittators", "affectulas", "afettators", "afectarians", "affECTado", "affECTarians", "afittadas", "afectators", "affectarians", "afettadas", "afitecturated", "afECTado", "affecturated", "afelectulas", "afelectados", "afettulas", "afectionados", "afittados", "afectionarians", "afectionado", "afectionurated", "affettulas", "afectado", "afECTados", "affettadas", "afectadas", "afitectados", "affettados", "afittulas", "afECTarians", "affECTurated", "afelectadas", "afectulas", "afECTurated", "afecturated", "afettados", "afitectarians", "afelectators", "affettators", "affECTados", "affectators", "affectado", "afitectado", "affectados", "affectadas"]}}
{"id1": "15445861", "id2": "12380475", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", "cpFiles", " cpFile", "cpDir", "copyDir", " copyFiles", "cpfile", " cpfile", " cpFiles", " cpDir", "copyFiles", "cpFile", " copyDir", " copyfile"], "srcFile": ["srcTime", "srcDir", "sourcePage", "sqLine", " srcPage", "destfile", "rcTime", "rcDir", "synfile", "sqTime", "sourceFile", "rcLine", "rcfile", "rcPage", "sqFile", "srcLine", "sysWeb", " srcPath", " srcLine", " srcTime", " srcWeb", "sourcePath", "sourceLine", "srcfile", "rcFile", "sqPage", " srcModel", "synLine", "rcPath", "srcModel", "srcWeb", "srcPage", "synWeb", "sourceDir", "sourceModel", "sysLine", "sourcefile", "sysfile", "sysFile", " srcDir", "destPage", " srcfile", "destModel", "synFile", "srcPath"], "destFile": ["portLine", "gtPlace", "estEmail", "portPage", "gtPage", "destfile", " destfile", "gtFILE", "DestPort", "sourceFile", "expFile", "estFile", "expPlace", "destDir", "optDir", "DestTable", "gtFile", " destFolder", "potPort", "destFolder", "imgfile", "portPlace", "optFolder", "expPage", "sourceFine", "expLine", "gtLine", "DestDir", "destEmail", " destPort", "destPlace", "tomFILE", "DestFolder", "potfile", "potFile", "imgFine", "tomEmail", "optFile", "tomFile", "Destfile", " destTable", "potDir", " destDir", "optTable", "DestFile", "estFILE", "sourceDir", "portFile", "estPort", "gtEmail", "destLine", "imgDir", "destPort", "gtPort", "destTable", "destFILE", "sourcefile", "DestFine", "imgFile", "destPage", "tomPort", "destFine"], "in": ["el", "inside", "din", "irm", "ins", "en", "old", "ini", "ze", "IN", "inn", "con", "io", "inf", "cin", "gin", "on", "mm", "from", "ar", "ic", "it", "by", "init", "al", "ain", "act", "ind", "is", "inc", "up", "rin", "i", "input", "source", "iter", "inner", "info", "isin", "im", "In"], "out": ["cn", "output", "OUT", "co", "v", "dis", "ex", "cache", "sum", "con", "user", "net", "io", "ne", "sys", "n", "on", "err", "outs", "it", "c", "by", "writer", "ou", "and", "to", "obj", "res", "gc", "auto", "aos", "nt", "ch", "client", "write", "up", "one", "inner", "null", "o", "t", "log", "end", "Out", "at", "outer", "can"], "buffer": ["length", "initial", "binary", "cache", "message", "total", "window", "buf", "print", "phrase", "sequence", "stack", "queue", "bank", "block", "raw", "table", "frame", "bar", "bridge", "reason", "comment", "attribute", "paste", "document", "batch", "body", "base", "library", "word", "history", "append", "template", "memory", "display", "mem", "character", "iter", "row", "variable", "Buffer", "buff", "sample", "pad", "command", "bone", "temp"], "no": ["nn", "num", "node", "mo", "sha", "yes", "bo", "total", "orno", "NO", "lo", "un", "ne", "io", "vo", "nos", "ko", "how", "sn", "zero", " NO", "eno", "a", "read", "to", "po", "none", "pos", "No", "nr", "who", "number", "i", "never", " No", "ano", "os", "start", "na", "ni", "o", "not", "go", "index", "n"]}}
{"id1": "4481712", "id2": "15129155", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"deleteObject": [" deleteobject", "destroyObj", "destroyobject", "destroyItem", "deleteObj", " deleteItem", " deleteObj", "getobject", "deleteobject", "getItem", "getObj", "deleteItem", "destroyObject", "getObject"], "id": ["k", "f", "object", "value", "uid", "p", "Id", "data", "message", "kid", "description", "mid", "path", "delete", "ref", "rid", "ident", "it", "link", "tag", "key", "oid", "md", "sid", "event", "hash", "name", "pid", "ID", "h", "vid", "i", "db", "row", "type", "url", "t", "ids", "d", "info", "n"], "conn": ["core", "ann", "cmd", " col", "org", " cx", "port", "enc", "gen", "cc", "err", "pkg", " conv", "socket", "ca", "dc", "pg", " ch", "obj", "Conn", "mn", "wp", "nt", "cp", "pos", "oss", " ex", "cat", " ac", " cp", "local", "host", "ssl", "co", "com", "ens", " cmd", " mc", "jp", "addr", "ctx", "pt", "ll", " c", " cont", "urg", "ch", "ctrl", "close", "conv", "auth", "conf", " rc", "cons", "pas", " ce", "ws", "cb", " mem", "cn", "loc", "en", "here", "bo", "connect", "nc", "con", "nw", "cfg", " dc", "resp", "c", " pc", "priv", "mc", "nick", "win", "ld", " net", "rel", "lang", "cf", " connection", "canon", "net", "sys", "ns", "pub", " comm", " compat", "col", "comm", "gate", " con", "connection", " core", "cert", " win", "act", "open", "client", "cur", " cs", "db", "coll", " db", "ct", "ce", "tp", " cc", "n"], "stmt": ["statpt", " stMT", " stmm", "statm", "Stmb", "astm", "stMT", "statmb", " stmn", "strmb", "STm", "ostmt", "StMT", "strm", "strmt", "utm", "stmb", "Stpt", "stmm", "stpt", "Ststat", "formm", "strMT", "utst", "STMT", "stm", "stmp", "STmp", "formstat", " stpt", "ostpt", "astpt", "formMT", " ststat", "Stmm", "stmn", "STmm", "ostm", " stmb", " stm", "ststat", "astmt", "Stmp", "formmt", "STst", "ostmm", "Stmn", "utmp", "STmt", "strmn", "utmt", "Stst", "astmm", "Stmt", "stst", "Stm", "statmt"], "dbConn": [" dbRec", " dbObj", "DbConn", " dbCt", " dbConnect", "dsCon", "dbCt", "DBColl", "DBConn", "DbConnect", "dsCt", "dbColl", "dbCon", "dsConnect", "dbObj", "dbConnect", "dsConn", "DBObj", " dbCon", "dbRec", "DbColl", "DbObj", "DbCt", " dbColl", "DbCon", "DBRec", "DbRec"], "selfConnection": ["SelfThread", "ownThread", "selfFree", "SelfConnect", "ownLink", "selfCategory", "selfOnly", " selfConnect", "ownConnection", " selfThread", "reConnection", "selfConnect", " selfInfo", "alsoCategory", "alsoLink", "selfconnection", "alsoConnect", "SelfFree", "alsoConnection", "SelfInfo", "Selfconnection", "ownFree", "SelfOnly", " selfOnly", "SelfConnection", "reconnection", " selfconnection", "ownOnly", "SelfCategory", " selfFree", "selfInfo", " selfLink", "ownConnect", "reConnect", "selfThread", "reLink", "selfLink", "SelfLink", " selfCategory"]}}
{"id1": "6966398", "id2": "9805906", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "label": 1, "substitutes": {"reader": ["dr", "mr", "stream", "ri", "rc", "rs", "er", "cer", "driver", "lr", "io", "handler", "buffer", "parser", "wrapper", "loader", "writer", "rl", "runner", "ro", "query", "redo", "builder", "file", " read", " readers", "rr", "rar", "Reader", "rx", "this", "older", "ner", "r", "input", "iter", "inner", "rer", "row", "roller", "sr", "rot", "read", "ocr"], "ks": ["k", "fs", "checks", "icks", "ars", "akes", "kies", "sky", "uk", "cs", "bs", "ros", "ls", "ols", "ips", "mk", "kes", "nets", "km", "ys", "ms", "obs", "ss", "ki", "kr", "ds", "ke", "KS", "kk", "ses", "vs", "eps", "ups", "eks", "ates", "keys", "uds", "ces", "sk", "oss", "kb", "cks", "agles", "hs", "qs", "ans", "ck", "kens", "kas"], "key": ["k", "core", "object", "tk", "sky", "KEY", "ssh", "char", "er", "service", "mk", "Key", "cer", "pair", "user", "owner", "my", "entry", "by", "ke", "sign", "link", "ey", "ca", "ek", "x", "obj", "power", "file", "ox", "base", "y", "hash", "client", "keys", "sk", "trust", "null", "type", "root", "password", "info"], "chain": ["Chain", "stream", "binary", "cache", "channel", "data", "pair", "list", "chains", "string", "path", "box", "form", "group", "sequence", "stack", "test", "bank", "block", "c", "sche", "trace", "table", "frame", "sign", "ca", "range", "ver", "piece", "file", "batch", "code", "base", "pool", "family", "hash", "check", "number", "type", "root", "ce", "password", "component", "result", "can"], "os": ["fs", "oos", "css", "osi", "ot", "bs", "cs", "ls", "ose", "us", "io", "ys", "sys", "ms", "obs", "js", "ds", "oses", "oids", "ts", "bos", "aos", "uts", "ox", "cos", "Os", "pos", "is", "oS", "out", "oss", "ops", "oes", "o", "oso", "los", "OS", "ols", "ps", "ios"], "stamper": ["important", "stAmper", " strampler", " stcampler", " stimper", " stumter", "stimpler", " stammer", "println", "New", "stimmer", "stramPER", "stumper", " stcammer", " stramPER", "stamter", "stAmPER", " strammer", "valid", "stAmmer", "annot", "stammer", " stimter", " stampler", "The", " stumpler", "stimPER", "stimper", "Print", "stramper", "stumpler", "stAmpler", "read", "_", "stummer", " stcamper", " stamter", "strampler", "strammer", " stumper", " stcamter", "this", "good", "def", "stampler", "stamPER", " stamPER", " stramper", "stumter", " stimpler", "font", " stimmer", " stummer"], "appearance": ["appreciation", "patternearance", "Applies", " appearances", "ascears", "accearances", " appeared", "displayeared", "displayreciation", "patternearances", "apears", "suppeared", "Appeared", "atteared", "appearances", "acreciation", "attearances", "apreciation", "acearances", " appearing", "displaylies", "accearance", "displayearances", "Appearances", "ascearing", "displayendix", "patternendix", "displayearing", "appears", "Appearance", "apearing", "applies", "apearances", "patternearing", "displayears", "attlies", "aceared", "aplies", "acearance", "appeared", "acclies", "appearing", "suppearances", "ascearance", " appendix", "apearance", "ascearances", "suppearance", "attearance", "apeared", "appendix", "accears", "displayearance"]}}
{"id1": "16549995", "id2": "15904772", "code1": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"mysqlPasswordHash": ["mysqlPasshash", "mysQLPassHash", "mysQLPasswordUpdate", "mysQLPasswordSalt", "mysqlTokenhash", "mysqlUserhash", "mysqlTokenHash", "mysqlUserSalt", "mysqlPasswordUpdate", "mysqlPasswordhash", "mysQLPassSalt", "mysQLPassUpdate", "mysQLPasswordhash", "mysqlUserUpdate", "mysqlPassUpdate", "mysQLPasswordHash", "mysqlPassSalt", "mysQLPasshash", "mysqlPassHash", "mysqlTokenUpdate", "mysqlUserHash", "mysqlPasswordSalt", "mysqlTokenSalt"], "string": ["object", "value", "cache", "data", "message", "char", "format", "list", "service", "secret", "content", "user", "s", "chain", "print", "sequence", "buffer", "test", "secure", "str", "strings", "space", "network", "text", "ident", "array", "spec", "prefix", "file", "function", "address", "name", "word", "this", "source", "input", "filename", "null", "ring", "type", "url", "site", "password", "escape"], "digest": ["divest", "Diger", "decist", " diger", "dependester", " digested", "descest", "Digester", "decse", " digist", "Digested", "descested", "digist", "divhest", "Dighest", "digum", "encess", " digess", "dependested", "encested", "decge", "mdested", "encum", "decested", "digested", "deschest", "dighest", "digests", "encist", "DigEST", "descgest", "mdum", " digum", " digEST", "descester", "digse", "diger", "descests", "encest", "digess", " digse", "digge", "divester", " digge", " digester", "diggest", "Digest", "mdess", " diggest", "Digse", "Diggest", "decester", "decest", "decer", "Digests", "digEST", "mdest", "dependests", "dependest", "encge", "digester", "divested", "descEST", "descse"], "encodedPassword": ["loadedcodedDescription", "encodingPassword", "encodedDescription", "encashedpassword", "enashedLength", "loadedcodedString", "encodingFilter", "enccodedSecret", "enodedLast", "encachedpassword", "decodedDescription", "enccodedLast", "encashedPassword", "enashedPassword", "encodingSecret", "decryptedDescription", "encryptedColumn", "encodedColumn", "encachedColumn", "encodedString", "enccodedLength", "encodedLast", "loadedodedString", "encodingLast", "encodedpassword", "encodedLength", "enodedPassword", "enccodedPassword", "loadedcodedColumn", "enciedSecret", "encachedString", "loadedodedColumn", "enodedpassword", "enccodedFilter", "enodedSecret", "loadedcodedPassword", "decryptedPassword", "enccodedDescription", "encodingString", "encryptedDescription", "encachedPassword", "encachedLength", "encryptedFilter", "encryptedString", "decodedPassword", "enccodedString", "encodingDescription", "decodedString", "enashedpassword", "encachedDescription", "encodedFilter", "decryptedFilter", "loadedodedDescription", "encryptedPassword", "decryptedString", "encodedSecret", "loadedodedPassword", "encashedLength", "enodedLength", "enccodedpassword", "enccodedColumn", "enciedPassword", "decodedFilter", "enciedLast"], "hash": ["length", "ashes", "ash", "output", "value", "header", "search", "sh", "hz", "sha", "cache", "rh", "sum", "message", "total", "window", "where", "each", "ssh", "color", "Hash", "chain", "print", "test", "stack", "random", "valid", "block", "has", "zero", "array", "score", "cloth", "password", "replace", "report", "all", "oh", "key", "transform", "ashed", "hex", "build", "pool", "flash", "shift", "mask", "height", "this", "check", "dig", "h", "loop", "number", "username", "full", "row", "url", "hed", "filter", "html", "hello", "index", "history", "result", "handle"]}}
{"id1": "4852691", "id2": "20663364", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"hash": ["update", " encoding", "id", " salt", " key", "sum", "string", "Hash", "print", " sum", " equals", " message", " Hash", "sign", " hashing", " check", "dump", "run", "hex", "code", " text", " h", "h", " signature", " fingerprint", " mac"], "data": ["image", "DATA", "value", "output", "ata", "dat", "message", "area", "secret", "content", "string", "form", "sequence", "any", "buffer", "hello", "state", "space", "raw", "text", "what", "command", "dump", "batch", "name", "this", "input", "json", "padding", "bytes", "sample", "info", "password", "d", "result", "action"], "digest": ["dese", "Digute", " digose", "duose", " digested", "duger", " digist", "Digester", "mdse", "duest", " hexests", "digist", "Digested", " hexute", "Digist", "mdested", "mdEST", "digested", "DigEST", "signEST", "digests", "redist", "redest", " digute", " digEST", "digse", " digse", "signest", " digester", "deEST", "Digest", " digger", "digger", "redger", "duist", "digute", "Digse", "redose", "deist", "signse", " hexest", "mdester", "mdest", " hexested", "deest", "Digests", "signested", "digEST", "digester", " digests", "digose"]}}
{"id1": "838844", "id2": "17729554", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"convert": ["compversion", "CONfer", "converted", "CONvert", "consversion", "converting", "unverted", "converts", "Converted", "Conversion", "compverts", "unvert", "compvert", "CONverting", "Confer", "unversion", "Convert", "Converts", "Converting", "confer", "consVERT", "unprocess", "consverting", "CONverted", "conVERT", "consvert", "unfer", "unverts", "CONVERT", "conversion", "CONversion", "conprocess", "compprocess", "ConVERT", "Conprocess"], "src": ["loc", "host", "iv", "rel", "ins", "stream", "rc", "rs", "SOURCE", "RC", "scan", "scene", "SourceFile", "sc", "ebin", "hl", "sin", "cc", "s", "usr", "path", "addr", "sys", "attr", "ource", "str", "st", "from", "sq", "pkg", "func", "http", "inst", "dist", "sit", "upload", "ser", "orig", "req", "ur", "img", "file", "rx", "buster", "txt", "ipl", "source", "input", "filename", "cur", "config", "uri", "start", "url", "sr", "its", "Source", "rest", "href", "cont"], "dest": [" destination", " Destination", "port", "Dest", "dat", "tif", " orig", "disk", "target", "test", "gin", "table", "dist", "orig", "dir", "img", " dst", " Dest", "est", "write", "txt", "source", " destinations", "foreign", "mat", "rest", "temp", "result"], "in": ["ins", "din", "el", "en", "stream", "b", "serv", "IN", "inn", "io", "inf", "cin", "m", "bin", "from", "st", "ar", "as", "sql", "ad", "file", "res", "reader", "ind", "is", "up", "rin", "d", "source", "input", "i", "r", "inner", "l", "isin", "In"], "p": ["f", "pe", "b", "jp", "php", "er", "pers", "dp", "P", "m", "pm", "parser", "py", "pt", "pp", "pd", "pre", "c", "pkg", "part", "ping", "vp", "post", "it", "ph", "j", "pg", "wp", "op", "sp", "prot", "pc", "per", "cp", "lp", "pa", "pro", "fp", "h", "ap", "pl", "i", "r", "g", "l", "parse", "rep", "t", "d", "at", "tp", "ps", "pb", "pi"], "ds": ["bs", "rs", "drivers", " os", "dl", "yes", "aws", "js", "gs", "ts", "ads", "df", "tes", "eds", "ras", "mys", "di", "nas", "ks", "ports", "its", "ods", "d", "gd", "ats", "xs", "ands", "dds", "sets", "dt", "dh", " dd", "DS", "lists", "vs", "uds", "ags", "scripts", "iffs", "ws", "tags", "els", "dd", "terms", " d", " des", "ls", "sd", "s", "tests", "outs", "posts", "docs", "ils", "os", "Ds", "hs", "hd", "ps", "dp", "cs", "sts", "ys", "ns", "obs", "ss", "pd", "dos", "des", " DS", "workers", "eps", "dates", "loads", "points", " ads", "db", "cks", "edes", "qs", "tp", "amps"], "format": ["f", "feat", "top", " Format", "ats", "mt", "output", "MAT", "id", "style", "cf", "mode", "pattern", "fm", "feature", "path", "form", "set", "it", "sche", "status", "table", "size", "spec", "pretty", "tag", "shape", "file", "layout", "act", "settings", "name", "lat", "unit", "template", "source", "title", "policy", "l", "version", "type", "parse", "ct", "mat", "t", "filter", "Format", "at", "module", "fc", "pi"], "hasPixelData": ["HasPixelDATA", "HasPixelData", "hasixelData", " hasPixeldata", " hasPixelDATA", "hasPixeldata", "hasFramedata", "HaspixelData", "HaspixelDATA", "HasPixeldata", "haspixeldata", "hasPixelDATA", "haspixelData", "haspixelDATA", "hasFrameData", "hasixeldata", "Haspixeldata", "hasFrameDATA", "hasixelDATA"], "inflate": ["incelATE", "infolate", "infolocate", "informat", "Informated", "Informat", "infolat", "Informocate", "incelate", "infolated", "invalidicate", "incelocate", "invalidATE", "inflocate", " invalidate", "informocate", "inFlate", "inflated", " inflATE", " invalidicate", "informate", "invalidocate", "Inflate", "Inflat", "inFLate", " invalidocate", "Inflated", "inFlicate", "Informate", " invalidATE", "inFLated", "inFLocate", "inFlocate", "incelicate", "informated", "Inflocate", "invalidate", " inflicate", "inflATE", " inflocate", "inflat", "inFLat", "inflicate", "inFlATE"], "pxlen": ["mxln", "tmplen", "packfun", "packls", "mxlen", "xylen", "pexln", "xpden", "tmpln", "phplength", "packln", "pexlen", "pexden", "mmlin", "pxlength", "mxdec", "phpln", "pexlength", "xylength", "pxlin", "xyln", "xylin", "pxln", "packlength", "xpln", "cplength", "pixellen", "pxls", "cpden", "cpln", "xplength", "pixelfun", "cplen", "tmplength", "packlen", "pxfun", "pexls", "pixells", "xplen", "mmln", "pxden", "mmlength", "mmlen", "tmplin", "pixellength", "phpdec", "phplen", "packdec", "mxlength", "pxdec", "pexfun"], "out": ["crit", "cmd", "output", "store", "OUT", "gr", "ex", "screen", "sum", "list", "user", "net", "io", "group", "print", "sys", "cfg", "ln", "err", "conn", "outs", "writer", "ou", "inv", "pretty", "prefix", "dir", "init", "obj", "res", "aos", "msg", "name", "client", "gov", "inter", "up", "log", "Out", "temp", "outer"]}}
{"id1": "13439950", "id2": "16851955", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["downloadStaticFile", "readRemoteRemote", "readremoteFilename", "downloadRemoteFile", "downloadStaticRemote", "readStaticRemote", "readRemoteFilename", "readRemoteFrom", "downloadRemoteFilename", "readLocalFrom", "downloadStaticFilename", "downloadRemoteRemote", "downloadRemoteFrom", "readLocalRemote", "readLocalFilename", "readremoteRemote", "readremoteFrom", "downloadStaticFrom", "readremoteFile", "readStaticFrom", "readLocalFile", "readStaticFilename", "readStaticFile"], "response": ["image", "onse", "reply", "output", "value", "server", "cache", "data", "message", "relation", "description", "service", "format", "secret", "string", "print", "sequence", "resolution", "str", "block", "example", "resp", "continue", "application", "request", "view", "answer", "network", "status", "report", "connection", "res", "body", "address", "settings", "line", "vector", "source", "respons", "reset", "Response", "version", "json", "summary", "next", "sample", "command", "send", "result"], "url": ["loc", "rel", "el", "sl", "cmd", "ssl", "gl", "b", "https", "dl", "hl", "char", "bel", "lr", "web", "ref", "str", "ll", "ret", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "URL", "build", "base", "name", "mount", "mail", "pl", "lb", "r", "uri", "Url", "l", "abs", "fl"], "is": ["isa", "fs", "sis", "isl", "ins", "lis", "ri", "iss", "rs", "ris", "bs", "ir", "serv", "ists", "isi", "nis", "sys", "ms", "iso", "in", "it", "ic", "sels", "bis", "as", " Is", "IS", "iris", "ates", "Is", "isc", "does", "i", "isf", "es", "os", "\u00eds", "ip", "ais", "its", "ios"], "br": ["hr", "rel", "dr", "bm", "mr", "bl", "b", "bs", "bf", "gr", "bn", "BR", "jp", "adr", "buf", "bp", "vr", "lr", "repl", "bi", "str", "rob", "shr", "bro", "bridge", "fr", "bh", "ro", "browser", "Br", "ber", "ver", "res", "sp", "bt", "tr", "be", "nr", "pr", "cr", "r", "bc", "bd", "rb", "wr"], "s": ["z", "ins", " samples", "ats", "value", " inputs", "b", "rs", "p", "sts", "ls", " gets", "v", "bs", "stats", "ves", "e", "string", "csv", "gets", "sn", "S", "ns", "ms", "str", "m", "ss", " ts", "strings", "sq", "js", "gs", "single", "sym", "a", "j", "sv", "ts", "sql", "sb", "res", "tes", "y", "ies", "less", "sports", "txt", "h", "i", "r", "se", "still", "g", "es", "os", "l", "its", "o", "t", "series", "sample", "qs", "w", "ps", "n"], "eof": ["eeov", "eol", "eif", "seot", "eeOF", "geif", "seof", "Eos", "eeomp", "eeef", " eol", "eot", "eOf", "eeot", "sef", " eov", "eomp", "eeof", "Eef", " eos", "Eol", " eOf", "geof", "eeif", "eeOf", "geOF", "eeol", "ef", "eef", " eOF", " eef", "Eov", "eos", "Eomp", "seef", " eif", "eov", "Eof", "eeow", "EOf", " eow", " eomp", "geow", " eot", " ef", "eeos", "eOF", "eow"]}}
{"id1": "14764852", "id2": "3514286", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"doRequest": ["runQuery", "runRequest", " doResponse", "runGet", "DoRequest", "DoQuery", "doQuery", "doResponse", "runResponse", "DoResponse", " doGet", " doQuery", "doGet", "DoGet"], "method": ["top", "th", "mode", "class", "message", "each", "mid", "process", "path", "m", "Method", "term", "via", "request", "text", "mod", "eth", "pkg", "http", "post", "nom", "send", "tr", "history", "right", "ind", "mount", "met", "rem", "hod", "property", "head", "agent", "type", "url", "METHOD", "period", "rest", "direct", "end", "command", "module", "verb", "action"], "headers": ["terms", "xs", "pres", "writers", "header", "mods", "drivers", "bits", "events", "fields", "authors", "ers", "weights", "files", "actions", "packages", "issues", "links", "options", "ilers", "images", "boxes", "users", "holders", "limits", "codes", "ppers", "reports", "heads", "params", "dates", "members", "modules", "rooms", "keys", "head", "ports", "names", "groups", "frames", "ters", "blocks", "tags", "checks"], "auth": ["cmd", "ssl", "ht", "iam", "mk", "form", "xy", "acl", "ac", "pub", "ic", "pkg", "http", "aut", "password", "upload", "login", "priv", "urg", "img", "cert", "force", "act", "Auth", "cp", "ok", "aud", "help", "lit", "anon", "authent", "pas", "crypt", "ip", "stat", "util", "hd", "cb", "uth", "read"], "target": ["loc", "host", "rel", "top", "scope", "ARGET", "location", "profile", "message", "gt", "peer", "path", "dest", "origin", "state", "iat", "src", "subject", "eth", "resource", "table", "link", "to", "range", "base", "address", "proxy", "arg", "client", "template", "source", "uri", "ip", "url", "tx", "root", "Target", "arget"], "body": ["object", "reply", "b", "bs", "shell", "other", "dis", "data", "message", "description", "content", "ody", "ne", "buffer", "obs", "any", "ODY", "bill", "subject", "Body", "options", "text", "part", "by", "post", "news", "vol", "note", "bh", "report", "comment", "related", "query", "file", "msg", "params", "be", "pos", " Body", "out", "ob", "h", "source", "parts", "se", "db", "null", "json", "bytes", "odies", "plain"], "con": ["cn", "cal", "cmd", "en", "co", "ran", "cf", "cu", "com", "dial", "bo", "dat", "dec", "nc", "connect", "rec", "sin", "ln", "un", "cgi", "conn", "pen", "c", "col", "comm", "Con", "ca", "gate", "bon", "ocon", "ver", "trans", "cb", "Conn", "ain", "fn", "cos", "ch", "cp", "cond", "uc", "CON", "can", "cr", "syn", "cur", "cat", "conv", "ctrl", "conf", "win", "cons", "pan", "pas", "ct", "bur", "xc", "ce", "cm", "go", "compl", "cont", "mon"], "res": ["rel", "gr", "rs", "cs", "red", "ex", "RES", "vals", "reg", "us", "ne", "ms", "val", "ress", "resp", "ret", "news", "re", "inv", "ts", "req", "des", "Res", "obj", "nt", "pr", "rem", "out", "respons", "results", "reset", "cons", "pas", " Res", "rest", "rep", "ps", "result"]}}
{"id1": "21821404", "id2": "20028790", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"getWebPage": ["downloadWebPages", "getDebugpage", "downloadWebpage", "getwebUrl", "getwebPages", "downloadwebPage", "getWebpage", "getLiveUrl", "getWebPages", "getDebugUrl", "downloadWebPage", "getDebugPages", "getLivePage", "getDebugPage", "getWebUrl", "downloadwebPages", "getLivePages", "getwebpage", "downloadWebUrl", "downloadwebpage", "getwebPage", "downloadwebUrl", "getLivepage"], "urlObj": [" urlOb", "uriCtrl", "urlCtrl", "Urlobj", " urlObject", "UrlCtrl", "httpOb", " urlobj", "httpObj", "uriobj", "urlObject", "urlobj", "urlOb", "logObject", "urlInd", " urlCtrl", "urlInfo", "httpObject", " urlOnce", " urlInd", " urlInfo", "UrlObj", "uriObj", "uriObject", "logInfo", "logOb", "logObj", "UrlObject", "UrlOnce", "httpInfo", "uriOnce", "uriInd", "urlOnce", "UrlInd"], "content": ["core", "context", "object", "ontent", "value", "output", "header", "comments", "data", "message", "Content", "equ", "format", "empty", "string", "clean", "complete", "sequence", "buffer", "str", "section", "continue", "raw", "wrapper", "text", "article", "view", "load", "response", "reason", "page", "comment", "document", "layout", "result", "body", "code", "address", "current", "txt", "write", "template", "display", "source", "title", "ext", "ce", "articles", "html", "cm", "command", "temp", "read", "cont"], "is": ["fs", "ese", "ri", "id", "rs", "ris", "when", "ists", "his", "ms", "err", "has", "ism", "re", "bis", "sit", "IS", "res", "be", "se", "es", "ais", "its", "not", "plays", "lis", "iss", "are", "being", "string", "e", "web", "chain", "iso", "or", "Is", "name", "isa", "isl", "other", "s", "in", "c", "internet", "tis", "iris", "out", "isc", "does", "isf", "os", "\u00eds", "ist", "isin", "was", "ios", "sis", "ot", "ir", "more", "isi", "where", "nis", "net", "sys", "by", "rys", "sels", "a", "ire", "ois", "as", "mis", "were", "ians", "i", "and", "job"], "reader": ["dr", "ipper", "stream", "ri", "liner", "dra", "ader", "ocker", "er", "iterator", "io", "handler", "editor", "buffer", "parser", "in", "loader", "writer", "runner", "reading", "ser", "ro", "file", "per", "Reader", "rar", "rr", "ner", "r", "iter", "inner", "anger", "row", "roller", "iper", "read"], "line": ["el", "column", "record", "ine", "liner", "online", "eline", "zone", "message", "char", "email", "detail", "e", "string", "ln", "le", "lo", "print", "sequence", "cell", "section", "block", "lin", "entry", "text", "part", "frame", "nl", "Line", "stroke", "inline", "page", "link", "comment", "range", "label", "piece", "file", "lane", "lined", "word", "l", "row", "LINE", "sample", "point"]}}
{"id1": "18374598", "id2": "5683576", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"download": ["update", " downloaded", "poll", "dial", "GET", "data", " Download", "connect", "pull", "delete", "loader", "load", "link", "Download", "upload", "install", " downloads", "file", "open", "check", "get", "create", "submit", "filename", "url", "save", "sample", "read"], "a": ["ia", "eta", "el", "u", "aa", "go", "b", "v", "ata", "apa", "alpha", "data", "ga", "area", "ae", "s", "ai", "path", "an", "any", "ac", "from", "au", "ar", "c", "ab", "part", "array", "sta", "ca", "va", "all", "attribute", "aaa", "as", "la", "ma", "aos", "al", "base", "address", "era", "arg", "name", "pa", "ap", "h", "ta", "i", "r", "title", "ao", "l", "app", "na", "url", "aw", "t", "o", "html", "att", "d", "at", "oa", "A", "sa", "am"], "p": ["pe", "b", "perm", "par", "jp", "pat", "bp", "pers", " pe", "P", "q", "pre", "pt", "m", "pp", "pkg", "c", "part", "ping", "vp", "j", "pg", "x", "power", "pard", "wp", "op", "pc", "pos", "cp", "pid", "lp", "pa", "pr", "pro", "ap", "h", "pl", "i", "g", "l", "ip", "prop", "rep", "t", "pad", "np", "d", "tp", "ps", "pb", "pi"], "td": ["div", "cot", "ot", "dd", "th", " TD", "dt", "dial", "dl", "nd", "lf", "tc", "dh", "tif", "sd", "od", "pt", "pd", "tf", "ds", "dc", "ts", "md", "ad", "ptr", "df", "tmp", "nt", "pc", "det", "tr", "TD", "cz", "d", "ld", "db", "deb", "cd", "tap", "bd", "ct", "t", "fd", "hd", " sd", "tp", "fc", "pb"], "f": ["fs", "ft", "b", "cf", "v", "fw", "bf", "fin", "uf", "lf", "fm", "alf", "fo", "af", "fe", "e", "form", "ff", "tf", "sf", "c", "fb", "j", "fr", "fx", "fa", "xf", "file", "df", "fn", "fp", "fi", "h", "i", "g", "l", "fl", "t", "o", "fd", "rf", "F", "d", "w", "fc", "func"], "total": ["max", "initial", "eta", "length", "num", "Total", "equal", "count", "scale", "sum", "stable", "net", "le", "complete", "sequence", "sys", "percent", "valid", "buffer", "normal", "table", "active", "otal", "to", "note", "available", "all", "trans", "nt", "base", "none", "current", "open", "ta", "template", "done", "meta", "full", "unique", "len", "number", "last", "start", "t", "info"], "progress": ["length", "update", "distance", "pdf", "portion", "important", "poll", "grade", "scale", "count", "speed", "process", "print", "percent", "complete", "state", "offset", "Progress", "finished", "debug", "scroll", "continue", "status", "resource", "priority", "step", "dist", "bar", "performance", "usage", "payment", "report", "ptr", "address", "depth", "current", "pro", "display", "done", "memory", "age", "success", "summary", "t", "wait", "history", "result"], "in": ["ins", "inside", "din", "en", "ini", "ze", "IN", "inn", "con", "ai", "io", "inf", "cin", "on", "mm", "bin", "from", "ar", "it", "ic", "by", "to", "init", "ind", "is", "inc", "rin", "get", "i", "input", "win", "iter", "inner", "oin", "l", "o", "and", "im", "In"], "out": ["cn", "ins", "output", "OUT", "b", "co", "v", "ex", "cache", "list", "con", "s", "net", "io", "ne", "sys", "on", "err", "conn", "outs", "it", "c", "by", "writer", "OU", "ou", "vol", "to", "obj", "res", "aos", "auto", "nt", "at", "pool", "ch", "pos", "put", "lock", "client", "write", "oss", "g", "os", "l", "null", "o", "t", "end", "log", "Out", "cb", "w", "outer", "can"], "buf": ["arr", "cmd", "bl", "b", "vec", "bed", "uf", "norm", "data", "window", "box", "buffer", "obs", "aka", "bin", "block", "pkg", "bar", "cv", "cap", "orig", "img", "wb", "bag", "seq", "Buff", "batch", "msg", "cp", "br", "ob", "cat", "conv", "db", "tab", "row", "rb", "Buffer", "mu", "buff", "bytes", "next", "cb", "pb"], "n": ["max", "cn", "z", "num", "nn", "en", "b", "v", "norm", "count", "ng", "dn", "nc", "nm", "N", "ln", "ne", "sn", "nw", "an", "ns", "nb", "m", "on", "c", "nor", "nl", "j", "nan", "note", "yn", "x", "nt", "fn", "y", "none", "ren", "nr", "no", "number", "len", "i", "g", "l", "na", "gn", "wn", "t", "o", "names", "np", "d", "w", "min"], "percentage": ["quantance", "percentension", "CENTategy", "scaleage", "centity", "percentility", "quantension", "percentant", "scaleager", "Percentume", "taxension", "quantage", "Percentant", "scaleility", "parility", "propity", "centade", "parager", "CENTage", "scaleAGE", "parage", "percentager", "percentade", "percentile", "Percentity", "parension", "quantility", "Percentile", "oppage", "propade", "centage", "propage", "centile", "Percentategy", "percentance", "oppant", "Percentage", "taxage", "percentume", "percentAGE", "parAGE", "propile", "centAGE", "CENTume", "Percentility", "oppility", "parance", "taxility", "percentategy", "oppade", "centume", "CENTade", "percentity", "taxance", "centategy", "centility", "Percentade", "centager"], "tmpPercentage": ["tmpIntage", "tmpPropage", "tmppercenture", "tmpPercentency", "tmpIntade", "tmpPercentate", "tmppercentate", "tmppercentane", "tmpPropency", "tmppercentade", "tmpPropade", "tmpPercentade", " tmpIntage", " tmpIntency", " tmppercentate", " tmpIntade", "tmpPlusure", "tmpPlusane", "tmpPercentane", "tmpIntance", " tmpPercentane", "tmpPercenture", " tmpPercentency", "tmpMagnages", "tmppercentages", "tmpPlusage", " tmpPercenture", " tmppercentane", "tmpMagnage", " tmpPercentate", " tmppercentages", " tmppercentage", "tmppercentage", " tmpPercentages", " tmpPercentance", " tmppercentade", "tmpMagnate", "tmpPercentages", "tmpPropance", " tmpIntance", "tmpIntency", "tmpPercentance", " tmppercenture", "tmpMagnade", " tmpPercentade", "tmpPlusade"], "size": ["length", "max", "loc", "num", "Size", "position", "scale", "count", "sum", "SIZE", "ose", "ize", "capacity", "ze", "sd", "area", "s", "empty", "e", "loss", "sn", "notice", "space", "set", "sw", "c", "storage", "small", "body", "sp", "code", "name", "see", "used", "len", "g", "needed", "l", "bytes", "now", "send"], "checksum": ["hsul", "hascan", "cksave", "timesave", "hasam", "readsave", "ksum", "checksam", "checkssum", "hsumm", "actionsumm", "ksam", "checksumm", "kscan", "checksave", " checkssum", "actionssum", "hasum", "actionsul", "checksul", "hassum", "readsum", "actionsum", "timessum", " checksumm", "timesum", "ckssum", "hssum", "hsum", "timesul", "cksul", "readsul", "cksam", "readssum", "cksum", "kssum", " checksul", "checkscan", "ckscan"]}}
{"id1": "21642215", "id2": "14598566", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"addIDs": [" addIDS", " addID", " addNames", "addNames", "setIDS", "setNames", "processIDs", "processIDS", "setID", "processNames", "addID", "processID", "setIDs", "addIDS"], "row": ["rows", "record", "ry", "node", "ows", "channel", "instance", "pair", "list", "user", "box", "group", "cell", "buffer", "block", "entry", "board", "raw", "error", "rank", "post", "rown", "col", "table", "skip", "ro", "report", "item", "week", "ack", "roll", "batch", "Row", "tr", "out", "r", "ow", "job", "star", "result"], "name": ["image", "value", "search", "question", "format", "description", "string", "path", "Name", "text", "a", "NAME", "label", "prefix", "key", "item", "query", "file", "address", "word", "ame", "template", "title", "source", "filename", "create", "version", "type", "named", "password", "n"], "in": ["update", " IN", "ins", "din", "el", "ssl", "copy", "en", "again", "scan", "pin", "serv", "ex", "ini", "il", "IN", "er", "inn", "con", "s", "ln", "form", "inf", "cin", "gin", "m", "on", "bin", "xml", "conn", "it", "ic", "vin", "re", "init", "sql", "nin", "mc", "file", "al", "ain", "reader", "is", "inc", "out", "check", "up", "rin", "get", "source", "input", "r", "win", "inner", "db", "conf", "l", "i", "t", "log", "isin", "at", "local", "In", "n"], "urlName": ["urlname", "implNAME", "logname", "UrlKey", "implPath", "logNAME", " urlname", "UrlName", "implNames", " urlNAME", "urlNames", " urlPath", "urlNAME", "logKey", "Urlname", "UrlNames", "UrlNAME", "lKey", "lNames", "lNAME", "logName", "urlKey", "lName", "lPath", " urlNames", "implName", "lname", "implname", "urlPath"], "url": ["rel", "el", "sl", "ssl", "gl", "b", "ls", "channel", "il", "char", "con", "web", "ref", "str", "ll", "loader", "ret", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "URL", "file", "base", "reader", "open", "client", "mount", "r", "uri", "Url", " URL", "l", "cl", "t", "result"], "inputLine": ["helloPort", "patternRow", "intLine", "cachePage", "operationNet", "submitLine", "inputNode", "cacheLine", "cacheNode", "singleBlock", "commandLine", "inputL", " InputLINE", "listEntry", "InputBlock", "submitBlock", "inLINE", " InputLine", "singleDe", "latLINE", "dataLink", " inputFrame", "InputFile", "keyL", "intBlock", "tableLink", "dataNet", "tempLINE", "sourceNode", "inputRecord", "formLINE", "InputL", "latRecord", "operationLINE", "inL", "singleLINE", "dataline", "patternLINE", "formFrame", "helloEntry", " inputEntry", "firstLine", "firstLINE", "commandLINE", "keyLINE", "inputLINE", "listLINE", "commandBlock", "formBlock", "InputLine", "tableLine", "statusline", "Inputline", "statusLINE", "formLine", "inputLin", "tempLine", "inputDe", "viewLINE", "dataBlock", "patternLine", "inputline", "listPort", "inputEntry", "intLin", "inLine", "cacheLINE", "intline", "inputFile", "dataLine", " inputRecord", "operationLine", "keyLine", " inputRow", " Inputline", " inputLink", "inputNet", "tableLINE", "viewRow", "dataFile", " inputLin", "inRecord", "inputRow", "inline", "latLine", "helloLINE", "listLine", " inputBlock", "inputFrame", "InputLINE", "helloLine", " inputFile", "contextRow", "viewLine", "submitLINE", "dataFrame", " inputLINE", " inputNet", "statusLine", " InputLin", "keyline", "sourcePage", "firstBlock", "contextLINE", " inputline", " inputDe", " inputPage", "latline", "contextLine", "dataPort", "sourceLine", "sourceLINE", "inputPort", "intLINE", "dataLINE", "templine", " inputPort", " inputNode", "inputPage", "inputLink", "submitDe", "inputBlock", "tablePort", "InputRow", "patternline", "singleLine", "statusFile"], "score": ["length", "distance", "core", "value", " scores", "search", "style", "scan", "match", "grade", "count", "scale", " Score", "sum", "message", "sc", "level", "goal", "loss", "average", "test", "Score", "weight", "set", "err", "scroll", "rank", "error", "status", "report", "strength", "confidence", "depth", "price", "check", "display", "source", "scoring", "success", "rate", "draw", "index", "result"], "metaboliteID": ["metabiliterUID", "metabolitationId", "metmboliteIN", "metabiliterHandle", "metabolitableHandle", "metabolitionid", "metabolitateId", "metaboliteHandle", "metabiliteID", "metabolitationIN", "metabolitesid", "metabolitateID", "metabolITEName", "metmbolitationIN", "metabolitableUID", "metaboliterIN", "metabolteID", "metabolitationName", "metabolteHandle", "metaboliciteName", "metabolicitationID", "metaboliteId", "metabiliteUID", "metabiliteId", "metabolisticId", "metabolitationInfo", "metabolITEID", "metaboliterUID", "metaboliteIN", "metaboliceInfo", "metaboliceID", "metabolitationID", "metabolitionName", "metabolitesName", "metaboliciteId", "metaboliteType", "metmboliteId", "metabolicitationInfo", "metabolicITEID", "metabolitationid", "metaboliteUID", "metaboliteName", "metaboliciteID", "metabiliterid", "metabolitateid", "metaboliterId", "metaboliteid", "metabolicITEId", "metaboliterID", "metabolitableID", "metabolicitationId", "metabolitableId", "metaboliterName", "metaboliceid", "metabolITEId", "metabolicitationid", "metabolicITEType", "metabiliteHandle", "metaboliterType", "metabiliteid", "metabolitateInfo", "metaboliceId", "metabolicITEName", "metabolteUID", "metaboliterHandle", "metabolITEType", "metabolitationType", "metabolitionID", "metabiliterId", "metabolitesID", "metabiliteName", "metabolisticIN", "metabolisticID", "metmboliteID", "metabiliterName", "metmbolitationId", "metabolteId", "metaboliciteType", "metmbolitationID", "metaboliciteInfo", "metaboliterid", "metabiliterID", "metaboliciteid", "metaboliteInfo"], "dataScore": ["errorScore", "parentScore", " dataRank", "dataTest", "dataAge", "divRank", "relationScore", "ataScore", "parentRank", "errorSize", "DataSc", "tdAge", "dataSc", "relationSize", "ataSc", "divScore", "tdScore", "dataWeight", " dataTransfer", "arrayScore", " dataSpeed", "blockStyle", "arraySpeed", "arrayStyle", "errorWeight", " dataSc", "dataRank", "blockSc", " dataWeight", "relationscore", "blockScore", " dataAge", "deviceTransfer", "DataScore", "dataSpeed", "relationWeight", "tdSc", "divSize", "dataTransfer", "parentTest", "DataRank", "parentSc", "deviceScore", "blockSpeed", "dataStyle", "dataSize", "DATAScore", "deviceSize", "DATARank", "DataSize", "DATASc", " dataSize", "DATATest", " dataTest", "errorscore", "divSc", "ataTransfer", "arraySc", "ataSize", "arrayAge", "datascore", "deviceSc", " datascore", " dataStyle"], "data": ["image", "DATA", "value", "words", "values", "video", "ata", "multiple", "cache", "dat", "window", "description", "string", "content", "chain", "ns", "buffer", "valid", "space", "set", "zero", "raw", "text", "array", "rew", "supported", "size", "map", "table", "step", "users", "available", "all", "draw", "missing", "batch", "hex", "base", "params", "none", "hash", "extra", "keys", "details", "td", "results", "json", "lines", "mu", "bytes", "series", "html", "info"], "molecularWeight": ["molellularFont", "mlecularWeight", "molecularFont", "moleudoWeight", "mleularweight", "moleuralWeight", "mleularScore", "moleularWater", "moleularData", "mlecularScore", "moleularFont", "mlecularData", "moleudoWater", "mleularData", "molecularScore", "moleculeData", "moleculeweight", "molecularData", "molecularweight", "moleularScore", "moleculeFont", "moleudoScore", "mleularFont", "moleuralScore", "moleularWeight", "molellularweight", "mlecularWater", "mleularWeight", "mlecularweight", "moleuralWater", "mlecularFont", "mleularWater", "moleculeWeight", "moleularweight", "molecularWater", "molellularWeight", "molellularData"]}}
{"id1": "5441579", "id2": "11952735", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"createPseudoUUID": ["createPseudoUuid", "createPseudoRandomUID", "createPseudoUID", "createPseanRandomID", "createPseudoUniqueuid", "createPseanUID", "createPseudoUniqueID", "createPseudoRandomId", "createPseanRandomUID", "createPseudoUUUID", "createPseanUId", "createPseudoUId", "createPseudoUUId", "createPseudoRandomID", "createPseanUUID", "createPseudoRandomuid", "createPseudoUniqueId", "createPseanRandomuid", "createPseudoUniqueUID", "createPseanUuid", "createPseudoUUuid", "createPseanRandomId"], "messageDigest": [" messageDiger", "messageDrise", "messageDesignist", "messageDriest", "messageDigests", "messageDigested", " messageDigment", "messageMacest", " messageDesignest", "numberDesignests", "messageDist", " messageDesignester", "messageMacse", "messageDests", "messageDesignest", "messagedigist", "numberDesignist", "numberDesignest", " messageDigested", "messageDesignests", "numberDigest", "messageHasests", "messagedigse", " messageDigifier", " messageDigester", "messagediger", "messageLocest", " messageDesignist", "numberDesignester", "messageDest", "messageHasest", "messageHasist", " messagedigest", "messagedigested", "messageLocment", " messagedigifier", "messageDesignse", "messageDigester", "messagedigest", "messageDiger", " messageDigse", "messageDigment", "messageDriist", "numberDigests", "messageDigse", "messageLocse", "messageMacested", " messageDesignse", "messageDesignester", " messagedigment", "messageMacer", "messageDester", " messageDigist", "messagedigifier", "messagedigester", "messageDigifier", "numberDigester", "numberDigist", "messagedigment", "messageDriester", " messagedigse", "messageLocifier", "messageDigist", "messageHasester"], "localHost": ["Localhost", "localServer", "LocalServer", "localAddress", "localhost", "LocalHost", "remoteHost", "remoteAddress", "localPort", "localhosthost", "LocalPort", " localPort", "localhostHost", " localAddress", " localhost", " localServer", "localhostPort", "remotehost", "remotePort", "LocalAddress", "localhostServer"], "digestBytes": ["digestedBs", "Diggestbytes", " digestKeys", "DigestParts", "diggeAttributes", " digestedbytes", "digestBs", "mixestedbytes", "DigestServices", "digestedParts", "mixestAttributes", "digestServices", " digestResults", "digesterBs", "digESTBytes", "mixestArgs", "digestParts", "digestExamples", "mixestedArgs", "digetParts", " digestedBytes", "digesterResults", "mixestedServices", "digistanceKeys", "digesterValues", " digestArgs", "Digestbytes", "diggestExamples", "digestValues", "digestedResults", "diggestbytes", "digESTArgs", "digstBytes", "digestArgs", "digesterArgs", " digestValues", "digestAttributes", "digstParts", "diggestBytes", "digistanceBytes", "DiggestBytes", "digESTLinks", "diggeParts", "digesterLinks", "diggeBytes", "digetbytes", "digstServices", "digesterbytes", "digesterParts", "digestKeys", "diggeServices", "digetBytes", "mixestedBytes", "digestbytes", "digstAttributes", " digestedValues", "mixestedAttributes", "mixestbytes", "digestedServices", "digesterBytes", "DigestBytes", "digistanceExamples", "diggestParts", "mixestedParts", "digestedbytes", "drivenestBytes", "digestedArgs", "digESTValues", "digestedAttributes", "digestedLinks", "drivenesterValues", "drivenestBs", "diggestServices", "digESTbytes", "mixestedLinks", "digestedValues", " digestExamples", "mixestLinks", "DiggestServices", "digestResults", "mixestServices", "drivenestParts", "diggestKeys", "digestLinks", "drivenesterBs", " digestbytes", "digestedBytes", " digestParts", "mixestBytes", "digetServices", "DiggestParts", "mixestParts", "drivenestValues", "drivenesterParts", "drivenesterBytes"], "sb": ["sth", "sl", "ssl", "sh", "abb", "b", "bs", "shell", "bf", "bn", "SB", "jp", "ib", "sd", "bp", "sn", "obb", "nb", "src", "sw", "esm", "gob", "rob", "sf", "bps", "fb", "ibl", "bis", "tn", "sv", "bh", "storage", "stab", "bg", "wb", "pg", "sam", "gc", "eb", "sp", "bt", "erb", "lp", "gb", "bj", "bash", "lb", "ctrl", "kb", "db", "zb", "pb", "ub", "rb", "sg", "bb", "sbm", "cb", "sa"]}}
{"id1": "21348951", "id2": "20920051", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"processAddByURLSubmit": ["processAddByURLSubit", "processAddByURlsummission", "processAddByURLSubsmit", "processAddByURLSummission", "processAddByURlsummitted", "processAddByURlsubmitted", "processAddByURLSubsmission", "processAddByURLSummitted", "processAddByURLSUBit", "processAddByURLSubmission", "processAddByURlsummit", "processAddByURlsubmission", "processAddByURLSumit", "processAddByURLSubsit", "processAddByURLSubsmitted", "processAddByURlsumit", "processAddByURLSubmitted", "processAddByURlsubmit", "processAddByURLSUBmission", "processAddByURLSummit", "processAddByURlsubit", "processAddByURLSUBmitted", "processAddByURLSUBmit"], "url": ["loc", "el", "u", "sl", "ssl", "id", "location", "ls", "dl", "char", "email", "external", "bel", "string", "web", "path", "ref", "un", "addr", "q", "rect", "str", "ll", "resource", "http", "rl", "ul", "nl", "link", "page", "browser", "ur", "key", "impl", "URL", "document", "file", "item", "run", "force", "base", "address", "name", "mount", "mail", "input", "uri", "Url", "l", "util", "html", "use"], "invalidUrlMsg": ["invalidStrLog", "inInvalidUrlMsg", "inInvalidUrlStr", "invalidUrMessage", "invalidUrStr", "invalidUrLog", "invalidURLMsg", "invalidURLStr", "invalidFileMsg", "invalidurlMsg", "inInvalidURLMsg", "invalidUrlLog", "invalidUrMsg", "invalidUrlStr", "inInvalidUrlmsg", "inInvalidURLmsg", "invalidStrMessage", "inInvalidStrMsg", "invalidFileMessage", "inInvalidUrlLog", "invalidURLmsg", "invalidFileLog", "invalidStrMsg", "inInvalidURLStr", "invalidStrStr", "invalidFileStr", "invalidUrlMessage", "invalidUrmsg", "inInvalidStrLog", "inInvalidStrStr", "invalidurlmsg", "invalidurlStr", "inInvalidStrMessage", "invalidUrlmsg", "inInvalidUrlMessage"], "xmlSourceWriter": ["xmlSourceFileBuilder", "xmlSourcesReader", "xmlStringWriting", "jsonStringReader", " xmlSourceWrite", "xmlSourceWrite", "xmlSourcesWriting", "xmlSourceFileWriter", "xmlsourceReader", "xmlsourceBuilder", "xmlSourceBuilder", "xmlStringCode", "jsonSourceWriting", "xmlsourceWrite", "xmlSourceRW", "xmlStringWriter", " xmlSourceBuilder", "xmlSourceFileRW", "xmlsourceWriting", "jsonSourceReader", "jsonStringWriter", "jsonStringWriting", "xmlsourceRW", " xmlSourceRW", "jsonSourceWriter", "xmlSourceWriting", "jsonSourceCode", "xmlStringReader", "xmlsourceWriter", " xmlSourceWriting", "xmlSourceFileWriting", " xmlSourceReader", "xmlSourceReader", "xmlSourcesWriter", "xmlSourcesCode", "xmlSourceCode", "jsonStringCode"]}}
{"id1": "16511008", "id2": "23620712", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMessageSyntax", "createNewProfilingMessageCyntax", "createNewProfilingMessagesymbol", "createNewProfilingMsgSchentax", "createNewProfilingMessageSchembol", "createNewProfilingMessageSchentax", "createNewProfilingMsgSyntax", "createNewProfilingMsgSchembol", "createNewProfilingMessageCymbol", "createNewProfilingMessagesyntax", "createNewProfilingMsgSymbol"], "configID": ["caseID", " configIDs", "Configid", "configURI", "configOR", "cfgID", "confPK", "ConfigID", "configIDs", "confId", " configid", " configURL", "cfgURI", " configPK", "caseURL", "componentID", "confURI", "cfgIDs", "confID", "configML", "ConfigML", "confOR", " configML", "configId", "componentOR", "cfgId", "configPK", " configId", "componentPK", "configURL", "configid", "ConfigURL", "caseid", " configURI", "componentId", "caseML", " configOR", "confIDs"], "programMessageSymbolID": ["programMessageSySyID", "programMessageSyElementName", "programMessageSymbolName", "programMessageSyrorN", "programMessageSyTypeID", "programMessageSymbN", "programMessageSymbolN", "programMessageSymmbolid", "programMessageSySyid", "programMessageSyTypeId", "programMessageSymmbolId", "programMessageSyptionID", "programMessageSymbId", "programMessageSyElementId", "programMessageSySyId", "programMessageSymbIDs", "programMessageSyptionId", "programMessageSymmbolIDs", "programMessageSymmbolName", "programMessageSySyName", "programMessageSymbolValue", "programMessageSyTypeName", "programMessageSyrorId", "programMessageSyptionid", "programMessageSymbolId", "programMessageSymmbolValue", "programMessageSyElementValue", "programMessageSyrorID", "programMessageSyptionName", "programMessageSymmbolID", "programMessageSymbolIDs", "programMessageSyElementID", "programMessageSyrorIDs", "programMessageSymbolid", "programMessageSyTypeValue", "programMessageSymmbolN", "programMessageSymbID"], "profilingMessageSymbol": ["profilingMessageSyse", "profilingMessageSymb", "profilingMessagesyols", "profilingMessageSysmb", "profilingMessageSymntax", "profilingMessageSyols", "profilingMessageSymavior", "profilingMsgSyavior", "profilingMsgSymbol", "profilingMessagePyavior", "profilingMessageSyavior", "profilingMsgSymntax", "profilingMessageSysols", "profilingMessageSYmb", "profilingMessageSymse", "profilingMessagesymbol", "profilingMessageSYse", "profilingMessageCyavior", "profilingMessageSysmbol", "profilingMsgSyntax", "profilingMessageSYmbol", "profilingMessagesymb", "profilingMessagesyse", "profilingMessageCyntax", "profilingMessageSymols", "profilingMsgSymavior", "profilingMessageSyntax", "profilingMessagePyntax", "profilingMessageCymbol", "profilingMessageSymmbol", "profilingMessageSymmb", "profilingMessagePymbol", "profilingMsgSymmbol"], "connection": ["initial", "context", "engine", "server", "established", "position", "channel", "bo", "we", "Connection", "connect", "relation", "communication", "con", "city", "device", "handler", "generation", "sequence", "database", "subject", "network", "conn", "application", "entry", "volume", "resource", "collection", "table", "writer", "response", "link", "note", "socket", "usage", "session", "document", "function", "library", "connected", "directory", "reference", "settings", "operation", "current", "ion", "client", "open", "line", "system", "character", "config", "cone", "db", "close", "condition", "created", "associated", "ce", "command", "module", "information"], "statement": ["processor", "bind", "Statement", "mt", " Statement", "shell", "position", "language", "message", "relation", "instance", "description", "list", "ment", "chain", "print", "sequence", "phrase", "state", "database", "subject", "set", "network", "application", "rule", "stan", "volume", "resource", "response", "note", "EMENT", "storage", "usage", "report", "comment", "session", "linger", "sql", "document", "expression", "function", "library", "execute", "directory", "reference", "sp", "template", "memory", "se", "activity", "policy", "condition", "parse", "t", "stat", "journal", "management", "command"], "resultSet": ["resultRow", "rowRow", "rowHandle", "traceSet", "resultPath", "rowSet", " resultSource", " resultScan", " resultS", "resultset", "ResultSource", "rowset", "ResultList", " resultRow", "ResultRow", " resultset", "ResultPath", "eventList", "ResultSet", "ResultS", "eventSet", "traceset", "traceSource", "resultScan", "traceList", "resultSource", "resultList", "recordset", "recordSet", "rowS", " resultPath", "resultS", "recordList", "eventPath", "resultHandle", "Resultset", " resultList", "ResultScan", "recordHandle", "ResultHandle", "rowScan", "rowList", "eventset"], "query": ["update", "quote", "scope", "search", "scan", "question", "script", "show", "message", "sum", "select", "Query", "where", "string", "content", "how", "print", "sequence", "test", "q", "sq", "request", "commit", "join", "volume", "table", "spec", "note", "comment", "quest", "QU", "key", "sql", "transform", "expression", "gate", "init", "code", "menu", "execute", "lock", "eries", "qu", "ion", "call", "ERY", "check", "get", "title", "create", "find", "condition", "parse", "ql", "password", "command", "send", "read"], "msg": ["mess", "Msg", "cmd", "mt", "og", "gr", "gem", "ex", "sum", "message", "nm", "char", "med", "gen", "e", "cfg", "notice", "str", "m", "err", "gm", "man", "sm", "term", "text", "pkg", "gs", "error", "em", "comm", "note", "reason", "bg", "req", "ged", "sql", "md", "nom", "mn", "kg", "mun", "name", "mb", "warn", "mail", "txt", "cmp", "mem", "doc", "title", "g", "meg", "mu", "mag", "log", "sg", "ext", "html", "rup", "ung", "mg"]}}
{"id1": "7143591", "id2": "14865947", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getWebByUrl": ["getUrlByurl", "getWebFromurl", "getUrlByString", "getWebbyURL", "getUrlByURL", "getWebbyString", "getUrlbyURL", "getWebFromURL", "getWebByURL", "getWebbyurl", "getWebFromString", "getUrlbyurl", "getWebByString", "getUrlbyString", "getWebFromUrl", "getUrlByUrl", "getUrlbyUrl", "getWebByurl", "getWebbyUrl"], "strUrl": ["txtURL", "strUr", "nameStr", "nameDb", "sturl", " strStr", "instURL", "stDb", "drurl", "drUrl", "drUr", "STRURL", "Strurl", "txtStr", "stringUr", "strStr", "StrURL", "insturl", "nameEmail", "volUr", " strurl", "arrurl", " strGl", "STRUr", "drDb", "nameURL", "strGl", "STRStr", "STREmail", "nameUr", "volURL", "stringUrl", "strEmail", " strURL", "nameUrl", "drURL", "StrStr", "STRUrl", "volStr", "strURL", "stURL", "arrStr", "instUrl", "stUr", "StrUrl", "stringURL", "instUr", "arrUr", "StrUr", " strDb", "txtGl", "arrEmail", "arrURL", "arrUrl", "volUrl", "strDb", "StrGl", "stUrl", "txtUrl", " strUr", "stringDb", "strurl", "nameurl"], "charset": ["ChARSets", "chorsET", "Charsec", "chARSets", "ChARSec", "charsets", "charsET", "chARSec", "chorsec", "chorset", "ChARSET", "chorsets", "chARSET", "Charsets", "ChARSet", "CharsET", "charsec", "chARSet", "Charset"], "fileIndex": ["ileNum", "stringPath", "ileIndex", "byteInd", "byteIndex", " fileNum", " fileindex", "fileInd", "ileInd", "ileindex", "bytePath", " fileInd", "bytePos", "filePos", "stringPos", "fileNum", "byteindex", "byteNum", "stringIndex", "fileindex", " filePos", "stringindex"], "url": ["f", "rel", "sl", "cmd", "ssl", "bl", "gl", "https", "ls", "dl", "il", "hl", "bel", "con", "web", "net", "str", "ll", "ret", "resource", "rl", "http", "ul", "nl", "link", "socket", "www", "browser", "ur", "URL", "connection", "obj", "cert", "build", "cp", "name", "open", "client", "get", "r", "uri", "Url", "g", "l"], "conn": ["cn", "access", "cmd", "en", "ens", "enc", "Connection", "nc", "connect", "iw", "con", "ln", "net", "nw", "addr", "sys", "ctx", "c", "nec", "comm", "Con", "socket", "ca", "pg", "connection", "obj", "Conn", "nt", "act", "ch", "cp", "open", "oss", "conv", "l", "ctr", "pas", "ws", "cb", "handle"], "is": ["isa", "fs", "isl", "ins", "lis", "ri", "bits", "bs", "ris", "iss", "id", "ir", "serv", "ls", "ists", "rs", "isi", "ib", "nis", "us", "s", "si", "ms", "sys", "iso", "has", "in", "it", "js", "or", "http", "bis", "as", "IS", "res", "iris", "are", "im", "Is", "out", "isc", "i", "isf", "iter", "es", "os", "ip", "ais", "its", "ist", "ws", "info", "was", "ios"], "filePath": [" filepath", "fSystem", "Filepath", "familySystem", "fileFile", "ioPath", " filePATH", "fFile", "filepath", "familyPath", "fPath", "fName", "fileName", "FileFile", "FilePath", "ioSystem", "familypath", "ioName", "ioFile", "FilePATH", " fileSystem", "FileSystem", "familyPATH", "FileName", "filePATH", "fileSystem"], "pw": [" pwb", "pv", " pwp", "npwr", "mwh", "cpwr", "mwd", "fw", "npwt", "cpwd", "Pwd", "npwe", "mwb", "jW", "npwd", " pwt", "npv", " pW", "wpv", "apwb", "jw", "pwe", "apwh", "wpwe", " pv", " pwr", "pws", "Pwb", "pW", "fW", "pwp", " pwd", "Pw", "pwt", "npw", "wpw", "pwb", "PW", "cpwp", " pwe", "mw", "pwh", "pwr", "cpw", "pwd", "jwb", "fwd", "fws", "Pws", "npwp", " pwh", "jwd", " pws", "apw", "apwd", "wpwt"], "fos": ["wos", "foss", "bo", "fo", "eOS", "flOs", "foses", "flo", "woss", " foss", "bOs", "wOS", "floses", "bos", "fOs", "flos", " fOs", "eos", "fOS", "wOs", " foses", " fo", "eOs", "eoss", " fOS", "boses"], "writer": ["riter", "output", "liner", "fw", "woman", "println", "window", "nw", "editor", "handler", "buffer", "player", "aster", "member", "walker", "wrote", "rew", "author", "worker", "aver", "ter", "ser", "width", "wb", "writ", "builder", "wright", "console", "usher", "rw", "widget", "wp", "nt", "reader", "out", "write", "w", "writing", "written", "desc", "wn", "Writer", "wr", "master"], "bReader": ["bClient", " bBuffer", " bWriter", "bcClient", "rbR", "bBuffer", " bRead", "bhBuffer", "aR", "aReader", "rbReader", "bcReader", "bcBuffer", "bWriter", " bR", "bR", "bhReader", " bClient", "rbWriter", "bhClient", "aWriter", "bRead", "rbRead", "aRead"], "sb": ["sth", "ssl", "b", "bs", "bf", "SB", "ib", "CB", "nb", "sw", "rob", "sq", "sf", "bis", "sv", "bh", "stab", "bg", "wb", "eb", "sp", "bt", "erb", "lp", "gb", "bj", "mb", "lb", "kb", "zb", "bsp", "pb", "rb", "bd", "sg", "bb", "cb", "sa"], "rLine": ["bRow", "rFrame", "srLine", "rrLine", " rLe", "bline", " rChan", "brFrame", " rLink", "rRow", "srL", "rrChan", "srChan", " rFrame", "rrEl", "rrLe", "rLe", " rL", "rline", "rEl", "srRow", " rEl", "brLine", "rChan", "brL", "rLink", "srLe", "rL", "lline", "bLink", "lLine", "bLine", "lLink", " rRow", " rline", "srEl", "srFrame", "brRow", "lRow"], "tmp_rLine": ["tmp_nrLine", "tmp_bLine", "tmp_nrRow", "tmp_rObj", "tmp_lRow", "tmp_pBlock", "tmp_lline", "tmp_RVal", "tmp_pL", "tmp_rSet", "tmp_rChain", "tmp_rLin", "tmp_eLine", "tmp_rgLin", "tmp_bline", "tmp_hLine", "tmp_rL", "tmp_nrChain", "tmp_nBlock", "tmp_rnLin", "tmp_rnLine", "tmp_pline", "tmp_eline", "tmp_lVal", "tmp_pRow", "tmp_lChain", "tmp_RL", "tmp_cObj", "tmp_nSet", "tmp_RBlock", "tmp_RRow", "tmp_RChain", "tmp_lRecord", "tmp_cline", "tmp_rgOrig", "tmp_eRecord", "tmp_hLin", "tmp_rgRule", "tmp_nL", "tmp_rRule", "tmp_rRow", "tmp_nrVal", "tmp_drLin", "tmp_rnOrig", "tmp_rBlock", "tmp_rVal", "tmp_nLine", "tmp_lLine", "tmp_cRow", "tmp_rnRule", "tmp_drLine", "tmp_hRule", "tmp_rOrig", "tmp_RRecord", "tmp_rgLine", "tmp_Rline", "tmp_eObj", "tmp_rline", "tmp_drline", "tmp_RSet", "tmp_drRow", "tmp_pSet", "tmp_eRow", "tmp_bRow", "tmp_bLin", "tmp_rRecord", "tmp_pLine", "tmp_hOrig", "tmp_lObj", "tmp_pLin", "tmp_RLine", "tmp_cLine"], "str_len": ["str_Len", "str2len", "string3length", " str_Len", "str__ll", "str_ls", "str__len", "string_len", "str_length", "str2ll", " str_ll", " str2len", "string3vec", "string_ls", "str2Len", "str__Len", "string_length", "str_ll", " str2Len", "str3vec", "str3ls", "str_vec", "string3len", "str2ls", "str3len", "str3length", "str__ls", " str_ls", "string_vec", " str2ll", " str2ls", "string3ls"]}}
{"id1": "8216539", "id2": "4599372", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentasText", "getFileContentAsText", "getFileTextAsStr", "getFileContentasString", "getFileContentasStr", "getFileContentAsStr", "getFileTextAsString", "getFileTextAsText"], "filePath": [" fileDef", " filepath", "baseName", " fileInfo", "Filepath", "entryPATH", "FileString", "ileInfo", "fileInfo", "fileString", "ileName", "FileInfo", "filepath", "FileDef", "basePath", "FILEPath", "ileDef", "fileName", "baseString", " fileString", "fileDef", "FilePath", "FILEPATH", "FILEName", "ilePath", " fileName", "FILEpath", "basepath", "entryName", "FilePATH", "entrypath", "entryPath", "FileName", "filePATH"], "encoding": ["enode", "encordering", "encuing", "unicoding", "characteroding", "ENCaching", "characteraching", "enaching", "encode", "ENCoding", "Encordering", "ENCging", "characterordering", "Encuing", "enuing", "Encging", "unicode", "encging", "enoding", "ENCordering", "encaching", "Encoding", "Encode", "characterging", "unicaching", "unicuing", "Encaching"], "testURL": ["testingUrl", "testedRE", "TestURL", "testUrl", "checkUR", " testRE", "TestSR", "testingURL", " testSR", "testingRE", " testUrl", "checkSR", "checkUrl", " testUR", "testUR", "testingUR", "checkURL", "TestUR", "testSR", "testingSR", "testedURL", "TestUrl", "testedUR", "testRE", "testedUrl"], "input": ["stream", "empty", "q", "acl", "has", "hidden", "add", "comment", "file", "missing", "address", "reader", "get", "feed", "unsigned", "url", "context", "Input", "iterator", "form", "it", "view", "active", "quick", "eval", "upload", "init", "op", "batch", "current", "quit", "submit", "json", "start", "PUT", "command", "exec", "channel", "data", "audio", "pull", "in", "raw", "tmp", "up", "source", "qa", "config", "ip", "accept", "focus", "image", "output", "exist", "list", "xml", "from", "act", "lat", "open", "client", "cur", "iter", "inner", "sample", "hello", "read", "cont", "can"], "sw": ["Sw", "wh", "sl", "tw", "sh", "ew", "fw", "ows", "we", "enc", "sc", "iw", "ews", "sn", "nw", "wl", "sf", "rew", "sv", "wra", "sem", "SW", "sb", "sp", "wa", "wr", "hw", "kw", " Sw", "sk", "wo", "su", "igm", "sur", "wn", "ow", "aw", "ws", "w", "was", "sa", "sm"]}}
{"id1": "14390569", "id2": "20310134", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"title": ["tip", "header", "question", "message", "description", "setup", "content", "string", "Title", "notice", "theme", "subject", "lead", "term", "text", "size", "itle", "password", "metadata", "label", "prefix", "heading", "holiday", "layout", "msg", "name", "hash", "template", "details", "parts", "filename", "help", " Title", "TIT", "type", "start", "padding", "summary", "t", "hd", "html"], "imageURL": ["imageURI", "photoURI", "fileUrl", "mediaID", "fileString", "imageID", " imageUR", "ImageUrl", "photoUR", "imageUR", "ImageID", "fileURI", "imageString", "mediaUrl", " imageURI", "mediaURL", "ImageURL", " imageString", "photoUrl", "photoURL", "fileURL", "ImageURI", "ImageUR", "photoID", "imageUrl", "photoString", "mediaURI", " imageUrl"], "jd": ["jsD", "ajpd", "kd", "simD", "javad", "djd", " jsd", "qD", "Jp", "Jc", "simdt", "ujD", " jdo", "Jmd", "kbd", "jsds", "gbd", "jsdm", "jad", "jds", "zad", "ijd", "gd", "Jdo", "ujmd", "djds", "djad", "jpd", "ajds", "jmd", "zd", "ujd", "simmd", "simd", "Jd", "jjbd", "javadm", "djdo", "gdo", "qds", "qd", "ujdt", "djc", "kds", " jdt", "JD", "jobd", " jD", "jdt", "jc", "qbd", "jjp", "jjD", "ajd", "jbd", "jD", "kdo", "kdt", "ujad", "Jdt", "jjd", "Jad", "jobdo", " jc", "jsd", " jds", "javapd", "jobdt", "qdo", "jdm", "djsd", "ijD", "ajdm", " jad", "gds", "ijds", "jdo", "zsd", "Jds", "jspd", "qp", "javads", "Jbd"], "jl": ["isl", " ol", "bol", "yl", "jac", "kel", "jin", "abl", "dj", "jj", "dl", "il", "igl", " li", "kl", "ln", "lu", "Label", "kn", "js", "ja", "li", "ibl", "J", "ij", "nl", "j", "elle", "ell", "ijk", "jah", "elly", "kj", "ji", "dll", "lp", "bj", "txt", "elt", "syn", "uj", "dyl", "gn", "mil", "lv", "jet", "rl", "jc"], "icon": ["image", "cn", " Icon", "cil", "\u4e2d", " fruit", "ico", "ex", "icol", "iao", "con", "nic", " captcha", "conn", "ic", "pen", "addon", "chron", " ancestor", "Icon", "iban", "ICO", "label", "ocon", " lang", "fa", "gc", "pic", "fn", " intent", "lock", "ion", " tip", " widget", " canvas", "syn", "png", " screen", "conv", "eric", " ion", "font", " conn", "icons", "jc"], "chooser": ["Chooser", "pooder", "poicer", " chooder", "Chooder", "choose", " choerer", "chooder", "boose", "CHOose", "CHOosen", "CHOoser", "boosen", "Choose", "Choosen", " choose", "composen", " choicer", "pooser", "composer", "choosen", "choerer", "boerer", "Choicer", " choosen", "choicer", "comperer", "booser", "poose", "CHOicer", "compicer", "compose"], "jp": [" ip", "JP", " je", "jin", " gp", "p", " mp", "bp", " sp", " ja", "js", "ja", "ij", " ap", "j", " np", "kj", "pic", "sp", " sip", "bj", "btn", " pl", " dj", " pic", "np", " cp", " joint", "jc"], "jb": ["qbd", "qb", "Jcb", "jcb", "kjbd", "qcb", "Jb", " jcb", "kjb", "jbd", " jbd", "kjcb", "Jbd"], "e": ["f", "u", "en", "p", "v", "er", "te", "s", "ev", "ed", "E", "m", "Event", "it", "c", "or", "re", "a", "ie", "event", "g", "es", "o", "t", "d", "ee", "w", "n"], "returnVal": ["responseVol", " returnVAL", "ReturnVal", "retValue", " returnVol", "returnVol", " returnValue", "returnval", "Returnval", " returnValid", "retVal", " returnval", "responseVal", "ReturnValue", "returnValue", "ReturnVAL", "getVAL", "responseValid", "returnValid", "getVol", "retval", "getValid", "returnVAL", "getVal", "retVAL", "responseVAL"], "file": ["f", "image", "core", "drop", "fs", "port", "angle", "work", "model", "channel", "class", "il", "relation", "format", "fe", "path", "user", "le", "io", "foo", "target", "buffer", "real", "valid", "tree", "rule", "or", "File", "resource", "http", "table", "status", "FILE", "link", "to", "page", "report", "dir", "document", "run", "body", "library", "base", "be", "name", "word", "open", "fp", "h", "ile", "get", "source", "place", "filename", "create", "full", "db", "null", "type", "stat", "info", "local", "handle"], "fileName": ["FileExt", "fileExt", "entityPath", "entityNAME", " fileClass", "FileFace", "fileSet", "imageName", "handlename", "FILENAME", "imageFace", "ileName", "taskFace", " fileNames", "FILEExt", "imagePath", "taskName", " fileExt", "FileSet", "handleNAME", "Filename", "entityName", "FileNAME", " filename", "handleName", "FILEPath", "fileNAME", "entitySet", "fileClass", "FilePath", "ileClass", "FILENames", "imageNAME", "FILEName", "ilename", "ileNAME", " filePath", "filePath", "FILESystem", "filename", "imagename", "FILESet", " fileSystem", "fileNames", "FileSystem", "taskname", "handleClass", "FileName", "taskPath", "fileSystem", "FileNames", " fileNAME", "fileFace"], "ext": ["Ext", "cmd", "ord", "exp", "ix", "EXT", "ex", "typ", "ec", "enc", "aux", "external", "pat", "test", "part", "cod", "xp", "sem", "vert", "fr", "req", "dir", "lex", "hex", "ag", "prot", "ind", "word", "def", "txt", "off", "exe", "len", "exc", "xt", "desc", "ct", "t", "end", "eur", "lib", "cont"], "i": ["cli", "mi", "id", "pi", "ini", "ii", "si", "ai", "bi", "print", "m", "iu", "it", "ei", "status", "li", "ti", "j", "xi", "init", "hi", "ori", "phi", "y", "is", "ui", "fi", "di", "gi", "ci", "qi", "info", "index", "I"], "doIt": [" doIs", "waIt", " doIT", "donIt", "odoit", "didIs", "diWhich", "doneIT", "doIs", "doYou", " doHe", "donIT", "doneIt", "waIT", "doIT", " doWhich", "diit", " doit", "diHe", "didYou", "doneit", "odoIT", "odoIt", "didit", "donit", "doit", "diIt", "donYou", "odoWhich", "doWhich", "doHe", "waIs", "donIs", "odoHe", "didIt", " doYou"], "src": ["loc", "rel", "ins", "sl", "rt", "ssl", "sh", "copy", "rc", "rs", "https", "sc", "usr", "ources", "crop", "sys", "ource", "rob", "from", "st", "sq", "sec", "gs", "rl", "http", "inst", "ser", "trans", "init", "impl", "sub", "sb", "ptr", "tmp", "rx", "comp", "source", "lb", "syn", "proc", "inner", "conv", "input", "r", "start", "ctr", "rb", "sr", "url", "rest", "cont"], "dest": ["loc", "rel", "output", "https", "port", "Dest", "dat", "usr", "way", "target", "nw", "sys", "origin", "st", "gest", "slave", "dist", "orig", "trans", "dir", "des", "coord", "nom", "pot", "sp", "est", "tmp", "pipe", "cp", "master", "out", "mem", "comb", "source", "iter", "foreign", "cat", "proc", "decl", "pas", "desc", "rest", "local", "temp", "cont", "can"]}}
{"id1": "18504192", "id2": "1357662", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " CopyFiles", "copyfile", " transferfile", " CopyStream", "CopyFiles", " transferStream", "CopyFile", "copyFiles", "CopyStream", "Copyfile", " transferFile", " CopyFile", " transferFiles", " Copyfile"], "in": ["ins", "din", "el", "en", "b", "id", "old", "IN", "inn", "inf", "cin", "gin", "on", "mm", "from", "ic", "it", "or", "vin", "as", "edIn", "ind", "is", "inc", "up", "rin", "input", "i", "l", "o", "isin", "In", "n"], "out": ["k", "ot", "output", "OUT", "b", "v", "serv", "ex", "gt", "s", "net", "ne", "io", "err", "outs", "it", "ou", "to", "po", "nt", "i", "oss", "g", "help", "os", "l", "t", "log", "o", "Out", "at", "w", "n"], "source": ["access", "inside", "scope", "copy", "store", "search", "shell", "seed", "scan", "style", "SOURCE", "position", "match", "instance", "service", "sin", "secret", "ources", "back", "iterator", "origin", "sequence", "ource", "src", "space", "me", "subject", "from", "resource", "volume", "spec", "comment", "init", "query", "file", "force", "ie", "reader", "before", "system", "open", "template", "pse", "se", "input", "create", "inner", "start", "parse", "Source", "sample", "use", "info", "local"], "destination": ["restation", " destinated", "seeination", "comification", " destinator", "seeension", "restinator", "restinated", " destension", "destregation", "Destination", "seeinator", "Destension", "Destinated", " destregation", " destato", "Destinator", "destato", "destation", "Destation", "seeinated", " destation", "comregation", "coordification", "coordination", "comato", "destification", "coordato", "restination", "coordregation", "comination", "destension", " destification", "destinated", "destinator"]}}
{"id1": "11546108", "id2": "4750967", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"run": ["running", "evaluate", "invoke", "exec", "search", "scan", "Run", "launch", "runs", "process", " runs", "hello", "block", "runner", "apply", "render", "impl", "execute", "call", "loop", "submit", "find", "start", "sample", " Run", "wait", "go", "func"], "in": ["f", "ins", "din", "copy", "again", "fin", "p", "sum", "IN", "er", "inn", "ln", "inf", "cin", "gin", "on", "bin", "from", "by", "and", "add", "all", "mc", "mn", "file", "ma", "reader", "is", "inc", "line", "out", "rin", "get", "input", "r", "source", "inner", "oin", "conf", "l", "asin", "isin", "info", " din", "read", "In"], "ligneEnCours": ["ligneENCsours", "ligneEnNourses", "ligneEnCsours", "ligneEncears", "ligneEnCourses", "ligneEnConturs", "ligneENcours", "ligneENContChamp", "ligneEnChour", "ligneEnContRS", "ligneEnCuChamp", "ligneEnCsour", "ligneEnCoours", "ligneENConturs", "ligneConcurs", "ligneEnChodes", "ligneConcour", "ligneEnCuours", "ligneENNourses", "ligneENCons", "ligneENCRS", "ligneEnCoodes", "ligneENCsour", "ligneEnCons", "ligneEnCour", "ligneENCour", "ligneConcodes", "ligneEnCoourses", "ligneConCurs", "ligneEnClChamp", "ligneENcears", "ligneEnNurs", "ligneEnClRS", "ligneEnCsons", "ligneEnCurs", "ligneEnNours", "ligneEncour", "ligneENNurs", "ligneEnNres", "ligneEnCsurs", "ligneConCour", "ligneENCChamp", "ligneENNres", "ligneEnACears", "ligneEnContours", "ligneENCsons", "ligneEncurs", "ligneConCodes", "ligneEnCoons", "ligneENCurs", "ligneEncours", "ligneEnACours", "ligneENCours", "ligneENCres", "ligneENCourses", "ligneEnACurs", "ligneConCours", "ligneENContRS", "ligneEnCres", "ligneEnCodes", "ligneEnCuurs", "ligneEncons", "ligneEnCears", "ligneENcour", "ligneEnCoour", "ligneEnCuRS", "ligneENcurs", "ligneENNours", "ligneEnACour", "ligneEnCores", "ligneEnCChamp", "ligneConcours", "ligneEnClurs", "ligneENContours", "ligneENCsurs", "ligneEnCRS", "ligneEncodes", "ligneENCears", "ligneEnContChamp", "ligneEnChours", "ligneEnChurs", "ligneEnClours"], "i": [" j", "cli", "mi", "b", " I", "pi", "v", "ix", "p", "ini", "ii", "si", "e", "ai", "io", "bi", "n", "m", "iu", "continue", "it", "multi", "ei", "li", "ti", "j", "xi", "init", "x", "ori", "phi", "y", "ind", "is", "ui", "off", "iter", "g", "di", "oi", "l", "asi", "ci", "t", "index", "I"], "informations": ["Informsates", "ingenerions", "Informates", "InformATIONS", "instrations", "informates", "Informsions", "InformsATIONS", "informsions", "information", "informATIONS", "inflations", "Informions", "ingenerATIONS", "ingenerates", "instrators", "inflates", "informsATIONS", "Informsations", "instrATIONS", "Information", "informsations", "informsation", "Informsation", "Informsators", "inflions", "informions", "informsates", "inflators", "Informators", "inflation", "informsators", "ingenerations", "informators", "Informations", "instration", "inflATIONS"], "version": ["server", "value", "id", "v", "port", "position", "channel", "class", "format", "description", "sequence", "program", "part", "status", "major", "ver", "label", "edition", "client", "serial", "number", "title", "source", "type", "versions", "index", "VERSION", "action"], "url": ["loc", "host", "domain", "id", "location", "pattern", "format", "path", "print", "str", "resource", "http", "link", "label", "browser", "URL", "file", "base", "address", "source", "title", "filename", "uri", "Url", "l", "download", "href"], "texteErreur": ["texteErneur", "texteErbreur", "texteErrorbreUR", "texteErrerurred", "texteErbreul", "texteErREut", "texteErrut", "texteErreuer", "texteCorseure", "texteCorreult", "texteErrur", "texteErreure", "texteStrneurred", "texteErriur", "texteCorreur", "texteErruer", "texteErleur", "texteErrorbreur", "texteErrorbreuer", "texteErseura", "texteStrreurred", "texteIrbreul", "texteErreurred", "texteStrneur", "texteIrbreUR", "texteErrorreuer", "texteErseul", "texteErrerurs", "texteErreult", "texteErreurs", "texteErrerur", "texteErrure", "texteErbreura", "texteErREur", "texteErreut", "texteErbreUR", "texteCorseult", "texteErneurred", "texteErrorreUR", "texteErreUR", "texteErseut", "texteErriura", "texteIrbreura", "texteErruleurs", "texteCorseut", "texteErrult", "texteErreul", "texteErrorreur", "texteIrreul", "texteErreura", "texteIrreura", "texteErruleurred", "texteCorreure", "texteErREure", "texteErriUR", "texteErrUR", "texteStrreur", "texteIrbreur", "texteErREult", "texteCorseur", "texteErseult", "texteErriul", "texteErseur", "texteErrorreure", "texteErruleur", "texteErleure", "texteIrreUR", "texteErseure", "texteErrorbreure", "texteErleUR", "texteErseUR", "texteStrreurs", "texteErbreuer", "texteErleuer", "texteStrneurs", "texteErneurs", "texteErbreure", "texteIrreur", "texteCorreut"], "numErreur": ["numErReurs", "numErbreur", "numErneau", "numErReau", "numerReur", "numErneurs", "numErr\u00e9iber", "numErneur", "numErbreiber", "numErneUR", "numerreiber", "numErreau", "numErreiber", "numErr\u00e9urs", "numErReUR", "numerReUR", "numErreUR", "numErbreurs", "numerReurs", "numErReur", "numerreurs", "numErr\u00e9ur", "numErbreUR", "numerReiber", "numErreurs", "numerreur", "numErr\u00e9UR", "numerreUR", "numErbreau", "numErReiber"], "al": [" sal", "el", "cal", "ial", "bl", "AL", " fal", "alist", "bal", " wal", "ral", "alog", "tal", "ali", "alf", "aval", " bal", "af", "dal", " tal", "wal", " recal", "ar", "hal", "sal", "a", "all", "pal", "alon", " aval", "ad", "stal", "ale", "fal", "mal", "atal", "als", "ap", " hal", "Al", "l", "sel", "ald", " mal", " cal", " bl", "att"]}}
{"id1": "15645004", "id2": "10540676", "code1": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"unzip": ["undrop", " unpack", "openpackage", "unpackage", "Unpackage", "opendrop", "openzip", "openpack", " undrop", "Unpack", " unpackage", "unpack", "Undrop", "Unzip"], "filename": ["f", "folder", "p", "bf", "doi", "location", "archive", "SourceFile", "println", "nm", "kl", "fil", "path", "csv", "ename", "src", "subject", "via", "sf", "Filename", "pkg", "File", "FILE", "nl", "ivo", "metadata", "NAME", "prefix", "file", "kj", "nil", "fn", "directory", "existent", "name", "zip", "word", "txt", "fp", "ame", "title", "username", "uri", "source", "url", "n"], "in": ["mi", "ins", "din", "inside", "en", "ry", "ri", "fin", "pin", "ir", "ex", "ini", "sum", "ze", "IN", "inn", "con", "ln", "io", "inf", "cin", "gin", "local", "mm", "bin", "from", "it", "ar", "ic", "vin", "and", "add", "inv", "init", "file", "al", "reader", "ind", "zip", "is", "inc", "out", "up", "rin", "i", "input", "iter", "inner", "conf", "ill", "isin", "info", " din", "In"], "entry": ["image", "record", "pe", "entity", "field", "ry", "header", "match", "je", "archive", "pattern", "char", "instance", "enter", "list", "ent", "rance", "e", "cell", "member", "qual", "xml", "set", "from", "or", "part", "add", "link", "comment", "attribute", "item", "key", "card", "connection", "file", "obj", "ie", "nt", "directory", "existent", "event", "zip", "word", "system", "element", "def", "check", "ace", "inter", "line", "se", "inner", "row", "existing", "next", "ce", "Entry", "zo", "info", "index", "result"], "first_entry": ["firstKnownneeded", "first_connection", "first_directory", " first_connection", "first_ent", " first_Entry", " first_directory", " first_record", " first_iterator", "First_needed", "First_file", "first_needed", "First_entry", "first_iterator", "firstKnownentry", "first_record", "first_file", "first_Entry", " first_ent", "firstKnownexistent", "First_existent", "first_existent", "firstKnownfile"], "subdir": ["Subdel", "relDir", "ubdef", "ubdel", " subdel", " subfolder", "subdel", "subDir", "reldir", "supdir", "ubvol", "Subdir", "relfolder", "ubdir", "superdir", " subgroup", "superfolder", "supfolder", "subvol", "ubgroup", " subDir", "superdel", "Subfolder", "ubDir", "ubfolder", "subdef", "relvol", "supdel", "Subdef", "Subvol", "SubDir", "subfolder", "subgroup", " subdef", "supgroup"], "dir": ["div", "loc", "folder", "dr", "copy", "id", "ir", "self", "window", "path", "dest", "io", "addr", "src", "pkg", "mod", "direction", "vol", "all", "prefix", "init", "file", "DIR", "tmp", "directory", "parent", "pos", "name", "ind", "zip", "out", "doc", "cur", "uri", "wd", "db", "iter", "row", "desc", "url", "Dir", "root", "fd", "temp", "d", "module"], "outfile": [" outlink", "outputline", "fromfile", "indb", "outload", "infield", "OutFile", "outdb", "altfile", "outfield", "outline", "newFile", "newdir", "inload", "fromFile", "outputdir", "inFile", "newlink", "altFile", "Outlink", "inline", "fromline", "newfile", "infile", "outputFile", "fromfield", "outputfile", "outputfield", "Outdb", "indir", " outFile", "Outfile", "altload", "Outdir", "outFile", " outload", "outlink", "outputdb"], "outdir": ["subfd", "outputfd", "outDir", " outfolder", "outwd", "newDir", " outDir", "outdb", "outputDir", "subdb", "outfd", "outcond", "OUTcond", "OUTfolder", "newdir", "Outfolder", " outwd", "outputdir", "Outrun", "subwd", "OUTdir", "Outcond", "OUTrun", " outfd", "newdb", "subcond", "outputfolder", "subrun", " outdb", "outrun", "newfolder", "subfolder", "Outdir", "outputwd", "outfolder", "outputdb"], "fo": ["eto", "oos", "wt", "co", "mo", "fif", "bo", "ott", "tif", "te", "FO", "io", "flo", "oo", "sty", "uo", "opa", "obo", "ho", "xf", "po", "so", "soc", "fi", "wo", "aco", "oe", "os", "ero", "o", "oso", "zo", "jo", "info", "hea", "ato"], "bos": ["fs", "bys", "oos", "pdf", "tops", "bs", "mos", "bits", "ows", "cs", "bes", "bo", "bas", "bi", "sys", "nos", "obs", "bin", "outs", "js", "ots", "ds", "dos", "bis", "bh", "ts", "eros", "boards", "aos", "tes", "so", "fits", "cos", "uts", "jas", "oops", "uds", "oss", "ops", "es", "os", "ods", "bytes", "los", "zo", "ws", "ios"], "read": ["length", "readable", "bind", "copy", "en", " count", "stream", "old", "count", "transfer", "select", "allow", "index", "print", "Read", "buffer", "give", "val", "pack", "continue", "text", "view", "reads", "size", "load", "add", "reading", "ready", "skip", "fill", "READ", "query", "ad", "run", "build", "seek", "depth", "open", " Read", "check", "write", "loop", "get", "len", "feed", "input", "find", "iter", "close", "start", "play", "parse", "log", "end", "next", "first", "draw", "w", "send", "n"], "data": ["image", "DATA", "length", "value", "ata", "dl", "cache", "dat", "message", "window", "area", "content", "partial", "sequence", "buffer", "valid", "str", "bin", "block", "zero", "raw", "text", "da", "table", "size", " DATA", "step", "all", "ATA", "res", "batch", "good", "no", "def", "extra", "out", "done", "bus", "number", "results", "json", "row", "bytes", "o", "sample", "pad", "next", "d", "n"], "read_position": ["read_size", "read_chain", " read_chain", "read_location", " read_location", " read_size"]}}
{"id1": "21363911", "id2": "4481712", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testTransactions": ["testTacts", " testTransaction", "testtransacts", " testTransacts", "testTactions", " testtransitions", "testTransaction", " testtransactions", " testtransaction", " testtransacts", "testTransitions", "testtransactions", " testTransitions", "testTaction", "testtransitions", "testTitions", "testtransaction", "testTransacts"], "con": ["enc", "gen", "cc", "ln", "un", "pen", "re", "Con", "cv", "res", "cp", "pl", "xc", "util", "cal", "co", "ran", "ens", "com", "cache", "don", "ctx", "ac", "pt", "conn", "ic", "gc", "console", "ain", "ch", "ctrl", "conv", "conf", "cons", "sur", "cm", "cn", "en", "bn", "bo", "connect", "nc", "sc", "c", "mc", "po", "fn", "pc", "ren", "CON", "win", "config", "fl", "go", "fc", "rc", "cf", "dial", "dn", "tc", "rec", "on", "anc", "gate", "connection", "act", "open", "client", "cur", "bc", "db", "coll", "ct", "cont", "can"], "st": ["sth", "wt", "et", "sl", "ft", "mt", "const", "std", "th", "rt", "co", "sts", " superst", "bo", "nd", "stage", "sc", "s", "stre", "ln", "sn", "stop", "str", "pt", "sw", "art", "irst", "stan", "it", "St", "sta", "inst", "step", "sty", "ts", "fr", "sb", "obj", "sol", "so", "sp", "bt", "est", "nt", "put", "h", "cr", "ST", "ld", "ste", "statement", "l", "cl", "ost", "start", "ct", "ist", "t", "stat", "rest", "ast", "must", "ust", "stra", "tt", "ut"], "rs": ["hr", "ins", "ars", "dr", "rt", "ri", "bs", "ris", "ros", "rots", "usr", "ms", "ress", "js", "gs", "re", "rates", "ts", "ims", "res", "ras", "aps", "ks", "its", "rd", "rus", "ges", "icks", "ats", "xs", "dds", "ows", "arms", "vers", "arts", "vs", "rr", "ags", "rss", "ws", "rows", "els", "rings", "pres", "ls", "s", "vr", "times", "RS", "rl", "ems", "pc", "cases", "irms", "hs", "rets", "ps", "stats", "rel", "mr", "rc", "cs", "sts", "ues", "ys", "sys", "ns", "ss", "Rs", "rys", "ds", "ics", "ires", "rx", "acks", "r", "rm", "abs", "sr", "ubs", "qs"]}}
{"id1": "9327525", "id2": "18570190", "code1": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"test02_ok": ["test02__ok", "test02AOK", "test02__Ok", "test2_full", "test02Aok", "test2_Ok", "test2_OK", "test2_ok", "test02Afull", "test2__full", "test02_Ok", "test02__full", "test2__ok", "test02__OK", "test02_OK", "test02AOk", "test2__Ok", "test02_full", "test2__OK"], "client": ["cli", "context", "core", "ssl", "server", "co", "cache", "tc", "connect", "window", "api", "service", "con", "google", "secure", "handler", "cell", "sim", "acl", "network", "conn", "wrapper", "loader", "request", "c", "collection", "resource", "http", "control", "phone", "session", "connection", "console", "pool", "cp", "system", "call", "uri", "config", "policy", "close", "null", "cl", "app", "ci", "ip", "remote", "Client", "cm", "contact", "local"], "post": ["dd", "copy", "patch", "p", "process", "form", "test", "valid", "pre", "set", "pp", "Post", "request", "push", "http", "load", "add", "method", "link", "upload", "read", "apply", "install", "wp", "op", "body", "build", "put", "zip", "call", "write", "posts", "get", "POST", "submit", "ost", "ip", "url", "row", "parse", "next", "save", "pod", "and", "send"], "nameValuePairs": ["nameValueParappings", "nameNameParars", "nameValuesPonents", "nameValueParuffs", "nameValuePararms", "nameValueCompings", "nameValueAssair", "nameNamePersings", "nameValuePersairs", "nameValuePersars", "nameValueParars", "nameValuePersuffs", "nameValueEairs", "nameValuePars", "nameNamePersars", "nameValueCharms", "nameValueAssairs", "nameNamePair", "nameValueparms", "nameValuePonents", "nameValueAppings", "nameNameParms", "nameValueAssarms", "nameValuesPings", "nameValueputes", "nameValueChappings", "nameValuesParms", "nameNamePairs", "nameValuePointarms", "nameNamePars", "nameValueChars", "nameValuepairs", "nameValuesPair", "nameValueCompairs", "nameValuePersonents", "nameValuesPars", "nameValueAssars", "nameValuespairs", "nameValueApparms", "nameValuepars", "nameNamePersairs", "nameValueParair", "nameValuePings", "nameValuePersappings", "nameValueChair", "nameValuePores", "nameValuespair", "nameValueEars", "nameValueponents", "nameValuePair", "nameValuesPappings", "nameValuePutes", "nameValueParairs", "nameNamePersarms", "nameValueCompappings", "nameValueAppairs", "nameValueEair", "nameValuespings", "nameValueMaputes", "nameNamePersutes", "nameValuepair", "nameValuePointonents", "nameValuePersutes", "nameValuePersair", "nameNameParores", "nameValuePersarms", "nameValuePointairs", "nameValuePointars", "nameValuePappings", "nameNamePutes", "nameValueCompair", "nameValuePersings", "nameValueParores", "nameNamePores", "nameValuePuffs", "nameValueChings", "nameValuesponents", "nameValuesPairs", "nameNameParairs", "nameNamePings", "nameValueCompars", "nameValueChairs", "nameValueMapairs", "nameNamePersair", "nameValuespappings", "nameValuepings", "nameValuepores", "nameValueParms", "nameValuepappings", "nameValuesparms", "nameValuespars", "nameValueMapars", "nameValuepuffs", "nameNameParair"], "response": ["onse", "object", "reply", "output", "server", "header", "model", "channel", "profile", "message", "given", "description", "service", "ve", "sequence", "tree", "block", "example", "resp", "entry", "application", "request", "view", "answer", "network", "resource", "http", "status", "frame", "volume", "page", "report", "connection", "res", "document", "console", "body", "pos", "def", "still", "respond", "Response", "json", "version", "command", "result"], "entity": ["image", "el", "object", "quote", "pe", "output", "encrypted", "person", "voice", "model", "channel", "eme", "ity", "data", "message", "instance", "ent", "e", "empty", "my", "ITY", "xml", "entry", "Entity", "error", "resource", "status", "note", "ell", "metadata", "comment", "obj", "document", "body", "code", "existent", "event", "put", "line", "activity", "details", "oe", "json", "type", "ENT", "eric", "ce", "ee", "result"], "instream": ["Inform", "inspod", "Inline", "insstream", "insline", "Instream", "inputcontext", " inform", " inStream", " inconsole", "outcontext", "inStream", "inputstream", "inline", "inputStream", "inform", "inpod", "inputform", "inputconsole", " inpod", "inscontext", "outform", "incontext", "Inconsole", " incontext", "inconsole", " inline", "outStream", "inputline", "inputpod", "outstream"], "reader": ["operator", "stream", "holder", "liner", "upper", "ader", "relation", "er", "iterator", "driver", "handler", "editor", "buffer", "parser", "maker", "loader", "writer", "rl", "runner", "reading", "READ", "builder", "file", "console", "controller", "rr", "Reader", "rar", "latest", "ner", "r", "book", "inner", "rer", "row", "roller", "read"]}}
{"id1": "20920051", "id2": "14785308", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"copyTo": ["moveDir", "CopyFiles", "copyFiles", "transferTo", "transferFiles", "copyFrom", "opyPhoto", "CopyTo", " copyFile", "CopyFrom", "moveOver", " copyPhoto", "transferFile", " copyFiles", "copyFile", "moveTo", " copyFrom", "opyDir", "movePhoto", "copyOver", " copyOver", "opyOver", "copyDir", "copyPhoto", "CopyFile", "transferFrom", " copyDir", "opyTo"], "source": ["shell", "style", "old", "id", "empty", "target", "src", "status", "visible", "note", "sql", "file", "missing", "sp", "template", "get", "se", "details", "oss", "null", "use", "local", "scope", "store", "search", "seed", "select", "sort", "entry", "size", "spec", "init", "name", "unit", "start", "Source", "original", "sl", "copy", "service", "sin", "s", "subject", "raw", "sf", "resource", "query", "ie", "base", "parent", "ace", "pse", "input", "config", "site", "component", "image", "scan", "SOURCE", "flat", "secure", "origin", "ource", "from", "part", "none", "iter", "sample"], "dest": ["loc", "del", "folder", "port", "Dest", "dat", "self", "path", "target", "ref", "test", "origin", "src", "st", "it", "tom", "dist", "dc", "to", "orig", "trans", "dir", "des", "nom", "dev", "tmp", "nt", "est", "parent", "name", "master", "this", "good", "opt", "pro", "out", "txt", "doc", "null", "desc", "rest", "end", "d", "w", "deg", "result"], "temp": ["mt", "unt", "p", "dat", "alt", " tmp", "mk", " temporary", "empty", "por", "path", "test", "EMP", "tar", "buffer", "mm", "pt", "mod", "em", "orig", " Temp", "emp", "Tem", "mp", "tmp", "parent", "porary", "cp", "zip", "out", "txt", "w", "template", "Temp", "pl", "rem", "rm", "tm", "tem", "null", "tab", "fake", "make", "t", "local", "stem"], "sel": ["del", "el", "ael", "sl", "kel", "ial", "zh", "ls", "nel", "lf", "rol", "sc", "select", "selected", "ele", "Sel", "elect", "kl", "ml", "le", " sl", "fol", "cell", "nav", "El", "cel", "rl", "sels", "nl", "sv", "ser", "sol", "so", "sil", "pl", "se", "syn", "Se", "cl", "fl", " lic", "selection", "mil", "sen", "lv"], "tempDest": ["poraryTemp", "poraryDec", "ptDest", " tempdest", " temporaryNeg", "destLoc", "poraryDe", "poraryDir", " tempDir", "tempNeg", "tempLoc", "destTemp", "destDec", "temDe", "ptNeg", " tempNeg", "poraryLoc", " tempTemp", "tempDe", "mmLoc", "poraryDest", " temporaryTemp", "destDest", "mmDest", "ptdest", "temdest", "tempDir", " temporarydest", " tempDe", "ptTemp", "mmTemp", "tempTemp", "mmDec", " temporaryDest", "temDest", "tempDec", "porarydest", "temDir", "tempdest"], "sourceCh": ["seedChan", "ourceColl", "seedCh", "statusCol", " sourceCor", "sampleCh", "samplech", "srcCh", "startCol", "ourceChan", "sourcech", "ourceCr", "ourceCH", "sampleCor", "srcCol", "sourceCol", " sourceCH", "srcCor", "srcChan", "startCh", "statusCh", "sourceCH", "statusCr", "sourceChan", "seedColl", " sourceCol", " sourcech", "startComp", "statusCH", "startCH", "srcColl", "sampleComp", "sourceComp", "srcch", "sourceCr", " sourceCr", "seedCol", "ourceCol", "sourceCor", " sourceComp", "srcCH", "sourceColl", "srcComp", "ourceComp", "ourceCh"], "destCh": ["destCol", "destC", "tempChan", " destChan", "estC", " destChar", " destCl", "tempCh", "estDest", " destCol", "targetChar", "tempCl", "usrCh", "usrC", "targetChan", "destChan", "targetC", "restChan", "restC", "destDest", "estCl", "destCl", "usrChar", " destDest", "restCol", " destC", "targetCh", "destChar", "usrChan", "tempCol", "restCh", "estCh", "tempC"]}}
{"id1": "20623709", "id2": "15822137", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"split": ["copy", "scan", "scale", "count", "transfer", "format", "disk", "sync", "process", "part", "join", "map", "upload", "share", "batch", "Split", "seek", "slice", "unit", "open", "lock", "append", "write", "parse", "align", "use", "read"], "targetDirectory": ["baseDirectory", " targetdirectory", "testDirect", "baseDir", "baseFile", "TargetDirectory", "TargetFolder", " targetLocation", "localdirectory", "TargetLocation", "targetMemory", "localDir", " targetFolder", " targetDir", "testDir", "targetdirectory", "targetLocation", "targetDir", "baseDirect", "baseMemory", "Targetdirectory", "baseFolder", "targetFile", " targetMemory", "testLocation", " targetFile", "localFile", "TargetDirect", "testDirectory", "TargetDir", "targetDirect", " targetDirect", "localDirectory", "targetFolder", "TargetMemory", "basedirectory"], "prefix": ["fixed", "pres", "p", "ix", "pattern", "format", "localhost", "path", "pre", "zero", "pkg", "Pref", "status", "size", "alias", "key", "tag", "FIX", " suffix", "base", "directory", "fixes", "name", "this", "fix", "template", "title", "username", "filename", "uri", "version", "type", "padding", "division", "root", "password", "command", "index", "PRE", "pi"], "maxUnitBases": ["maxUnityAliades", "maxUnityLicas", "maxUnityLounds", "maxUnityBounds", "maxUnityLases", "maxUnitReplases", "maxUnitChases", "maxUnitReplounds", "maxUnitChias", "maxUnityBases", "maxUnityAliias", "maxUnitBounds", "maxUnitChounds", "maxUnitBades", "maxUnitbades", "maxUnitBicas", "maxUnitReplicas", "maxUnitbias", "maxUnityAliases", "maxUnitLages", "maxUnityBages", "maxUnitReplages", "maxUnitLases", "maxUnitAliases", "maxUnitChades", "maxUnitChages", "maxUnitLicas", "maxUnityBicas", "maxUnitAliias", "maxUnitbounds", "maxUnitAliounds", "maxUnitLounds", "maxUnitChicas", "maxUnityLages", "maxUnitBias", "maxUnityBades", "maxUnitbases", "maxUnitAliades", "maxUnityAliounds", "maxUnitBages", "maxUnityBias"], "maxUnitEntries": ["maxUnityEntries", "maxUnitEntryries", "maxUnitErires", "maxUnitentries", "maxUnitEntryrys", "maxUnitIntegriers", "maxUnityentries", "maxUnitErrys", "maxUnitIntegires", "maxUnitIntegrys", "maxUnitentrs", "maxUnitEntryires", "maxUnityEntrys", "maxUnitEntryriers", "maxUnityentrys", "maxUnityEntires", "maxunitEntries", "maxunitEntrs", "maxUnityentrs", "maxunitEntires", "maxUnityentires", "maxUnitEntrys", "maxUnitentires", "maxUnitEntriers", "maxunitEntrys", "maxUnitEntires", "maxUnitEntrs", "maxUnityEntrs", "maxUnitErrs", "maxUnitIntegries", "maxUnitentrys", "maxUnitErries"], "fis": [" fi", " fii", "Fis", " fiss", "fiss", "vic", "fic", "ifci", "ifii", "fii", "ifis", " fic", "Fic", "vis", "fi", "Fci", "viss", "vi", "Fiss", "Fi", "Fii", "ific"], "fci": ["tcu", "cfai", "mii", "Fini", "tco", "Fco", " fii", "cfini", "Fis", "cfco", "cfic", "cfis", "cfico", " fai", "tii", "fic", "mci", " fcu", "tci", "fcu", "cfci", "fii", "mco", "fico", " fic", "Fic", "mcu", "fai", "Fci", "Fico", "fini", " fico", " fini", "Fai"], "fos": ["yaos", "wos", "foss", " faos", "floss", "Foss", "yios", "Faos", "wios", "ybos", " foss", "fbos", "wbos", "flaos", "FOS", "yos", "flos", "fOS", "faos", "waos", "Fos", "flOS", " fios", " fOS", "fios", " fbos"], "fco": ["pco", "Foco", "pci", "Fco", " fcos", "tco", "Fcon", " fdo", "cdo", "tcos", " fso", "pcos", "fso", "Fso", "cso", "toco", "pso", "Fcos", "fcos", "Fdo", " fcon", "ccon", "tdo", "fcon", "Fci", "cco", "fdo", " foco", "foco"], "buffer": ["length", "callback", "record", "binary", "holder", "position", "match", "cache", "channel", "data", "message", "window", "char", "buf", "order", "queue", "sequence", "stack", "database", "phrase", "block", "print", "entry", "button", "timeout", "limit", "table", "black", "bridge", "note", "comment", "document", "function", "batch", "library", "address", "event", "append", "template", "memory", "source", "iter", "reset", "row", "Buffer", "flush", "padding", "buff", "filter", "sample", "pause", "command", "index", "temp", "read", "result", "complete"], "currentBasesCount": ["currentBasedCount", "currentBasedCode", "currentbasesCount", "currentBasedLength", "currentBadesLength", "currentbasesLength", "currentbaseCount", "currentbasesCode", "currentBadesCode", "currentBaseCode", "currentBaseLength", "currentbaseCode", "currentbaseLength", "currentBaseCount", "currentBasesLength", "currentBadesCount", "currentBasesCode"], "currentEntriesCount": ["currentEntrsCount", "currentEntrysCount", "currentEntriesCode", "currentEntriesFlag", "currentEntiesFlag", "currentEntiesCount", "currentEntiesCode", "currentEntrysCode", "currentEntrsCode", "currentEntrysFlag", "currentEntrsFlag"], "targetCount": ["argetCount", " targetAmount", " targetInfo", "targetNum", "argetInfo", "TargetInfo", "TargetCount", "argetNum", "TargetAmount", "TargetNum", "argetAmount", " targetNum", "targetInfo", "targetAmount"], "fastaChannel": ["fastityChan", "fastpaButton", "fastoChan", " fastaQueue", "fastoProvider", "fastaiQueue", "fastityQueue", "fastoChannel", "fastityStream", " fastaButton", "fastoConnection", "fastoQueue", " fastaChan", "fastaProvider", "fastpaConnection", "fastityChannel", "fastaButton", " fastaProvider", " fastaStream", "fastaConnection", "fastaQueue", " fastoStream", "fastaStream", "fastaiStream", "fastaiChannel", "fastaiChan", "fastpaChannel", "fastoStream", "fastaChan", "fastpaProvider", "fastoButton", " fastoQueue", " fastoChan", " fastaConnection", " fastoChannel"], "totalSeqCount": ["totalSegCounter", "totalSeQCount", "totalSeqsSize", "totalSeQCounter", "totalSeqsCounter", "totalSeqsCode", "totalSeQCode", "totalSeqCode", "totalSegSize", "totalSegCount", "totalSegCode", "totalSeqSize", "totalSeqCounter", "totalSeQSize", "totalSeqsCount"], "totalResiduesCount": ["totalResiduationsCode", "totalResIdueCount", "totalResidusCount", "totalResIduesCode", "totalResidusCode", "totalResiduesFlag", "totalResIduesCount", "totalResIduesFlag", "totalResidueCount", "totalResiduationsCount", "totalResidueCode", "totalResidueFlag", "totalResIdueFlag", "totalResiduationsFlag", "totalResIdueCode", "totalResidusFlag", "totalResiduesCode"], "prevTime": ["parThread", "parTime", " previousThread", "parT", " prevThread", " previousT", " prevT", " previousTime", "prevThread", "prevT"], "fastaFileSize": ["fastaFilesLength", "fastaReaderLength", "fastATableLength", "fastaFileName", "fastaTableSize", "fastoFileLength", "fastATableName", "fastaFilesHeight", "fastATableHeight", "fastAFileHeight", "fastoFileSIZE", "fastATableSize", "fastaChainSIZE", "fastoTableSize", "fastaFileLength", "fastaFilesName", "fastaChainLength", "fastaTableHeight", "fastafileSize", "fastoTableOwner", "fastAFileLength", "fastafileSIZE", "fastoTableSIZE", "fastAFileSize", "fastaReaderName", "fastaFileOwner", "fastaReaderHeight", "fastaTableOwner", "fastaChainOwner", "fastaReaderSize", "fastaFilesSize", "fastoTableLength", "fastoFileSize", "fastaTableName", "fastaFileHeight", "fastaTableLength", "fastafileOwner", "fastaChainSize", "fastAFileName", "fastafileLength", "fastaFileSIZE", "fastaTableSIZE", "fastoFileOwner"], "fastaFileReadOffset": ["fastaFilesLoadLength", "fastaFilereadOrder", "fastaFilereadOffset", "fastaPageReadOffset", "fastaFileInputLocation", "fastaFileInputPosition", "fastaPageReadOrder", "fastaFileWriteOffset", "fastaFileWriteAmount", "fastaChainReadPosition", "fastaFilesReadLength", "fastaFileReaderoffset", "fastaFileReadLocation", "fastaFilesReadAmount", "fastaFileViewAmount", "fastaFileReadOrder", "fastaFilereadAmount", "fastaFileCurrentoffset", "fastaFileInputAmount", "fastaFileCurrentLocation", "fastaFileViewPos", "fastaPageLoadPos", "fastaFileReadLength", "fastaFileCurrentPosition", "fastaFileInputoffset", "fastaFilesLoadOffset", "fastaPageLoadOffset", "fastaChainReadOffset", "fastaFileReadAmount", "fastaFileWriteOrder", "fastaChainReadoffset", "fastaFilesReadOffset", "fastaChainCurrentOffset", "fastaFilesLoadAmount", "fastaFilesLoadOrder", "fastaPageReadPos", "fastaChainCurrentoffset", "fastaFileCurrentOffset", "fastaChainCurrentLocation", "fastaFileReadPos", "fastaFileInputOrder", "fastaFileLoadLength", "fastaFileViewOrder", "fastaFileReaderPosition", "fastaPageLoadAmount", "fastaChainReadLocation", "fastaFileLoadOrder", "fastaFileWriteLength", "fastaFileLoadOffset", "fastaPageReadAmount", "fastaFileReaderOffset", "fastaFileLoadAmount", "fastaFileLoadPos", "fastaFileInputLength", "fastaFileInputOffset", "fastaFileReadoffset", "fastaFileViewOffset", "fastaFilesReadOrder", "fastaFileReaderLocation", "fastaFileReadPosition", "fastaPageLoadOrder", "fastaChainCurrentPosition", "fastaFilereadPos"], "partitionStartOffset": ["partitionEndOff", "partitionStartPoint", "partitonStartingPosition", "partitionEndPosition", "partitonStartOff", "partitionDataPoint", "partitonStartOffset", "partitionStartPosition", "partitonStartingOff", "partitionStartingPoint", "partitionDataOff", "partitionDataPosition", "partitionStartOff", "partitionStartingOff", "partitionStartingPosition", "partitionEndPoint", "partitionDataOffset", "partitonStartingOffset", "partitionStartingOffset", "partitonStartPoint", "partitonStartPosition", "partitonStartingPoint"], "bufferSize": ["bufLength", "tableSIZE", "tableName", " bufferCode", "buffLength", "bufSIZE", "bufferSIZE", "sequenceSize", "bufferName", "tableSize", "buffSIZE", "sequenceLength", "buffName", " bufferSIZE", " bufferLength", "sequenceSIZE", "bufferCode", "BufferSIZE", "buffSize", "bufferLength", "bufCode", "BufferName", "sequenceCode", "BufferLength", "BufferSize", "tableLength", "bufSize"], "fastaBuffer": ["fastmaBuffer", "fastoStore", "wildanBuff", "fastmaBuilder", "fastmaStore", "fastoCounter", " fastoCounter", "fasteBuffer", "fastcaRequest", "FastaBuffer", "fastasBuilder", "FastmaBuffer", "fasteMemory", "fastoRequest", "fastasQueue", "fastasRequest", " fastaDB", " fastaBuilder", "fastasStore", "fastalCounter", "fastalBuff", "wildanCache", "fastasCache", "fastoBuff", "fastmaCache", "FastmaRequest", "fastuMemory", "fastalBuffer", "fastaMemory", "fastaCache", "fastaBuff", "fastaBuilder", "FastmaBuff", "fastasBuff", "wildaBuff", " fastoQueue", "wildaBuffer", "fastanCache", "fasteDB", "fastoBuffer", "FastaRequest", "fastsaBuff", " fastoBuffer", "fastcaBuffer", "fastcaCache", "fastasBuffer", "FastaBuff", "fastanBuffer", "fastmaBuff", "FastmaStore", " fastaCache", "fastalQueue", "wildanBuffer", "fastsaBuffer", " fastaCounter", "fastcaBuff", "fastaDB", "fastmaRequest", "fastaRequest", "fastuDB", "fastmaQueue", "fastasCounter", "wildanRequest", "fastanBuff", "fastanRequest", "wildaRequest", "wildaCache", "fastsaQueue", "FastaStore", "fastmaChannel", " fastaQueue", "fastaCounter", " fastaBuff", "fastoQueue", "fasteBuff", " fastaMemory", "fastaStore", "fastsaChannel", "fastaQueue", "fastuBuffer", " fastoBuff", "fastuBuff"], "fastaReadState": ["fastoReaderSTATE", "fastoReadStatus", "fastoReadSTATE", "fastaLoadType", "fastoReaderStatus", "fastaLoadStatus", "fastaLoadSTATE", "fastaReadSTATE", "fastaReaderType", "fastaCurrentStatus", "fastoReaderType", "fastoReadType", "fastaReadStatus", "fastaCurrentSTATE", "fastaReadType", "fastoReaderState", "fastaReaderState", "fastaCurrentType", "fastaReaderStatus", "fastaLoadState", "fastaCurrentState", "fastaReaderSTATE", "fastoReadState"], "nBytes": ["numNs", " nbytes", " nItems", "NItems", "nNs", "nsbytes", "NParts", "nBlocks", "nbytes", "nrBytes", "noBlocks", "NKeys", "NBytes", " nParts", "nItems", "nrItems", "numBlocks", "Nbytes", " nNs", "nrKeys", " nBlocks", "noNs", "nParts", "nKeys", " nWords", "noBytes", "numBytes", "numbytes", "nWords", "NWords", "nsBytes", "nrbytes", " nKeys", "nsWords", "nsParts", "nobytes"]}}
{"id1": "1357662", "id2": "18696387", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["CopFileTO", "copyFileFrom", "copyFileFile", "copyfileTO", "CopFileFrom", "CopFileFile", "copyDirectoryTo", "copyfileFile", "copyDirectoryFrom", "CopDirectoryFrom", "copyToFile", "copyToTo", "CopDirectoryFile", "copyToTO", "copyfileFrom", "copyDirectoryTO", "copyfileTo", "CopFileTo", "copyFileTO", "copyDirectoryFile", "CopDirectoryTO", "copyToFrom", "CopDirectoryTo"], "destination": ["delification", "destinator", "destinity", " destinated", "restification", "estinations", " desturation", " destinator", "estinated", "restinated", "Destification", " destinate", "delination", "Destination", "distinate", "Destinated", "estination", "distification", "catinated", "disturation", "catinate", "delinity", "destinate", "catination", "dominations", "descinate", "dominator", "deluration", "descination", "domination", "dominated", "descinated", "destification", "distinity", "estinator", "destinations", "restination", " destinations", "restinate", " destinity", "distinated", "desturation", "distination", "destinated", " destification", "descification", "catification", "Destinate"], "srcChannel": ["sinChan", "srcStream", " srcStream", " srcChan", "srcCase", " srcChain", "srChain", "srcCh", "srChannel", "insChain", "sysChan", "sourceChannel", "rcStream", "sourceConnection", "insChannel", "srChan", "insCh", "srcChain", "sysStream", " srcCh", " srcchannel", "sysChannel", "rcCh", "sysConnection", "rcConnection", "srcChan", "srcConnection", "srcchannel", "sinChannel", "sourceChan", " srcCase", "srCase", " srcConnection", "sinCase", "rcChannel", "sourceCh", "rcChan", "rcchannel", "rcChain", "sinChain", "insChan", "sourcechannel"], "destChannel": ["destC", "certCh", "certChannel", " destChan", "homechannel", "srcC", "certCan", "destConnection", "destCategory", "Destchannel", "DestCategory", "destChan", " destchannel", "homeChannel", "etcConnection", "etcChannel", "srcChan", "destCan", "srcConnection", "srcchannel", "DestCan", " destCan", "etcC", "DestCh", " destC", "homeChan", " destCh", "homeCategory", " destConnection", "DestConnection", "destCh", "DestChan", "destchannel", "DestChannel", " destCategory", "etcChan", "certConnection"]}}
{"id1": "9319440", "id2": "12171364", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"load": ["update", "store", "show", "process", "Load", "loader", "view", "link", "upload", "install", "init", "dump", "file", "loading", "build", "library", "loads", "open", "call", "get", "create", "save", "download", "read", "LOAD"], "id": ["image", "k", "uid", "Id", "data", "kid", "mid", "description", "token", "path", "ref", "rid", "it", "ident", "aid", "link", "tag", "key", "oid", "md", "ad", "sid", "edit", "hex", "code", "hash", "name", "pid", "ID", "event", "no", "h", "i", "title", "create", "uri", "one", "db", "l", "json", "ip", "t", "ids", "info", "and", "job"], "xml": ["image", "cloud", "context", "css", "pdf", "output", "model", "message", "format", "php", "s", "string", "content", "csv", "ml", "print", "m", "om", "tree", "tml", "pp", "text", "chart", "http", "response", "sv", "px", "export", "report", "img", "x", "document", "file", "sql", "sheet", "md", "batch", "body", "xf", "msg", "name", "zip", "mail", "txt", "template", "doc", "json", " XML", "parse", "tx", "t", "ql", "log", "html", "im", "n"], "url": ["loc", "f", "rel", "sl", "cmd", "ssl", "gl", "b", "git", "dl", "hl", "service", "bel", "con", "ref", "addr", "q", "ll", "ret", "loader", "resource", "http", "rl", "re", "ul", "comm", "nl", "link", "socket", "ur", "URL", "connection", "res", "cert", "build", "base", "dll", "mb", "open", "mount", "client", "lb", "r", "Url", "l", "cl", "att", "handle"], "conn": [" connection", "Connection", "con", "ctx", "http", "j", "socket", " con", "connection", "res", "Conn", "obj", "nt", "ch", " err", "open", "client", "txt", "w", " cs", "Url", " net", "ws", " res", "cb", " cur", "n"], "reader": ["context", "dr", "stream", "ri", "rc", "er", "iterator", "io", "handler", "buffer", "parser", "in", "wrapper", "loader", "writer", "rl", "resource", "http", "runner", "worker", "reads", "reading", "ser", "ro", "connection", "file", "nt", "rar", "Reader", "rx", "client", "cur", "r", "ner", "iter", "inner", "input", "rer", "row", "roller", "rot", "read"], "str": ["arr", "del", "z", "bl", "exec", "exp", "cs", "p", "gr", "ls", "STR", "data", "char", "Str", "string", "e", "s", "ev", "chain", "print", "err", "m", "st", "pt", "block", "text", "it", "entry", "part", "set", "comm", "j", "fr", "obj", "hex", "sp", "msg", "tr", "name", "line", "txt", "cr", "r", "syn", "bc", "inner", "source", "iter", "t", "next", "qs", "w", "cont", "n"]}}
{"id1": "20751378", "id2": "2465747", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"hashPassword": ["updateText", "HashText", "Hashpassword", "updatePrivate", " hashPrivate", "HashPrivate", "hashText", " hashText", "updatePassword", " hashpassword", "HashPassword", "hashpassword", "updatepassword", "hashPrivate"], "password": ["column", "value", "encrypted", "Password", "p", " Password", "security", "pattern", "language", "message", "sword", "email", "description", "secret", "string", "token", "user", "device", "print", "phrase", "database", "application", "request", "argument", "login", "command", "prefix", "attribute", "key", "query", "connection", "expression", "comment", "address", "directory", "PASS", "word", "name", "client", "property", "username", "input", "pass", "wd", "auth", "reset", "shadow", "crypt", "default", "padding", "wordpress", "hello", "w"], "hash": ["ash", "object", "rh", "ashing", "token", "has", "method", "reading", "bh", "ah", "report", "oh", "tag", "address", "mass", "check", "h", "username", "title", "alg", "her", "log", "locking", "sh", "value", "search", "cache", "string", "print", "proof", "hing", "zero", "array", "ping", " Hash", "replace", "key", "tr", "put", "number", "version", "shadow", "crypt", "filter", "result", "copy", "here", "other", "class", "sum", "message", "Hash", "user", "test", "str", "response", "build", "shift", "mask", "uh", "index", "handle", "dig", "sha", "ha", "total", "where", "checking", "block", "cloth", " hashing", "alert", "ho", "hex", "height", "trust", "also", "hed", "html", "hello"], "md": ["del", "dr", "dd", "cmd", "mt", "der", "red", "sha", "nd", "dh", "mk", "sd", "od", "ms", "mm", "m", "pm", "man", "pd", "mod", "js", "ds", "and", "add", "dir", "sam", "obj", "mn", "ad", "df", "managed", "mp", "mc", "dm", "det", "mand", "ind", "grad", "ld", "di", "cd", "bd", "hd", "d", "MD", "sm"]}}
{"id1": "3584508", "id2": "14502142", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": ["downloadFile", "downloadUrl", "downloadResource", "copyUrl", "copyFile", " copyFile", " copiedUrl", " copiedFile", "copyAddress", " copyAddress", " copiedAddress", "downloadAddress", " copyUrl", " copiedResource"], "url": ["loc", "f", "rel", "host", "el", "sl", "ssl", "gl", "https", "ls", "dl", "gif", "hl", "char", "service", "string", "github", "path", "ml", "ref", "web", "str", "ll", "ret", "resource", "http", "rl", "re", "ul", "nl", "link", "browser", "ur", "URL", "file", "cert", "base", "address", "mb", "mount", "mail", "source", "r", "uri", "Url", "l", "null", "cl", "fl", "util", "html"], "input": ["image", "initial", "context", "access", "inside", "ssl", "exec", "stream", "sum", "select", "enter", "Input", "pull", "index", "empty", "audio", "form", "user", "state", "acl", "in", "raw", "text", "it", "request", "http", "add", "eval", "active", "upload", "init", "file", "missing", "op", "base", "ain", "act", "reader", "before", "open", "up", "get", "source", "qa", "config", "feed", "inner", "iter", "null", "start", "ip", "unknown", "PUT", "parse", "accept", "focus", "info", "local", "read", "cont", "can"], "output": ["image", "update", "you", "object", "entity", "online", "other", "position", "format", "secure", "web", "net", "ne", "group", "print", "icon", "network", "continue", "hidden", "secondary", "text", "table", "Output", "response", "ou", "four", "ilo", "bool", "connection", "file", "console", "auto", "beta", "put", "current", "client", "out", "write", "display", "unsigned", "null", "success", "next", "o", "exit", "remote", "component", "outer"], "b": ["f", "k", "ba", "z", "u", "bs", "v", "bf", "binary", "bits", "p", "ib", "char", "bp", "bi", "nb", "m", "block", "ab", "c", "by", "fb", "j", "B", "wb", "sb", "obj", "eb", "ble", "body", "base", "y", "be", "mb", "gb", "bit", "br", "ob", "i", "r", "bc", "g", "db", "l", "rb", "t", "buff", "bb", "d", "cb"]}}
{"id1": "23452437", "id2": "8754809", "code1": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"internalCopy": [" deepCop", " internalSave", " doCopy", " doTransfer", "internalTransfer", " doCop", " deepTransfer", " internalCop", " deepSave", " deepCopy", " doSave", "internalCop", " internalTransfer", "internalSave"], "fSource": ["fileSourceFile", "rfSource", "dataSOURCE", " fTarget", "pSource", "fileStar", "vTarget", "gSOURCE", " fSourceFile", " fSOURCE", "rfStar", "gTarget", "fmsource", "oSource", "fmSourceFile", "dataSourceFile", "pCopy", "pSourceFile", "vsource", "fCopy", " fCopy", "tTarget", "fTarget", "tSource", "fileSource", "fStar", "dataStar", "gSource", "tSourceFile", "tSOURCE", "oSOURCE", "oSourceFile", "gsource", "vSource", "psource", "dataSource", "fsource", "oTarget", "vSOURCE", "fSOURCE", "fileSOURCE", "rfSourceFile", "fSourceFile", " fsource", "fmSource", "rfSOURCE", "fmCopy"], "file": ["f", "image", "output", "th", "p", "port", "data", "message", "format", "path", "fil", "e", "chain", "print", "le", "files", "local", "io", "or", "File", "resource", "table", "FILE", "spec", "page", "base", "name", "out", "fp", "h", "ile", "txt", "source", "template", "filename", "ol", "db", "l", "null", "type", "t", "log", "use", "info", "w"], "o": ["et", "ot", "u", "output", "og", "co", "v", "ooo", "mo", "bo", "ome", "fo", "onet", "e", "lo", "io", "ko", "on", "iso", "O", "oo", "to", "ro", "ho", "obj", "po", "auto", "op", "ox", "so", "y", "no", "out", "ob", "ol", "oe", "ao", "os", "l", "\u00f3", "ow", "ok", "yo", "go", "oa"], "i": ["f", "mi", "u", "ri", "ini", "ib", "il", "I", "ii", "si", "ai", "io", "bi", "qi", "in", "ki", "iu", "it", "ic", "li", "bis", "ij", "xi", "hi", "phi", "is", "out", "ui", "iter", "di", "l", "gi", "ci", "ip", "info", "im", "oi", "pi"], "b": ["f", "z", "bl", "binary", "bf", "v", "bs", "p", "bits", "buf", "blue", "bi", "buffer", "nb", "bin", "ab", "fb", "bar", "bis", "j", "bh", "a", "bg", "B", "sb", "eb", "body", "base", "bt", "be", "erb", "mb", "gb", "bit", "br", "ob", "bus", "l", "bd", "rb", "buff", "bb", "lib", "pb"], "n": ["k", "cn", "nn", "num", "nu", "en", "v", "count", "nc", "N", "ln", "ne", "sn", "un", "an", "ns", "nb", "m", "on", "ll", "c", "nor", "a", "j", "nan", "nl", "span", "yn", "mn", "missing", "nt", "y", "ren", "after", "no", "out", "number", "len", "r", "syn", "l", "na", "gn", "ni", "t", "d"]}}
{"id1": "23402240", "id2": "11645260", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"actualizarNdivisiones": [" actualizarNumenters", " actualizarMisioners", " actualizarNisione", " actualizarNdomes", " actualizarNdomers", " actualizarMdivisionas", " actualizarMdivisione", " actualizarNdivisionas", " actualizarNisionas", " actualizarNumente", " actualizarMdivisioners", " actualizarNdivisioners", " actualizarMisione", " actualizarNisioners", " actualizarNdome", " actualizarMisionas", " actualizarNumentes", " actualizarMisiones", " actualizarMdivisiones", " actualizarNumentas", " actualizarNisiones", " actualizarNdivisione", " actualizarNdomas"], "idTorneo": ["idTornepo", "idMornee", "idLTanei", "idMornepo", "idTeroo", "idTeroon", "idToralO", "idTorneos", "idTeroO", "idTalepo", "idTaneO", "idLTaneo", "idTornos", "idTorne", "idLTornei", "idTalee", "idTaneo", "idLTaneO", "idTornpo", "idTaneon", "idToralon", "idMorneos", "idTrono", "idMornpo", "idMorneo", "idTronpo", "idLTorneo", "idTronos", "idTaleos", "idMorno", "idLTorneon", "idTeroi", "idMornos", "idTornee", "idTorali", "idTornei", "idTrone", "idTorneon", "idTanei", "idTorneO", "idLTaneon", "idToralo", "idLTorneO", "idTorno", "idMorne", "idTaleo"], "nDivisiones": ["nDivideals", "ndivisiones", "nDivisionses", "nDecisionales", "nDivitione", "nDivions", "nDividees", "nDecisionals", "ndivisione", "nDecisione", "nDivideales", "nDivisionales", "nDivisionss", "nDecisiones", "nDivisionse", "nDeciones", "nDivionals", "nDecione", "nDiviones", "ndiviones", "ndivions", "nDivisionsales", "nDivitionals", "ndivisions", "nDecionales", "nDivionales", "nDivitionales", "ndivione", "nDivisionals", "nDivitiones", "nDivione", "nDivisions", "nDivides", "ndivisionales", "nDividee", "ndivionales", "nDivisione", "nDecionals"], "intResult": ["strResult", "uintReturn", "floatresult", "strResults", "IntResult", "uintResults", "uintValue", "strValue", "floatReturn", "IntResults", " intValue", "strReturn", "interResult", "INTReturn", "interReturn", " intReturn", "intReturn", "intResults", "INTResult", "uintResult", "INTResults", "interRes", " intRes", "INTresult", " intResults", "intRes", "interResults", "intValue", " intresult", "IntReturn", "intresult", "floatResults", "IntRes", "floatResult"], "sql": ["cmd", "seed", "ls", "dl", "select", "description", "s", "string", "csv", "ln", "sn", "q", "pel", "xml", "pp", "sq", "status", "table", "scl", "nl", "spec", "sv", "inv", "login", "query", "expression", "sb", "sol", "sp", "fn", "params", "mail", "template", "db", "sel", "json", "url", "ql", "SQL", "log", "spr", "qs"], "connection": ["context", "engine", "server", "port", "position", "location", "computer", "channel", "bo", "Connection", "connect", "relation", "communication", "nc", "description", "con", "user", "pointer", "handler", "database", "subject", "network", "conn", "application", "c", "collection", "writer", "resource", "table", "response", "link", "socket", "to", "page", "creator", "session", "document", "po", "function", "directory", "pool", "connected", "reference", "open", "ion", "client", "current", "system", "no", "number", "platform", "created", "statement", "close", "db", "condition", " Connection", "command"], "ps": ["processor", "pe", "mt", "cs", "p", "rs", "pn", "prep", "jp", "ips", "PS", "s", "pers", "gres", "pps", "pt", "pp", "pd", "gs", "ds", "ping", "ts", "pg", "res", "ptr", "po", "eps", "mp", "sp", "Ps", "cp", "pos", "aps", "pr", "fp", "posts", "pse", "proc", "statement", "fps", "ports", "tp", "pb", "stats"]}}
{"id1": "12349563", "id2": "2461169", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" pathexists", " resourceExisted", " pathExists", " resourceexits", " resourceexisted", " resourceexists", " pathExits", " pathExistent", " resourceIsisted", " resourceIsists", " resourceExistent", " resourceexistent", " resourceIsits", " pathexits", " resourceIsistent", " resourceExits", " pathExisted", " pathexistent", " pathexisted"], "location": ["loc", "translation", "server", "value", "search", "country", "behavior", "position", "zone", "message", "window", "where", "description", "uration", "color", "area", "module", "string", "localhost", "path", "program", "resolution", "hello", "LOC", "Location", "resource", "availability", "direction", "ocation", "available", "usage", "comment", "document", "file", "layout", "connection", "library", "address", "directory", "reference", "name", "family", "history", "system", "ion", "template", "filename", "uri", "human", "padding", "href", "remote", "zo", "command", "local", "slot", "point"], "url": ["loc", "f", "u", "sl", "cmd", "ssl", "gl", "b", "https", "ls", "dl", "hl", "char", "bel", "con", "google", "user", "str", "ll", "ret", "pkg", "http", "ul", "nl", "www", "ur", "URL", "res", "cert", "build", "base", "address", "open", "call", "mail", "client", "h", "mount", "out", "pl", "r", "Url", "l", "t", "n"], "cxn": [" cexn", "cexnor", "cxN", "CtxN", "ctxn", "ctxN", " cxN", "conN", " cexN", "Cxnn", "cwxN", "cxxN", "Ctxns", "conn", "ctxns", "connn", "cxxn", "Cxn", "cxns", "cexn", "cxxns", "Ctxn", " cexns", "cexN", "ctxnn", "Ctxnn", " cexnor", "conns", "cwxnn", "ctxnor", "CxN", "cwxns", " cxnor", "cexns", "Cxns", "cxxnor", "cxnn", " cxns", "cwxn", "cxnor"], "is": ["isa", "fs", "isl", "sis", "lis", "iss", "bits", "rs", "ris", "bs", "ir", "serv", "ists", "dis", "isi", "s", "si", "ys", "ms", "sys", "iso", "has", "in", "was", "bis", "tis", "ts", "ois", "ims", "init", "as", "IS", "iris", "Is", "ires", "isc", "does", "i", "still", "oss", "isf", "es", "os", "abs", "ip", "ais", "its", "info", "isin", "im", "ps", "ios"], "byteBuffer": ["noteFlow", "noteBuffer", "binarySet", " byteQueue", "binaryBuffer", "byteFlow", "noteQueue", " byteWindow", "binaryContext", "byteContext", "basicQueue", "bufferContext", "bufferSet", " byteSet", "bufferBuffer", "byteWindow", "binaryWindow", " byteFlow", "bufferWindow", "byteMatrix", "basicMatrix", "byteQueue", "basicFlow", "basicBuffer", " byteMatrix", " byteContext", "noteMatrix", "byteSet"]}}
{"id1": "1169642", "id2": "9647576", "code1": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"run": ["invoke", "exec", "Run", "work", "launch", "process", "test", "request", "runner", " check", "apply", "render", "init", "execute", "call", "loop", "get", "submit", " launch", "start", " evaluate", "sample", " Run", "evaluate", "hello", "func"], "key": ["k", "host", "et", "here", "KEY", "id", "sum", "message", "kid", "mk", "Key", "string", "token", "path", "foo", "owner", "chain", "ref", "member", "my", "str", "entry", "request", "pkg", "by", "ke", "link", "sign", "ey", "prefix", "item", "x", "query", "hex", "wa", "y", "change", "hash", "name", "this", "lock", "no", "client", "kw", "def", "keys", "template", "sk", "title", "check", "json", "mac", "type", "row", "password", "kind", "index"], "st": ["sth", "z", "sl", "const", "mt", "store", "std", "stream", "sts", "stable", "s", "string", "sn", "stack", "stop", "ust", "str", "sw", "ss", "src", "from", "pt", "text", "St", "sta", "station", "sty", "sv", "fr", "ts", "sb", "dom", "sp", "est", "base", "put", "se", "r", "ST", "stri", "ste", "statement", "l", "start", "ost", "ist", "stuff", "t", "rest", "ast", "d", "tt"], "url": ["loc", "f", "host", "el", "u", "sl", "ssl", "domain", "gl", "stream", "org", "https", "location", "ls", "dl", "il", "hl", "email", "char", "bel", "github", "string", "web", "ml", "ref", "un", "addr", "user", "lr", "str", "err", "ll", "xml", "ret", "or", "http", "rl", "ul", "nl", "link", "socket", "www", "browser", "ur", "impl", "URL", "file", "cert", "build", "address", "name", "mount", "mail", "client", "get", "r", "uri", "Url", "l", "null", "cl", "fl", "t", "log", "util", "html", "now"], "geoJSON": ["geoaKT", "geolaML", "sexolaJSON", "geoML", "geographicText", "neoaKT", "geeJSON", "sexoJSON", "neojson", "geoaJSON", "geuText", "GeoString", "gepoJSON", "GepoJSON", "neoJS", "neoJSON", "geejson", "geiString", "geoString", "gepojson", "neoaJSON", "geeString", "gepoString", "geoJS", "geoSON", "gepoJS", "geolaKT", "sexoML", "geiJSON", "geuML", "geolajson", "sexolaSON", "geuSON", "neoajson", "geojson", "geiJS", "GepoJS", "geuJSON", "geijson", "geographicML", "geolaJS", "geographicSON", "neoaJS", "geoKT", "sexolaML", "sexoSON", "sexoText", "geoaJS", "geolaJSON", "geolaSON", "geoajson", "neoKT", "Gepojson", "geiKT", "GeoJS", "GeoJSON", "Geojson", "GepoString", "geeJS", "geoText", "geographicJSON", "geolaText", "sexolaText"], "is": ["isa", "isl", "sis", "ins", "lis", "iss", "are", "bs", "ris", "serv", "dis", "ists", "ls", "isi", "where", "nis", "us", "s", "si", "ys", "sys", "ms", "obs", "iso", "has", "ic", "inst", "bis", "inv", "ois", "ims", "init", "IS", "iris", "vs", "vis", "mis", "Is", "isc", "isf", "es", "os", "abs", "ip", "ais", "its", "info", "isin", "im", "ios"], "in": ["update", "mi", "ins", "din", "got", "en", "again", "with", "ini", "sum", "correct", "IN", "inn", "ln", "un", "inf", "gin", "cin", "valid", "on", "bad", "setting", "bin", "from", "lin", "kin", "it", "by", "load", "and", "init", "mc", "loading", "mn", "reader", "ind", "no", "found", "out", "inc", "rin", "get", "input", "find", "inner", "iter", "asin", "unknown", "parse", "t", "using", "ill", "isin", "at", " din", "read", "In", "n"], "line": ["column", "entity", "ine", "ole", "field", "eline", "message", "list", "string", "e", "ln", "ice", "le", "chain", "print", "sequence", "cell", "phrase", "section", "block", "lin", "entry", "continue", "text", "frame", "inline", "Line", "link", "stroke", "page", "stay", "range", "comment", "piece", "file", "lined", "word", "iter", "l", "row", "log", "LINE", "sample", "point", "n"], "tile": ["image", "Tile", "node", "skill", "mate", "texture", "match", "profile", "grid", "tc", "feature", "figure", "tif", "detail", "te", "ele", "game", "player", "complete", "buffer", "cell", "theme", "chip", "tree", "via", "tf", "tle", "league", "layer", "table", "ti", " Tile", "prototype", "ite", "piece", "plane", "ie", "slice", "vector", "template", "details", "title", "vt", "square", "t", "pixel", "sample"], "geoms": [" geometry", "geom", "geometry", "gaims", "veoms", "veometry", "geims", " geotypes", "neums", "greomers", "neoms", "greom", "neicles", " geicles", " geims", "geums", "greometry", " geom", "veomers", "genums", "gaotypes", "neims", "neom", "geotypes", "veom", "geomers", "gaom", " geomers", "genicles", "gaoms", "genom", "geicles", "neotypes", "greoms", "genoms", " geums"], "i": ["cli", "mi", "z", "id", "b", "pi", "v", "p", "ix", "ri", "ini", "level", "list", "ii", "si", "ai", "bi", "m", "multi", "c", "li", "ij", "a", "j", "xi", "x", "zi", "phi", "y", "this", "slice", "ui", "d", "uri", "di", "start", "ci", "t", "o", "info", "im", "index", "I"], "geo": ["geometry", "geom", "geos", " geot", "Geometry", "noteographic", "lebo", "leographic", "peographic", "gei", "memo", "geoa", "Geo", "gometry", "greoo", "geonometry", "membo", "geot", "geol", "pee", "goa", "leo", "leso", "geso", "greos", "geoo", " geoo", "gebo", "leol", "memol", " gebo", "gee", "Gei", "GEometry", "geonoa", "neo", " geol", "leom", " geographic", "peometry", "peom", "noteo", "gographic", "seo", "seographic", "seometry", "neoo", "neos", "memographic", "greot", "peo", "GEo", "seoa", "greo", "neot", "Gee", "geono", "pei", "GEe", "noteso", "GEi", "geonographic", " geos", "noteom", "peso", "go", "geographic"], "mf": ["gfer", "Mfa", "gmf", " mfer", "mfa", "Mf", "cmv", "gcf", "mmcf", "mcf", "gmcf", "cmcf", "mfer", "gmv", " mcf", "gf", "cmf", "mfo", "cmfa", "Mv", "mmfo", "mmfer", "gmfa", "mv", "gfo", "mmf", " mfo", "Mcf"], "gc": ["cs", "rg", "nc", "tc", "ga", "cc", "gpu", "ctx", "gm", "gp", "gs", "dc", "gro", "pg", "mc", "pic", "pc", "gb", " pg", "bc", "gg", "vg", "ig", "gn", "gly", "GC", "sg", " GC", "gd"]}}
{"id1": "20751378", "id2": "18339787", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"hashPassword": ["updateText", "HashText", "Hashpassword", "updatePrivate", " hashPrivate", "HashPrivate", "hashText", " hashText", "updatePassword", " hashpassword", "HashPassword", "hashpassword", "updatepassword", "hashPrivate"], "password": ["column", "value", "encrypted", "Password", "p", " Password", "security", "pattern", "language", "message", "sword", "email", "description", "secret", "string", "token", "user", "device", "print", "phrase", "database", "application", "request", "argument", "login", "command", "prefix", "attribute", "key", "query", "connection", "expression", "comment", "address", "directory", "PASS", "word", "name", "client", "property", "username", "input", "pass", "wd", "auth", "reset", "shadow", "crypt", "default", "padding", "wordpress", "hello", "w"], "hash": ["ash", "object", "rh", "ashing", "token", "has", "method", "reading", "bh", "ah", "report", "oh", "tag", "address", "mass", "check", "h", "username", "title", "alg", "her", "log", "locking", "sh", "value", "search", "cache", "string", "print", "proof", "hing", "zero", "array", "ping", " Hash", "replace", "key", "tr", "put", "number", "version", "shadow", "crypt", "filter", "result", "copy", "here", "other", "class", "sum", "message", "Hash", "user", "test", "str", "response", "build", "shift", "mask", "uh", "index", "handle", "dig", "sha", "ha", "total", "where", "checking", "block", "cloth", " hashing", "alert", "ho", "hex", "height", "trust", "also", "hed", "html", "hello"], "md": ["del", "dr", "dd", "cmd", "mt", "der", "red", "sha", "nd", "dh", "mk", "sd", "od", "ms", "mm", "m", "pm", "man", "pd", "mod", "js", "ds", "and", "add", "dir", "sam", "obj", "mn", "ad", "df", "managed", "mp", "mc", "dm", "det", "mand", "ind", "grad", "ld", "di", "cd", "bd", "hd", "d", "MD", "sm"]}}
{"id1": "16556717", "id2": "5035872", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"getSHADigest": ["getSHAdegest", "getSHAdegester", "getSHADegse", "getSHAdegse", "getSHADdigest", "getSHAdigester", "getSHADDigse", "getSHAdegests", "getSHADegest", "getSHADDigester", "getSHADDigest", "getSHAdigests", "getSHADegests", "getSHAdigest", "getSHADigse", "getSHADdigester", "getSHADdigse", "getSHADdigests", "getSHADigester", "getSHADegester", "getSHAdigse", "getSHADigests", "getSHADDigests"], "password": ["value", "words", "Password", "id", " Password", "pattern", "data", "sword", "message", "email", "description", "secret", "string", "token", "user", "phrase", "database", "text", "response", "login", "prefix", "key", "session", "address", "hash", "word", "name", "username", "input", "pass", "wd", "auth", "reset", "padding", "command", "w"], "digest": ["mentester", "dEST", "mentest", "mentEST", " digested", "dighash", "digment", " digist", "Digester", "Digment", "digist", "Digested", "dest", "hashEST", "mentgest", "Digist", "decEST", "digested", "DigEST", "dist", "decgest", "igEST", " digEST", "digse", "hashment", " digse", "diggest", "Digest", "Dighash", "igest", "Digse", "dested", "igse", " digment", "hashest", "ighash", "Diggest", "decester", "decest", "hashested", "digEST", " dighash", "digester"], "sha": ["access", "ssl", "sh", "shell", "git", "alpha", "ha", "sum", "ssh", "api", "si", "lambda", "wal", "addr", "HA", "tar", "acl", "ya", "has", "func", "iso", "sq", "ppa", "da", "sche", "a", "ka", "ca", "ah", "md", "sam", "hi", "shared", "po", "ma", "auto", "ho", "wa", "phi", "asha", "hash", "pa", "no", "ta", "qa", "ao", "mac", "na", "SHA", "go", "shi", "sa", "pi"], "pwhash": ["pswashed", " pwhay", "pthat", "pswash", "pshash", "pshay", "pswhash", " pswhash", "pthash", "pwhat", "pWHhash", "pwhashed", "pwhhash", " pswat", "pWHashed", "pshhash", "pWHay", " psway", "pthashed", " pwhhash", " pswashed", "pswat", "pWHat", "pwhay", " pswash", "pshashed", " pwhashed", "pWHash", "pthhash", "psway", " pwhat"]}}
{"id1": "19113613", "id2": "14619453", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"copy": ["core", "same", "move", "co", "transfer", "php", "sync", "delete", "crop", "py", "Cop", "clip", "opy", "map", "link", "to", "replace", "paste", "init", "Copy", "gc", "share", "proxy", "cos", "cp", "zip", "slice", "write", "split", "clone", "create", "cat", "ip", "save", "download", "pixel", "cross", "cop"], "in": ["mi", "ins", "el", "inside", "din", "en", "id", "old", "ir", "ini", "IN", "sin", "inn", "con", "ai", "net", "inf", "cin", "gin", "on", "bin", "from", "ar", "ic", "it", "by", "re", "inv", "all", "init", "ie", "y", "act", "ind", "is", "inc", "check", "up", "rin", "i", "input", "iter", "inner", "l", "o", "isin", "info", "local", "In"], "out": ["ot", "output", "store", "OUT", "en", "co", "b", "v", "p", "port", "ex", "cache", "gt", "ent", "con", "over", "net", "io", "sys", "local", "on", "err", "set", "conn", "it", "outs", "OU", "ou", "to", "all", "ver", "obj", "res", "result", "op", "aos", "tmp", "nt", "base", "y", "ch", "this", "ion", "client", "write", "can", "oss", "one", "inner", "os", "null", "l", "not", "o", "log", "t", "end", "Out", "at", "w", "outer", "n"], "source": ["scope", "store", "search", "shell", "style", "scan", "SOURCE", "position", "language", "relation", "select", "format", "service", "sin", "lower", "s", "string", "si", "cause", "origin", "sequence", "ource", "local", "src", "space", "subject", "from", "resource", "status", "range", "attribute", "prefix", "key", "sql", "query", "ie", "base", "sp", "parent", "this", "system", "unit", "template", "input", "title", "se", "inner", "start", "Source", "site", "ce", "use", "finder", "index"], "target": ["rel", "translation", "top", "scope", "output", "ARGET", "style", "other", "location", "match", "pattern", "tif", "gt", "goal", "module", "token", "dest", "print", "test", "origin", "tree", "term", "join", "resource", "table", "step", "link", "alias", "to", "that", "key", "bolt", "query", "base", "parent", "arg", "template", "null", "url", "t", "root", "point", "local", "Target", "arget"], "files": ["assets", "fs", "models", "values", "ls", "events", "features", "banks", "lets", "items", "actions", "packages", "issues", "headers", "images", "balls", "users", "thumbnails", "pieces", "facts", "books", "reports", "workers", "styles", "objects", "members", "services", "jobs", "modules", "resources", "details", "parts", "plates", "pages", "les", "tools", "lines", "uploads", "ports", "faces", "iles", "states"], "file": ["f", "image", "folder", "el", "pe", "field", "node", "port", "work", "model", "data", "relation", "feature", "fe", "e", "ve", "le", "path", "foo", "print", "user", "tree", "block", "rule", "entry", "File", "resource", "table", "FILE", "tile", "page", "label", "dir", "key", "item", "document", "child", "base", "parent", "library", "be", "name", "event", "word", "current", "line", "fp", "ile", "full", "filename", "row", "play", "job", "local"], "inCh": [" inCl", "incSam", " inChan", "incCor", "inChan", "inSam", "InCh", " inCod", "cinCh", "rinChan", "rinCod", "dinCor", "cinCr", "dinCh", "inCor", "outch", "cinCod", "inCr", "cinChan", "outCod", "InCod", "inCod", "dinSam", "cinCor", "dinCr", "cinSam", "rinCh", "incCh", "inCl", "rinCl", "outChan", "inch", "incCr", "cinch", "InChan", " inch", "InCl"], "outCh": ["outputCh", "inChan", "outCol", "outGr", "newch", "newCod", "newGr", "outputGr", "outputChan", "outputCod", " outCol", "outch", "outCod", " outch", " outGr", "newChan", "inCol", "inch", "outChan", " outCod", " outChan", "newCh", "newCol"]}}
{"id1": "5872038", "id2": "3184073", "code1": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["update", "patch", "value", "p", "scale", "format", "service", "php", "process", "print", "complete", "parser", "xml", "pack", "pp", "request", "load", "eval", "apply", "report", "render", "dump", "transform", "query", "document", "python", "shape", "build", "interpret", "call", "se", "create", "start", "url", "save", "next", "send", "read", "handle"], "SAXException": ["SAXPFailure", "SAXPception", "SAHException", "SAVception", "SAXception", "SAHFailure", "SAXFailure", "SAVFailure", "SAXPException", " SAXception", "SAHception", "SAVException", " SAXPFailure", " SAXPception", " SAXPException", " SAXFailure"], "IOException": [" IOFailure", "StreamProblem", "IOProblem", "IOFailure", "ConnectionException", " IOProblem", "ConnectionProblem", "ConnectionFailure", "StreamFailure", "StreamException"], "httpclient": ["httpsconnection", "httpsClient", "hconnection", "httpClient", " httpClient", "ttpclient", "hClient", " httpconnection", "httpsclient", "httpscon", "httpcon", "ttpClient", "httpserver", "httpsserver", "ttpserver", "httpconnection", "hclient", " httpcon", " httpserver", "ttpcon"], "result": ["there", "record", "output", "the", "dat", "data", "message", "profile", "description", "Result", "RESULTS", "request", "answer", "status", "table", "response", "page", "report", "res", "successfully", "event", "cup", "this", "current", "client", "true", "memory", "cur", "su", "proc", "created", "results", "success", "make", "successful", "date", "now"], "spf": ["picfac", "psf", "aspfac", "ispf", "ipfi", "opcf", "ispFactory", "picfp", "ispfx", "opf", "ispfc", "lpfx", "lpFactory", "lpf", "ipF", "spcf", " spfac", "opF", "spfi", "ospf", " spfp", "spfc", "ospFactory", "psfi", "pscf", "opfi", "spfx", "spfp", "spFactory", "ospfc", "psF", "aspf", "picf", "ipf", "spF", "ospfx", "aspfp", "spfac", "ipcf", "lpfc"], "sp": ["sl", "pe", "sh", "esp", "p", "ep", "Sp", "jp", "sc", "spe", "bp", "pt", "pp", "pd", "sq", "spl", "ph", "sv", "sam", "pic", "op", "so", "asp", "pc", "lp", "pr", "ap", "isp", "sk", "pl", "osp", "se", "bsp", "SP", "spr", "tp", "ps", "pb", "sm"]}}
{"id1": "3584508", "id2": "18793482", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": ["downloadFile", "downloadUrl", "downloadResource", "copyUrl", "copyFile", " copyFile", " copiedUrl", " copiedFile", "copyAddress", " copyAddress", " copiedAddress", "downloadAddress", " copyUrl", " copiedResource"], "url": ["loc", "f", "rel", "host", "el", "sl", "ssl", "gl", "https", "ls", "dl", "gif", "hl", "char", "service", "string", "github", "path", "ml", "ref", "web", "str", "ll", "ret", "resource", "http", "rl", "re", "ul", "nl", "link", "browser", "ur", "URL", "file", "cert", "base", "address", "mb", "mount", "mail", "source", "r", "uri", "Url", "l", "null", "cl", "fl", "util", "html"], "input": ["image", "initial", "context", "access", "inside", "ssl", "exec", "stream", "sum", "select", "enter", "Input", "pull", "index", "empty", "audio", "form", "user", "state", "acl", "in", "raw", "text", "it", "request", "http", "add", "eval", "active", "upload", "init", "file", "missing", "op", "base", "ain", "act", "reader", "before", "open", "up", "get", "source", "qa", "config", "feed", "inner", "iter", "null", "start", "ip", "unknown", "PUT", "parse", "accept", "focus", "info", "local", "read", "cont", "can"], "output": ["image", "update", "you", "object", "entity", "online", "other", "position", "format", "secure", "web", "net", "ne", "group", "print", "icon", "network", "continue", "hidden", "secondary", "text", "table", "Output", "response", "ou", "four", "ilo", "bool", "connection", "file", "console", "auto", "beta", "put", "current", "client", "out", "write", "display", "unsigned", "null", "success", "next", "o", "exit", "remote", "component", "outer"], "b": ["f", "k", "ba", "z", "u", "bs", "v", "bf", "binary", "bits", "p", "ib", "char", "bp", "bi", "nb", "m", "block", "ab", "c", "by", "fb", "j", "B", "wb", "sb", "obj", "eb", "ble", "body", "base", "y", "be", "mb", "gb", "bit", "br", "ob", "i", "r", "bc", "g", "db", "l", "rb", "t", "buff", "bb", "d", "cb"]}}
{"id1": "18164929", "id2": "4750967", "code1": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"isCodebaseDownloadable": ["isCodeBaseDownloadable", "isCodebaseUploaded", "isCodebasedownloadible", "isCodebasedownloadable", "isCodeBaseDownloadible", "isCodebaseUploadible", "isCodeBasedownloadable", "isCodebaseLoadible", "isCodeBasedownloaded", "isCodeBaseDownloadAvailable", "isCodeBaseDownloaded", "isCodebaseLoadable", "isCodebasedownloaded", "isCodeBasedownloadAvailable", "isCodebaseUploadable", "isCodebaseDownloaded", "isCodebaseLoaded", "isCodebaseUploadAvailable", "isCodebaseDownloadAvailable", "isCodebaseDownloadible", "isCodebaseLoadAvailable", "isCodeBasedownloadible", "isCodebasedownloadAvailable"], "p": ["f", "u", "pe", "b", "v", "jp", "properties", "bp", "s", "e", "P", "q", "m", "pp", "pkg", "c", "vp", "ps", "a", "j", "sp", "cp", "lp", "pa", "pro", "fp", "h", "r", "g", "prop", "t", "o", "np", "d", "w", "tp", "project", "pb"], "file": ["f", "image", "length", "id", "port", "message", "total", "format", "content", "path", "partial", "print", "complete", "offset", "error", "File", "resource", "table", "status", "limit", "FILE", "link", "page", "dir", "item", "body", "base", "name", "line", "fp", "ile", "source", "title", "type", "info", "action"], "codebase": [" codingbase", " codingBase", "codase", "Codebind", "codebas", " codease", "codeBase", "codebind", "keybase", " codebind", " codebased", "codease", "Codebase", "corebuffer", "corebased", "cachebase", "codebuffer", "cachebas", "corease", "corebasic", "keybasic", "codbas", "cachebuffer", "coeBase", "keybas", "corebas", "codbased", " codebas", " codeBase", "coebase", "cachebasic", "corebase", "codebasic", "codebased", "Codebased", " codingbind", "coebased", "codbase", "CodeBase", "keybuffer"], "cbUrl": ["tcUrl", "cdOb", "cpurl", "obbUr", "cdURL", "cfgUrl", "obbOb", "ctrlurl", "rbUrl", "cpInt", "ctrlInt", "cfgEl", "cdUr", "fbIs", "cfgUr", "cbIs", "ctrlURL", "cpSl", "gbInt", "cbUr", "bbURL", "fbURL", "gburl", "ctrlUrl", "sburl", "sbURL", "fbUr", "cburl", "rburl", "rbUr", "cbEl", "bbSl", "sbUr", "obbURL", "ctrlIs", "bbUr", "tcURL", "fbUrl", "rbURL", "cbInt", "tcUr", "cdUrl", "gbURL", "gbUrl", "ctrlUr", "cpUrl", "cbURL", "bbUrl", "cbOb", "sbIs", "tcSl", "cpURL", "cfgURL", "obbUrl", "cpUr", "gbUr", "cpEl", "ctrlEl", "cbSl", "sbUrl", "sbOb"], "protocol": ["bisility", "Protrol", "bisocol", "protility", "Protocol", "patotype", "pronrol", "paticle", "patocol", "protrol", "Proticle", "tility", "prototype", "pronocol", "proticle", "bisicle", "patrol", "bisotype", "ticle", "Protility", "Prototype", "totype", "pronicle", "pronotype", "tocol"], "filename": ["length", "f", "binary", "software", "location", "message", "lower", "string", "fil", "path", "ename", "src", "text", "Filename", "File", "resource", "ername", "FILE", "fle", "prefix", "key", "nil", "fn", "directory", "name", "family", "river", "word", "ame", "fp", "txt", "assembly", "username", "source", "uri", "title", "json", "til", "names", "stem"], "size": ["eng", "sent", "z", "iz", "equal", "Size", "count", "sum", "SIZE", "ize", "ze", "s", "empty", "notice", "izes", "ms", "offset", "fee", "body", "pos", "name", "mem", "start", "bytes", "send"], "files": ["assets", "fs", "models", " Files", "videos", "classes", "features", "stars", "items", "packages", "links", "headers", "Files", "images", "balls", "users", "thumbnails", "sections", "reports", "workers", "seconds", "objects", "members", "modules", "resources", "parts", "plates", "mails", "pages", "ports", "bytes", "bees", "names", "faces", "groups", "iles", "frames", "blocks", "tests"], "st": ["z", "sl", "rt", "mt", "sh", "std", "ft", "sts", "stru", "nd", "stage", "stable", "s", "net", "stack", "stop", "ust", "str", " St", "sw", "ss", "set", "space", "it", "St", "sta", "inst", "step", "trans", "sp", "nt", "est", "se", "r", "ST", "ste", "l", "start", " ST", "ost", " est", "ct", "stuff", "t", "rest", "end", "ist", "ast", "d", "tt", "stem", "ut"], "url": ["f", "rel", "host", "el", "ssl", "gl", "org", "b", "https", "ls", "il", "char", "email", "service", "web", "path", "addr", "ll", "conn", "ret", "loader", "or", "http", "ul", "nl", "link", "socket", "browser", "ur", "impl", "key", "URL", "obj", "base", "address", "cp", "mount", "mail", "pro", "ob", "client", "pl", "r", "uri", "Url", "l", "tool", "t", "log", "util", "html", "handle"], "part": ["top", "PART", "patch", "var", "with", "par", "work", "pair", "string", "path", "partial", "str", "art", "pre", "pt", "val", "from", "join", "step", "span", "page", "trans", "Part", "piece", "prefix", " Part", "key", "tmp", "base", "sp", "body", "pet", "pos", "joined", "word", "name", "split", "place", "parts", "r", "se", "start", "thing", "rest", "t", "sample", "pad", "point", "and", "info", "local"], "data": ["image", "DATA", "rel", "object", "record", "value", "output", "video", "ata", "cache", "dat", "relation", "message", "instance", "format", "list", "area", "content", "user", "group", "state", "valid", "block", "entry", "text", "error", "join", "writer", "table", " DATA", "step", "response", "to", "metadata", "what", "all", "session", "item", "key", "dir", "ad", "obj", "batch", "this", "good", "no", "def", "extra", "client", "found", "done", "details", "db", "results", "json", "row", "default", "summary", "next", "fd", "d", "info", "module", "result", "action"], "len": ["del", "el", " Len", "en", "fin", "vec", "ls", "enc", "dec", "mid", "lan", "repl", "ln", "lim", "qual", "val", "ll", "gz", "wid", "nl", "Len", "yn", "cap", "seq", "mn", "body", "fn", "msg", "pos", "ren", "cmp", "mult", "elt", "mem", "syn", "l", "lon", "mat", "ail", "cb"], "success": [" successful", "length", "progress", "top", "access", "rc", "ata", " succeeds", "select", " proceed", " succeed", "setup", "social", "process", "complete", "sys", "first", "Success", " succ", "continue", "secondary", "error", "status", " successfully", " Success", "control", " suc", "ready", "comment", "failed", "successfully", "result", "msg", "good", "client", "serial", "platform", "photo", "close", "pass", "results", "submit", "fail", "global", "danger", "accept", "summary", "default", "primary", "successful", "info", "index", "master", " successes"]}}
{"id1": "19652200", "id2": "23510383", "code1": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 0, "substitutes": {"init": ["initial", "update", " relocate", "store", " initiate", "connect", "launch", " initialization", "empty", " intern", "Init", "load", " constructor", "construct", "run", " Init", "get", "create", "config", "reset", "start", "save", "release", "info", "index", "read"], "file": ["f", "image", "output", "binary", "port", "data", "il", "message", "format", "disk", "path", "user", "io", "le", "fil", "form", "buffer", "real", "tree", "rule", "File", "resource", "http", "table", "load", "FILE", "link", "upload", "page", "report", "attribute", "dir", "document", "body", "base", "be", "name", "this", "open", "current", "line", "ile", "full", "source", "filename", "uri", "create", "null", "log", "info", "local", "handle"], "url": ["loc", "rel", "host", "f", "u", "sl", "ssl", "gl", "b", "location", "api", "char", "string", "web", "path", "q", "str", "ll", "resource", "http", "nl", "link", "browser", "ur", "URL", "base", "address", "name", "open", "mount", "mail", "get", "i", "r", "uri", "Url", "l", "cl", "abs", "util"], "stream": ["context", "Stream", "engine", "port", "channel", "message", "ream", "path", "form", "chain", "stack", "buffer", "view", "resource", "status", "link", "socket", "page", "session", "console", "pool", "open", "source", "input", "download", "handle"], "byteArray": ["byteList", "byteString", " byteString", "ByteString", "charArray", "ByteList", "charList", "charString", " byteList", "ByteArray"], "content": ["value", "header", "comments", "data", "message", "Content", "format", "path", "section", "raw", "text", "status", "size", "page", "comment", "body", "code", "hash", "template", "source", "title", "config", "json", "version", "summary", "media", "cont", "action"]}}
{"id1": "5744493", "id2": "10385815", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" synchronizedFullMove", " doPageDownload", " synchronizedFullCopy", " synchronizedFullDownload", " synchronizedFileCopy", " doStreamCopy", " synchronizedFileDownload", " doStreamDownload", " doFullCopy", " doFileDownload", " synchronizedFileMove", " doStreamMove", " doPageMove", " doPageCopy", " doFullMove", " doFileCopy", " doFileMove", " doFullDownload"], "in": ["ins", "din", "el", "en", "b", "old", "ex", " input", "IN", "inn", "inf", "cin", "gin", "mm", "ac", "from", "ic", "it", "or", "init", "as", "file", "ain", "ind", "inc", "up", "rin", "source", "input", "i", "r", "l", "o", "isin", "ck", "In", "n"], "out": ["ot", "output", "OUT", "v", "p", "serv", "ex", "gt", "s", "net", "io", "ne", "outs", "it", "c", "ou", "to", "as", "file", "res", "po", "op", "nt", "ch", "write", "up", "check", "help", "os", "l", "null", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["dinCommand", " inChan", "cinCommand", "inConnection", "innCategory", "isinChannel", "inChan", "isinButton", "isinConnection", "vinChannel", "Inchannel", "InCh", "INStream", "vinCase", "outchannel", " inCommand", "inCategory", "innButton", "inCh", "cinButton", " inCase", "vinConnection", "INchannel", "INChannel", "innerStream", "inStream", "InChannel", "dinCase", "cinChannel", "innerchannel", "innerChan", "dinButton", "innCommand", "dinChan", "isinChan", " inCh", " inConnection", " inchannel", "outCh", "dinConnection", "inCase", "dinChannel", "inchannel", "outChan", "INChan", " inCategory", "inCommand", " inButton", "outStream", "InChan", "innerChannel", "innChannel", "cinCategory", "vinCommand", "inButton"], "outChannel": ["cosMachine", "outputCh", "aosChannel", "onChan", "outputStream", "inChan", " outCh", "outSection", "cosDisk", "newChannel", "onchannel", "outputChan", " outchannel", "outDisk", " outRoom", "outConnection", "outchannel", "OutStream", "onConnection", "aosSection", "OutCh", "OutChannel", "outerChan", "aosDisk", "cosSection", "outRoom", "upSection", "upMachine", "inStream", "onChannel", "upChannel", " outConnection", "newChan", "outCh", "outerStream", "outputChannel", "OutChan", "outerChannel", "outChan", "cosChannel", "outerRoom", "newchannel", "aosMachine", " outStream", "outStream", "outMachine", "upDisk", "inRoom", " outChan", "newConnection"], "maxCount": ["MaxCount", "minSize", "maxSize", " maxLength", " maxFlag", " maxCast", "MAXCount", "MAXFlag", "minCount", "minFlag", "minLength", "MaxLength", "MAXLength", "maxLength", "MaxCast", "minCast", "maxFlag", "MaxSize", " maxSize", "maxCast"], "size": ["length", "readable", "sent", "equal", "Size", "position", "scale", "count", "show", "sum", "message", "SIZE", "ose", "ize", "ze", "capacity", "sd", "area", "speed", "si", "total", "empty", "gets", "notice", "ms", "resolution", "any", "duration", "m", "space", "set", "scroll", "fee", "score", "south", "export", "range", "shape", "small", "body", "name", "seek", "shift", "is", "height", "keys", "write", "len", "close", "start", "bytes", "sample", "send", "read"], "pos": ["loc", "rel", "length", "exp", "p", "port", "position", "Pos", "pi", "Position", "POS", "pointer", "offset", "pt", "zero", "resp", "it", "part", "limit", "spec", "to", "page", "coord", "pg", "x", "seq", "po", "left", "sp", "cos", "pc", "pid", "no", "def", "pro", "pr", "off", "pl", "i", "len", "pass", "doc", "os", "l", "start", "row", "o", "point", "pose", "index", "slot", "ps", "n"]}}
{"id1": "9096319", "id2": "20190303", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"handleNodeRegainedService": ["handleNodeRegalledService", "handleNoderegainedServices", "handleNodeRegalledSite", "handleNoderegainedSite", "handleNoderegainsSite", "handleNodeRegalledServices", "handleNodeRegainsSite", "handleNoderegainsServices", "handleNodeRegifiedService", "handleNodeRegainedSite", "handleNodeRegifiedServices", "handleNodeRegainsServices", "handleNodeRegainedServices", "handleNoderegainsService", "handleNodeRegainsService", "handleNoderegainedService", "handleNodeRegifiedSite"], "eventID": ["serviceKey", "EventId", "eventUID", "eventId", "EventUID", "nodeType", "EventID", "nodeKey", "nodeId", " eventName", " eventType", "eventKey", "serviceTime", "nodeUID", " eventUID", "serviceId", "eventType", "serviceUID", " eventId", "EventType", "EventTime", " eventKey", "EventName", "nodeName", "nodeTime", "eventName"], "nodeID": ["NodeIT", "localJS", " nodeIT", "serverID", "moduleid", " nodeJS", "odeIDE", "odeID", "moduleIDE", "serverInfo", "nodeInfo", " nodeName", " nodeIDs", "NodeName", "moduleID", "entityId", "nodeId", " nodeId", "nodeIT", "resourceId", "serverId", "serverIDs", "instanceInfo", "NodeIDs", "localID", "volumeName", "NodeID", "moduleId", "entityJS", "volumeId", " nodeInfo", "instanceID", " nodeid", "instanceIDs", " nodeIDE", "localId", "nodeIDE", "serverName", "volumeIT", "moduleIT", "nodeJS", "instanceId", "volumeID", "entityID", "nodeid", "resourceName", "Nodeid", "resourceID", "nodeIDs", "nodeName", "NodeId", "odeId"], "ipAddr": ["ipSender", "ipAddaddr", "ipaddrt", "ipAddrt", "ipAndr", "epAddri", "ipAdder", "ipReshr", "ipAddressrar", "epAddrs", "ipAcr", " ipAddressp", "ipSendr", "epAddressl", " ipAddhr", " ipAddressrs", "ipAddl", "ipAcrs", "ipStorehr", "ipAddressp", "ipAddressri", "ipIntr", "ipAttp", "epAddr", " ipAddaddr", "ipStorer", "ipAddhr", "ipAddsn", " ipAdder", "ipIntaddr", " ipaddrs", " ipAddp", " ipAddn", "ipResrs", "ipAttr", "ipAddp", "ipAddsrs", "ipAddressrs", "ipStorers", "ipIntrs", "ipaddrs", "epAddressri", "ipSendp", "ipAndl", "ipAddresser", "ipAndp", " ipAddrt", "ipaddr", "ipAddri", " ipAttrar", " ipAddressaddr", "epAddressr", "ipAddrar", " ipAddrs", " ipAttr", " ipaddrt", " ipAddrar", " ipAddl", "ipIntp", "ipaddl", "ipResr", "ipAddressr", "ipResrt", " ipAtter", "ipAddrs", "ipAddsr", "ipAndri", "epAddressrs", "ipAddn", "ipAndrs", "ipaddp", "ipAddressaddr", "ipAcn", " ipaddp", "ipAndrt", "ipAttrar", " ipAddrb", "epAddl", " ipAttp", " ipaddr", "ipAddsrb", "ipAddressl", "ipAtter", "ipAddrb", "ipSendrar", "ipStorert", "ipAcrb", " ipAddressr"], "serviceID": [" serviceType", "serviceKey", " serviceKey", "servID", "servName", "ServiceName", "sourceId", " serviceNAME", "sourceJO", " serviceNOTE", " serviceid", "sourceID", "servId", "securityId", " serviceName", "ServiceId", "resourceId", "componentID", "servKey", "serviceLAN", "serviceNAME", " serviceLAN", "securityid", "serviceid", "serviceId", "ServiceNAME", "Serviceid", "sourceName", "serviceType", "componentName", " serviceId", "securityID", "serviceJO", "servLAN", "serviceNOTE", "servid", "componentNOTE", "serviceName", "ServiceNOTE", "componentId", "resourceName", "ServiceLAN", "securityName", "ServiceType", "ServiceID", "resourceID", "servNAME", "ServiceJO", "resourceType", "ServiceKey", " serviceJO"], "eventTime": ["ageType", "Eventtime", " eventTimes", "eventTIME", "eventtime", " eventtime", "attributeTIME", "attributeType", "attributeTime", "ventTimes", " eventType", "ventTime", "agetime", "eventType", "eventTimes", "EventType", "EventTime", "ageTime", "ventType", "EventTIME", "ventTIME", "ageTIME", "attributeTimes", " eventTIME"], "log": [" logger", "ger", "lo", "le", "pel", "err", "set", "link", "note", "de", "report", "tag", "sql", "file", "be", "lock", "pl", "se", "cat", "row", "url", "util", "use", "Log", "cal", "store", "og", "iam", "com", "enter", "ge", "entry", "ar", "it", "error", "or", "prot", "call", "mail", "conf", "l", "tab", "json", "at", "w", "en", "bug", "ex", "channel", "message", "email", "user", "blog", "debug", "base", "msg", "out", "full", "config", "t", "crit", "low", "scale", "ome", "net", "cell", "xml", "gob", "category", "LOG", "event", "zip", "db", "ext", "and", "cont"], "dbConn": ["tableObj", "sbCon", "fbConn", "Dbconn", "tableConn", " dbObj", "DbConn", " dbConnect", "DBCon", "sbObj", "dbCons", "dbconn", "bdConnect", " dbCons", "sbConnect", "bdCon", "sbConnection", "bdObj", "DBCons", " dbconn", "DBConn", "DbConnect", "cbConnection", "dbCon", "gbCon", "dbObj", "dbConnect", "dbConnection", "userCon", "gbConn", "bConn", "bCons", "gbConnect", "cbCon", "gbConnection", "fbCon", "tableCon", "userConn", "cbConn", "fbObj", "userObj", " dbCon", "bdConn", "DBConnect", "bConnect", "userConnect", "DbObj", "sbConn", "fbConnect", "cbConnect", "tableconn", "DbCon", "bCon"], "outageUpdater": ["outageUpdatedager", "outageUpnomer", "outageUpdatater", "outageUpnater", "outageUPtoder", "outageUndter", "outageUtDrer", "outageUppoder", "outageUptatter", "outageUpdatedATER", "outageUPdarer", "outageUpndATER", "outageUpnarer", "outageUpdATER", "outageUplitter", "outageUdataser", "outageUpddater", "outageUplaters", "outageUprater", "outageUpdataser", "outageUpmomer", "outageUpDarer", "outageUPtatter", "outageUdatoder", "outageUpmetter", "outageUpDaser", "outageUpmrer", "outageUPtter", "outageUpDaters", "outageUplater", "outageUpdatedarer", "outageUpmATER", "outageUPdter", "outageUpDrer", "outageUpdetter", "outageUpmaser", "outageUpDager", "outageUpdter", "outageUpdatemaser", "outageUtdater", "outageUptaser", "outageUplarer", "outageUpmter", "outageUpmater", "outageUpndater", "outageUpnditter", "outageUdetter", "outageUtdrer", "outageUPdaters", "outageUpdatedaser", "outageUpnoder", "outageUpdrer", "outageUpdager", "outageUpdomer", "outageUppater", "outageUPdATER", "outageUpdatemomer", "outageUpDatter", "outageUtDaser", "outageUptager", "outageUpdaterager", "outageUpdoder", "outageUtdaser", "outageUPdatter", "outageUptoder", "outageUptter", "outageUPdaser", "outageUptaters", "outageUpdaser", "outageUpdatemater", "outageUpnitter", "outageUdatater", "outageUprager", "outageUpDATER", "outageUndater", "outageUplATER", "outageUpDater", "outageUplter", "outageUpdaterater", "outageUpraters", "outageUptitter", "outageUPtitter", "outageUpmitter", "outageUnndter", "outageUdaser", "outageUpdatetter", "outageUpprer", "outageUPnATER", "outageUprarer", "outageUtdoder", "outageUpDoder", "outageUpdatter", "outageUptarer", "outageUPnaters", "outageUpnaser", "outageUpdatedaters", "outageUpdboder", "outageUpdbetter", "outageUdatetter", "outageUPtaser", "outageUtDoder", "outageUppaser", "outageUpnter", "outageUpnATER", "outageUndATER", "outageUdoder", "outageUnndATER", "outageUpddaser", "outageUpdaterarer", "outageUpdarer", "outageUpdatemATER", "outageUPnater", "outageUpdateraters", "outageUPdater", "outageUdater", "outageUtDater", "outageUptater", "outageUpdbater", "outageUnndater", "outageUpnatter", "outageUnditter", "outageUpdbaser", "outageUpdaters", "outageUpdatedomer", "outageUpdatedater", "outageUPditter", "outageUPdoder", "outageUpnaters", "outageUPtater", "outageUPnarer", "outageUnnditter", "outageUPtaters", "outageUploder", "outageUpdatoder", "outageUpditter", "outageUpmoder", "outageUpndter", "outageUpddomer", "outageUpddATER"]}}
{"id1": "4389475", "id2": "19134229", "code1": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openConnection": ["openConnect", "getConnection", "Openconnection", " openConnect", "newECTION", "initconnection", "getSession", "OpenECTION", "openChannel", "OpenChannel", "initConnection", "OpenConnect", " openECTION", "getConnect", "OpenObject", "openSession", " openChannel", "openECTION", "newconnection", "newConnect", "OpenConnection", " openSession", "openconnection", "getChannel", "openObject", "initConnect", "initObject", "newConnection", " openconnection", "newObject", "OpenSession"], "url": ["loc", "el", "u", "sl", "ssl", "gl", "b", "v", "https", "location", "ls", "dl", "il", "char", "email", "bel", "string", "github", "web", "ml", "ref", "kl", "addr", "q", "rect", "str", "xml", "ll", "term", "ret", "request", "http", "rl", "comm", "nl", "link", "req", "ur", "impl", "URL", "file", "res", "force", "build", "base", "address", "this", "mount", "mail", "call", "ob", "get", "r", "uri", "Url", "l", "abs", "cl", "log", "util", "html", "job"], "name": ["length", "id", "v", "old", "data", "nm", "string", "order", "path", "local", "normal", "m", "str", "on", "from", "Name", "part", "size", "a", "nl", "to", "NAME", "all", "prefix", "key", "dir", "file", "base", "parent", "word", "hash", "no", "def", "ame", "mem", "source", "r", "filename", "title", "len", "nam", "l", "null", "named", "t", "names", "now", "info", "w", "n"], "f": ["fs", "u", "ft", "field", "b", "cf", "fw", "v", "bf", "p", "lf", "uf", "perm", "alf", "fm", "fo", "af", "elf", "fe", "e", "ff", "tf", "sf", "c", "it", "fb", "col", "j", "fr", "fx", "fa", "xf", "file", "fg", "x", "df", "fn", "y", "fac", "fp", "fi", "h", "fab", "i", "full", "g", "l", "fl", "t", "fd", "rf", "F", "d", "w", "fc"], "f2": ["e2", "k2", "filetwo", "file1", "k6", "ftwo", " ftwo", "e0", " f6", "fb2", "file0", "k1", "f6", "f0", "etwo", "f1", "file2", " f0", "e1", "fb6", " f1", "ktwo", "fbtwo", "fb1"]}}
{"id1": "1798720", "id2": "14191679", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"save": ["update", "folder", "store", " Save", "Save", "archive", "data", "delete", "pack", "pkg", "upload", "install", "export", "register", "init", "dump", "zip", " seal", "saving", "filename", "version", "aw", "accept", "download", "release", "send"], "packageName": ["PackageNames", "packageType", "moduleName", "packageCode", "packagename", " packageId", "moduleCode", " packageKey", "PackageId", "packageKey", "pkgname", "pkgId", "PackageName", "pkgType", " packagename", "pkgNames", "packageId", "moduleId", " packageType", "modulename", "moduleKey", "packageNames", "pkgKey", "pkgName", " packageNames", "moduleNames", " packageCode", "pkgCode", "PackageType"], "fileContents": ["FileContents", "FileItems", "fileIngredients", "pageNames", "byteContent", "FileIngredients", " fileIngredients", "FileBytes", "byteValues", "byteContents", "FileContent", "FileValues", "pageItems", " fileBytes", "fileBytes", "fileValues", " fileItems", " fileValues", "pageContents", "packageContents", " fileContent", "fileContent", "packageNames", "pageBytes", "packageIngredients", "byteNames", "fileItems", "FileNames", "packageContent"], "fileNames": [" fileLeaks", "FileContents", "FileLeaks", "moduleName", "moduleContents", "fieldTypes", " fileVaults", "resourceNames", "fileLeaks", "dirNames", "resourceContents", "FileValues", "issueVaults", " fileNumbers", " fileTypes", "moduleVaults", "dirLeaks", "resourceNumbers", "FileKeys", " fileKeys", "fileValues", "messageKeys", "fileName", "fileTypes", " fileValues", "FileTypes", "fileVaults", "issueName", "messageName", "dirKeys", "resourceValues", " fileName", "fileNumbers", "issueNames", "issueContents", "messageNames", "fileKeys", "moduleNames", "FileName", "dirTypes", "resourceTypes", "FileNames", "fieldNumbers", "fieldNames", "messageValues", "fieldContents"], "dirBase": ["irbase", "DIRBase", "DIRBottom", "directoryBas", "dirBasic", "pkgBas", "irBase", " directoryBottom", "folderbase", "DIRBuilder", "dirbase", "directoryBasic", "folderBase", "pkgbase", "irSet", "pathbase", "DirBase", "dirBuilder", "pkgBase", " directoryBuilder", "dirBas", "directorybase", "dirBottom", "directorySet", "DirBas", "irBas", "DIRBas", "pathBas", "folderBasic", " directoryBas", "folderBas", "pathBasic", "dirSet", "DirBuilder", " directoryBase", "directoryBase", "pkgSet", "pathBase", "DirBottom"], "packageDir": ["packageDef", "pkgPath", "pkgDef", "modulePath", "moduleDef", "moduleFolder", "installDir", " packageFolder", "podDef", "packageD", "podDist", "packagePath", "pkgRel", " packageRel", "moduleDir", " packageDef", " packageDist", "pkgFolder", " packageD", "pkgDir", "packageDist", "podDir", "installDef", "podD", "installDist", " packagePath", "moduleRel", "packageFolder", "packageRel", "installD"], "created": ["raised", "creat", "forced", "present", "arted", "confirmed", "started", "registered", "given", "TED", " generated", "checked", "Created", "made", "generated", "activated", "filled", "produced", "loaded", "called", " started", "founded", "ready", "creator", "provided", "ced", "locked", "recorded", "released", "developed", "joined", "existent", "installed", "create", "allowed", "creation", "printed", "defined", "associated", "successful", "reported", "mounted", "added"], "currentPath": ["recentParent", " currentParent", "CurrentCh", "recentName", "recentPath", "currentlyPath", "currentCh", "CurrentPath", "currentlyFile", "currentFile", "currentlyCh", " currentCh", "CurrentPoint", "currentParent", "currentlyName", "CurrentParent", "currentPoint", "CurrentName", " currentFile", " currentPoint", " currentName", "CurrentFile", "recentPoint", "currentName"], "i": ["cli", "mi", "u", "id", "ri", "q", "status", "them", "g", "di", "gi", "ci", "mu", "ski", "info", "I", "f", "pi", "exp", "ix", "chain", "my", "m", "ki", "multi", "it", "ic", "li", "xi", "init", "key", "ji", "batch", "ind", "o", "qi", "v", "p", "ex", "ity", "si", "me", "iu", "in", "major", "j", "ie", "zi", "iii", "slice", "iy", "uri", "os", "ip", "go", "index", "ami", "iq", "ini", "jj", "ii", "ai", "bi", "cgi", "yi", "sim", "ei", "ij", "ti", "hi", "phi", "y", "this", "ui", "im", "oi"], "file": ["f", "et", "header", "p", "port", "fo", "format", "disk", "path", "le", "io", "handler", "buffer", "set", "rule", "sf", "File", "resource", "table", "FILE", "link", "page", "comment", "dir", "child", "body", "base", "parent", "pool", "name", "h", "ile", "template", "source", "db", "l", "row", "type", "play", "log", "info", "local", "handle"], "fos": ["oos", "ffos", "wos", "foss", "oaos", " faos", "fbo", "fo", "floss", "Foss", "oow", "Faos", "fbow", "foses", "foes", "ffoes", "flo", "woss", " foss", "sfos", "woses", "fbos", "fbaos", "oo", "ffo", "flaos", "FOS", "floses", "flos", "fOS", "faos", "floes", "woes", "sfaos", "Fos", " foses", " fo", "Foes", "fow", "sfOS", " fOS", "Fo", "sfoss", " foes", "ffaos", " fow"], "fileSrc": ["fileDrl", "fileErl", "jobSrc", "fileEri", "fileInrc", "fileNri", "fileNrc", " fileInsRC", "fileSsrc", "fileNci", "jobSri", "fileInsrc", "fileInRC", "fileSci", " fileSsrc", "fileSRC", " fileSRC", "fileDource", "fileErc", "fileSri", "fileDrc", "fileSrl", "fileInsRC", "fileSource", "jobNci", " fileInsrc", "jobSci", " fileSource", "fileDri", "fileDRC", "jobSrl", " fileInsource", "jobNrl", "fileNrl", "jobNrc", "fileEci", "fileInource", "fileInsource", "fileDci", "jobNri", "fileDsrc", "fileInssrc", " fileInssrc"], "fileDst": ["fileSlt", "fileDnd", "FileSst", "fileNst", "FileSpl", "FileSnd", "fileNot", "FileDnd", "FileDot", "FileSlt", "FileDlt", "FileDld", "FileDpl", "fileDot", "fileDld", "FileDcr", "fileSst", "fileDpl", "fileScr", "filedld", "fileNld", "fileNcr", "fileSpl", "fileWot", "fileWpl", "filedcr", "filednd", "fileWst", "fileWlt", "fileSld", "fileSot", "fileDlt", "fileNpl", "fileNnd", "filedst", "fileDcr", "FileSot", "fileNlt", "FileScr", "FileSld", "fileSnd", "FileDst"], "reader": ["context", "readable", "dr", "actor", "stream", "ri", "rc", "upper", "ader", "ocker", "er", "review", "oder", "driver", "iterator", "handler", "Larry", "buffer", "parser", "entry", "loader", "author", "resource", "rl", "runner", "reading", "ro", "ler", "query", "controller", "rr", "rar", "Reader", "rx", "ner", "r", "book", "iter", "inner", "rer", "row", "roller", "rot", "read"], "writer": ["riter", "operator", "writers", "store", "server", "stream", "liner", "println", "window", "format", "later", "service", "driver", "iterator", "user", "order", "player", "editor", "print", "buffer", "handler", "test", "parser", "maker", "wrapper", "walker", "loader", "entry", "table", "worker", "runner", "ter", "storage", "creator", "browser", "report", "query", "document", "wright", "caster", "console", "function", "builder", "Reader", "word", "client", "write", "wire", "writing", "iter", "manager", "variable", "adder", "flush", "Writer", "draw", "w", "read", "outer"], "line": ["column", "record", "ine", "pe", "entity", "ole", "header", "node", "style", "liner", "port", "eline", "message", "detail", "string", "user", "ln", "le", "chain", "print", "sequence", "cell", "valid", "kin", "block", "rule", "entry", "continue", "lin", "text", "frame", "stroke", "Line", "inline", "nl", "page", "link", "range", "comment", "label", "code", "lined", "word", "number", "source", "l", "row", "LINE", "sample", "edge", "point", "date"]}}
{"id1": "19322941", "id2": "11334468", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearchWithTwoLetter", "test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearch_MultiWords", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearchWithtwoLetter", "test_lookupResourceType_FullSearch_Multiwords", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearch_ThreeLetter", "test_lookupResourceType_FullSearch_MultiLetter", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_TwoLetter", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearch_MultiWord", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearch_twoLetter"], "url": ["f", "el", "u", "sl", "ssl", "https", "location", "ls", "char", "service", "google", "str", "ll", "conn", "loader", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "impl", "URL", "document", "build", "base", "uu", "name", "open", "get", "r", "uri", "Url", "l", "null", "job"], "connection": ["server", "office", "online", "established", "position", "computer", "channel", "Connection", "connect", "relation", "communication", "instance", "description", "message", "con", "pointer", "handler", "database", "network", "conn", "application", "entry", "wrapper", "c", "government", "collection", "resource", "http", "request", "response", "machine", "link", "socket", "to", "creator", "session", "query", "console", "operation", "directory", "reference", "connected", "settings", "open", "ion", "client", "number", "still", "character", "uri", "close", "created", "statement", "condition", "creation", "using", "command", "information"]}}
{"id1": "14598566", "id2": "7425022", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFilebynIR", "copyFilebyNIO", "copyFileBynIO", "copyFileBynio", "copyFileByNio", "copyFilebyNII", "copyFileByNDio", "copyFileByNDIO", "copyFilebynio", "copyFileByNII", "copyFilebynII", "copyFileByStandardIR", "copyFileByStandardIO", "copyFileByStandardII", "copyFileBynIR", "copyFilebynIO", "copyFileByNDIR", "copyFileBynII", "copyFileByNIR", "copyFilebyNio", "copyFileByNDII", "copyFileByStandardio", "copyFilebyNIR"], "in": ["ins", "din", "el", "en", "b", "id", "old", "IN", "inn", "cin", "gin", "on", "mm", "from", "st", "ic", "it", "ar", "vin", "as", "sql", "edIn", "ind", "is", "inc", "up", "rin", "i", "input", "source", "l", "o", "isin", "In"], "out": ["ot", "u", "output", "OUT", "b", "v", "serv", "ex", "gt", "s", "net", "ne", "io", "str", "err", "outs", "it", "ou", "to", "po", "op", "nt", "ch", "check", "oss", "g", "os", "l", "null", "t", "log", "o", "Out", "at", "w", "n"], "sourceChannel": ["SourceListener", "seedMember", "srcButton", " sourceProvider", "ourceChan", "parseButton", "SourceConnection", "parseMember", "sourceConnection", "ourceChain", "sourceCategory", " sourceListener", "sourceMember", "ourceConnection", " sourceConnection", "srcChain", "Sourcechannel", "givenListener", "srcChannel", "SourceChannel", "parseCategory", "srcListener", "srcChan", "srcConnection", " sourceChan", "ourceChannel", "sourceListener", "sourceChan", "sourceButton", "sourceProvider", "parseChannel", "seedCategory", " sourceMessage", "ourcechannel", " sourcechannel", "givenMessage", "seedChannel", "srcCategory", "srcMember", "sourceChain", "givenProvider", "ourceListener", "srcProvider", " sourceChain", "seedButton", "givenChannel", "sourcechannel", "srcMessage", "sourceMessage"], "destinationChannel": [" destationChan", "DestationChan", "destationStream", "destationChan", "destinationClient", "destationChannel", "destructionChan", "destinationsComponent", "destensionClient", "DestinationChan", "DestationConnector", "destructionConnection", "destinationConnection", "DestinationChannel", " destinationChan", "DestinationClient", "destensionChannel", "DestinatorClient", "DestinationConnection", "destensionChan", "DestinatorChannel", "DestationStream", " destationComponent", "destinatedChannel", "destensionStream", "destructionChannel", "destationConnector", "destationConnection", "DestinatorConnection", "destinatorChan", "destensionConnector", "destationClient", " destinationConnection", "destinationsChan", "destinationsConnection", "destinatorConnection", "DestationChannel", "destinationComponent", "DestinationConnector", " destationChannel", "destinationsChannel", "destationComponent", "destinatedConnector", "DestinationStream", "destinatorClient", "DestinatorChan", "destinatorChannel", " destinationComponent", "destinationConnector", "destensionConnection", "destinatedChan", "destructionComponent", " destationConnection", "destinationChan", "destinatedStream", "destinationStream"]}}
{"id1": "14047629", "id2": "23273706", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"source": ["image", "copy", "output", "stream", "shell", "seed", "SOURCE", "position", "channel", "data", "message", "format", "service", "content", "iterator", "sequence", "buffer", "ource", "q", "src", "in", "from", "request", "resource", "sql", "query", "expression", "file", "console", "address", "reader", "event", "system", "input", "se", "proc", "Source", "sample", "result"], "process": ["context", "processor", "object", "cmd", "store", "exec", "flow", "node", "Process", "p", "work", "script", "class", "task", "connect", "service", "thread", "processing", "chain", "sys", "program", "state", "pm", "network", "term", "pp", "status", "post", "frame", "method", "and", "link", "session", "complex", "init", "file", "component", "function", "run", "console", "code", "execute", "pipe", "build", "cp", "pid", "call", "check", "mem", "memory", "place", "se", "proc", "create", "condition", "parse", "make", "use", "command", "job", "project", "handle"], "processStdOut": ["processStrdEx", "processStrEx", "processStrOut", "processStstdIn", "processStstEr", "processStstEx", "processStrrEr", "processStrrOut", "processStstOut", "processStrrIn", "processStstIn", "processStrIn", "processStrdIn", "processStstdEr", "processStrdEr", "processStdEx", "processStrEr", "processStstdEx", "processStrdOut", "processStstdOut", "processStrrEx", "processStdEr"], "processStdIn": ["processStrOut", "processStsIN", "processSTdIn", "processStdIns", "processSTtIn", "processStdsIn", "processStdIN", "processSTtIns", "processSttOut", "processStdsIN", "processStackdsIN", "processStdsIns", "processStsIn", "processStdin", "processSttIns", "processStackdin", "processStrIn", "processStackdIn", "processSttIN", "processSTtOut", "processStsin", "processStackdIN", "processSTdIns", "processStackdOut", "processStdsin", "processStackdsin", "processStackdsOut", "processSttIn", "processStdsOut", "processStrIns", "processStackdsIn", "processStrIN", "processSTdIN", "processStrin", "processSTdOut", "processStsOut", "processSTtIN"]}}
{"id1": "838844", "id2": "3024970", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"convert": ["compversion", "CONfer", "converted", "CONvert", "consversion", "converting", "unverted", "converts", "Converted", "Conversion", "compverts", "unvert", "compvert", "CONverting", "Confer", "unversion", "Convert", "Converts", "Converting", "confer", "consVERT", "unprocess", "consverting", "CONverted", "conVERT", "consvert", "unfer", "unverts", "CONVERT", "conversion", "CONversion", "conprocess", "compprocess", "ConVERT", "Conprocess"], "src": ["loc", "host", "iv", "rel", "ins", "stream", "rc", "rs", "SOURCE", "RC", "scan", "scene", "SourceFile", "sc", "ebin", "hl", "sin", "cc", "s", "usr", "path", "addr", "sys", "attr", "ource", "str", "st", "from", "sq", "pkg", "func", "http", "inst", "dist", "sit", "upload", "ser", "orig", "req", "ur", "img", "file", "rx", "buster", "txt", "ipl", "source", "input", "filename", "cur", "config", "uri", "start", "url", "sr", "its", "Source", "rest", "href", "cont"], "dest": [" destination", " Destination", "port", "Dest", "dat", "tif", " orig", "disk", "target", "test", "gin", "table", "dist", "orig", "dir", "img", " dst", " Dest", "est", "write", "txt", "source", " destinations", "foreign", "mat", "rest", "temp", "result"], "in": ["ins", "din", "el", "en", "stream", "b", "serv", "IN", "inn", "io", "inf", "cin", "m", "bin", "from", "st", "ar", "as", "sql", "ad", "file", "res", "reader", "ind", "is", "up", "rin", "d", "source", "input", "i", "r", "inner", "l", "isin", "In"], "p": ["f", "pe", "b", "jp", "php", "er", "pers", "dp", "P", "m", "pm", "parser", "py", "pt", "pp", "pd", "pre", "c", "pkg", "part", "ping", "vp", "post", "it", "ph", "j", "pg", "wp", "op", "sp", "prot", "pc", "per", "cp", "lp", "pa", "pro", "fp", "h", "ap", "pl", "i", "r", "g", "l", "parse", "rep", "t", "d", "at", "tp", "ps", "pb", "pi"], "ds": ["bs", "rs", "drivers", " os", "dl", "yes", "aws", "js", "gs", "ts", "ads", "df", "tes", "eds", "ras", "mys", "di", "nas", "ks", "ports", "its", "ods", "d", "gd", "ats", "xs", "ands", "dds", "sets", "dt", "dh", " dd", "DS", "lists", "vs", "uds", "ags", "scripts", "iffs", "ws", "tags", "els", "dd", "terms", " d", " des", "ls", "sd", "s", "tests", "outs", "posts", "docs", "ils", "os", "Ds", "hs", "hd", "ps", "dp", "cs", "sts", "ys", "ns", "obs", "ss", "pd", "dos", "des", " DS", "workers", "eps", "dates", "loads", "points", " ads", "db", "cks", "edes", "qs", "tp", "amps"], "format": ["f", "feat", "top", " Format", "ats", "mt", "output", "MAT", "id", "style", "cf", "mode", "pattern", "fm", "feature", "path", "form", "set", "it", "sche", "status", "table", "size", "spec", "pretty", "tag", "shape", "file", "layout", "act", "settings", "name", "lat", "unit", "template", "source", "title", "policy", "l", "version", "type", "parse", "ct", "mat", "t", "filter", "Format", "at", "module", "fc", "pi"], "hasPixelData": ["HasPixelDATA", "HasPixelData", "hasixelData", " hasPixeldata", " hasPixelDATA", "hasPixeldata", "hasFramedata", "HaspixelData", "HaspixelDATA", "HasPixeldata", "haspixeldata", "hasPixelDATA", "haspixelData", "haspixelDATA", "hasFrameData", "hasixeldata", "Haspixeldata", "hasFrameDATA", "hasixelDATA"], "inflate": ["incelATE", "infolate", "infolocate", "informat", "Informated", "Informat", "infolat", "Informocate", "incelate", "infolated", "invalidicate", "incelocate", "invalidATE", "inflocate", " invalidate", "informocate", "inFlate", "inflated", " inflATE", " invalidicate", "informate", "invalidocate", "Inflate", "Inflat", "inFLate", " invalidocate", "Inflated", "inFlicate", "Informate", " invalidATE", "inFLated", "inFLocate", "inFlocate", "incelicate", "informated", "Inflocate", "invalidate", " inflicate", "inflATE", " inflocate", "inflat", "inFLat", "inflicate", "inFlATE"], "pxlen": ["mxln", "tmplen", "packfun", "packls", "mxlen", "xylen", "pexln", "xpden", "tmpln", "phplength", "packln", "pexlen", "pexden", "mmlin", "pxlength", "mxdec", "phpln", "pexlength", "xylength", "pxlin", "xyln", "xylin", "pxln", "packlength", "xpln", "cplength", "pixellen", "pxls", "cpden", "cpln", "xplength", "pixelfun", "cplen", "tmplength", "packlen", "pxfun", "pexls", "pixells", "xplen", "mmln", "pxden", "mmlength", "mmlen", "tmplin", "pixellength", "phpdec", "phplen", "packdec", "mxlength", "pxdec", "pexfun"], "out": ["crit", "cmd", "output", "store", "OUT", "gr", "ex", "screen", "sum", "list", "user", "net", "io", "group", "print", "sys", "cfg", "ln", "err", "conn", "outs", "writer", "ou", "inv", "pretty", "prefix", "dir", "init", "obj", "res", "aos", "msg", "name", "client", "gov", "inter", "up", "log", "Out", "temp", "outer"]}}
{"id1": "838844", "id2": "18613870", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"convert": ["compversion", "CONfer", "converted", "CONvert", "consversion", "converting", "unverted", "converts", "Converted", "Conversion", "compverts", "unvert", "compvert", "CONverting", "Confer", "unversion", "Convert", "Converts", "Converting", "confer", "consVERT", "unprocess", "consverting", "CONverted", "conVERT", "consvert", "unfer", "unverts", "CONVERT", "conversion", "CONversion", "conprocess", "compprocess", "ConVERT", "Conprocess"], "src": ["loc", "host", "iv", "rel", "ins", "stream", "rc", "rs", "SOURCE", "RC", "scan", "scene", "SourceFile", "sc", "ebin", "hl", "sin", "cc", "s", "usr", "path", "addr", "sys", "attr", "ource", "str", "st", "from", "sq", "pkg", "func", "http", "inst", "dist", "sit", "upload", "ser", "orig", "req", "ur", "img", "file", "rx", "buster", "txt", "ipl", "source", "input", "filename", "cur", "config", "uri", "start", "url", "sr", "its", "Source", "rest", "href", "cont"], "dest": [" destination", " Destination", "port", "Dest", "dat", "tif", " orig", "disk", "target", "test", "gin", "table", "dist", "orig", "dir", "img", " dst", " Dest", "est", "write", "txt", "source", " destinations", "foreign", "mat", "rest", "temp", "result"], "in": ["ins", "din", "el", "en", "stream", "b", "serv", "IN", "inn", "io", "inf", "cin", "m", "bin", "from", "st", "ar", "as", "sql", "ad", "file", "res", "reader", "ind", "is", "up", "rin", "d", "source", "input", "i", "r", "inner", "l", "isin", "In"], "p": ["f", "pe", "b", "jp", "php", "er", "pers", "dp", "P", "m", "pm", "parser", "py", "pt", "pp", "pd", "pre", "c", "pkg", "part", "ping", "vp", "post", "it", "ph", "j", "pg", "wp", "op", "sp", "prot", "pc", "per", "cp", "lp", "pa", "pro", "fp", "h", "ap", "pl", "i", "r", "g", "l", "parse", "rep", "t", "d", "at", "tp", "ps", "pb", "pi"], "ds": ["bs", "rs", "drivers", " os", "dl", "yes", "aws", "js", "gs", "ts", "ads", "df", "tes", "eds", "ras", "mys", "di", "nas", "ks", "ports", "its", "ods", "d", "gd", "ats", "xs", "ands", "dds", "sets", "dt", "dh", " dd", "DS", "lists", "vs", "uds", "ags", "scripts", "iffs", "ws", "tags", "els", "dd", "terms", " d", " des", "ls", "sd", "s", "tests", "outs", "posts", "docs", "ils", "os", "Ds", "hs", "hd", "ps", "dp", "cs", "sts", "ys", "ns", "obs", "ss", "pd", "dos", "des", " DS", "workers", "eps", "dates", "loads", "points", " ads", "db", "cks", "edes", "qs", "tp", "amps"], "format": ["f", "feat", "top", " Format", "ats", "mt", "output", "MAT", "id", "style", "cf", "mode", "pattern", "fm", "feature", "path", "form", "set", "it", "sche", "status", "table", "size", "spec", "pretty", "tag", "shape", "file", "layout", "act", "settings", "name", "lat", "unit", "template", "source", "title", "policy", "l", "version", "type", "parse", "ct", "mat", "t", "filter", "Format", "at", "module", "fc", "pi"], "hasPixelData": ["HasPixelDATA", "HasPixelData", "hasixelData", " hasPixeldata", " hasPixelDATA", "hasPixeldata", "hasFramedata", "HaspixelData", "HaspixelDATA", "HasPixeldata", "haspixeldata", "hasPixelDATA", "haspixelData", "haspixelDATA", "hasFrameData", "hasixeldata", "Haspixeldata", "hasFrameDATA", "hasixelDATA"], "inflate": ["incelATE", "infolate", "infolocate", "informat", "Informated", "Informat", "infolat", "Informocate", "incelate", "infolated", "invalidicate", "incelocate", "invalidATE", "inflocate", " invalidate", "informocate", "inFlate", "inflated", " inflATE", " invalidicate", "informate", "invalidocate", "Inflate", "Inflat", "inFLate", " invalidocate", "Inflated", "inFlicate", "Informate", " invalidATE", "inFLated", "inFLocate", "inFlocate", "incelicate", "informated", "Inflocate", "invalidate", " inflicate", "inflATE", " inflocate", "inflat", "inFLat", "inflicate", "inFlATE"], "pxlen": ["mxln", "tmplen", "packfun", "packls", "mxlen", "xylen", "pexln", "xpden", "tmpln", "phplength", "packln", "pexlen", "pexden", "mmlin", "pxlength", "mxdec", "phpln", "pexlength", "xylength", "pxlin", "xyln", "xylin", "pxln", "packlength", "xpln", "cplength", "pixellen", "pxls", "cpden", "cpln", "xplength", "pixelfun", "cplen", "tmplength", "packlen", "pxfun", "pexls", "pixells", "xplen", "mmln", "pxden", "mmlength", "mmlen", "tmplin", "pixellength", "phpdec", "phplen", "packdec", "mxlength", "pxdec", "pexfun"], "out": ["crit", "cmd", "output", "store", "OUT", "gr", "ex", "screen", "sum", "list", "user", "net", "io", "group", "print", "sys", "cfg", "ln", "err", "conn", "outs", "writer", "ou", "inv", "pretty", "prefix", "dir", "init", "obj", "res", "aos", "msg", "name", "client", "gov", "inter", "up", "log", "Out", "temp", "outer"]}}
{"id1": "13891080", "id2": "5299276", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", "transferFile", "cloneTo", "cloneDir", "copyDir", "cloneStream", "copyTo", " copyTo", " copyStream", "transferTo", " copyDir", "transferStream", "transferDir", "cloneFile"], "srcFile": ["subfile", "initFile", "subBlock", "sourceFile", "rcfile", "initfile", "srcBlock", " srcEmail", "initEmail", " srcPath", "destPath", " srcBlock", "subEmail", "srcfile", "rcFile", "rcPath", "srcEmail", "sourcefile", "subFile", " srcfile", "initBlock", "srcPath"], "destFile": ["refFile", "refMail", "srcDir", "altDir", " destfile", "destfile", " dstfile", " destMail", "litDir", "destDir", "altfile", "litMail", "DestPlace", "DestDir", "altFile", " destStyle", "litFile", "destPlace", "altStyle", "srcfile", " destPlace", "destStyle", "Destfile", "srcStyle", " dstPlace", "refDir", "refFILE", " destDir", " dstFile", "DestFile", "litFILE", "destFILE", " dstDir", "destMail", " destFILE"], "srcChannel": ["rbChannel", "srcStream", " srcSection", " srcStream", " srcChan", "srcFace", "srcButton", "rbClient", "subClient", " srcButton", "rcStream", "rbFace", "curConnection", "curChan", " srcchannel", " srcClient", "curChannel", "rcConnection", "rbButton", "srcChan", "srcClient", "srcConnection", "srcchannel", "subChannel", " srcConnection", "curchannel", "rcChannel", " srcFace", "rcChan", "curStream", "srcSection", "rcchannel", "curSection", "subFace", "subButton", "rcSection"], "dstChannel": ["dblConnection", " dotBuffer", "dblChan", "dndCow", "ddestBuffer", " dotUser", "rddestChannel", "dotConnection", "distUser", " dstChan", "rdstChannel", "dotStore", "dotChan", "ddestCow", "dstBuffer", "dblChannel", " dotChannel", "dotUser", " dotChan", "ddestStore", "dblStore", "rdstStore", " dstCow", "dndChannel", "dstChan", "dstCow", "ddestChannel", "dndConnection", "dstStore", " dstConnection", "rdstConnection", " dotCow", " dstUser", "ddestChan", "rddestStore", "distBuffer", "distChannel", "rddestChan", " dotConnection", "distConnection", "dotCow", "ddestConnection", "rdstChan", " dstBuffer", "rddestConnection", "dstConnection", "dndChan", "dotBuffer", "dotChannel", "ddestUser", "dstUser"]}}
{"id1": "1141361", "id2": "9398454", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"makeRead": [" initialRead", " processRead", " initialFind", " processPost", " doCreate", " doPost", " processCreate", " doFind", "doCreate", " initialCreate", " initialPost", " doRead", "doFind", " processFind", "doRead", "doPost"], "user": ["host", "server", "uid", "field", "person", "student", "message", "string", "owner", "USER", "database", "rule", "author", "by", "post", "use", "users", "table", "usage", "creator", "connection", "file", "name", "word", "client", "nick", "username", "account", "auth", "url", "human", "password", "User", "date", "project", "plugin"], "databaseID": ["databaseId", "connectionId", "databaseTime", " databaseId", "directoryid", "databaseAND", "directoryId", "directoryIDs", "databaseid", "connectionTime", " databaseTime", "directoryTime", "directoryID", "connectionID", " databaseAND", "connectionIDs", "databaseIDs", "connectionid", " databaseid", "directoryAND", " databaseIDs", "connectionAND"], "time": ["length", "etime", "runtime", "value", "id", "frequency", "money", "port", "mode", "zone", "message", "tc", "TIME", "tim", "times", "sequence", "delay", "duration", "ime", "timeout", "clock", "year", "hour", "tm", "created", "age", "timer", "start", "version", "type", "Time", "rate", "second", "t", "end", "info", "date", "now", "tt"], "query": ["cmd", "quote", "search", "work", "question", "script", "task", "message", "select", "Query", "description", "string", "clean", "content", "then", "q", "term", "entry", "sq", "request", "view", "note", "comment", "gate", "quest", "sql", "transform", "run", "body", "menu", "execute", "code", "eries", "qu", "call", "title", "qa", "find", "condition", "ql", "command"], "statement": ["bind", "quote", "cmd", "Statement", "mt", "ements", "shell", "binary", "frequency", "position", "confirmed", "language", "message", "communication", "description", "list", "le", "print", "phrase", "buffer", "sequence", "database", "subject", "state", "rule", "entry", "article", "definition", "commit", "status", "volume", "table", "usage", "fr", "ts", "storage", "page", "report", "comment", "session", "that", "sql", "expression", "connection", "document", "console", "function", "batch", "sp", "execute", "library", "word", "call", "template", "memory", "se", "number", "condition", "ct", "journal", "stat", "media", "command", "finder", "slot", "result", "yahoo"], "count": ["length", "loc", "ount", "num", "flag", "sum", "message", "total", "list", "complete", "any", "state", "nb", "set", "c", "status", "size", "table", "report", "all", "batch", "code", "nt", "amount", "OUNT", "ind", "current", "found", "counter", "check", "call", "number", "find", "coll", "Count", "now", "contact", "index", "handle"]}}
{"id1": "2642914", "id2": "21125261", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarJx", "addFileToTarGst", "addFileToTarGet", "addFileToTarGep", "addFileToTarGsz", "addFileToTarRx", "addFileToTarJzip", "addFileToTarBzip", "addFileToTarGp", "addFileToTarRzip", "addFileToTarJw", "addFileToTarGw", "addFileToTarGez", "addFileToTarGsp", "addFileToTarGt", "addFileToTarGezip", "addFileToTarBx", "addFileToTarGx", "addFileToTarBw", "addFileToTarJz", "addFileToTarBp", "addFileToTarRw", "addFileToTarRz", "addFileToTarGszip", "addFileToTarGzip", "addFileToTarBt", "addFileToTarBz"], "taro": ["Tolan", " targo", "Taro", "tory", "maro", "Tamo", "trary", "traro", "tary", "stoa", "Tara", " tara", "ttara", "waro", "tro", " tory", " taco", "ttosa", "troa", "stargo", "Taco", " tro", "ktrar", "retaco", "Tory", " trar", "qtolan", "thamo", "tempamo", "qtro", "trar", "marro", "tamo", "qtaro", "retaro", "warro", "stro", " tarro", "ktarro", "staco", "thosa", "Tarro", "Targo", "tosa", "tara", "retamo", "tolan", "stamo", "wargo", "tempro", "ktara", "wro", "starro", " toa", "thrar", "targo", "Tro", " tary", "temparo", "tharo", "retara", "tharro", "ktaro", " tamo", " tolan", "stary", "ttamo", "qtory", " tosa", "taco", "ttaro", "margo", "trro", "toa", "mro", "staro", "tempargo", "thara", "tarro"], "path": ["core", "th", "p", "ex", "pattern", "string", "clean", "ath", "ref", "chain", "print", "local", "m", "entry", "PATH", "text", "c", "dir", "key", "transform", "file", "name", "binding", "mount", "h", "full", "doc", "parts", "url", "Path", "root", "kind", "w", "history", "project", "pi"], "base": ["server", "b", "bf", "bare", "bas", "buffer", "basic", "normal", "bad", "absolute", "part", "based", "alias", "Base", "prefix", "file", "build", "parent", "relative", "family", "name", "binding", "extra", "check", "template", "full", "create", "common", "db", "reset", "ase", "start", "shadow", "default", "padding", "root", "pad"], "f": ["fs", "life", "ft", "b", "cf", "v", "bf", "p", "perm", "lf", "uf", "fm", "alf", "af", "fo", "elf", "fe", "e", "form", "inf", "far", "tf", "sf", "c", "fb", "fr", "fx", "fa", "xf", "file", "fg", "df", "fed", "y", "fac", "fp", "fi", "h", "fab", "i", "r", "g", "l", "fl", "t", "o", "fd", "rf", "F", "d", "w", "fc"], "entryName": ["entryname", "ryName", "EntryKey", "rowType", "EntryPath", "elementPath", "EntryName", "ryLetter", "cueKey", "elementKey", "entryLetter", "rowLetter", "rowname", "ryname", "cuename", "cueType", " entryLetter", "ryType", "elementname", "EntryType", " entryname", " entryKey", " entryType", "elementName", "cueName", "entryType", "entryKey", "rowName", "entryPath", " entryPath", "Entryname"], "goIn": [" goIns", " goin", "poIN", "poIn", "GoIN", "moInput", "geIn", "goInput", "goIN", "moIns", "moin", "GoIn", "GoOut", "moIn", "geIns", " goIN", "Goin", "goin", "poOut", "poin", " goOut", " goInput", "goIns", "gein", "GoIns", "moIN", "geInput", "goOut"], "tarEntry": [" tarItem", "warEntry", "warEnt", "warComponent", "rarEnt", " tarentry", "rarCategory", "tarComponent", "warItem", "rarComponent", "tarEnt", "rarEntry", " tarCategory", "tarentry", "rarentry", "carCategory", " tarComponent", "rarItem", "carEntry", "carentry", "tarItem", "tarCategory", "carEnt", " tarEnt"], "children": ["fs", "cloud", "cs", "kids", "ls", "stories", "cache", "hawks", "each", "items", "Children", "ml", "files", "packages", "ll", "they", "many", "follow", "balls", "ul", "users", "all", "reports", "batch", "aos", "parent", "objects", "members", "ren", "jobs", "modules", "keys", "resources", "pages", "json", "parents", "ports", "wn", "names", "groups", "los", "roots", "blocks", "ps", "these", "gall"], "child": ["Child", "id", "shell", "lf", "count", "cache", "friend", "char", "cell", "q", "cow", "ll", "block", "entry", "follow", "c", "uncle", "brother", "col", "ph", "fr", "page", "comment", "label", "key", "file", "batch", "parent", "ch", "name", "zip", "client", "last", "close", "l", "row", "pixel", "fd", "background", "job", "handle"]}}
{"id1": "13852596", "id2": "19335986", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"execute": [" sweep", "exec", " deploy", " benchmark", " scan", "launch", " assemble", " proceed", "process", " inherit", " executed", " eval", " execution", " executable", " resolve", " exec", "init", " perform", "construct", "run", " chain", " test", " launch", " replay", " release", " evaluate", "evaluate"], "resources": ["rows", "ions", "writers", "models", "rs", "ris", "classes", "banks", "ifiers", "Resources", "builders", "lets", "items", "types", "files", "actions", "flows", "packages", "issues", "apps", "relations", "they", "artifacts", "images", "resource", "users", "reports", "res", "workers", "objects", "services", " Resources", "modules", "rooms", "archives", "accessible", "pointers", "scripts", "results", "stores", "uploads", "locks", "ports", "projects", "bytes", "ids", "names", "groups", "faces", "roots", "blocks", "these"], "i": ["cli", "ia", "mi", "ami", "ri", "pi", "v", "ir", "ex", "ini", "ali", "list", "I", "ii", "si", "e", "ai", "io", "bi", "q", "in", "iu", "ki", "multi", "abi", "li", "ij", "ti", "j", "bis", "xi", "ims", "hi", "ori", "ji", "im", "phi", "iri", "ui", "h", "g", "di", "gi", "l", "ip", "ci", "mu", "\u0438", "t", "info", "oi", "ios"], "classFile": ["classFolder", "cellClass", "attributeChain", "ClassFilename", "fastFile", "connectionFile", "sourceFile", "attributeFile", "clfile", "classifiedFile", "classifiedfile", "attributeFiles", " classFiles", "sourceFILE", "fastFiles", "targetSourceFile", " classTree", "parentfile", "ClassChain", " classfile", "typeFILE", "clFiles", "classifiedFiles", "parentFile", "connectionFILE", "classFiles", " classClass", "classfile", " classResource", "classFilename", "classEntry", "ClassFiles", " classEntry", "instanceFiles", "targetFile", "attributeFILE", "fastFILE", "instanceFilename", "ClassClass", " classSourceFile", "parentSourceFile", "connectionfile", "clTree", "cellFile", "ClassSourceFile", "classLine", "classFILE", "targetFILE", "clFile", "recordFile", "typeLine", "ClassTree", "recordfile", " classChain", "objectFile", " classDirectory", "ClassFILE", "ClassDirectory", "classDirectory", "sourceClass", "classChain", "sourceFiles", "classResource", "attributeResource", " classFILE", "userFile", "objectFolder", "targetFiles", "classTree", "Classfile", "classifiedSourceFile", "userFILE", "userFiles", " classLine", "recordFilename", "userfile", "ClassFile", "fastfile", "objectClass", "classSourceFile", " classFolder", "recordFiles", "instanceDirectory", "typeFiles", "typeFile", "parentFILE", "connectionSourceFile", "attributeEntry", "ClassLine", "classClass", "ClassResource", "cellFolder", "ClassEntry", "instanceFile", " classFilename", "classifiedFILE"], "inputStream": ["audioStream", " inputSource", "ipStream", "InputTime", " inputSt", "outputPort", "thisFile", "audioSteam", "jsonStreamer", "ipFile", "outStreamer", "InputSteam", "familyStyle", "ipSteam", "outputStyle", "familySource", "InputMode", "inputMode", "innerSteam", "inSet", "familySteam", "familyFile", "ipStyle", "jsonSteam", "outputstream", " inputSteam", "inputStreamer", "thisSource", " inputstream", "inSteam", "innerStream", "inStream", " inputTime", "inputSteam", "inStreamer", "thisSteam", "outSteam", "audioStreamer", "inputstream", "thisStream", "inputSt", "inputPort", "familyStream", "innerSet", "Inputstream", " inputPort", "outputFile", "errorStream", "instream", "inPort", "inputStyle", " inputFile", "InputStream", "inputSource", "errorstream", "errorSteam", " inputMode", "jsonStream", "outputTime", "outStream", "innerStreamer", "outputSteam", "outSt", "errorMode", "inputSet", "audioSt", " inputStreamer", "jsonSet", "inputTime", "inputFile"], "reader": ["image", "readable", "dr", "dd", "mr", "operator", "field", "actor", "stream", "red", "ger", "instance", "er", "service", "peer", "oder", "review", "driver", "user", "owner", "iterator", "handler", "editor", "test", "parser", "penter", "rule", "entry", "wrapper", "loader", "definition", "layer", "author", "rl", "runner", "worker", "reading", "prototype", "key", "ler", "builder", "query", "document", "draft", "per", "rar", "Reader", "client", "older", "write", "ner", "r", "inner", "manager", "rer", "row", "variable", "Writer", "finder", "master", "read"], "oldSize": [" oldsize", "oldersize", "oldsize", "olderFontSize", "olderSize", "oldFontSize", "OLDLength", "oldLength", "OLDSize", "OLDFontSize", " oldFontSize", " oldLength", "OLDsize", "olderLength"], "writer": ["riter", "writers", "actor", "node", "message", "format", "er", "service", "buf", "review", "driver", "owner", "player", "editor", "handler", "buffer", "test", "parser", "penter", "weight", "walker", "entry", "wrapper", "loader", "wrote", "definition", "author", "worker", "runner", "method", "ter", "storage", "key", "wb", "ler", "builder", "document", "rw", "draft", "Reader", "word", "write", "vector", "ner", "r", "writing", "inner", "manager", "written", "row", "variable", "finder", "adder", "Writer", "draw", "w", "read"], "b": ["f", "u", "bs", "v", "p", "bf", "bits", "binary", "ib", "bp", "nb", "m", "bin", "c", "ab", "fb", "bis", "a", "wb", "B", "sb", "emb", "batch", "base", "erb", "mb", "gb", "bit", "br", "ob", "h", "r", "g", "db", "l", "rb", "t", "bound", "bb", "d", "w", "n"], "outputStream": [" outputSteam", "inputView", "outputString", "resultstream", "Outputstream", " outputForm", "inputForm", "inputPoint", "writePoint", "outputstream", "resultStream", " outputString", "OutputStream", "inputstream", "inputSteam", " outputView", "OutputSteam", "OutputForm", "resultForm", "writeView", "OutputString", "outputPoint", "resultString", " outputPoint", "writeStream", "outputForm", "outputSteam", "outputView", "resultSteam", "writeSteam"], "injectedClasses": ["injectedCountes", "injectedClassets", "injectedClassBytes", "injectClassES", "injectedSuccessets", "injectClassets", "injectedSuccesses", "injectClassBytes", "injectUses", "injectedUsBytes", "injectedClassES", "injectedUsets", "injectedCountBytes", "injectUsets", "injectedCountES", "injectClasses", "injectUsBytes", "injectUsES", "injectedUsES", "injectedCountets", "injectedUses", "injectedSuccessES", "injectedSuccessBytes"], "newSize": ["NewName", "oldMax", "newName", "oldName", "NewFontSize", "newFontSize", "oldFontSize", "NewSize", "NewMax", "newMax", " newMax", " newFontSize", " newName"]}}
{"id1": "23296117", "id2": "400275", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractInternalFile", "extractNativelib", "extractNativeFile", "extractnativeFile", "extractednativeLib", "extractBaseLib", "extractnativeLib", "extractInternalLibrary", "extractedNativeFile", "extractednativeLibrary", "extractedNativeLibrary", "extractInternallib", "extractBaseLibrary", "extractNativeLibrary", "extractnativeLibrary", "extractedNativelib", "extractedNativeLib", "extractednativelib", "extractBaselib", "extractednativeFile", "extractInternalLib", "extractBaseFile", "extractnativelib"], "sysName": ["sysN", "nsNames", "synType", "ysType", "sysType", "systemName", "ysN", "nsHandle", "ysMap", " sysNames", "sysname", " sysN", " sysHandle", "systemType", "systemMap", "systemname", "ysNames", " sysname", "nsName", "sysHandle", "systemN", "sysMap", "systemNames", "synName", "sysNames", "ysName", "ysname", "nsname", "synMap", "systemHandle", "synname"], "name": ["id", "data", "nm", "about", "string", "s", "ename", "me", "term", "Name", "mod", "loader", "part", "resource", "a", "alias", "NAME", "brain", "file", "run", "base", "word", "ame", "nam", "title", "create", "filename", "source", "version", "type", "unknown", "default", "named", "root", "names", "info", "local", "module", "n"], "load": ["update", "store", "cache", "show", "connect", "launch", "enter", "boot", "sync", "require", "Load", "test", "debug", "loader", "hold", "loaded", "remove", "link", "install", "label", "register", "oad", "dump", "init", "loading", "force", "library", "lock", "loads", "call", "check", "write", "hack", "warn", "create", "help", "fail", "start", "leaf", "play", "parse", "include", "save", "download", "util", "use", "local", "read", "LOAD"], "warning": ["Warning", "very", "value", "war", "ew", "fw", "we", "message", "weak", "web", "yellow", "WARNING", "setting", "debug", "speaking", "error", "ping", "pretty", "usage", "comment", "WARN", "loading", "console", "function", "force", "wa", "only", "getting", "testing", "flash", "warn", "saving", "writing", "help", "default", "success", "aw", "starting", "info", "w"], "fullname": [" fullName", "longame", "shortname", "Fullpath", "localname", "fullName", " fullpath", "flatName", "shortNAME", "localName", "fullypath", "fullyvalue", "fulln", "shortpath", "longname", "longName", "flatname", "fullyame", "fullyname", "localfilename", "shortn", "fullfilename", "FullName", "flatfilename", "fullNAME", "localpath", " fullfilename", "fullyNAME", "Fullvalue", " fullame", "flatpath", "longnamed", " fulln", "longn", "fullnamed", "longpath", "longvalue", " fullnamed", "Fullname", "Fullfilename", "fullvalue", "longNAME", "fullame", "fullynamed", "longfilename", "shortName", "fullyName", "fullpath"], "path": ["image", "cmd", "patch", "th", "near", "exp", "p", "pattern", "where", "php", "string", "partial", "chain", "pointer", "test", "ref", "pt", "raw", "PATH", "trace", "link", "spec", "dir", "key", "transform", "prefix", "file", "hex", "this", "def", "pro", "up", "full", "w", "filename", "uri", "route", "prop", "Path", "root", "local", "ath"], "url": ["f", "host", "loc", "rel", "sl", "ssl", "gl", "org", "atl", "https", "ls", "norm", "dl", "channel", "bel", "con", "lr", "web", "user", "addr", "rect", "str", "err", "ll", "xml", "raw", "loader", "ret", "resource", "http", "rl", "li", "nl", "link", "socket", "req", "ur", "impl", "URL", "res", "cert", "build", "mb", "open", "mount", "client", "lb", "r", "Url", "l", "abs", "fl", "util", "job"], "conn": ["cn", "cmd", "ssl", "exec", "cf", "ls", "serv", "enc", "connect", "nc", "jp", "iw", "reg", "canon", "ws", "sync", "con", "cc", "addr", "ctx", "str", "resp", "c", "col", "comm", "socket", "pg", "sql", "connection", "obj", "Conn", "res", "mc", "cert", "nt", "msg", "pc", "ch", "cp", "open", "client", "cmp", "cur", "close", "conv", "config", "conf", "ctr", "pas", "ct", "cm", "cb", "cont", "handle"], "in": ["ins", "din", "inside", "el", "en", "ry", "again", "serv", "ini", "IN", "inn", "con", "ai", "net", "io", "inf", "ln", "cin", "gin", "m", "mm", "bin", "on", "from", "it", "ar", "ic", "st", "or", "re", "all", "init", "nin", "mc", "ain", "ind", "is", "inc", "rin", "i", "input", "source", "iter", "r", "inner", "oin", "info", " din", "read", "In", "n"], "targetFile": ["argetFile", " targetEntity", "argetLog", "targetEntity", " targetFilename", "sourcePage", "TargetFile", "saveEntity", "thisfile", "targetFILE", "thisFile", " targetFILE", "topFile", "TargetPage", "argetFilename", "topfile", "proxyFolder", "sourceFile", "targetPage", " targetPage", "TargetFILE", " targetFolder", "thisPath", "argetFull", "targetFull", "TargetLog", "saveFILE", "TargetFilename", "proxyFile", " targetPath", "sourcePath", "toFilename", "targetLog", "targetfile", "proxyEntity", "toFile", "targetFilename", " targetLog", "saveFile", "TargetPath", "topFilename", "thisPage", "argetfile", "argetFILE", "proxyFILE", "tofile", "toPage", "targetFolder", "targetPath", "TargetFull", "saveFolder", " targetFull", "Targetfile", "topPath", "sourceFilename", "sourcefile", " targetfile"], "out": ["ins", "cmd", "boot", "buf", "err", "comment", "obj", "nt", "pos", "check", "oss", "null", "mit", "log", "OUT", "co", "cache", "io", "ne", "chain", "n", "bin", "it", "or", "OU", "ou", "inv", "to", "init", "aos", "auto", "cos", "ch", "no", "write", "conv", "conf", "o", "end", "at", "w", "result", "cn", "p", "v", "other", "ex", "sum", "con", "user", "outs", "c", "timeout", "all", "up", "one", "oe", "os", "flush", "t", "ot", "output", "again", "net", "ns", "writer", "pool", "ion", "client", "inner", "Out", "outer", "can"], "targetLastModified": ["targetLastmodify", "targetLastLoadifier", "targetlastModed", "targetLastModmodified", "targetlastModmodified", "targetMaxReified", "targetLastReured", "targetlastModified", "targetMaxModifier", "targetlastQualifier", "targetLastModifier", "targetLastMsmodified", "targetLastmodured", "targetLastmodified", "targetLastmodifier", "targetLastReifier", "targetlastQualified", "targetMaxModify", "targetLastLoadify", "targetLastMsified", "targetLastModed", "targetLastReified", "targetMaxReured", "targetMaxModured", "targetlastQualed", "targetLastLoadured", "targetLastLoadified", "targetLastMsifier", "targetLastQualed", "targetLastModify", "targetlastQualmodified", "targetMaxReifier", "targetlastModifier", "targetLastQualifier", "targetLastMsed", "targetMaxReify", "targetLastQualmodified", "targetLastReify", "targetLastModured", "targetMaxModified", "targetLastQualified"], "sourceLastModified": ["sourceLastTrified", "sourceLastmodTime", "sourceLastTrification", "sourceLastModsmodified", "sourceLastModed", "sourceLastTimed", "sourcelastModify", "sourcelastModified", "sourceLastTrTime", "sourceLastModsified", "sourceLastMsify", "sourcelastTrified", "sourcelastTrTime", "sourceLastTimification", "sourceLastTimmodified", "sourceLastmodify", "sourceLastMsification", "sourcelastTrify", "sourceLastModsification", "sourceLastMsified", "sourceLastModification", "sourceLastMsTime", "sourceLastTimified", "sourceLastModsed", "sourceLastTrify", "sourceLastmodification", "sourcelastModification", "sourceLastModmodified", "sourceLastModify", "sourcelastTrification", "sourceLastModTime", "sourcelastModTime", "sourceLastmodified"], "len": ["length", "L", "el", "num", "fun", "en", "fin", "vec", "ls", "lf", "count", "dl", "hl", "buf", "lan", "ln", "le", "lim", "str", "val", "ll", "size", "nl", "Len", "cap", "all", "seq", "nt", "pos", "no", "elt", "pl", "syn", "ld", "l", "coll", "fl", "mat", "t", "bytes", "end", "pad", "n"]}}
{"id1": "23517481", "id2": "15129155", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"md5": [" MD4", "MD4", "md3", " MD2", "MD3", "md4", " md4", " md2", "MD5", " MD3", "MD2", " md3", "md2", " MD5"], "uri": ["u", "domain", "ri", "du", "location", "message", "char", "description", "path", "io", "origin", "qi", "q", "uni", "URI", "subject", "via", "term", "resource", "http", "link", "ur", "prefix", " URI", "query", " ur", "file", "course", "force", "uu", "address", "msg", "directory", "name", "unit", "ui", "i", "filename", "url", "util", "remote", "password", "requ"], "messageDigest": ["Messagediger", "MessageDiger", "Messagedigse", "messagedigest", "messageDoment", "messageDose", "messageDiger", "messageDigester", "messagedigse", "messagedigester", "Messagedigester", "messageDoest", " messageDigse", " messageDigment", "MessagedigEST", "messageMDest", "messagediger", "messageDigEST", "messagedigment", " messageDigose", "messageDigment", "MessageDigest", "messageDigose", "messagedigose", "messageDigse", "messageMDEST", " messagedigse", "messageDoose", "messagedigEST", "MessageDigester", "Messagedigest", "messageMDse", "MessageDigEST", " messagedigest", "messageMDer", " messagedigment", " messagedigose", "messageMDester", "MessageDigse"], "bytes": ["ions", "terms", "xs", "uses", "words", "bs", "bits", "values", "bes", "classes", "clips", "s", "types", "times", "gets", "buffer", "files", "strings", "Bytes", "outs", "gs", "images", "bps", "users", "odes", "pieces", "tes", "seconds", "sofar", "ies", "loads", "gb", "ors", "ces", "steps", "ings", "pages", "es", "les", "groups", "frames", "blocks", "amps"], "stringBuffer": ["soundBuff", "libraryCenter", "libraryBlock", "ringBuff", "stringsBuilder", " stringBuff", "stringLength", "StringLength", "libraryController", " stringChannel", "soundbuffer", "stringController", "ringLength", "statusBlock", "ringQuery", "stringsBuff", " stringLength", "stringBlock", "StringQuery", "stringView", "StringChannel", " stringCenter", "libraryBuffer", "stringsQuery", "Stringbuffer", "stringQuery", " stringView", "ringView", "soundBuffer", "StringBuff", "stringsBuffer", "ringBuffer", "stringbuffer", "soundChannel", " stringbuffer", "statusBuffer", "stringChannel", "stringBuff", "stringBuilder", "ringBuilder", "statusCenter", " stringBlock", " stringController", "StringView", "stringCenter", "statusController"], "b": ["k", "f", "z", "u", "value", "id", "v", "p", "binary", "bs", "ib", "s", "e", "bi", "nb", "c", "a", "j", "B", "x", "obj", "sb", "y", "be", "ch", "gb", "out", "h", "i", "r", "l", "rb", "o", "t", "buff", "bb", "d", "w", "n"], "hex": ["mix", "sh", "exp", "cf", "com", "ex", "red", "alpha", "solid", "alph", "hl", " Hex", "color", "form", "print", "percent", "str", "rendered", "term", "raw", "imal", "re", "ph", "tex", "sv", "bh", "des", "dump", "rex", "x", "xf", "ch", "none", "hash", "zip", "def", "pex", "comp", "h", "serial", "full", "uint", "lit", "json", "prop", "oct", "tx", "buff", "sex", "ext", "html", "hello", "escape"]}}
{"id1": "18504192", "id2": "5723876", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyStream", " CopyFiles", "copyfile", " transferfile", " CopyStream", "CopyFiles", " transferStream", "CopyFile", "copyFiles", "CopyStream", "Copyfile", " transferFile", " CopyFile", " transferFiles", " Copyfile"], "in": ["ins", "din", "el", "en", "b", "id", "old", "IN", "inn", "inf", "cin", "gin", "on", "mm", "from", "ic", "it", "or", "vin", "as", "edIn", "ind", "is", "inc", "up", "rin", "input", "i", "l", "o", "isin", "In", "n"], "out": ["k", "ot", "output", "OUT", "b", "v", "serv", "ex", "gt", "s", "net", "ne", "io", "err", "outs", "it", "ou", "to", "po", "nt", "i", "oss", "g", "help", "os", "l", "t", "log", "o", "Out", "at", "w", "n"], "source": ["access", "inside", "scope", "copy", "store", "search", "shell", "seed", "scan", "style", "SOURCE", "position", "match", "instance", "service", "sin", "secret", "ources", "back", "iterator", "origin", "sequence", "ource", "src", "space", "me", "subject", "from", "resource", "volume", "spec", "comment", "init", "query", "file", "force", "ie", "reader", "before", "system", "open", "template", "pse", "se", "input", "create", "inner", "start", "parse", "Source", "sample", "use", "info", "local"], "destination": ["restation", " destinated", "seeination", "comification", " destinator", "seeension", "restinator", "restinated", " destension", "destregation", "Destination", "seeinator", "Destension", "Destinated", " destregation", " destato", "Destinator", "destato", "destation", "Destation", "seeinated", " destation", "comregation", "coordification", "coordination", "comato", "destification", "coordato", "restination", "coordregation", "comination", "destension", " destification", "destinated", "destinator"]}}
{"id1": "17475530", "id2": "344764", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    static HttpURLConnection connect(String url, String method, String contentType, String content, int timeoutMillis) throws ProtocolException, IOException, MalformedURLException, UnsupportedEncodingException {\n        HttpURLConnection conn = (HttpURLConnection) (new URL(url).openConnection());\n        conn.setRequestMethod(method);\n        conn.setConnectTimeout(timeoutMillis);\n        byte[] bContent = null;\n        if (content != null && content.length() > 0) {\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", contentType);\n            bContent = content.getBytes(\"UTF-8\");\n            conn.setFixedLengthStreamingMode(bContent.length);\n        }\n        conn.connect();\n        if (bContent != null) {\n            OutputStream os = conn.getOutputStream();\n            os.write(bContent);\n            os.flush();\n            os.close();\n        }\n        return conn;\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinktoImage", "testAddLinksToimage", "testAddLinkFromImages", "testAddLinkForimage", "testAddLinktoimage", "testAddLinkstoImages", "testAddLinksToImages", "testAddLinkForImages", "testAddLinkToPicture", "testAddLinkForImage", "testAddLinktoImages", "testAddLinkFromPicture", "testAddLinkToImages", "testAddLinkFromimage", "testAddLinkFromImage", "testAddLinkstoimage", "testAddLinkToimage", "testAddLinkstoImage", "testAddLinkstoPicture", "testAddLinkForPicture", "testAddLinktoPicture", "testAddLinksToImage", "testAddLinksToPicture"], "in": ["k", "ins", "din", "inside", "en", "v", "ex", "ini", "show", "sum", "IN", "er", "inn", "ed", "gin", "cin", "on", "m", "bin", "set", "from", "it", "or", "by", "vin", "re", "and", "add", "sein", "all", "init", "nin", "file", "mc", "al", "ma", "at", "ind", "is", "inc", "out", "check", "up", "rin", "doc", "source", "input", "i", "r", "inner", "get", "one", "include", "o", "password", "isin", "info", " din", "In", "pi"]}}
{"id1": "9099457", "id2": "14785308", "code1": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"hash": ["update", "id", "sum", "message", "format", "string", "Hash", "print", "str", "text", "sign", " hashing", "link", "tag", "dump", "key", "hex", "code", "address", "name", "check", "h", "uri", "shadow", "type", "component", "index"], "value": ["object", "output", "values", "v", "position", "language", "data", "message", "select", "description", "string", "content", "test", "sequence", "tree", "val", "example", "raw", "text", "label", "attribute", "item", "key", "expression", "python", "document", "name", "VALUE", "word", "current", "this", "vector", "source", "input", "title", "null", "json", "version", "type", "variable", "sample", "password", "hello", "Value", "now", "result"], "md": ["cmd", "dd", "amd", "der", "red", " cmd", " mc", "mg", " rm", " sm", "mk", "sd", " dd", "od", " sd", "ms", "m", "mm", "pm", "pt", "gm", "pd", "mod", "strong", "down", "and", "add", "ke", "de", "dir", "sam", "ad", "mn", "df", "nt", "msg", "dm", "mand", "ind", "mb", "det", "met", "h", "grad", "ld", "td", "rm", "di", "bd", "hd", "d", "MD", "sm"], "md5hash": ["md2sum", " md3hash", "md5cache", "md3print", "MD2Hash", "md3hash", "md2Hash", "md3sha", "md5hex", "MD2h", "md2hash", "md4hash", "md5sum", "md3sum", "md7sum", "md50print", " md5sum", "md45hash", " md3print", "md45sum", " md3hex", " md3sum", "md2cache", "md3cache", "MD5hash", "md4h", "md4sum", "MD5sum", "MD2hash", "md50hash", "md4Hash", " md3sha", "MD5h", "md7Hash", "md45sha", "md2h", " md3cache", "md5Hash", " md5sha", "md45hex", "md2sha", "md2hex", " md5cache", " md5hex", "md5print", "md7hash", " md5print", "MD2sum", "MD5Hash", "md50sum", "md3hex", "md5h", "md50cache", "md7h", "md2print", "md5sha"]}}
{"id1": "9327525", "id2": "9398454", "code1": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"test02_ok": ["test02__ok", "test02AOK", "test02__Ok", "test2_full", "test02Aok", "test2_Ok", "test2_OK", "test2_ok", "test02Afull", "test2__full", "test02_Ok", "test02__full", "test2__ok", "test02__OK", "test02_OK", "test02AOk", "test2__Ok", "test02_full", "test2__OK"], "client": ["cli", "context", "core", "ssl", "server", "co", "cache", "tc", "connect", "window", "api", "service", "con", "google", "secure", "handler", "cell", "sim", "acl", "network", "conn", "wrapper", "loader", "request", "c", "collection", "resource", "http", "control", "phone", "session", "connection", "console", "pool", "cp", "system", "call", "uri", "config", "policy", "close", "null", "cl", "app", "ci", "ip", "remote", "Client", "cm", "contact", "local"], "post": ["dd", "copy", "patch", "p", "process", "form", "test", "valid", "pre", "set", "pp", "Post", "request", "push", "http", "load", "add", "method", "link", "upload", "read", "apply", "install", "wp", "op", "body", "build", "put", "zip", "call", "write", "posts", "get", "POST", "submit", "ost", "ip", "url", "row", "parse", "next", "save", "pod", "and", "send"], "nameValuePairs": ["nameValueParappings", "nameNameParars", "nameValuesPonents", "nameValueParuffs", "nameValuePararms", "nameValueCompings", "nameValueAssair", "nameNamePersings", "nameValuePersairs", "nameValuePersars", "nameValueParars", "nameValuePersuffs", "nameValueEairs", "nameValuePars", "nameNamePersars", "nameValueCharms", "nameValueAssairs", "nameNamePair", "nameValueparms", "nameValuePonents", "nameValueAppings", "nameNameParms", "nameValueAssarms", "nameValuesPings", "nameValueputes", "nameValueChappings", "nameValuesParms", "nameNamePairs", "nameValuePointarms", "nameNamePars", "nameValueChars", "nameValuepairs", "nameValuesPair", "nameValueCompairs", "nameValuePersonents", "nameValuesPars", "nameValueAssars", "nameValuespairs", "nameValueApparms", "nameValuepars", "nameNamePersairs", "nameValueParair", "nameValuePings", "nameValuePersappings", "nameValueChair", "nameValuePores", "nameValuespair", "nameValueEars", "nameValueponents", "nameValuePair", "nameValuesPappings", "nameValuePutes", "nameValueParairs", "nameNamePersarms", "nameValueCompappings", "nameValueAppairs", "nameValueEair", "nameValuespings", "nameValueMaputes", "nameNamePersutes", "nameValuepair", "nameValuePointonents", "nameValuePersutes", "nameValuePersair", "nameNameParores", "nameValuePersarms", "nameValuePointairs", "nameValuePointars", "nameValuePappings", "nameNamePutes", "nameValueCompair", "nameValuePersings", "nameValueParores", "nameNamePores", "nameValuePuffs", "nameValueChings", "nameValuesponents", "nameValuesPairs", "nameNameParairs", "nameNamePings", "nameValueCompars", "nameValueChairs", "nameValueMapairs", "nameNamePersair", "nameValuespappings", "nameValuepings", "nameValuepores", "nameValueParms", "nameValuepappings", "nameValuesparms", "nameValuespars", "nameValueMapars", "nameValuepuffs", "nameNameParair"], "response": ["onse", "object", "reply", "output", "server", "header", "model", "channel", "profile", "message", "given", "description", "service", "ve", "sequence", "tree", "block", "example", "resp", "entry", "application", "request", "view", "answer", "network", "resource", "http", "status", "frame", "volume", "page", "report", "connection", "res", "document", "console", "body", "pos", "def", "still", "respond", "Response", "json", "version", "command", "result"], "entity": ["image", "el", "object", "quote", "pe", "output", "encrypted", "person", "voice", "model", "channel", "eme", "ity", "data", "message", "instance", "ent", "e", "empty", "my", "ITY", "xml", "entry", "Entity", "error", "resource", "status", "note", "ell", "metadata", "comment", "obj", "document", "body", "code", "existent", "event", "put", "line", "activity", "details", "oe", "json", "type", "ENT", "eric", "ce", "ee", "result"], "instream": ["Inform", "inspod", "Inline", "insstream", "insline", "Instream", "inputcontext", " inform", " inStream", " inconsole", "outcontext", "inStream", "inputstream", "inline", "inputStream", "inform", "inpod", "inputform", "inputconsole", " inpod", "inscontext", "outform", "incontext", "Inconsole", " incontext", "inconsole", " inline", "outStream", "inputline", "inputpod", "outstream"], "reader": ["operator", "stream", "holder", "liner", "upper", "ader", "relation", "er", "iterator", "driver", "handler", "editor", "buffer", "parser", "maker", "loader", "writer", "rl", "runner", "reading", "READ", "builder", "file", "console", "controller", "rr", "Reader", "rar", "latest", "ner", "r", "book", "inner", "rer", "row", "roller", "read"]}}
{"id1": "9319440", "id2": "5049453", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["update", "store", "show", "process", "Load", "loader", "view", "link", "upload", "install", "init", "dump", "file", "loading", "build", "library", "loads", "open", "call", "get", "create", "save", "download", "read", "LOAD"], "id": ["image", "k", "uid", "Id", "data", "kid", "mid", "description", "token", "path", "ref", "rid", "it", "ident", "aid", "link", "tag", "key", "oid", "md", "ad", "sid", "edit", "hex", "code", "hash", "name", "pid", "ID", "event", "no", "h", "i", "title", "create", "uri", "one", "db", "l", "json", "ip", "t", "ids", "info", "and", "job"], "xml": ["image", "cloud", "context", "css", "pdf", "output", "model", "message", "format", "php", "s", "string", "content", "csv", "ml", "print", "m", "om", "tree", "tml", "pp", "text", "chart", "http", "response", "sv", "px", "export", "report", "img", "x", "document", "file", "sql", "sheet", "md", "batch", "body", "xf", "msg", "name", "zip", "mail", "txt", "template", "doc", "json", " XML", "parse", "tx", "t", "ql", "log", "html", "im", "n"], "url": ["loc", "f", "rel", "sl", "cmd", "ssl", "gl", "b", "git", "dl", "hl", "service", "bel", "con", "ref", "addr", "q", "ll", "ret", "loader", "resource", "http", "rl", "re", "ul", "comm", "nl", "link", "socket", "ur", "URL", "connection", "res", "cert", "build", "base", "dll", "mb", "open", "mount", "client", "lb", "r", "Url", "l", "cl", "att", "handle"], "conn": [" connection", "Connection", "con", "ctx", "http", "j", "socket", " con", "connection", "res", "Conn", "obj", "nt", "ch", " err", "open", "client", "txt", "w", " cs", "Url", " net", "ws", " res", "cb", " cur", "n"], "reader": ["context", "dr", "stream", "ri", "rc", "er", "iterator", "io", "handler", "buffer", "parser", "in", "wrapper", "loader", "writer", "rl", "resource", "http", "runner", "worker", "reads", "reading", "ser", "ro", "connection", "file", "nt", "rar", "Reader", "rx", "client", "cur", "r", "ner", "iter", "inner", "input", "rer", "row", "roller", "rot", "read"], "str": ["arr", "del", "z", "bl", "exec", "exp", "cs", "p", "gr", "ls", "STR", "data", "char", "Str", "string", "e", "s", "ev", "chain", "print", "err", "m", "st", "pt", "block", "text", "it", "entry", "part", "set", "comm", "j", "fr", "obj", "hex", "sp", "msg", "tr", "name", "line", "txt", "cr", "r", "syn", "bc", "inner", "source", "iter", "t", "next", "qs", "w", "cont", "n"]}}
{"id1": "19912848", "id2": "12783713", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileFileString", "decodeFileFileFiles", "decodeFileFilefile", "decodeFileFileFile", "decodeString2Files", "decodeStringTofile", "decodeFileAsFile", "decodeStringToFiles", "decodeFile2File", "decodeFileAsFiles", "decodeString2File", "decodeFileToString", "decodeFileAsString", "decodeFileTofile", "decodeFileToFiles", "decodeString2String", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFile", "decodeStringToString", "decodeString2file", "decodeFile2file"], "infile": ["isinfile", "Inbase", "frombase", "fromfilename", "inputfolder", "Infile", "Infilename", "isinname", "fromfile", "inname", "inbase", "inputfile", "outbase", "infolder", "fromFile", "inFile", "infilename", "outname", "isinFile", "inputname", "isinfolder", "outFile", "InFile", "outfilename", "outfolder", "inputFile"], "outfile": ["todir", "inFILE", "inname", "otname", "OutFile", "otFile", "otfile", " outname", "Outfilename", "outdir", "otFILE", "inFile", "infilename", "outname", "toFile", "tofilename", "outFILE", " outFILE", "indir", "tofile", " outFile", "Outfile", "Outdir", "outFile", "outfilename"], "in": ["ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "auto", "nt", "fn", "ion", "can", "write", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "paste", "attribute", "comment", "shape", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "shift", "check", "write", "before", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "scope", "sufficient", "value", "exist", " succeeds", "ratulations", "support", " succeed", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "6304373", "id2": "16557837", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaAndTplates", "uploadOrDeleteMediaAndTemplates", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTplates", "uploadOrDeleteMediaOrTemppl", "uploadOrDeleteMediaOrTempplates", "uploadOrDeleteMediaAndTemTemplate", "uploadOrDeleteMediaOrTempics", "uploadOrDeleteMediaAndTTemplate", "uploadOrDeleteMediaOrTemics", "uploadOrDeleteMediaOrTics", "uploadOrDeleteMediaAndTpl", "uploadOrDeleteMediaOrTpl", "uploadOrDeleteMediaAndTemics", "uploadOrDeleteMediaOrTemTemplate", "uploadOrDeleteMediaOrTTemplate", "uploadOrDeleteMediaAndTempl", "uploadOrDeleteMediaOrTempTemplate", "uploadOrDeleteMediaAndTics"], "action": ["update", "ction", "fun", "operator", "actor", "behavior", "mode", "scene", "exclusive", "instance", "format", "feature", "admin", "process", "activation", "ACTION", "Action", "actions", "on", "acl", "article", "view", "error", "commit", "active", "step", "method", "what", "edit", "expression", "ACT", "op", "function", "wrong", "operation", "change", "act", "controller", "address", "event", "call", "policy", "version", "type", "ase", "go", "now", "verb"], "object": ["image", "entity", "office", "actor", "node", "model", "class", "integer", "relation", "instance", "format", "detail", "information", "subject", "entry", "article", "volume", "resource", "what", "attribute", "item", "oid", "obj", "document", "function", "operation", "address", "act", "objects", "event", "hash", "element", "no", "property", "number", "one", "version", "thing", "unknown", "o", "not", "job", "module", "project"], "numElements": ["numEles", "numElem", "numelements", " numeles", " numElem", " numelements", "numeles", "numNlement", "numElelements", "numelem", " numEles", "numNles", "numElelem", "numNlements", " numelem", " numelement", "numEleles", "numNlem", "numElelement", "numelement"], "req": [" conf", "Request", "Msg", " std", "Requ", " fr", "Resp", " requ", " cmd", "Cmd", " msg", " cred", "q", " cir", "request", " request", " resp", "qt", "quest", "obj", "res", "msg", "txt", " serv", "conf", "tx", " res", "requ"], "session": ["context", "ssl", "store", "search", "cache", "task", "window", "thread", "group", "stack", "state", "subject", "conn", "request", "status", "http", "Session", "response", "socket", "browser", "connection", "sid", "ses", "ess", "parent", "event", "essions", "system", "client", "ession", "config", "manager", "tx", "use", "local"], "ftp": ["FTps", "FTP", " ftP", " ftps", "afp", "FTp", "ftP", "afP", "afps", " fttp", "ftps", "aftp", "fttp", "FTtp"], "user": ["record", "store", "other", "person", "job", "student", "self", "instance", "er", "usr", "order", "owner", "form", "USER", "User", "sys", "group", "basic", "device", "me", "rule", "view", "author", "by", "part", "users", "ter", "ser", "to", "usage", "browser", "ver", "query", "dev", "parent", "per", "event", "word", "current", "system", "client", "usa", "used", "display", "mem", "open", "username", "account", "config", "auth", "db", "manager", "human", "util", "use", "info", "result", "plugin"], "links": ["rel", "blogs", "flags", "Links", "ls", "self", "items", "properties", "types", "actions", "packages", "network", "relations", "js", "link", "dir", "owners", "Link", "details", "scripts", "mails", "pages", "lines", "projects", "groups", "href", "html", "tags"], "folders": ["foldors", "temors", "dirers", "contors", "conters", "contories", "foldes", "temers", "dirors", "temes", "dirories", "temories", "contes", "foldories", "dires"], "folder": ["host", "context", "letter", "container", "old", "location", "zone", "stage", "email", "enter", "area", "lower", "Folder", "path", "box", "device", "sequence", "buffer", "files", "database", "region", "volume", "resource", "collection", "size", "upload", "dir", "card", "sheet", "layout", "topic", "base", "directory", "controller", "family", "zip", "fold", "system", "older", "loop", "feed", "filename", "center", "root", "division", "gallery", "module", "project", "room"], "server": ["host", "engine", "store", "domain", "seed", "port", "computer", "scale", "stage", "instance", "email", "er", "service", "localhost", "area", "peer", "enter", "owner", "device", "handler", "test", "buffer", "database", "mobile", "Server", "resource", "slave", "serving", "erver", "ser", "socket", "browser", "ver", "connection", "console", "directory", "system", "client", "manager", "center", "version", "url", "root", "site", "remote"], "login": ["license", "search", "id", "pin", "match", "computer", "profile", "email", "admin", "secret", "cookie", "token", "owner", "net", "print", "blog", "basic", "cell", "database", "nic", "in", "ident", "author", "ping", "join", "insert", "bridge", "ername", "note", "phone", "connection", "john", "fn", "name", "lock", "nick", "mail", "number", "username", "skin", "pass", "account", "filename", "auth", "submit", "fail", "Login", "ip", "log"], "password": ["encrypted", "value", "Password", "strip", "confirmed", "exclusive", "pattern", "profile", "sword", "ssh", "email", "description", "secret", "token", "path", "device", "restricted", "sudo", "phrase", "picture", "database", "parser", "another", "resource", "worker", "stroke", "pretty", "performance", "comment", "prefix", "attribute", "paste", "python", "command", "power", "pool", "PASS", "hash", "word", "username", "pass", "photo", "auth", "policy", "crypt", "padding", "productive", "wordpress", "hello", "escape"], "fileTransferFolder": ["fileDownloadDirectory", "fileMovefolder", "fileImportLocation", "FileTransferfolder", "fileTransferArea", "FileUploadDirectory", "FileUploadLocation", "fileTransferFile", "fileTransferfolder", "fileUploadLocation", "FileTransferFile", "fileTransferLocation", "fileUploadArea", "FileUploadFolder", "FileUploadFile", "FileTransferDirectory", "fileDownloadFolder", "fileImportfolder", "fileDownloadLocation", "fileUploadFolder", "fileUploadfolder", "fileMoveFolder", "fileImportArea", "fileUploadDirectory", "fileUploadFile", "FileTransferLocation", "FileTransferArea", "FileUploadArea", "FileUploadfolder", "fileDownloadFile", "fileMoveFile", "FileTransferFolder", "fileImportFolder", "fileMoveDirectory", "fileDownloadArea", "fileTransferDirectory", "fileDownloadfolder"], "liveFolder": ["embedDir", "LiveFolder", "LiveDir", " livefolder", "liveDir", " liveDir", "Livefolder", "liveDirectory", "embedfolder", " liveDirectory", "embedFolder", "LiveDirectory", "livefolder", "embedDirectory"], "servers": ["teers", "servvers", "Serctors", "servctors", "serctors", "tectors", "teors", "serors", "tevers", "serers", "servors", "Serors", "Serers", "Servers"], "message": ["mess", "warning", "essage", "show", "data", "language", "window", "description", "content", "say", "string", "sequence", "buffer", "m", "application", "status", "trace", "response", "reason", "Message", "comment", "alert", "report", "browser", "document", "body", "msg", "flash", "mail", "template", "memory", "number", "summary", "media", "log", "contact", "management", "command", "result"]}}
{"id1": "3514286", "id2": "1235538", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"getHashedPassword": ["getShashedSecret", "getShashedPassword", "getHashesUser", "getShashedpassword", "getHackedpassword", "getHashSecret", "getHackedPassword", "getHashedSecret", "getShashedUser", "getShashUser", "getHashespassword", "getHashPassword", "getShashPassword", "getShashpassword", "getHashedUser", "getHackedSecret", "getHashpassword", "getShashSecret", "getHackedUser", "getHashUser", "getHashedpassword", "getHashesPassword", "getHashesSecret"], "password": ["value", "Password", "pattern", "data", "message", "sword", "email", "description", "secret", "string", "token", "user", "phrase", "database", "raw", "text", "login", "attribute", "prefix", "key", "address", "hash", "word", "name", "username", "input", "pass", "wd", "reset", "REDACTED", "shadow", "default", "padding", "wordpress", "command"], "digest": ["hashse", " digested", "Digester", "mdse", " Digester", "Digested", "dests", "dest", "mdests", "digested", "hashester", "digests", "digse", " digse", " digester", "Digest", " Digest", "Digse", "hashest", "dested", " Digse", "hashests", "mdester", "mdest", "Digests", "hashested", "digester", " digests"], "hashedInt": ["hashedId", "hashashedINT", "hhedId", " hushedId", "hcheckedInteger", "hushedId", "hashingInt", "hhedTx", " hushedInteger", "hashingINT", " hashedInteger", "hashInteger", "hushedTx", "happedInteger", "hhedInteger", "hashINT", "hashashedInteger", "hashedINT", "hashedTx", "happedTx", " hashedTx", "hashInt", " hashedId", "hashingInteger", "hashedInteger", "hcheckedInt", "hashashedInt", " hushedTx", "happedInt", "hushedInt", " hushedInt", "happedId", "hashashingInteger", "hcheckedINT", "hashashingINT", "hushedInteger", "hashashingInt", "hhedInt"]}}
{"id1": "22431487", "id2": "21827619", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"doPost": [" doPOST", "internalQuery", "internalPOST", "DoPost", "DoPOST", "internalGet", "DoQuery", "doPOST", "doQuery", " doGet", "internalPost", " doQuery", "doGet", "DoGet"], "URL": ["L", "Address", "REF", "OUT", "SOURCE", "GET", "UR", "STR", "AT", "IN", "LL", "EL", "IL", "URI", "UL", "TL", "CL", "PATH", "SSL", "Location", "Name", "API", "FILE", "NAME", "DL", "HTML", "SR", "RAW", "PORT", "ID", "Url", "HTTP", "url", "METHOD", "PUT", "Path", "RL"], "params": ["param", "pins", "terms", "words", "values", "p", "rs", "par", "AMS", "months", "Parameters", "vals", "fields", "properties", "items", "times", "actions", "mm", "pps", "packages", "amps", "options", "marks", "news", "ams", "requires", "sql", "forms", "phys", "batch", "styles", "settings", "changes", "members", "idents", "keys", "points", "posts", "Par", "details", "parts", "ops", "config", "pages", "json", "lines", "ports", "tags", "names", "photos", "ps", "stats"], "util": ["nu", "hum", "u", "fun", "cu", "utf", "security", "il", "api", "format", "utils", "ool", "lu", "eu", "um", "wal", "form", "tree", "tu", "iu", "http", "hu", "ul", "etc", "usage", "install", "fu", "ui", "Ut", "modern", "hog", "conv", "ils", "help", "uh", "til", "url", "mu", "info", "lib", "rot", "ility", "ut"], "uri": ["host", "nu", "u", "quote", "sky", "uid", "domain", "ri", "du", "location", "api", "service", "path", "ref", "uni", "URI", "subject", "term", "resource", "http", "based", "link", "range", "ur", "prefix", " URI", "course", "uu", "base", "address", "phi", "msg", "directory", "this", "unit", "client", "ui", "wiki", "source", "url", "pi"], "httpclient": [" httpce", "httpsconnection", "httpsClient", "httpClient", " httpClient", "httpce", "Httpnet", " httpconnection", "hClient", "httpsclient", "HttpClient", "Httpconnection", "httpserver", "Httpserver", "Httpclient", "httpnet", "httpsnet", "httpconnection", " httpnet", "Httpce", "hserver", "hclient", " httpserver", "hce"], "postMethod": ["putRequest", "handleMethod", " postClient", "postClient", "handleRequest", "putmethod", "pubMethod", "PostOperation", "postOperation", "postRequest", "PostField", "preMETHOD", "handleMETHOD", "pubRequest", "handleClient", " postRequest", "preRequest", "PostMETHOD", "putMETHOD", "putMethod", "postMETHOD", "PostRequest", "putField", "preMethod", "postmethod", "Postmethod", "pubOperation", "pubMETHOD", "postField", "httpMethod", "preOperation", "httpmethod", " postMETHOD", "putOperation", "httpOperation", "PostMethod", "putClient", "httpField"], "paramString": ["paramStr", "permBuffer", "attributeString", "permArray", "attributeBuffer", "aramStr", "paramBuffer", "postString", "postBuffer", " paramChain", "postStr", "paramsUnit", "paramUnit", "termFile", "ParamStr", "pString", "processString", "ParamByte", "argString", "paramsSet", "ParamArray", "permNumber", "attributeArray", "attributeByte", "paramFile", " paramFile", "paramList", "permChain", "aramShort", "ParamUnit", "paramsstring", "ParamBuffer", "paramstring", " paramstring", "paramChain", "ParamList", "paramsStr", "pSet", "paramArray", "pstring", " paramList", "pStr", " paramStr", "paramShort", "ParamString", "paramsString", "paramNumber", " paramUnit", "argstring", "paramsList", "termNumber", "permString", "aramBuffer", "postShort", " paramSet", "termString", "processstring", "permFile", "paramSet", " paramNumber", "termChain", "permByte", "aramString", "ParamShort", "paramByte"], "i": ["mi", "u", "id", "il", "ms", "q", "ims", "gu", "di", "gi", "ci", "ski", "d", "info", "I", "f", "ia", "pi", "ix", "us", "e", "io", "chain", "my", "m", "ic", "multi", "it", "or", "li", "xi", "init", "key", "ori", "ji", "uu", "ind", "is", "fi", "o", "qi", "iv", "v", "p", "er", "si", "eu", "me", "in", "iu", "c", "j", "x", "ie", "slice", "ip", "t", "ql", "index", "ami", "b", "ini", "ii", "ai", "bi", "sim", "ei", "ti", "a", "ij", "hi", "phi", "y", "ui", "im", "oi"], "xx": ["von", "XX", "xs", "hz", "XXXX", "fw", "xxx", "enc", "yy", "zz", "ang", "mk", "ous", "XXX", "foo", "xy", "pp", "zzy", "xxxx", "xi", "fx", "aaa", "kk", "x", "hex", "xxxxxxxx", "wx", "ess", "y", "smith", "bu", "fy", "yk", "kw", "txt", "REDACTED", "ux", " XX", "ck", "ng"], "httpResponse": ["HttpResp", "httpsClient", "httpResp", "httpClient", " httpClient", "consoleResponse", "httpsRes", "httpresponse", "httpRes", "consoleEntity", "HttpRes", " httpAnswer", "ttpClient", "httpAnswer", "consoleresponse", "ttpResp", "ttpEntity", " httpRes", "ttpRes", "ttpAnswer", " httpResp", "httpsResponse", "httpsresponse", "HttpResponse", " httpEntity", "Httpresponse", "consoleAnswer", "ttpResponse", "httpEntity", " httpresponse", "ttpresponse"], "strResult": ["strNow", "strResults", "STRRes", "STRRest", " strRest", "StrNow", "txtResult", "StrResult", "txtResults", "STRResult", "txtRest", "STRresult", "stringResult", " strResults", "strRes", "stringResults", "txtRes", "txtresult", "stringRes", "STRNow", "strresult", "StrRes", " strRes", "txtNow", "STRResults", " strresult", "StrResults", "Strresult", "stringresult", "strRest"]}}
{"id1": "19006212", "id2": "937612", "code1": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "code2": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"Load": ["Get", "Open", "Save", " Create", "New", "Play", "Find", "Read", "Init", "loader", "File", "load", "Download", "Add", " Add", " Init", "Create", "loads", " Read", "Import", " Import", "Loader", " Open", "Loading", " Get", "read"], "fname": [" fName", "fpfile", "fullName", " flynn", "pname", "flynn", " fnm", "pName", "ffile", "Ffile", "filepath", "lpath", " fpath", "fpath", "fnames", "frfile", "fcnames", "lfile", "fullnm", "frName", "fullfilename", "filefile", "fName", " ffile", "filetype", "fullname", "fullnames", "Fname", " ftype", "fileName", "Fpath", "fpName", "fcfilename", "fulllynn", "fclynn", "frnam", "fcpath", "pfile", "FName", "frname", "fnm", "fcname", "ppath", "fpname", "filename", " fnames", "lName", "fctype", " fnam", "fpnam", "ffilename", "fnam", "fcnm", "filenam", "lname", " ffilename", "fcName", "ftype"], "f": ["fs", "b", "cf", "p", "fw", "bf", "fm", "fo", "e", "form", " fa", "m", "face", "sf", "c", "a", "fr", "fa", "file", " e", "fp", "g", "t", "F", "d", "w", " F", "fc"], "aType": ["aTypes", "aFile", "oField", "aField", "bFile", "bTypes", " aTypes", "bType", "oFile", "bField", " aField", " aFile", "oType", "oTypes"], "aElement": ["AEntity", "oaElement", "aEntity", "oaCell", "AHeader", " aEntity", "oaHeader", " aCell", "ACell", "aHeader", " aHeader", "AElement", "aCell", "oaEntity"], "content": ["object", "value", "cache", "script", "data", "message", "Content", "format", "description", "sequence", "section", "xml", "text", "view", "size", "load", "comment", "label", "document", "layout", "code", "body", "txt", "template", "source", "title", "version", "default", "action"], "Ax": ["Ha", "Col", "Y", "Num", "Tx", "Am", "Pos", "AI", "He", "Ex", "ax", "ay", "X", "xi", "Az", "Ar", "Ap", "ox", "Ty", "At", "Al", "Wa", "Area", "Typ", "Dim", "AX"], "Ay": ["Gy", "Li", "Imm", "Bat", "Yu", "Serv", "Sky", "Tok", "Rot", "Ry", "Ak", "Lin", "Pan", "Py", "Az", "Xi", "Ty", "Ali", "Mut", "Bi", "Opp", "Sy", "Ac", "Mal", " Ny", "Bet", "Typ", "Ba"], "aTemplate": [" aTarget", "oController", "oTarget", "oTemplate", "oLayout", "anTemplate", "aController", "anLayout", "aTarget", " aController", " aLayout", "anTarget", "aLayout", "anController"], "factory": ["cfictionary", "hiber", "fictionary", "hixture", "fFactory", "tactory", "fiber", "Factory", "tacter", "FFactory", "formacter", "Fcreate", "cfFactory", "fixture", "fcreate", " fcreate", "cfcreate", "tixture", " fFactory", "formactory", "tiber", "formiber", "Fictionary", "facter", "formixture", "hacter", "cfactory", " fictionary", "hactory"], "data_read": ["data_used", "Data_length", "Data_read", "data_length", "Data_used", "data_loaded", "Data_loaded"], "url": ["loc", "rel", "u", "sl", "domain", "gl", "org", "location", "ls", "norm", "dl", "channel", "data", "char", "bel", "kl", "web", "lr", "user", "ref", "ml", "str", "ll", "xml", "loader", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "sql", "URL", "builder", "file", "address", "name", "mb", "mail", "ob", "ol", "uri", "Url", "l", "abs", "util", "bb", "result"], "parser": ["processor", "p", "doctor", "language", "instance", "format", "er", "peer", "cer", "arser", "iterator", "basic", "tar", "Parser", "xml", "penter", "walker", "bank", "asper", "loader", "layer", "writer", "worker", "browser", "ler", "builder", "document", "file", "function", "asser", "per", "Reader", "reader", "lp", "system", "jack", "inner", "policy", "rer", "json", "parse", "password"], "i": ["cli", "mi", "ami", "u", "iq", "id", "pi", "v", "ix", "ini", "er", "us", "ii", "si", "e", "ai", "bi", "chain", "yi", "my", "m", "me", "sim", "in", "ki", "multi", "it", "ei", "ic", "li", "ij", "ti", "j", "xi", "key", "x", "hi", "ji", "ie", "zi", "phi", "y", "ind", "is", "ui", "gu", "di", "oi", "gi", "ci", "t", "qi", "info", "index", "I"], "start_x": ["startingex", " start_X", "start_X", " start_xs", "start_xs", "start_ex", "startingxs", "start_ix", " start_ix", " start_ex", "startingix", "startingx"], "start_y": ["start_yy", "end_b", "start09cy", "start_py", "start09y", " start_cy", " start_yy", "start09x", "end_y", "end_x", "start_b", "start09yy", "end_py", "start_cy"]}}
{"id1": "14053882", "id2": "1097147", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["decryption", "decode", "encrypted", "decrypted", "Encrypt", " encode", "Encryption", "encryption", "Encrypted", "decrypt", "encode", " encryption", "Encode", " encrypted"], "plaintext": ["broadmessage", "plainText", " plainText", "longText", "mainText", " plainpassword", "longmessage", "plainpassword", "publictext", "broadth", " plainTEXT", "publicText", " plainth", "broadText", "plainTEXT", "mainpassword", "publicpassword", "maintext", "longtext", "plainth", "longth", "plainmessage", " plainmessage", "broadtext", "publicTEXT", "mainTEXT"], "md": ["del", "cmd", "dd", "mt", "dr", "mark", "der", "mo", " mc", "nd", "sha", " ma", "mg", "dh", "mk", "med", " dd", "sd", "od", "ms", "mm", "m", "esm", "pd", "mod", "ds", "metadata", "sam", "mc", "mn", "ma", " mo", "df", "managed", "nt", "mp", "dm", "mand", "det", "mb", "ind", "dig", "met", "grad", "ld", "rm", "cd", "hd", "d", "ng", "MD", "sm"], "raw": ["original", "encrypted", "value", "sh", "strip", "data", "message", "hook", "buf", "bare", "clean", "box", "random", "valid", "rendered", "pack", "custom", "array", " Raw", "available", "orig", "all", "known", "hex", "base", "RAW", "right", "good", "extra", "out", "clear", "full", "input", "r", "Raw", "unsigned", "row", "unknown", "aw", "bytes", "bound", " RAW", "n"], "hash": ["ashes", "ash", "sh", "search", "id", "sha", "cache", "sum", "message", "total", "ssh", "Hash", "print", "proof", "has", "hidden", "password", "sign", "alert", "tag", "key", "ashed", "hex", "cert", "tr", "flash", "mask", "height", "h", "hat", "json", "mac", "shadow", "url", "unknown", "hed", "href", "html", "handle"]}}
{"id1": "4618237", "id2": "15166511", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFiles2Stream", "writeFiles2File", "writeFilesToStream", "writeFile2Stream", "writeFileAndStream", "writeFileAndFiles", "writeFilesToFiles", "writeFile2File", "writeFile2Disk", "writeFiles2Disk", "writeFileAsDisk", "writeFilesToFile", "writeFilesToDisk", "writeFileAsFiles", "writeFileAsFile", "writeFile2Files", "writeFileAndFile", "writeFileToDisk", "writeFiles2Files", "writeFileToFiles", "writeFileToStream", "writeFileAndDisk", "writeFileAsStream"], "fin": ["f", "FIN", "irm", "din", "jen", "Fin", "en", "ran", "fw", "lf", "ini", "mid", "fil", "ln", "lo", "normal", "kin", "lin", "fur", "in", "ic", "han", "inv", "fr", "init", "fa", "mn", "fn", "fre", "fp", "fi", "rin", "details", "syn", "raf", "fl", "fd", "rf", "mil", "focus", "fc", "n"], "fout": [" fpo", "kout", "ffin", "Fin", "tOut", "fbOut", "fOut", "fboutput", " foutput", "ffOut", "tout", "tou", "Fout", " fOut", "fbpo", "tin", "foutput", "ffout", "kpo", "fbout", "Fou", "koutput", "fou", "ffou", "kOut", "fpo", "FOut"], "append": ["update", "folder", "ends", "equal", "seed", "pend", "allow", "flat", "string", "csv", "express", "grow", "absolute", "push", "join", "insert", "add", "note", "vert", "apply", "replace", "batch", "force", "ind", "animate", "app", "fail", "bold", "include", "end", "ended", "printf", "ext", "buff", "command", "send"], "inChannel": ["insideClient", "intChan", "insideSession", "sinMachine", " inChan", "InConnection", "rinCategory", "inConnection", "innCategory", "inputChan", "inChan", "pinCategory", "rinListener", "Inchannel", "rinChannel", "inClient", "rinChan", "sinButton", "intSession", "inCategory", "outchannel", " inCommand", "InStream", "outConnection", "innButton", "inSession", "insideChan", "insideChannel", " inStream", "outCommand", "pinButton", "inStream", "InChannel", "iChannel", "intChannel", "sinChannel", " inConnection", "innMachine", " inchannel", "inputChannel", "intClient", "sinCategory", " inCategory", "inchannel", "outChan", " inSession", " inClient", "inCommand", "inMachine", "inputCategory", "iChan", " inListener", "outStream", "inListener", "inputListener", "innChannel", "pinMachine", "iStream", "pinChannel", "inButton", "iCommand"], "outChannel": ["outputCh", " outController", "inChan", " outCh", "netChan", "userCh", "outController", "outputChan", " outchannel", "userChannel", "nameConnection", "outConnection", "outchannel", "invMember", "outputchannel", "inCh", "nameChannel", "netCh", "outputScope", "outScope", "nameScope", " outConnection", "outCh", "userMember", "netchannel", "OUTChan", "OUTchannel", "outputChannel", "OUTController", "inchannel", "outChan", " outScope", "OUTChannel", "nameChan", "outMember", "invCh", "invChannel", " outChan", "netChannel", "outputConnection", "netController", "netMember"]}}
{"id1": "20991673", "id2": "14773780", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "label": 0, "substitutes": {"generateTopicId": ["generateThreadName", "generatesTopicId", "generatesNodeName", "generateTransactionDir", "generatesNodeDir", "generateNodeDir", "generateTransactionID", "generateTopicID", "generateTopicDir", "generatesTopicName", "generatesNodeId", "generateNodeId", "generatesTopicID", "generateNodeID", "generateTransactionName", "generatesTopicDir", "generateNodeName", "generateThreadId", "generatesNodeID", "generateTopicName", "generateThreadDir", "generateThreadID", "generateTransactionId"], "topicName": [" topicFamily", "opicData", "opicInfo", "topicname", " topicname", "threadKey", " topicInfo", " topicNames", "TopicData", "messageInfo", "TopicFamily", " topicKey", "threadData", "topicInfo", " topicData", "threadname", "topicKey", "topicNames", "opicName", "opicFamily", "topicFamily", "TopicInfo", "TopicNames", "messageName", "TopicKey", "messagename", "messageNames", "TopicName", "Topicname", "threadName", "topicData"], "md": ["pdf", "cmd", "dd", "mt", "dr", "M", "bf", "der", "red", "sha", " mc", "mg", "dh", "mk", "med", "sd", "od", "ms", "m", "mm", "me", "pd", "mod", "de", "metadata", "mc", "mn", "ma", "df", "ME", "mp", " Md", "msg", "dm", "mand", "hash", "det", "mb", "dig", "ind", "grad", "rm", "ld", "di", "alg", "cd", "mac", "bd", "hd", "d", "ng", "MD", "sm"], "digest": ["candEST", " digested", "digressed", "Digested", "hashEST", "designest", "digidate", "decidate", "candressed", "decested", "digested", "DigEST", "designEST", "digests", " digEST", "designgest", "decests", "signest", "Digressed", "diggest", "Digest", "designested", "candest", "signidate", "hashest", "signests", "hashgest", "Diggest", "decest", "Digests", "signested", "digEST", "candested", " digressed", "hashested", "Digidate"], "newId": ["Newid", "nextById", "newById", " newid", "newMid", "newsid", "nodeId", "newsId", " newMid", " newById", "NewMid", "nextId", "nextid", "nodeMid", "newsById", "NewById", "newsMid", "newid", "nodeid", "nodeById", "NewId", "nextMid"]}}
{"id1": "1769771", "id2": "22801734", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " CopyFiles", " copyLine", " copyFiles", " CopyStream", "CopyFiles", " CopyLine", "CopyFile", "copyFiles", " copyStream", "CopyStream", " CopyFile", "CopyLine", "copyLine"], "in": ["ins", "din", "el", "en", "b", "old", "ini", " input", "IN", "inn", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ic", "init", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "l", "isin", "In"], "out": ["update", "ot", "output", "OUT", "b", "v", "p", "serv", "ex", "gt", "s", "net", "io", "err", "outs", "it", "c", "ou", "to", "file", "res", "po", "op", "nt", "msg", "up", "help", "os", "l", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["insideClient", "intChan", "innCase", " inChan", "cinCommand", "inConnection", "inChan", "intCommand", "cinRoom", "inClient", "Inchannel", "inScope", "sinButton", "outConnection", "outchannel", " inCommand", "inCategory", "innButton", "sinRoom", "insideCategory", " inCase", "ainChannel", "insideChannel", "sinCommand", "InChannel", "cinChannel", "dinchannel", "ainClient", "dinChan", "intChannel", "sinChannel", "ainScope", " inConnection", " inchannel", "dinConnection", "inCase", "sinCase", "inchannel", " inClient", " inButton", "outChan", "inCommand", "dinChannel", " inScope", " inCategory", "intchannel", "InChan", " inRoom", "sinClient", "inRoom", "innChannel", "innClient", "InCommand", "ainCategory", "insideScope", "inButton"], "outChannel": ["outputCh", "aosChannel", "blockChannel", "neSection", "inChan", "blockChan", " outCh", "outSection", " outManager", "outputChan", " outchannel", "inSection", "aosMember", "cnManager", "outchannel", "outputchannel", "inCh", "outputManager", "aosSection", "cnChan", "cnChannel", "parentChan", "outMany", "blockMany", "neMember", "inMember", "outCh", "parentGate", "outputChannel", "parentMany", "inchannel", " outGate", "outChan", "outMember", "outGate", "parentChannel", " outChan", "outManager", " outMany", "neChannel", "blockGate", "aosChan", "neChan"]}}
{"id1": "20247400", "id2": "9261777", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["ins", "din", "isin", "ze", "IN", "inn", "con", "ai", "net", "io", "inf", "gin", "cin", "on", "bin", "from", "it", "init", "file", "ind", "is", "inc", "check", "up", "rin", "i", "input", "source", "inner", "and", "info", " din", "In"], "out": ["ins", "ot", "cmd", "output", "OUT", "b", "other", "ex", "screen", "println", "we", "list", "gt", "con", "ln", "net", "io", "ne", "print", "sys", "str", "err", "outs", "it", "or", "writer", "OU", "ou", "to", "report", "dir", "obj", "auto", "msg", "name", "line", "write", "client", "check", "oss", "r", "os", "null", "t", "log", "o", "exit", "Out", "at", "w", "outer", "n"], "buffer": ["length", "processor", "output", "header", "b", "binary", "position", "match", "cache", "channel", "data", "message", "total", "window", "buf", "queue", "stack", "phrase", "sequence", "database", "block", "view", "limit", "trace", "table", "size", "bridge", "bar", "available", "comment", "attribute", "key", "shape", "document", "function", "batch", "library", "address", "event", "history", "append", "template", "memory", "source", "display", "se", "iter", "clear", "db", "variable", "Buffer", "flush", "buff", "filter", "sample", "pause", "command", "component", "index", "temp", "result"]}}
{"id1": "19584877", "id2": "12417893", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "21488868", "id2": "9846843", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "13421722", "id2": "9872346", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "label": 0, "substitutes": {"getFileSize": ["getByteLen", " getFilesLen", "getByteSize", " getFilesSize", "getContentLen", "getFilesBytes", " getFileLen", "getFilesLen", "getFilesSize", "getFilesLength", " getFileBytes", " getFileLength", "getFileLen", "getFileLength", "getContentSize", "getFileBytes", "getContentLength", "getByteLength", " getFilesBytes", "getByteBytes", " getFilesLength", "getContentBytes"], "address": ["host", "Address", "server", "domain", "search", "country", "port", "campus", "location", "message", "email", "description", "localhost", "string", "order", "addr", "network", "resource", "table", "add", "argument", "report", "attribute", "prefix", "street", "base", "directory", "reference", "name", "word", "number", "uri", "route", "ip", "remote", "password", "point", "command", "index"], "url": ["loc", "f", "el", "u", "sl", "ssl", "gl", "https", "atl", "git", "location", "ls", "dl", "il", "window", "email", "char", "string", "web", "path", "un", "ref", "q", "str", "ll", "xml", "conn", "http", "re", "rl", "ul", "nl", "link", "www", "browser", "ur", "URL", "file", "sb", "run", "console", "cert", "build", "base", "name", "mount", "mail", "client", "r", "uri", "Url", "l", "null", "parse", "util"], "connection": ["context", "translation", "access", "object", "output", "position", "channel", "language", "Connection", "connect", "relation", "communication", "message", "city", "pointer", "subject", "section", "network", "conn", "application", "entry", "c", "collection", "resource", "response", "machine", "link", "socket", "to", "creator", "session", "function", "operation", "controller", "reference", "directory", "connected", "event", "settings", "open", "system", "client", "ion", "display", "termination", "number", "character", "close", "statement", "cone", "condition", "creation", "version", "password", "command"]}}
{"id1": "23666973", "id2": "10936821", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openResourceInternal", "openSteamSimple", "openStreamRAW", "openFileInternal", "openResourceSimple", "openSteamRaw", "loadStreamInternal", "loadSteamRAW", "loadSteamSimple", "openSteamRAW", "loadStreamRaw", "openStreamInternal", "openFileRAW", "loadStreamSimple", "openResourceRaw", "openSteamInternal", "openResourceRAW", "openStreamSimple", "openFileRaw", "loadSteamInternal", "loadSteamRaw", "openFileSimple", "loadStreamRAW"], "filename": ["f", "length", "initial", "bol", "original", "bf", "location", "println", "message", "nm", "description", "string", "fil", "path", "kl", "whatever", "sequence", "ename", "lua", "src", "subject", "LCS", "Filename", "jpg", "FILE", "upload", "metadata", "prefix", "sql", "document", "file", "nil", "missing", "fn", "directory", "reference", "name", "river", "word", "ren", "java", "txt", "fp", "ame", "username", "source", "uri", "png", "title", "wikipedia", "til", "mson", "journal", "mpeg", "download", "stem"], "stream": ["old", "port", "sync", "ream", "stack", "buffer", "set", "status", "http", "load", "control", "socket", "link", "impl", "shape", "file", "reader", "check", "get", "feed", "row", "log", "download", "local", "length", "context", "Stream", " Stream", "ssl", "store", "instance", "back", "iterator", "form", "chain", "then", "wrapper", "view", "trace", "table", "upload", "console", "body", "mount", "loop", "proc", "conv", "find", "filter", "temp", "result", "dd", "sl", "engine", "channel", "message", "content", "clean", "test", "valid", "resource", "response", "export", "parent", "source", "input", "head", "still", "rest", "draw", "history", "poll", "output", "present", "window", "where", "list", "peer", "sw", "collection", "transform", "pipe", "pool", "event", "zip", "open", "iter", "next", "sample", "pod", "read", "cont"], "url": ["loc", "rel", "sl", "cal", "ssl", "gl", "b", "ls", "dl", "hl", "char", "external", "bel", "kl", "path", "lr", "web", "str", "ll", "pkg", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "impl", "URL", "file", "build", "mb", "mount", "mail", "call", "pl", "r", "uri", "Url", "l", "fl", "job"], "cl": ["cle", "el", "ssl", "sh", "gl", "cf", "com", "lf", "class", "dl", "sc", "tc", "hl", "cc", "kl", "ctx", "acl", "ll", "CL", "loader", "c", "Cl", "scl", "rl", "load", "comm", "impl", "dll", "lp", "pl", "cr", "ctrl", "decl", "fl", "ct", "log", "cm", "ck", "lc", "fc", "ocl"], "cn": ["nn", "cf", "bn", "bean", "pn", "atten", "aren", "dn", "nc", "avan", "unc", "uan", "csv", "tun", "cin", "nic", "ns", "oul", "conn", "san", "rn", "nan", "tn", "crow", "yn", "cv", "cap", "ocon", "enn", "gc", "mn", "cm", "fn", "non", "arn", "CN", "can", "unn", "tan", "CNN", "pan", "gn", "wn", "ct", "hn", "osen", "css", "sen", "cdn", "ern", "jc"]}}
{"id1": "13159394", "id2": "14317425", "code1": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"fetch": ["vget", " frieve", "vetch", " facet", "frieve", "ferieve", " fget", "feacet", "fget", "feetch", "feget", "facet", "vrieve", "vacet"], "request": ["initial", "context", "Request", "object", "server", "header", "forward", "position", "question", "message", "pair", "enter", "setup", "order", "web", "complete", "hello", "xml", "application", "raw", "resource", "http", "QUEST", "argument", "report", "req", "quest", "attribute", "session", "query", "document", "connection", "transform", "child", "address", "reference", "execute", "shift", "current", "client", "template", "input", "create", "reset", "HTTP", "url", "type", "remote", "password", "command", "project"], "GUI": ["Window", "SI", "Monitor", "VO", "DB", "GI", "Guest", "Widget", "UI", "gui", "IL", "Configuration", "LG", "URI", "Environment", "Steam", "Storage", "Interface", "Dialog", "API", "GU", "OU", "Settings", "FILE", "Player", "STAT", "Layout", "Graphics", "LOG", "Browser", "FH", "Gu", "GE", "Engine", "Manager", "INFO", "Hunt", "IE", "EA", "Client", "VM", "MI", "Context"], "httpclient": [" httpce", "Httpforce", "httpsClient", "hconnection", "httpsconnection", "httpcontext", "httpClient", " httpClient", "ttpclient", "httpce", "httpcli", "hClient", " httpconnection", "HTTPnet", "Httpcli", "httpsclient", "httpconn", "ttpconn", "ttpcontext", "Httpconn", "HttpClient", "ttpClient", "Httpconnection", "healthconn", "healthClient", "hforce", "httClient", "httpforce", " httpconn", "httpsce", "httconnection", "Httpclient", "HTTPclient", "ttpconnection", "httforce", "httpsconn", "healthconnection", "httpnet", "httpsnet", "ttpce", "httclient", "httpconnection", "HTTPconnection", " httpnet", "Httpcontext", " httpcli", "ttpcli", "hclient", "HTTPClient", "healthclient", " httpcontext"], "csf": ["cusf", "cusfi", "hsfe", " csfi", "jsf", "csfe", "tsfe", "tsr", "csfw", "hsf", "csr", "tsfw", "csfi", " csr", "hsfw", " csfw", "jsfi", "hsr", "jsfw", "cusfw", "tsf", " csfe"], "params": ["param", "rs", "p", "data", "Parameters", "properties", "s", "types", "headers", "options", "spec", "ams", "socket", "metadata", "session", " parameters", "base", "parent", "settings", "name", "pid", "client", "details", "config", "json", " props", "unknown"], "cookie": [" cook", "cmd", "copy", "value", "domain", " Cookie", "header", "id", "binary", "cache", "data", "Cook", "magic", "cook", "c", "ookie", "jar", "browser", "session", "ie", "code", "y", "name", "cmp", " cookies", "property", "o", "cb"], "origin": [" opaque", "copy", "domain", "ico", "location", " origins", " orig", "options", " domain", "ca", "orig", "browser", "jar", "sid", "cert", "base", "parent", "Orig", " org", "name", "uri", "CA", "ip", "url", "Origin", "o", "ce", " Origin"], "proxy": ["host", "poll", "server", "domain", "port", "cache", "profile", "localhost", "web", "user", "xy", "boss", "slave", "http", "resource", "link", "socket", "alias", "page", "browser", "connection", "force", "parent", "pool", "pipe", "library", "Proxy", "client", "pro", "reverse", "clone", "linux", "prime", "roxy", "shadow", "echo", "apache", "primary", "password", "project"], "currentRemoteGAEHost": ["currentRemoteGAEFPath", "currentRemoteGAeIP", "currentRemoteGAIEIP", "currentRemoteGAOHost", "currentRemoteGaeDomain", "currentRemoteGABHost", "currentRemoteGAEPath", "currentRemoteGaeHost", "currentRemoteGaEAddress", "currentRemoteGaePath", "currentRemoteGAIEHost", "currentRemoteGaEPath", "currentRemoteGAOIP", "currentRemoteGAODomain", "currentRemoteGaEIP", "currentRemoteGAEhost", "currentRemoteGaEHost", "currentRemoteGAEIP", "currentRemoteGaeIP", "currentRemoteGAOhost", "currentRemoteGAIEhost", "currentRemoteGAEDomain", "currentRemoteGAeHost", "currentRemoteGABAddress", "currentRemoteGAeDomain", "currentRemoteGAEFAddress", "currentRemoteGaEDomain", "currentRemoteGABhost", "currentRemoteGAEFhost", "currentRemoteGAIEDomain", "currentRemoteGAEAddress", "currentRemoteGAehost", "currentRemoteGAeAddress", "currentRemoteGAePath", "currentRemoteGABPath", "currentRemoteGaeAddress", "currentRemoteGAEFHost", "currentRemoteGaehost", "currentRemoteGaEhost"], "httpRequest": ["httpsrequest", "htmlCommand", "httpCommand", "httpEvent", "httQUEST", "httrequest", "webRequest", "webEvent", "ttpRequest", "basicQUEST", " httpCommand", "httRequest", "httpsRequest", "httpResponse", "basicRequest", " httpEvent", "ttprequest", "ttpCommand", "basicrequest", "htmlRequest", "webQuery", "httResponse", "webCommand", " httpResponse", "httpQUEST", "basicResponse", " httprequest", " httpQuery", "httprequest", "htmlEvent", "htmlQuery", "httpsResponse", "ttpResponse", "httpQuery", "ttpQUEST", "httpsCommand"], "response": ["onse", "object", "reply", "output", "value", "v", "yes", "data", "message", "relation", "description", "service", "content", "ve", "sequence", "tree", "xml", "block", "entry", "resp", "application", "example", "answer", "status", "http", "frame", "report", "all", "document", "res", "connection", "body", "out", "still", "respond", "one", "respons", "results", "es", "Response", "json", "version", "success", "next", "exit", "successful", "result"]}}
{"id1": "3053403", "id2": "13891080", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"fc": ["fs", "dl", "fm", "ec", "unc", "las", "wic", "acl", "owl", "dc", "fr", "cv", "df", "inc", "fp", "mac", "xc", "fd", "util", "ocl", "f", "icc", "co", "exp", "bf", "football", "form", "ctx", "ac", "imp", "ic", "fb", "disc", "aft", "fa", "gc", "console", "fab", "conv", "cm", "lc", "irc", "sc", "nc", "hl", "con", " dc", "frac", "tf", "c", "FC", "mc", "fn", "pc", "soc", "uc", "cas", "isc", "full", "win", "cl", "fps", "fl", "ric", "func", "cf", "cs", "rc", "tc", "ff", "abc", "anc", " con", "pic", "act", "vc", "cond", "bc", "RFC", "raf", "iac", "coll"], "buff": ["cmd", "important", "uf", "alf", "fo", "zz", "ott", "buf", "grow", "obb", "buffer", "src", "rend", "bis", "ph", "note", "fr", " Buff", "obj", "Buff", "orm", "nt", "bj", "def", "kw", "ob", "h", "alg", "vt", "rb", "cho", "bb", " buffs", "pb", "f", "qq", "supp", "exp", "bf", "back", "form", "ctx", "gz", "bin", "xff", "fb", "urg", "emb", "batch", "ind", "proc", "tab", "Buffer", "printf", "att", "cb", "butt", "bind", "hz", "norm", "utf", "bo", "nd", "aux", "prof", "ref", "FF", "resp", "tf", "hold", "sb", "tmp", "mb", "comp", "fred", "off", "mem", "ld", "tm", "fl", "hd", "np", "font", "func", "pdf", "pred", "gold", "th", "b", "uff", "bed", "fw", "lf", "dat", "alph", "boost", "inf", "ff", "xy", "cell", "interest", "pp", "bg", "hex", "act", "beck", "cond", "txt", "td", "bound", "html", "ust", "tt"], "encoding": ["escapoder", " enccode", "escapoding", "encending", "continoding", "convusing", " encaching", "enryption", "coding", "encode", "enending", "coder", "decoder", "deccode", "convoding", "enoding", "encoded", "encoder", " encusing", "continusing", "escapoded", "encaching", "enoded", "enccode", "coded", "encusing", "convryption", "encryption", "continaching", "convaching", "decryption", "cending", " encoder", "escapending", "enoder", "continryption", " encryption", "decoding"]}}
{"id1": "14758866", "id2": "2525897", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 0, "substitutes": {"getResourceAsStream": ["getStreamasInput", "getResourceasSteam", "getResourceASForm", "getStreamAsStream", "getStreamAsSteam", "getResourceASStream", "getResourceInInput", "getResourceAsForm", "getResourceASInput", "getStreamasSteam", "getResourceAsSteam", "getResourceasStream", "getStreamasStream", "getResourceasInput", "getResourceInStream", "getResourceAsInput", "getStreamasForm", "getResourceasForm", "getResourceInSteam", "getStreamAsForm", "getResourceInForm", "getStreamAsInput", "getResourceASSteam"], "name": ["image", "initial", "domain", "search", "id", "location", "cache", "format", "description", "string", "path", "Name", "pkg", "error", "part", "resource", "size", "a", "NAME", "prefix", "key", "file", "run", "missing", "base", "address", "word", "client", "ame", "title", "source", "filename", "uri", "version", "type", "names", "remote", "password", "local", "n"], "inputStream": [" inputView", "inputView", "currentPort", "uploadSteam", "rawstream", "quickForm", "InputSteam", "quickSteam", "uploadView", " inputForm", "inputForm", "rawView", "currentFile", " inputSteam", " inputstream", "quickStream", "inputSteam", "inputstream", "InputForm", "quickChannel", "inputPort", "uploadstream", "InputChannel", " inputPort", "inputChannel", "currentStream", "rawSteam", " inputFile", "InputStream", "uploadStream", "rawStream", "InputFile", "InputPort", " inputChannel", "currentSteam", "inputFile"], "in": ["context", "ins", "din", "stream", "p", "data", "IN", "con", "ai", "io", "inf", "buffer", "m", "bin", "xml", "file", "mc", "edIn", "input", "r", "inner", "o", "info", "In", "n"], "out": ["cn", "ins", "output", "OUT", "b", "p", "dis", "ex", "cache", "screen", "list", "ln", "net", "io", "cfg", "print", "group", "buffer", "sys", "user", "m", "err", "conn", "outs", "c", "writer", "ou", "inv", "pretty", "to", "report", "all", "dir", "obj", "res", "tmp", "nt", "msg", "client", "gov", "inter", "up", "last", "conv", "inner", "os", "l", "o", "t", "log", "Out", "info", "w", "outer", "n"], "url": ["loc", "f", "rel", "el", "ssl", "server", "domain", "gl", "b", "https", "git", "location", "ls", "dl", "il", "hl", "char", "bel", "github", "path", "web", "ref", "addr", "str", "ll", "xml", "raw", "resource", "http", "rl", "re", "nl", "link", "browser", "ur", "impl", "sql", "URL", "file", "build", "base", "address", "this", "mount", "mail", "call", "get", "r", "uri", "Url", "l", "abs", "cl", "log", "remote", "html", "handle"], "remoteName": ["commonPath", "localname", "externalPath", "localKey", "remotePath", "commonname", "remoteKey", "externalName", "remotename", "quickPath", "commonKey", "quickname", "externalKey", "quickKey", " remotePath", "externalname", "quickName", " remotename", "commonName", " remoteKey", "localPath"], "localName": ["shortname", "fixedFilename", " localFile", "localname", "fullName", "remoteFilename", "fullNames", "Localname", "fullValue", " localFilename", "LocalKey", "localKey", " localKey", "locImage", "singleName", "fixedNAME", "shortNAME", "LocalNames", "fullKey", "shortFilename", "localFilename", "localNode", " localNode", "remoteKey", "remoteNode", " localname", "locValue", "remoteFile", "LocalName", " localValue", "locName", "remoteNames", "localValue", "fullname", "fixedname", "singlename", "remoteType", "singleNAME", "localFile", "fixedName", " localType", "remoteValue", " localImage", "localImage", "singleFilename", "localNAME", "locFilename", "LocalValue", " localNames", "remoteImage", "localNames", "locType", "locNode", "localType", "shortName", "locFile"], "host": ["loc", "top", "bind", "server", "domain", "Host", "campus", "home", "localhost", "hook", "path", "target", "chain", "addr", "subject", "http", "www", "ca", "dir", "hop", "cert", "base", "address", "system", "height", "client", "h", "source", "uri", "ost", "ip", "root", "remote", "hd", "local", "handle"], "prot": ["top", "tp", "ssl", "server", "header", "ht", "https", "typ", "pattern", "format", "tel", "pat", "path", "net", "ref", "Prot", "eth", "pkg", "sche", "ret", "ping", "http", "iot", "col", "prototype", "prefix", "pool", "system", "client", "pro", "platform", "uri", "version", "type", "prop", "crypt", "ocol", "password", "at", "rot", "ios"], "port": ["length", "column", "pe", "server", "p", "position", "language", "message", "localhost", "print", "test", "duration", "pt", "pport", "timeout", "limit", "ping", "size", "priority", "trace", "post", "socket", "note", "page", "width", "report", "key", "ort", "file", "proxy", "pool", "Port", "PORT", "pid", "client", "pro", "number", "eport", "trust", "version", "ports", "padding", "password", "point", "project", "pi"], "cacheFile": [" cacheEntry", "mapDir", "cacheFiles", "localEntry", "CacheFolder", "apachefile", "mapStore", "proxyfile", " cacheDir", "tempFILE", "proxyFolder", "Cachefile", " cacheField", "acheFolder", "cacheFILE", " cacheUser", " cacheFiles", "localDir", "localFiles", " cacheFilename", " cacheStore", "localField", "achefile", "tempFile", "tempfile", "proxyFile", "mapFile", "localStore", "CacheFilename", "localUser", " cachefile", " cacheFolder", "CacheDir", "cacheFilename", "CacheEntry", " cacheInfo", "mapfile", "localfile", "cacheUser", "acheUser", "CacheStore", "acheDir", "tempFilename", "apacheFolder", "localFile", "cacheInfo", "acheField", "CacheFile", "apacheFile", "cacheDir", " cacheFILE", "cacheField", "cacheStore", "cachefile", "apacheInfo", "proxyInfo", "CacheFILE", "acheFile", "cacheEntry", "CacheFiles", "cacheFolder"], "urlConnection": ["URLComment", "channelConnection", " urlConnect", "urlTransaction", "browserConnector", "urlConn", "urlFile", "httpTransaction", "sslConnect", "dlConnection", "URLConnect", "methodConnection", " urlconnection", "httpConnect", "UrlConnect", "methodconnection", "httpFile", "URLConnection", "dlConn", "URLConn", "urlConnector", "urlComment", "channelComment", "UrlConnection", "urlconnection", "llconnection", "browserConn", "URLFile", "llConnector", "httpConn", "URLConnector", "methodConnect", "UrlResponse", "httpconnection", " urlTransaction", "llConnection", "browserConnection", "dlconnection", "channelConnect", "httpLink", "Urlconnection", "dlComment", "urlConnect", "sslconnection", "browserResponse", "httpConnection", "sslTransaction", "dlConnector", "dlConnect", "llConn", "browserConnect", "UrlLink", "channelConnector", " urlResponse", "sslConnection", "browserconnection", "urlLink", "methodLink", "urlResponse", "browserFile"], "httpURLConnection": ["httpHTTPConnect", "historyURLConnection", "httpREConnect", "httpSRConn", "httpURLEntry", "httpsURLConnect", "httpDOMEntry", " httpMLConnection", "webURLConnect", "httpALLconnection", "httpMLConn", "githubUrlconnection", "httpULInstance", "githubUrlConnect", "httpHTTPNetwork", "HttpHTTPInstance", "httpURLTransaction", "HttpHTTPEntry", "httpHTTPInstance", "HttpHTTPconnection", "httpUrlNetwork", "githubURLConnect", "historyILConnect", " httpMLconnection", "HttpHTTPConnect", "httpUrlConnection", "httpTLConnect", "httpURLConn", "historyURLconnection", " httpURLconnection", "httpULConnection", "githubURLConnection", "httpMLConnect", "httpsHTTPConnect", "httpTLConn", "HttpURLConnection", "webURLconnection", "httpHTTPConnection", "httpSRconnection", "httpHTTPConn", "httpUrlConnector", "httpILNetwork", " httpURLConn", "historyILNetwork", "httpREConn", "httpDBconnection", "httpULConnect", "HttpHTTPConnector", "githubURLconnection", "HttpURLEntry", "httpILConnect", "httpHTTPTransaction", "httpsURLConn", "httpTLConnector", "httpILconnection", "httpURLConnect", "httpsURLConnector", "httpHTTPConnector", "webUrlEntry", "httpHTTPEntry", "HttpURLConnector", "httpSSLEntry", "httpTLConnection", "httpUrlEntry", "githubURLTransaction", "httpDBConnect", "httpUrlTransaction", "httpDOMconnection", "httpREConnection", "httpALLConnect", "HttpURLconnection", "httpDBConnection", "httpSRConnection", "webURLEntry", "httpALLConn", "httpDOMConnect", "httpDBTransaction", "httpsHTTPConnection", "historyILconnection", "HttpURLConn", "httpULEntry", "httpURLNetwork", "httpSSLConnection", "httpHTTPconnection", "httpUrlconnection", "historyURLNetwork", " httpURLConnect", "httpPORTConnect", "httpsURLConnection", "httpUrlConnect", "webUrlConnection", "httpDOMConnection", "httpALLConnection", "httpMLconnection", "httpREConnector", "httpsHTTPConn", "webUrlconnection", "httpURLInstance", "historyILConnection", "httpMLConnection", "httpSSLConnect", "httpPORTConnection", " httpMLConnect", "HttpURLInstance", " httpMLConn", "httpsHTTPConnector", "webURLConnection", "httpSRConnect", "githubUrlConnection", "HttpURLConnect", "httpILConnection", "httpURLConnector", "historyURLConnect", "HttpHTTPConn", "webUrlConnect", "httpPORTConnector", "httpSSLInstance", "httpURLconnection", "HttpHTTPConnection", "githubUrlTransaction"], "responseCode": ["requestCount", " responseClass", "resultSize", "complianceClass", "requestClass", "responseActionCode", "responseCount", "replyCode", "resultCount", "replyClass", "resultCode", "complianceActionCode", " responseActionCode", "replyCategory", "complianceCategory", "responseSize", "ResponseSize", "resultClass", "ResponseClass", "complianceCode", " responseCategory", "ResponseCount", "requestSize", "requestCode", "ResponseCode", "replyActionCode", "responseCategory", "responseClass"], "lastModified": ["LastModification", " lastTrify", "lastMODifier", "lastContentified", "lastmoded", "lastContentify", "lastTrification", "lastModmodified", "New", "lastModifier", " lastTrmodified", "LastModified", "lastTrify", "lastContentmodified", "lastContentifier", "lastContented", "LastModifier", "lastTrified", "lastModify", "lastContentification", "LastContentification", " lastModification", "_", "lastMODification", " lastTrification", " lastTrified", "lastmodified", "lastmodification", "lastModification", "LastContentifier", "lastTrmodified", " lastModmodified", "LastModify", "lastModed", "lastTred", "lastmodmodified", " lastModed", "LastContentified", " lastTred", "lastmodify", " lastModify", "lastMODified", "LastContentify", "lastMODify", "lastTrifier"]}}
{"id1": "9805906", "id2": "20426057", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"dump": ["update", "copy", "store", " dumps", "show", "println", " show", " dumped", "diff", "print", " debug", "debug", "load", "link", " println", "export", "init", "zip", "write", "display", " describe", "flush", "save", "stat", "download", "info", "send", "read"], "source": ["image", "scope", "copy", "store", "search", "shell", "style", "SOURCE", "script", "select", "service", "form", "ink", "sequence", "origin", "ource", "sys", "src", "from", "text", "view", "resource", "spec", "init", "sql", "file", "ie", "parent", "java", "check", "template", "input", "se", "config", "iter", "start", "Source", "sample", "site", "remote", "info", "local"], "target": ["host", "top", "copy", "output", "style", "match", "pattern", "tif", "gt", "goal", "dest", "delete", "compatible", "test", "term", "it", "table", "link", "replace", "that", "to", "bolt", "file", "proxy", "base", "arg", "current", "template", "null", "mac", "t", "next", "local", "Target", "project", "arget"], "is": ["isa", "isl", "sis", "ins", "xs", "are", "iss", "mos", "ri", "ris", "bits", "lis", "ls", "ists", "ir", "ib", "isi", "nis", "ii", "s", "si", "ai", "ys", "ms", "sys", "iso", "has", "in", "ar", "it", "ic", "bis", "tis", "ics", "ois", "ims", "init", "IS", "iris", "act", "Is", "isc", "i", "oss", "isf", "es", "abs", "ip", "ais", "its", "ist", "isin", "im", "ios"], "os": ["fs", "oos", "ot", "osi", "mos", "bs", "ows", "cs", "ros", "ls", "ose", "s", "io", "sys", "nos", "obs", "ns", "ss", "outs", "js", "or", "ants", "ds", "dos", "oses", "ts", "bos", "aos", "uts", "ox", "cos", "Os", "pos", "oS", "oss", "OS", "es", "ost", "oes", "o", "los", "css", "ols", "ps", "ios"], "done": ["disabled", "progress", "flag", " continued", "du", "started", "shown", "die", "gone", "given", "later", "ished", "ded", "complete", "checked", "did", "finished", "valid", "set", "made", "filled", "continue", "loaded", "led", "expected", "enabled", "de", "dirty", "des", "failed", " Done", "only", "Done", "found", "seen", "created", "needed", "di", "desc", "pleted", "d"]}}
{"id1": "14168494", "id2": "659316", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyByte", " cpFile", " CopyByte", "CopyByte", " cpfile", " CopyStream", "CopyFile", " copyStream", "CopyStream", "Copyfile", " CopyFile", " cpByte", " cpStream", " copyfile", " Copyfile"], "dest": ["loc", "del", "v", "Dest", "cont", "usr", "gt", "way", "target", "nw", "origin", "pub", "st", "etc", "dist", "to", "them", "orig", "trans", "www", "dir", "des", "img", "nom", "tmp", "nt", "master", "good", "out", "doc", "source", "rest", "np", "d", "w", "temp", "result"], "src": ["loc", "rel", "iv", "ins", "sl", "rc", "rs", "ls", "sc", "usr", "sys", "from", "st", "sq", "sec", "inst", "upload", "ser", "req", "init", "sub", "img", "sb", "file", "rx", "source", "input", "cur", "sel", "start", "desc", "sr", "Source", "cont"], "srcChannel": ["sqChannel", "bgChannel", "instCh", "bgChain", " srcChan", "instCan", " srcMessage", " srcChain", "destMessage", "srcPanel", "bgPanel", "srcCh", "sysChan", "sourceChannel", "destChain", " srcCommand", "sqChain", "sqCan", "instChain", "srcChain", " srcCh", "destChan", "rcMessage", " srcchannel", "sysChannel", "srcCommand", "instChan", "rcCommand", "syschannel", "instChannel", "srcChan", "srcchannel", "sourceChan", "sqPanel", "rcChannel", "sourceCh", "rcChan", "destChannel", "rcchannel", "sysCommand", "bgCan", "rcChain", "srcCan", "srcMessage", "instPanel"], "dstChannel": ["ddestCh", "destCommand", "dbrHandler", " dstHandler", "dotButton", "pdestChannel", "dstHandler", "pstButton", " dstChan", "dotCh", "dotChan", "ddestCommand", " dstCh", " dotChannel", "dstCommand", "dstButton", "ddestClient", " dotCh", " dotChan", "ddestHandler", "dndButton", "dndCh", "pstCommand", "dndChannel", "dstChan", "ddestChannel", "pdestButton", "dstCh", "ddestChan", "pstChannel", " dstButton", " dotButton", "dndClient", "pdestClient", "destButton", "pstClient", "dndCommand", "destChannel", "dstClient", "ddestButton", " dotHandler", "pdestCommand", "destClient", "dbrCh", "dbrChannel", "dndChan", "dotChannel", "dbrChan", "dotHandler"]}}
{"id1": "6963063", "id2": "16673769", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "label": 0, "substitutes": {"mas": ["mons", "oos", "masters", "rums", "pres", "mos", "makes", "ris", "sts", "bs", "ists", "phas", "dal", "las", "alis", "ales", "mad", "bas", "amas", "aus", "wal", "ms", "ints", "nets", "asis", "marks", "vers", "mares", "sels", "boxes", "mes", "ares", "tis", "ams", "ims", "as", "men", "lists", "ma", "aos", "mont", "vs", "phis", "mast", "stal", "mis", "lands", "ras", "jas", "ames", "cas", "ias", "als", "mus", "finals", "pse", "MAS", "mails", "eas", "asks", "pas", "mers", "rices", "Mas", "stro", "ums", "sa", "mon"], "sort": ["store", "search", "ord", "port", "scale", "alpha", "sup", "alt", "rol", "sum", "lower", "s", "index", "order", "test", "val", "weight", "Sort", "it", "rank", "status", "score", "orted", "label", "trans", "ort", "orting", "dir", "late", "share", "orts", "send", "tmp", "ORT", "tr", "pos", "lock", "ind", "cmp", "su", "rm", "l", "start", "desc", "default", "orter", "ist", "save", "use", "first", "lib", "min"], "j": ["k", "ia", "z", "adj", "dj", "v", "other", "job", "jj", "jp", "ge", "jc", "aj", "q", "m", "it", "js", "jump", "ja", "J", "ij", "fr", "jl", "obj", "x", "kj", "ji", "ie", "at", "ind", "lock", "jas", "bj", "nr", "pr", "br", "is", "uj", "g", "json", "jit", "jo", "im", "oj", "n"], "i": ["cli", "mi", "id", "ri", "port", "status", "gu", "g", "di", "asi", "gi", "ci", "ni", "\u0438", "info", "I", "pi", "ia", "ix", "php", "iti", "io", "chain", "m", "iso", "ki", "multi", "it", "ic", "ret", "li", "xi", "init", "ori", "ji", "ind", "is", "fi", "fire", "qi", "si", "me", "iu", "in", "ie", "zi", "iii", "iri", "iy", "uri", "ip", "ish", "ami", "wi", "iq", "ir", "ini", "ii", "ai", "bi", "origin", "yi", "sim", "ei", "ij", "ti", "hi", "phi", "ui", "iter", "im", "oi"]}}
{"id1": "15896098", "id2": "620855", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checsam", "getSHA256Chechecksum", "getSHA256Checksume", "getSHA256Checkums", "getSHA256Checsum", "getSHA256Checkum", "getSHA256Checksums", "getSHA256Chechecksume", "getSHA256Checkume", "getSHA256Checkcksume", "getSHA256Checkchecksume", "getSHA256Checkchecksum", "getSHA256Checkcksam", "getSHA256Checkcksum", "getSHA256Checksam", "getSHA256Checsume", "getSHA256Chechecksums", "getSHA256Chechecksam", "getSHA256Checkcksums", "getSHA256Checkchecksam", "getSHA256Checsums", "getSHA256Checkam", "getSHA256Checkchecksums"], "source": ["image", "context", "value", "output", "seed", "style", "SOURCE", "data", "message", "format", "secret", "string", "content", "path", "s", "target", "sequence", "buffer", "ource", "src", "subject", "from", "raw", "in", "text", "status", "reason", "file", "body", "base", "name", "this", "out", "template", "input", "filename", "url", "Source", "sample"], "checksum": ["checksums", "cksums", "checkumb", "cssum", "checksim", "checkssum", "cksim", "checkums", "checkum", "cksume", " checksums", " checkssum", "checksume", " checksim", "checkim", " checksumb", "cksumb", "ckssum", "csum", "checksumb", "checkume", "csim", "cksum", " checksume", "csume"], "md": ["pdf", "cmd", "dd", "dr", "mt", " MD", "der", "mo", "red", "Cmd", "mg", "dh", "mk", "sd", "od", "ms", "m", "mm", "pm", "pd", "mod", "down", "ad", "mc", "mn", " Md", "df", "mp", "nt", "dm", "mand", "det", "ind", "mb", "def", "grad", "ld", "wd", "di", "cd", "bd", "hd", "d", "MD", "sm"], "byteData": ["byteList", " byteParts", "byteDat", "byteCount", "bytesArray", "bytesBytes", "phraseParts", "sliceDat", "ioDATA", "wordData", "reverseDat", "byteBytes", " byteDATA", "phraseDATA", "reverseDATA", "ioList", "bytedata", "channelParts", "sliceList", "routeCount", " byteArray", "ioDat", "sliceDATA", "channelData", " byteList", "ByteParts", "wordBytes", " bytedata", "reverseData", " byteBytes", "wordArray", "routeDATA", " byteCount", "byteDATA", "bledata", "phraseData", "byteArray", "phraseBytes", "routeDat", "bleRel", "ByteBytes", " byteDat", "reverseCount", "sliceData", " byteRel", "bytesData", "routeData", "ioData", "channelRel", "ByteDATA", "wordDATA", "byteRel", "bytesDATA", "bleData", "byteParts", "bleParts", "ByteData", "channeldata"], "sb": ["ssl", "sh", "b", "bs", "bf", "shell", "SB", "SF", "ib", "si", "obb", "nb", "sw", "sq", "sf", "bps", "sa", "bis", "sv", "bh", "bg", "xb", "wb", "sam", "eb", "sp", "bt", "erb", "lp", "gb", "bj", "mb", "ob", "bash", "lb", "kb", "db", "zb", "bsp", "ub", "rb", "sg", "bb", "sbm", "cb", "pb", "sm"], "i": ["cli", "life", "mi", "u", "id", "ri", "ms", "any", "q", "err", "set", "ime", "ims", "gu", "g", "di", "gi", "ci", "ski", "\u0438", "point", "info", "I", "pi", "ix", "io", "chain", "print", "my", "m", "ki", "multi", "ic", "it", "li", "xi", "to", "init", "ji", "ind", "loop", "l", "json", "o", "remote", "qi", "ity", "er", "si", "me", "iu", "major", "j", "ie", "iy", "uri", "ip", "history", "iq", "ini", "list", "ii", "ai", "bi", "sim", "ei", "ti", "ij", "hi", "phi", "y", "this", "ion", "client", "ui", "series", "im", "oi"], "hexString": [" HexString", "fullString", "exStore", "hashstring", "exArray", "shortResource", "hexBuffer", "htmlString", "exString", " hexArray", " hexResource", "htmlBuffer", "htmlstring", "htmlArray", "hexArray", "shortArray", "hashBuffer", "exBuffer", "fullStore", "shortString", " hexstring", " HexBuffer", " HexResource", "hashString", "hexResource", "shortstring", " hexBuffer", "hexstring", "shortBuffer", " hexStore", " Hexstring", "hashArray", "hexStore", "exstring", "fullstring", "fullBuffer"], "hex": ["mix", "sh", "zh", "exp", "com", "ex", "solid", "alph", "rh", "hl", " Hex", "php", "form", "rendered", "term", "raw", "he", "ph", "alias", "tex", "des", "dump", "rex", "x", "none", "flash", "def", "comp", "pex", "h", "full", " ex", "cat", "lit", "json", "prop", "oct", "tx", "sex", " sex", "ext", "html", "hello", "temp", "cont"]}}
{"id1": "23611770", "id2": "17792212", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"handle": [" reload", " repair", " accept", " migrate", " reopen", " resume", " handler", " cleanup", " paste", " modify", " restore", " rewrite", " rename", " roll", " transform", " resize", " rotation", " operate", " encode", " restart", " recover", " terminate", " replay", " reset", " release", " schedule", " move", "rot"], "srcChannel": ["srcChan", "srcConnection", "sourceConnection", "sourceChan", "sourceButton", " srcChan", "destButton", " srcConnection", "destConnection", "srcButton", "destChan", "sourceChannel", " srcButton"], "destChannel": [" destChan", "destConnection", "srcButton", "descChannel", "sourceChannel", "targetEntry", "sourceConnection", "targetChannel", "targetChan", "destChan", "targetButton", "resultChan", "resultChannel", "targetConnection", "srcChan", "srcConnection", "sourceChan", "sourceButton", "destButton", " destMember", "resultEntry", "descMember", "destEntry", "srcEntry", " destConnection", "DestConnection", "DestMember", "DestChan", "descChan", "descConnection", "destMember", "DestChannel", "resultConnection"], "destOutFile": ["destNewFile", "startFreeFile", "altOutFile", "destOutAll", "declOutField", "altZoneDir", "destZoneFile", "srcOutFile", "destOutputRow", "createdOUTFILE", "altOutAll", "destOUTL", "srcExDir", "destOutRow", "createdOUTFile", "destIntfile", "declOutL", "destOutFILE", "destExFILE", "srcOutfile", "destOutputfile", "declOUTField", "destInDir", "destOUTDownload", "altZonePoint", "srcOutDir", "destFreeile", "destExPath", "destOutile", "destOUTField", "destInsAll", " destIntfile", "declOutFile", "destZonePoint", "altZoneAll", "destInRow", "destExDir", " destOutputRow", "createdOutPath", "destNewDownload", "destOutPath", "createdOutDownload", "destExFilename", "destOUTFile", "destOutFilename", "destoutile", "destInFile", "altOutDir", " destIntKey", "startOutile", "destIntPath", "destOutKey", "destExField", "destoutFILE", "destOUTFILE", "destInsPoint", "destZoneAll", "destOUTRow", "destIntFile", "startOutFILE", "srcExFile", "destoutKey", "destExDownload", "altZoneFile", " destOutputFile", " destIntPath", "destNoile", "createdOUTPath", "destOutDownload", "declOUTFile", "destInsDir", "destoutFilename", "destOutputFile", "createdOutFILE", "destOutDir", "destoutPath", "destFreeFile", "destNoFile", "destInfile", "destOUTfile", "startFreeFILE", "destExFile", "destoutFile", "altOutPoint", "destOUTPath", " destOutPath", "destExL", "srcExFilename", "destInFilename", "destoutDir", "destNewFILE", "destoutfile", "destOutL", "destOutfile", " destOutRow", "destFreeFILE", "destOutPoint", "declOUTL", "startFreeile", "srcOutFilename", " destOutKey", "destNoFILE", "destZoneDir", "createdOUTDownload", "destExfile", " destIntFile", " destOutfile", "srcExfile", "destOutField", "destInsFile", " destOutputfile", "startOutFile", "destNewPath", "createdOutFile", "destIntKey"], "destOutFileCompressed": ["destOutFilecompression", "destOutFileZipressed", "destOutFileompress", "destOutFileExpress", "destOutFileComblied", "destOutFileCombression", "destOutFileCombured", "destOutFilenameComponentured", "destOutFileExpression", "destOutFileCompress", "destOutFileComponentrypted", "destOutFileComprypted", "destOutFileCondress", "destOutFileompended", "destOutFileHighlied", "destOutFieldCompression", "destOutFilenameCompiled", "destOutfileCompress", "destOutfilecompress", "destOutFileComponentress", "destOutFileZiplied", "destOutFileCondured", "destOutFileHighended", "destOutFileComponentressed", "destOutFileComponentression", "destOutFileComponentosed", "destOutfileCompression", "destOutFileZipured", "destOutFileCombiled", "destOutFieldZipressed", "destOutFieldZiprypted", "destOutFileCompended", "destOutFilecompress", "destOutFileCompiled", "destOutFileComposed", "destOutFileComponentured", "destOutFieldCompressed", "destOutFileHighress", "destOutFieldCompress", "destOutFileZipiled", "destOutFileCompression", "destOutFilecompressed", "destOutFilecompured", "destOutFieldZipression", "destOutFilenameComponentressed", "destOutFileComponentlied", "destOutFileCompured", "destOutFilenameCompured", "destOutFileExpended", "destOutFileCondosed", "destOutFieldZipress", "destOutFileExplied", "destOutFileZipress", "destOutfilecompured", "destOutFilenameComponentlied", "destOutFileCombressed", "destOutFileCombosed", "destOutFileompressed", "destOutFileComplied", "destOutFileHighressed", "destOutFileomplied", "destOutFileCondression", "destOutfileCompressed", "destOutFilenameCompressed", "destOutFieldComprypted", "destOutFilenameComponentiled", "destOutfileCompured", "destOutFileExpressed", "destOutFileExpured", "destOutfilecompression", "destOutFilecomprypted", "destOutFilenameComplied", "destOutFileZiprypted", "destOutfilecompressed", "destOutFileZipression", "destOutFileCondressed", "destOutFileComponentiled"], "out": ["cn", "ot", "output", "OUT", "co", "p", "serv", "ex", "cache", "con", "net", "io", "n", "buffer", "bin", "conn", "outs", "it", "c", "timeout", "writer", "ou", "to", "all", "obj", "gc", "res", "file", "auto", "aos", "batch", "nt", "cos", "pool", "ch", "result", "pos", "this", "opt", "client", "write", "full", "mem", "oss", "r", "one", "conv", "db", "g", "l", "os", "null", "o", "log", "end", "t", "Out", "at", "outer", "can"], "in": ["ins", "din", "inside", "en", "ri", "ini", "IN", "sin", "inn", "con", "ai", "io", "inf", "gin", "cin", "mm", "on", "bin", "from", "ar", "it", "ic", "init", "nin", "file", "al", "body", "reader", "ind", "is", "inc", "up", "rin", "input", "source", "iter", "inner", "oin", "r", "null", "conf", "o", "isin", "info", "read", "In"], "buf": ["arr", "cmd", "bl", "var", "b", "cf", "vec", "uf", "cache", "alph", "data", "box", "queue", "buffer", "obs", "str", "aka", "block", "bin", "err", "pkg", "ret", "text", "map", "bar", "cv", "cap", "img", "bag", "seq", "batch", "code", "tmp", "msg", "tr", "cp", "br", "txt", "mem", "doc", "cur", "bc", "cat", "db", "conv", "iter", "row", "Buffer", "rb", "prop", "tx", "buff", "bytes", "log", "pause", "cb", "result"], "len": ["length", "z", "el", "fun", "en", "fin", "vec", "ls", "lf", "count", "il", "lan", "e", "ln", "repl", "le", "val", "ll", "err", "part", "li", "nl", "Len", "cap", "all", "ler", "seq", "mun", "nt", "pos", "cmp", "h", "elt", "pl", "ld", "iter", "l", "lon", "coll", "t", "end", "bytes", "lib", "n"]}}
{"id1": "10451698", "id2": "8135072", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["core", "move", "co", "perm", "archive", "transfer", "sync", "delete", "crop", "Cop", "continue", "clip", "opy", "map", "remove", "link", "paste", "export", "Copy", "gc", "file", "share", "proxy", "cp", "zip", "slice", "write", "split", "clone", "create", "cat", "pixel", "download", "cop"], "source": ["image", "original", "scope", "store", "shell", "style", "SOURCE", "class", "cache", "instance", "service", "sin", "index", "secure", "empty", "target", "origin", "ource", "src", "subject", "space", "from", "entry", "in", "raw", "resource", "status", "size", "table", "http", "spec", "note", "sit", "init", "sql", "query", "file", "ie", "body", "base", "directory", "parent", "none", "sp", "name", "force", "unit", "current", "template", "get", "se", "config", "create", "details", "null", "inner", "start", "Source", "ce", "site", "remote", "use", "local"], "destinationDirectory": ["destinateDirectory", "destinatedirectory", "destmentFolder", "identinationLocation", "destinationDir", "destinationdirectory", "destinationsLocation", "identinatorInternal", "destinateFolder", "destmentDirectory", " destationFolder", "destinationInternal", " destationApplication", "destinationsDirectory", "targetinationsFolder", "targetinationsDir", "destinationLocation", "identinatorDirectory", "destarationDirectory", "destinatorDirectory", "destinationsInternal", "destinationApplication", "destinationsFolder", "destationFolder", "identinationInternal", "destineFolder", "destinationsDir", "destinatorLocation", "identinatorLocation", "destarationInternal", "destationApplication", "destineApplication", "targetinationsdirectory", " destinationFolder", "destinateApplication", " destinationdirectory", "destineDirectory", "destationDirectory", "targetinationFolder", "targetinationsDirectory", "identinationDirectory", " destationDirectory", " destationdirectory", "destarationLocation", "destmentDir", "targetinationDirectory", "destinationFolder", " destinationApplication", "destmentdirectory", "destinedirectory", "targetinationdirectory", "targetinationDir", "destinatorInternal", "destinationsdirectory", "destationdirectory"], "newDir": [" newRel", "Newdir", "newsFile", "NewFile", " newFolder", "NewFolder", "newFolder", "nextDir", "newsDir", "newdir", "newRel", "nextdir", " newDirectory", "NewDir", "newsFolder", "NewDirectory", "NewRel", "newsdir", "nextFile", "nextRel", " newdir", "newsDirectory", "newDirectory"], "children": ["pres", "when", "kids", "ls", "stories", "cache", "cont", "classes", "his", "each", "may", "items", "Children", "times", "ml", "files", "packages", "many", "apps", "relations", "links", "follow", "images", "users", "all", "related", "sub", "reports", "gc", "child", "nil", "objects", "members", "services", "jobs", "modules", "keys", "ren", "resources", "details", "bc", "pages", "uploads", "desc", "parents", "ports", "unknown", "projects", "lines", "its", "ids", "names", "groups", "blocks", "these"], "i": ["you", "mi", "u", "iq", "id", "ri", "pi", "ix", "ex", "ini", "us", "ii", "si", "index", "ai", "um", "chain", "bi", "ms", "io", "q", "my", "m", "sim", "me", "in", "ki", "iu", "multi", "ic", "it", "li", "ti", "span", "j", "ij", "xi", "ims", "init", "key", "x", "hi", "ji", "ie", "uu", "base", "phi", "y", "batch", "is", "client", "ui", "gu", "iter", "g", "di", "gi", "json", "ci", "ip", "ski", "t", "remote", "qi", "point", "im", "oi", "info", "I"], "newFile": ["ewfile", "NEWfile", "createDir", "newsFile", "NEWFile", "NewFile", "newTh", "NEWTh", " newfile", "ewLe", "newsGlobal", "Newfile", "nextDir", "newsDir", "ewDir", "NewDir", "goodFile", " newSourceFile", "newsTh", "newLe", "newfile", "ewFile", "createfile", " newGlobal", "newGlobal", "NewLe", "nextfile", "newsfile", "nextFile", "goodSourceFile", "newSourceFile", "NewGlobal", "nextLe", "goodfile", "createFile", "createSourceFile", "goodDir", "NewTh", "NEWDir"], "output": ["update", "object", "stream", "online", "position", "monitor", "cut", "message", "connect", "format", "admin", "blue", "web", "net", "io", "print", "buffer", "block", "network", "text", "writer", "Output", "response", "four", "enabled", "pretty", "ilo", "export", "document", "connection", "file", "console", "auto", "result", "batch", "body", "parent", "put", "current", "open", "out", "write", "display", "client", "internal", "config", "success", "next", "exit", "outer"], "input": ["image", "initial", "operator", "exec", "rc", "Input", "back", "io", "inf", "ink", "form", "buffer", "in", "from", "raw", "it", "ic", "error", "insert", "active", "add", "upload", "storage", "init", "child", "op", "ahead", "reader", "before", "current", "open", "inc", "out", "get", "feed", "internal", "inner", "iter", "unsigned", "start", "ip", "info", "local"], "buff": ["qq", "cmd", "bl", "b", "bs", "uff", "bf", "bed", "old", "uf", "nd", "bo", "data", "buf", "box", "ff", "buffer", "xx", "nb", "bin", "text", "hold", "xff", "fb", "black", "bg", "img", "sb", "seq", "eb", "Buff", "batch", "msg", "ch", "cond", "ind", "mb", "gb", "comp", "txt", "mem", "cat", "tab", "bytes", "printf", "bb", " buf", "bound", "cb", "tt", "pb"], "read": ["length", "readable", " write", "bind", "need", " count", "en", "stream", "old", "count", "select", "each", "like", "ink", "Read", "print", "q", "give", "str", "hello", "buffer", "test", "set", "raw", "push", "text", "hold", "in", "reads", "size", "load", "tell", "add", "reading", "ready", "skip", "READ", "query", "run", "ind", "seek", "before", " Read", "height", "check", "write", "mem", "get", "d", "feed", "find", "iter", "config", "len", "start", "t", "end", "wait", "and", "index", "send", "handle"]}}
{"id1": "1156851", "id2": "6403868", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 0, "substitutes": {"runWeb": ["runHttp", " runHttp", "processSite", "initSite", "processHttp", "initHttp", "initWeb", "processWeb", "runSite", " runSite", " runweb", "runweb", "processweb", "initweb"], "beginURL": ["endURL", "beginHTML", "useUrl", " beginALL", "createUrl", "wardUR", "endUrl", "useHTML", "BeginALL", "startURI", "BeginUR", "beginURI", "createURL", "useURI", "BeginUrl", " beginLocation", "useURL", " beginURI", "beginUrl", "createURI", "wardURL", "startURL", "createHTML", "startLocation", "BeginURI", "wardUrl", "beginLocation", "beginALL", "endUR", "startALL", "BeginURL", "BeginLocation", "beginUR", "BeginHTML"], "contextRoot": ["Contextroot", "resourcePath", "ctxParent", "ContextRoot", "ContextParent", "resourceRoot", "resourceURL", " contextBase", "resourceData", "resourceBase", " contextBox", " contextHome", "contextData", "ContextHome", "contextParent", "contextPath", "ContextBox", "ctxBase", " contextroot", "ctxHome", "contextHome", "ContextBase", "ctxBox", "contextroot", "contextURL", "ContextPath", " contextURL", "ContextURL", "contextBox", "ctxRoot", " contextPath", " contextData", "resourceroot", "ContextData", "ctxPath", "contextBase", " contextParent"], "pageURI": ["pageUR", "puri", "PagePath", "requestFile", "Pageuri", "pageName", " pageName", "pagePath", "requestUR", "pName", "PageURI", "requestPath", "pageURL", "requestURI", "PageFile", " pageUR", "pageuri", "pURI", "PageURL", " pageURL", " pageuri", "pageFile", "PageName", "pURL", " pageFile", "PageUR", " pagePath"], "vtURLs": ["VTURLS", "vtHTTPS", "vtSRls", "vtURers", "VTURLses", "vtTLList", "vtHTTPs", "VTURers", "VTURLls", "vtURLList", "voltTLList", "vtURLS", "vtURS", "vtURa", "VTURls", "vtURses", "voltURLls", "vtURLers", "vtSRList", "vturls", "vtOLls", "vtHTTPa", "vtHTTPls", "vtURls", "vturlS", "vturlls", "voltURLs", "VTURLs", "vturla", "VTURS", "vtURs", "vtTLs", "vtURList", "voltURLList", "vtULS", "vtURLses", "voltTLs", "vtGETs", "vtGETers", "vtSRs", "vtULs", "vtOLers", "VTURa", "vtURLa", "vtGETses", "VTURLers", "VTURLa", "vtGETls", "vtURLls", "vtOLs", "vtOLses", "VTURses", "VTURs", "vtTLls", "voltTLls", "vtULls"], "vtRobots": ["vtHuborts", "vsRobots", "vtHubugs", "virtReplots", "vetRobots", "vtPlugots", "vetRubows", "vsHubotos", "vetRobows", "vtUbugs", "vtPlugugs", "virtRoborts", "vtCapotos", "virtRobots", "vtUbotos", "vtReplops", "vsRobotos", "vsRobbs", "vtRobugs", "vtRoboles", "vtCapot", "vtReplots", "vtTabots", "virtReploles", "vtHubbs", "vtHubotos", "vtLegot", "vtLegotos", "vtCapots", "vtRobops", "vtHubops", "vtTabops", "vetRobot", "vtHubots", "vtTaborts", "vtPlugbs", "virtRobops", "vetRubotos", "vtPlugotos", "vtCapows", "vetRobotos", "vtReploles", "vetRubot", "vtUbbs", "vtTaboles", "vtRobotos", "vsHubots", "vtRobot", "vsRobugs", "vtRubows", "vetRubots", "vtUbots", "virtReplops", "vtHuboles", "virtRoboles", "vtRobbs", "vtRobows", "vtReplorts", "vtRubots", "virtReplorts", "vsHubbs", "vtRoborts", "vtRubot", "vsHubugs", "vtLegots", "vtRubotos", "vtLegows"], "indexer": ["IndexReader", "documente", "Indexe", "Indexator", "indexe", "indexor", " indexener", " indexe", "documenter", "indexator", "documentReader", "indexner", "Indexener", "Indexner", "documentener", "Indexor", "mixator", "mixner", "mixor", "searchner", "searchor", " indexReader", "Indexer", "searcher", "indexener", "mixer", "indexReader", "searchator"], "indexDoc": [" indexDocument", "indexDocument", " IndexPage", " Indexdoc", "IndexDoc", " IndexDocument", "Indexdoc", " indexdoc", "indexdoc", " IndexDoc", "indexPage", "IndexDocument", "IndexPage", " indexPage"], "sxURL": ["SxeURI", "spxUR", "sxeURL", "sxyUR", "sxUrl", " sxeUR", "sxIL", "sixBL", "sfxBL", "desxUrl", " sfxELF", "sfxURI", "sxeBL", "sxeIL", " sxEL", "sxxURL", " sXUrl", "sXEL", " sxeIL", "sxELF", "desXUR", "sxUSER", "SxUrl", "sfxID", "SxeBL", "sXALL", " sXUR", " sxUrl", "sfxEL", "desxALL", "sxfEL", "sxfALL", "sxyURL", "sixID", "desxURL", " sxUR", "SxeURL", "SxID", "sfxPORT", "spxUrl", "sxfURI", "sxeID", "desxUR", "SxeID", "SxURI", "sfxUR", "sXELF", " sxIL", "SxUR", "sxxIL", "sfxUSER", "sxALL", " sfxURL", " sXURL", "sxsURL", "sixURL", "sfxIL", "sXUR", "sxBL", "SXUrl", "sXURI", "desXUrl", " sxeUrl", "sxeURI", " sfxUR", "sxfUrl", "SxBL", "sxPORT", "sxsUSER", "sxePORT", "desXALL", "sxUR", "sxyUrl", "sfxURL", "desXURL", "sxsUR", "spxURL", "sXURL", "sxxALL", "sxxUR", "sxfUR", " sxELF", " sXEL", "sfxUrl", "sxxUrl", "SXURL", " sfxUrl", " sxeURL", "spxELF", "sxID", "sxsUrl", "SXURI", "sfxELF", "sxfURL", "sxEL", "sixURI", "SxURL", "SXUR", "sxeUrl", "sXUSER", "sXUrl", "sxURI", "sxyPORT", "sxeUR"], "sxRobotURL": ["sxRoboteURL", "sxRobotSTR", "sxRobOTURL", "sxRoboSTR", "sxRoboteSTR", "sxRoboteUR", "sxLegoURL", "sxRoboUrl", "sxroboteURL", "sxLegotUR", "sxRobosSTR", "sxLegoteSTR", "sxrobotURI", "sxRobosUrl", "sxRobottSP", "sxRoboteUrl", "sxRoboySP", "sxroboteUR", "sxRobotUrl", "sxRoboURL", "sxRobotePATH", "sxLegoteUR", "sxrobotUrl", "sxroboteUrl", "sxRoboURI", "sxRobOTUR", "sxroboteURI", "sxNobosURL", "sxRoboteURI", "sxRobotSP", "sxRobosUR", "sxRoboyURL", "sxNobotUrl", "sxRobrotUrl", "sxLegotURL", "sxLegoteUrl", "sxrobotURL", "sxRobottUrl", "sxRoboPATH", "sxLegoPATH", "sxRobOTUrl", "sxRobotURI", "sxRobrotURL", "sxNobosHTTP", "sxRobosHTTP", "sxNobotSP", "sxRobottHTTP", "sxRobosURL", "sxRobrotUR", "sxRoboUR", "sxRobotHTTP", "sxrobotUR", "sxLegotUrl", "sxRobotPATH", "sxLegoUrl", "sxLegotPATH", "sxNobotURL", "sxRobrotPATH", "sxRobotUR", "sxLegoteURL", "sxRobosSP", "sxRobottURL", "sxRoboyHTTP", "sxLegoUR", "sxLegotSTR", "sxRobOTURI", "sxRoboyUrl", "sxNobosUrl", "sxNobotHTTP", "sxNobosSP"], "pd": ["dd", "PF", "p", "bf", "ht", "dt", " md", "dl", "dh", " dd", "vd", "Parser", "pm", "parser", "pps", "dp", "pp", " cd", "ds", " prod", "px", "pg", "pard", "wp", "po", "df", "cp", "rpm", "lp", "PD", " PD", "pl", "td", "cd", "bd", "fd", "hd", "d", "tp", "pb", "xd"], "cb": ["cn", "callback", "ck", "abb", "cf", "bf", "tc", "cc", "bp", "CB", " CB", "obb", "cgi", "nb", "fb", "Callback", "dc", "cv", "wb", "xb", "sb", "eb", "bt", "cp", "erb", "gb", "cr", "lb", "ctrl", "bc", "cor", "kb", "proc", "cd", "rb", "bb", "pb"], "bIndexPage": ["bSearchDocument", "bLabelPath", "bFoundLine", "bConnectPage", "bFoundFile", "blFoundLine", "bSearchpage", "bCheckPages", "blFoundFile", "bSearchFile", "bLinkPage", "bindexLine", "blIndexPage", "boolCheckPage", "bAddpage", "bIndexFile", "bConnectFile", "bindexFile", " bLinkPath", "bCheckPage", " bIndexpage", "bLinkPages", "boolIndexPages", "bFindPage", "boolIndexpage", "boolCheckpage", " bIndexDocument", "bFindpage", "bConnectpage", "bProcessLine", "bAddSite", "blIndexLine", "bIndexPath", "bFoundPage", "bLinkFile", " bIndexUrl", "bProcessPage", "bAddPages", " bLinkPage", "bIndexLine", "bLinkPath", "bLinkUrl", "bindexPage", "bSearchPage", "blIndexFile", "bFindUrl", " bIndexPath", "bFoundpage", "bIndexPages", "bCheckpage", "bAddDocument", "boolIndexSite", "bCheckSite", "boolCheckSite", " bLinkUrl", "bIndexSite", " bLinkDocument", "bIndexpage", " bLinkFile", "bFindPath", "blFoundPage", " bIndexFile", "bIndexDocument", "bLinkpage", "bProcessFile", "bLabelPage", "boolIndexPage", "bIndexUrl", "bLinkDocument", "bLinkSite", "bAddFile", "bAddPage", " bLinkpage", "bLabelpage", "boolCheckPages", "bLabelUrl"], "urlConn": [" urlconn", "urlCon", "bbConn", "nlWin", "databaseCon", " urlConnect", "urlCt", "webConnect", "urlCons", "UrlConn", " urlCons", "urlCh", " urlCo", "UrlCo", "httpconn", "bbConnect", "databaseCt", "httpCh", "httpConnect", "UrlConnect", "databaseConn", "nlConn", "urlWin", "urlconn", "URLConn", "urlConnector", "bbconn", "httpConn", "fileCon", "httpWin", "urlCo", " urlCh", "nlConnector", "UrlCons", "nlConnect", "URLCt", "webCo", "fileConn", "webCons", "urlConnect", "webConn", "URLconn", "fileconn", "databaseconn", "bbCh", "URLCon", " urlWin", "fileCt", "httpConnector", " urlConnector"], "modDate": ["modifiedGe", "modTime", "modifiedDay", "modifiedTime", "mtDay", " modGe", " modDay", "mtTime", "mtDate", "modGe", "modDay", " modTime", "modifiedDate", "mtGe"], "bfReader": ["fbReader", "fbWriter", "btReader", "fbParser", "bbParser", "bbWriter", "btParser", "bfWriter", "bbRead", "bfParser", "btRead", "fbRead", "bbReader", "bfRead", "btWriter"]}}
{"id1": "17996547", "id2": "14502142", "code1": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", "copyDir", " copyFiles", "deleteDir", "deletefile", "CopyFiles", "CopyFile", "copyFiles", "deleteFile", "Copyfile", " copyDir", "deleteFiles", " copyfile", "CopyDir"], "fileToCopy": ["filetoCopy", "fileToApply", "FILEToCop", "fileTomDelete", "FILETOApply", "FILEToSave", "file2Cop", "fileFromRemove", "fileToWrite", "fileToSave", "fileToCop", " filetoCopy", "fileToDelete", "file2Save", "fileTOCop", "fileTomWrite", "fileTomRemove", "file2Apply", "fileTOSave", "fileFromDelete", " fileToDelete", "FILETOCop", "fileTomCopy", "FILETOCopy", "filetoDelete", " fileToRemove", " filetoDelete", "FILEToApply", "file2Copy", "fileFromCopy", "fileTOApply", " filetoWrite", "FILETOSave", "FILEToCopy", "filetoWrite", "fileTOCopy", " filetoRemove", "fileFromWrite", " fileToWrite", "filetoRemove", "fileToRemove"], "copiedFile": ["coponeFILE", "copifiedfile", "copIEDFile", "calledyingFILE", "copicedFilename", "coriedFilename", "partiedLog", " copcedFile", "partiedFile", "copriedPath", "copiedLog", "copanedFile", "copyingFILE", "calledyingFile", "coricedFilename", "copIEDLog", "coricedFile", " copcedFilename", "partriedFilename", "copriedFolder", " copriedDirectory", "coponeFile", "copyingFile", "callediedPlace", "copiatedFolder", "copanedDir", "partriedLog", "copifiedDir", "coponeFilename", "coriedfile", "copiatedDirectory", "copriedDirectory", "calledyingDir", "copiedFilename", " copcedfile", "copiedPath", " copiedPath", "copifiedFilename", "copifiedPlace", "callediedFILE", " copriedFolder", "coricedFILE", "copyingLog", "calledyingPlace", "callediedDir", "copriedFilename", "copicedFile", "copiatedFile", "copriedFile", "copifiedFILE", "copriedLog", "callediedFile", "copriedfile", "copanedFILE", " copiedDirectory", " copiedFolder", "coricedfile", "copyingPlace", "copcedfile", "copiedDirectory", "copicedFILE", " copriedPath", "coriedFile", "copyingFilename", "copicedfile", "copyingDir", "coponefile", "copiedfile", "copifiedFile", "partiedFilename", "copcedFile", "copiatedPath", "copyingFolder", " copiedfile", " copiedFilename", "copiedDir", "copriedFILE", "copIEDFilename", "copyingDirectory", "copcedFilename", "copiedFILE", " copriedFile", "copiedPlace", "copanedPlace", "copiedFolder", "coriedFILE", "partriedFile", "copyingPath"], "in": ["f", "ins", "din", "inside", "irm", "en", "ini", "IN", "inn", "con", "ai", "io", "inf", "form", "cin", "gin", "on", "bin", "from", "ar", "it", "vin", "ains", "re", "inv", "init", "file", "al", "ma", "ain", "per", "ind", "is", "inc", "out", "up", "rin", "doc", "i", "input", "source", "r", "inner", "iter", "conf", "get", "oin", "isin", "im", " din", "read", "In"], "outWriter": ["outputWriting", "outwriter", "OUTWriter", "backStreamer", "outputStream", "outHandler", "backReader", "outputWrit", "OutWriting", "backWriter", "outStreamer", "backwriter", "outputHandler", " outWrite", "OutWriter", " outStreamer", " outwriter", "outputWrite", "innerStream", "outputWriter", "OutReader", "innerHandler", "outputReader", "outReader", "innerWriter", "outWriting", "OUTwriter", "outWrite", " outHandler", " outReader", "outWrit", " outWriting", "outputwriter", "OUTReader", " outStream", "outStream", "innerWrite", "OutWrit", "OUTWriting", "outputStreamer", " outWrit"], "c": ["f", "k", "u", "cs", "v", "rc", "cf", "cut", "count", "cache", "ec", "sc", "nc", "char", "unc", "cc", "e", "chain", "q", "m", "ac", "C", "col", "dc", "cap", "mc", "gc", "code", "cos", "pc", "ch", "cp", "uc", "cmp", "out", "i", "cr", "character", "bc", "r", "l", "cd", "cl", "ct", "t", "ce", "cm", "d", "cb", "lc", "cont", "n"]}}
{"id1": "12055086", "id2": "8588992", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"copyDeleting": [" copydeletging", " copyDeeleging", " copyDelingging", " copyDelingving", " copyDeeleting", " copyDeeleing", " copyDeleing", " copyDeletting", " copydeleving", " copydeletting", " copyDeeleving", " copydeletving", " copyDeletging", " copydeleging", " copydeleting", " copydeleing", " copyDelingting", " copyDelinging", " copyDeleging", " copyDeleving", " copyDeletving"], "source": ["image", "original", "scope", "store", "search", "seed", "style", "SOURCE", "service", "back", "target", "form", "origin", "ource", "src", "from", "resource", "spec", "init", "sql", "query", "body", "sp", "parent", "base", "ace", "template", "input", "se", "oss", "start", "Source", "site", "ce", "sample", "local"], "dest": ["loc", "del", "th", "exp", "https", "port", "Dest", "way", "target", "origin", "src", "mm", "bin", "pub", "st", "it", "tom", "dist", "them", "orig", "trans", "dir", "img", "nom", "sp", "est", "cas", "comb", "cat", "lit", "null", "decl", "pas", "rest", "end", "temp", "d", "w", "master"], "buf": ["arr", "cmd", "bl", "b", "cf", "bs", "vec", "uf", "alph", "data", "capt", "box", "ref", "buffer", "str", "aka", "block", "pkg", "fb", "bh", "cv", "cap", "img", "bag", "fg", "seq", "Buff", "eb", "batch", "cast", "cp", "br", "comb", "cur", "bus", "cat", "conv", "db", "bc", "meg", "tab", "rb", "Buffer", "prop", "tx", "buff", "bytes", "pause", "cb"], "in": ["ins", "din", "inside", "el", "en", "ri", "ini", "ze", "IN", "inn", "con", "ai", "user", "un", "inf", "cin", "gin", "mm", "on", "bin", "from", "ic", "it", "or", "by", "init", "al", "per", "ind", "is", "inc", "rin", "input", "i", "iter", "inner", "isin", "info", "read", "In"], "out": ["cn", "output", "OUT", "en", "co", "v", "dis", "sum", "con", "net", "io", "ne", "sys", "n", "on", "conn", "outs", "by", "writer", "ou", "to", "page", "obj", "res", "auto", "aos", "nt", "ion", "client", "write", "up", "oss", "i", "conv", "inner", "os", "flush", "o", "t", "end", "log", "Out", "at", "outer", "can"], "count": ["length", "cloud", "ount", "z", "num", "core", "max", "deep", "sum", "total", "char", "cc", "index", "q", "nb", "acc", "c", "size", "add", "span", "cap", "comment", "batch", "code", "nt", "amount", "ch", "cond", "ind", "current", "counter", "check", "found", "number", "len", "common", "conf", "start", "ctr", "coll", "ct", "Count", "t", "now", "read", "cont", "n"]}}
{"id1": "14598566", "id2": "18613870", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFilebynIR", "copyFilebyNIO", "copyFileBynIO", "copyFileBynio", "copyFileByNio", "copyFilebyNII", "copyFileByNDio", "copyFileByNDIO", "copyFilebynio", "copyFileByNII", "copyFilebynII", "copyFileByStandardIR", "copyFileByStandardIO", "copyFileByStandardII", "copyFileBynIR", "copyFilebynIO", "copyFileByNDIR", "copyFileBynII", "copyFileByNIR", "copyFilebyNio", "copyFileByNDII", "copyFileByStandardio", "copyFilebyNIR"], "in": ["ins", "din", "el", "en", "b", "id", "old", "IN", "inn", "cin", "gin", "on", "mm", "from", "st", "ic", "it", "ar", "vin", "as", "sql", "edIn", "ind", "is", "inc", "up", "rin", "i", "input", "source", "l", "o", "isin", "In"], "out": ["ot", "u", "output", "OUT", "b", "v", "serv", "ex", "gt", "s", "net", "ne", "io", "str", "err", "outs", "it", "ou", "to", "po", "op", "nt", "ch", "check", "oss", "g", "os", "l", "null", "t", "log", "o", "Out", "at", "w", "n"], "sourceChannel": ["SourceListener", "seedMember", "srcButton", " sourceProvider", "ourceChan", "parseButton", "SourceConnection", "parseMember", "sourceConnection", "ourceChain", "sourceCategory", " sourceListener", "sourceMember", "ourceConnection", " sourceConnection", "srcChain", "Sourcechannel", "givenListener", "srcChannel", "SourceChannel", "parseCategory", "srcListener", "srcChan", "srcConnection", " sourceChan", "ourceChannel", "sourceListener", "sourceChan", "sourceButton", "sourceProvider", "parseChannel", "seedCategory", " sourceMessage", "ourcechannel", " sourcechannel", "givenMessage", "seedChannel", "srcCategory", "srcMember", "sourceChain", "givenProvider", "ourceListener", "srcProvider", " sourceChain", "seedButton", "givenChannel", "sourcechannel", "srcMessage", "sourceMessage"], "destinationChannel": [" destationChan", "DestationChan", "destationStream", "destationChan", "destinationClient", "destationChannel", "destructionChan", "destinationsComponent", "destensionClient", "DestinationChan", "DestationConnector", "destructionConnection", "destinationConnection", "DestinationChannel", " destinationChan", "DestinationClient", "destensionChannel", "DestinatorClient", "DestinationConnection", "destensionChan", "DestinatorChannel", "DestationStream", " destationComponent", "destinatedChannel", "destensionStream", "destructionChannel", "destationConnector", "destationConnection", "DestinatorConnection", "destinatorChan", "destensionConnector", "destationClient", " destinationConnection", "destinationsChan", "destinationsConnection", "destinatorConnection", "DestationChannel", "destinationComponent", "DestinationConnector", " destationChannel", "destinationsChannel", "destationComponent", "destinatedConnector", "DestinationStream", "destinatorClient", "DestinatorChan", "destinatorChannel", " destinationComponent", "destinationConnector", "destensionConnection", "destinatedChan", "destructionComponent", " destationConnection", "destinationChan", "destinatedStream", "destinationStream"]}}
{"id1": "2521141", "id2": "88047", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "move", "cut", "archive", "transfer", "select", "sync", "ate", "delete", "crop", "io", "set", "clip", "opy", "insert", "load", "remove", "link", "upload", "replace", "export", "paste", "edit", "Copy", "file", "share", "cp", "zip", "slice", "write", "get", "source", "clone", "create", "close", "save", "download", "cop"], "from_name": ["from_no", "fromkname", "from_filename", " from_part", " from_case", "fromamefilename", "from_key", " from_names", "from_info", "fromamename", " from_key", "fromkcase", " from_filename", "fromameName", "from_resource", " from_resource", "from_case", "fromkName", "from_Name", "from_names", " from_Name", " from_info", " from_no", "fromkpart", "fromamekey", "from_part"], "to_name": ["toNameget", "tolynm", "toNamefile", "toNamename", "toNamenew", " to_nm", "eto_Name", "to7new", "eto_word", "to_number", "from_new", "to_get", "to_word", "to7name", "to_Name", "tolynumber", "from_get", "to7file", "to_nm", "eto_name", "to_new", "tolyname", "to7get", "tolyfile", " to_number"], "from_file": ["fromlyfile", " from_time", "to_dir", "from_run", "from_File", "or_name", "or_File", "from_node", "or_file", "fromlyresource", " from_do", " from_port", " from_node", "fromsname", " from_File", "from_resource", "from_port", " from_resource", "or_run", " from_type", "fromlyFile", "from_dir", "fromlynode", "fromsfile", "fromsdir", "from_type", "from_time", "from_do"], "to_file": ["TO_element", "to_dir", " to_File", "toJfile", "to_link", "to_local", "TO_port", "to_tree", " to_base", "to_base", "toJdrop", " to_block", "to_files", "toJblock", "TO_FILE", " to_dir", "that_file", " to_local", "that_link", "that_File", "to_port", "to_type", "TO_files", "to_FILE", "TO_name", "TO_file", "to_create", "from_dir", "to_File", " to_run", "to_element", "from_type", "to_block", " to_create", "to_drop", "to_run", "that_tree", "toJFile", " to_drop"], "parent": ["folder", "top", "server", "id", "holder", "p", "port", "position", "par", "base", "where", "instance", "home", "peer", "event", "path", "owner", "user", "chain", "form", "test", "percent", "tar", "Parent", "my", "tree", "block", "rule", "paren", "man", "mother", "part", "timeout", "spec", "page", "comment", "prefix", "shape", "file", "ma", "child", "sp", "directory", "pool", "params", "name", "pid", "family", "unit", "relative", "cmp", "per", "pa", "up", "client", "def", "source", "null", "desc", "parents", "default", "global", "ip", "prop", "root", "temp", "pixel", "remote", "point", "master"], "dir": ["div", "rel", "folder", "del", "loc", "dr", "dd", "cmd", "ir", "red", "self", "rec", "dict", "path", "addr", "str", "mod", "part", "vol", "dist", "init", "md", "file", "DIR", "sp", "directory", "det", "tr", "cond", "ind", "good", "def", "dep", "dim", "cur", "iter", "wd", "di", "db", "cd", "Dir", "coll", "fd", "d", "local", "module", "cont"], "from": ["fun", "store", "en", "stream", "style", "old", "with", "com", "From", "window", "ent", "con", "empty", "back", "user", "form", "io", "normal", "on", "set", "term", "st", "in", "entry", "or", "by", "error", "re", "vol", "link", "fr", "orig", "init", "query", "file", "left", "so", "ie", "base", "pos", "before", "false", "no", "out", "check", "client", "source", "se", "inner", "reset", "start", "ra", "bound", "and", "local", "func"], "to": ["eto", "top", "output", "tt", "b", "co", "too", "total", "tty", "te", "stable", "please", "token", "e", "target", "ne", "sys", "on", "will", "into", "or", "by", "toc", "table", "pretty", "ts", "that", "must", "To", "po", "TO", "op", "auto", "nt", "so", "ma", "base", "two", "no", "tto", "out", "client", "ta", "can", "null", "o", "t", "go", "ato", "pi"], "buffer": ["binary", "cache", "message", "window", "char", "buf", "queue", "stack", "phrase", "sequence", "database", "block", "entry", "button", "table", "frame", "bar", "stroke", "available", "page", "paste", "attribute", "document", "function", "batch", "base", "event", "word", "append", "template", "memory", "character", "iter", "row", "variable", "Buffer", "buff", "sample", "password", "command", "temp"], "bytes_read": ["bytes__Read", "bytes2range", " bytes_Read", "bytes_run", "bytes__range", "bytes__write", "bytes2Read", "bytes2read", "wordsynclen", "words_write", "words_report", "words_read", "bytes__read", "bytes2write", "wordsyncwrite", "bytes_range", "bytesyncread", "wordsyncread", "Bytes_read", " bytes2read", "bytesyncreport", "bytes_write", " bytes_write", " bytes2Read", " bytes2write", "Bytes_write", "words_len", "Bytes_run", "bytesynclen", "wordsyncreport", " bytes_range", " bytes2range", "bytes_Read", "bytesyncwrite", "bytes_len", "bytes_report"]}}
{"id1": "22022715", "id2": "19784131", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 1, "substitutes": {"digest": ["digate", "mdine", "dine", "mden", "mnest", "dum", "Digested", "digum", "digist", "dest", "dests", "mdests", "mnests", "decge", "Digge", "mdested", "dge", "decested", "digested", "dist", "digests", "den", "mdum", "Digate", "mdist", "decate", "digge", "mnen", "Digest", "digine", "dested", "Digum", "digen", "mdest", "mnist", "decest", "Digine", "date"], "s": ["f", "ats", "b", "v", "p", "sts", "ls", "string", "e", "S", "ms", "str", "m", "ss", "space", "strings", "sq", "text", "js", "c", "a", "sv", "ts", "sql", "sb", "ses", "y", "is", "h", "i", "r", "l", "bytes", "t", "o", "ps", "n"], "ret": ["arr", "rt", "mt", "ft", "rs", "ert", "uf", "cont", "jp", "data", "reg", "gt", "buf", "back", "over", "repl", "ref", "test", "Ret", "val", "resp", "it", "re", "az", "ts", "report", "res", "tmp", "nt", "det", "pet", "tr", "arg", "Return", "gb", "out", "rem", "found", "elt", "txt", "r", "rm", "cat", "RET", "reset", "xt", "rep", "t", "ext", "rets", "att", "result"], "md": ["del", "pdf", "cmd", "dr", "dd", "mt", " MD", "der", "mo", "red", "nd", "dh", "mk", "sd", "med", "od", "ms", "m", "mm", "pm", "man", "pd", "sm", "mod", "ds", "and", "mc", "mn", " Md", "df", "managed", "dm", "mand", "det", "ind", "mb", "mail", "met", "ld", "rm", "di", "cd", "bd", "hd", "d", "MD", "mg"]}}
{"id1": "9738825", "id2": "823074", "code1": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"load": ["update", "store", "cache", "launch", "sync", "pull", "process", "Load", "set", "ll", "from", "pack", "loader", "view", "add", "link", "upload", "oad", "dump", "transform", "init", "file", "loading", "run", "pload", "construct", "build", "library", "lock", "loads", "open", "call", "mount", "create", "config", "find", "l", "parse", "play", "include", "save", "download", "use", "read", "LOAD"], "url": ["loc", "host", "rel", "el", "u", "domain", "gl", "b", "id", "location", "ls", "dl", "pattern", "char", "string", "path", "web", "ref", "un", "buffer", "q", "rect", "str", "xml", "ll", "term", "it", "resource", "http", "ul", "nl", "link", "page", "browser", "ur", "impl", "sql", "URL", "document", "file", "build", "base", "address", "name", "mount", "mail", "full", "pl", "source", "filename", "uri", "Url", "l", "null", "abs", "log", "util", "html", "job"], "locator": ["locoder", "dialinator", "vocer", "dialigator", "vocator", "vocrator", "generoder", " locer", "localator", "locationor", "localATOR", "callinator", "Locator", "LOCator", "locATOR", "Locor", "generator", " locoder", "locrator", "localer", " locace", "Locinator", "locationATOR", "locigator", " locinator", " locATOR", "LOCer", "generor", " locigator", " locor", "localor", "Locace", "callator", "locinator", "Locer", "Locigator", " locrator", "locationator", "dialace", "locer", "dialator", "calloder", "vocinator", "LOCrator", "locor", "callor", "locationinator", "localinator", "LOCinator", "locace", "generinator"], "stream": ["port", "sync", "empty", "ream", "path", "stack", "buffer", "socket", "impl", "shape", "reader", "check", "feed", "null", "row", "download", "length", "host", "Stream", "store", "encrypted", "instance", "string", "iterator", "form", "chain", "sign", "upload", "provided", "console", "body", "is", "mount", "loop", "filter", "channel", "screen", "data", "message", "clean", "test", "valid", "str", "in", "resource", "post", "response", "sam", "source", "input", "draw", "present", "stage", "window", "where", "thread", "secure", "sequence", "embed", "sw", "safe", "steam", "REAM", "transform", "pool", "pipe", "zip", "system", "open", "client", "inner", "sample", "pod", "read", "cont"]}}
{"id1": "13563706", "id2": "13063241", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "DoGET", "doPut", "Doget", "doGET", "handleGET", " doget", "doget", "handleGet", " doPut", "handleget", "handlePut", "DoGet", "DoPut"], "request": ["initial", "context", "Request", "search", "forward", "position", "message", "each", "setup", "order", "path", "user", "complete", "hello", "first", "subject", "xml", "application", "view", "resource", "QUEST", "re", "frame", "http", "socket", "report", "attribute", "transform", "query", "document", "connection", "address", "reference", "directory", "parent", "event", "current", "call", "get", "input", "create", "reset", "route", "version", "url", "use", "command", "project"], "response": ["image", "reply", "output", "server", "search", "header", "position", "continue", "security", "message", "relation", "description", "format", "service", "ve", "print", "sequence", "tree", "block", "network", "resp", "application", "view", "answer", "collection", "status", "http", "zero", "frame", "report", "render", "document", "res", "connection", "console", "hash", "see", "write", "display", "respond", "foundation", "Response", "version", "fire", "json", "default", "success", "condition", "summary", "next", "example", "ce", "exit", "result"], "selectedPage": [" selectedKey", "namedPage", "selectionPage", "electedpage", "lectedFrame", "lectedItem", "singlePage", "specifiedPage", "electionFrame", "selectedKey", "singlepage", "selectItem", "namedToken", " selectedPort", "specifiedPort", "namedpage", "selectFile", "selectedDocument", "namedKey", "selectedPath", "singleFrame", "namedLine", "lectedFile", "verifiedFile", "matchedFrame", " selectedpage", "electionPage", "selectPath", "lectedPath", "selectionItem", " selectedRow", "selectPort", "selectionLine", "verifiedRow", "selectedPort", "lectedPage", " selectedFrame", "electedPage", "matchedPort", "lectedRow", "namedFrame", "electionDocument", "selectedpage", "selectedFrame", "lectedDocument", "selectedItem", " selectedLine", "selectionToken", "electedFrame", "electionPort", "selectionPort", "namedPort", "singlePort", "lectedPort", "specifiedDocument", "specifiedFrame", "matchedPage", "selectedFile", "verifiedPage", "selectedToken", "lectedpage", "selectedRow", "lectedKey", "selectedLine", "verifiedpage", "selectLine", "electedPort", "lectedToken", "lectedLine", "selectPage", " selectedFile", "selectionFile", "matchedpage", " selectedPath"], "page": ["object", "record", "node", "port", "complete", "application", "phone", "menu", "address", "be", "line", "pages", "age", "row", "url", "log", "point", "server", "office", "cache", "profile", "instance", "form", "chain", "view", "table", "to", "document", "layout", "current", "display", "number", "policy", "version", "associated", "filter", "Page", "project", "result", "p", "channel", "message", "self", "user", "group", "me", "network", "rule", "resource", "parent", "site", " Page", "image", "output", "position", "language", "window", "peer", "pointer", "phrase", "block", "pp", "collection", "frame", "force", "proxy", "pool", "client", "created", "next", "successful"], "portalRequest": ["PortaleThread", "PortaleQuery", "portalEvent", "terminalidRequest", "portualResponse", " portalCall", "portalSession", "portaleApply", "portaleFrame", "PortaleContext", "portalrequest", "portpalRequest", "terminalQuery", "portortalEvent", "PortalThread", "terminalidResponse", "portalityRequest", "portortalThread", " portaleAccess", "portralSession", "portortalQuery", "portalaCall", "PortalRequest", "portalidRequest", "portalingRequest", "terminalidSession", "portsortalEvent", "portalAccess", "portortalResponse", "portralQuery", "PortalContext", "portsalrequest", "portpalResponse", "terminalResponse", "portaleAccess", "portalingCall", "portaleSession", "portalCall", "portpalContext", "terminalidQuery", "portalidContext", "PortaleRequest", "portalidFrame", "portalerequest", "portaleQuery", "portalApply", "portsortalRequest", "portalThread", "portaleRequest", "PortalFrame", "portsalEvent", "portralRequest", "portalingAccess", "portortalrequest", "portaleContext", "portalFrame", "portalaRequest", "portalResponse", " portaleRequest", "portpalThread", " portaleCall", "PortaleResponse", " portalAccess", "portalityResponse", "portualrequest", "portalContext", "portalaAccess", "portsalRequest", "portralContext", "portralResponse", "portalingApply", "terminalRequest", "PortaleFrame", "portsalResponse", "portaleCall", "portalidQuery", "portsortalrequest", "portalityFrame", "portaleEvent", "terminalSession", "portualEvent", "portalidSession", "PortalQuery", "portsortalResponse", "portalaApply", "portaleResponse", "portaleThread", "portalityContext", "portalQuery", "portalidResponse", "portualRequest", " portalApply", " portaleApply", "portortalContext", "portortalRequest", "PortalResponse"], "pageProp": ["keyComp", "profileZip", "profileProp", "poolPro", "officePack", " pageProperty", "imageProp", " pagePriv", "agePr", "keyProperty", " pagePack", "sectionZip", "phrasePr", "keyProp", "pageProperty", "pageDef", "profilePred", "pagePr", "imagePr", "poolProp", "officeDef", "propertyDef", " pagePred", "agePro", " pageComp", "officeProp", "pagePred", "officePriv", "propertyProp", "phraseComp", "sectionPred", "propertyPack", "pageZip", " pagePr", "poolPred", "pagePro", "sectionProp", "phraseProp", "sectionPro", "agePred", "keyPr", "profilePro", "poolZip", "phraseProperty", " pageDef", "propertyPriv", "pagePack", "pagePriv", "ageProp", " pagePro", "imagePro", "pageComp", "imagePred"], "possiblePage": [" packedLine", "PossibleChild", "pbableUser", "pableTag", "PossiblyPage", "possibleLine", "possibleChild", "PossiblyCollection", "pableCollection", " possibleCollection", " possibleLine", "pibleUser", "pspecifiedpage", "pentialpage", "possiblyLine", "pbablePage", "pentialTag", "PossibleTag", "pspecifiedPage", "possiblePages", "packedLine", "pbableCollection", " possibleTag", "possibleUser", "packedCollection", "PossiblyUser", "pentialPages", "possiblyTag", "PossibleUser", "packedPage", "packedTag", "pibleChild", "pableLine", "pablePage", "pibleCollection", "PossiblyChild", "possiblepage", "pspecifiedTag", "pbableChild", "possibleCollection", "possiblyChild", "possiblyCollection", "PossibleCollection", " packedPage", "possiblyUser", "piblePage", "PossiblePage", "possibleTag", " packedCollection", "Possiblepage", "PossiblePages", "pspecifiedPages", "possiblyPage", " packedTag", "pentialPage"], "property": ["object", "value", "domain", "header", "operator", "field", "behavior", "p", "position", "location", "integer", "class", "relation", "message", "feature", "description", "service", "properties", "string", "owner", "phrase", "rue", "rule", "definition", "resource", "trace", "frame", "Property", "metadata", "attribute", "key", "expression", "function", "address", "name", "title", "config", "policy", "type", "variable", "prop", "second", "command"], "referer": ["aferential", "afener", "reterer", "relrer", "rerer", "refender", "rerier", "verrer", "reportarer", " refrer", "reener", "reeree", "reered", "refrer", "rorirect", "frer", "relender", "reonder", "relerer", "relener", "referee", "Refrer", "reportered", "reporterer", "printrier", "reerer", "rearer", "refarer", "rangeener", "requerer", "refonder", "reerential", "defered", "referential", "relering", " refirect", "refrier", "relerential", "fering", "refener", "diffonder", "differing", "retarer", "requering", "defirect", "deferer", "Referer", "afrer", "rorerer", "retered", "rederee", "fener", "rangerer", "Referee", "refering", "vererential", "retrer", "requrer", "rangeerer", "redrer", "rederer", "differer", "diffrer", "rorered", "printrer", "ferer", " refered", "refered", "printerential", "reender", "redere", "rorrer", "defrer", "refirect", "reering", "Refere", "requonder", "aferer", "printerer", "rangeender", "vererer", "refere", "verrier", "reportrer", "reere"], "e": ["f", "p", "er", "te", "ge", "ae", "eu", "E", "me", "m", "err", "eg", "error", "a", "de", "x", "ie", "ception", "event", "h", "se", "r", "oe", "g", "es", "echo", "o", "eeee", "t", "eur", "ee", "n"]}}
{"id1": "6840241", "id2": "14878593", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["cover", "move", "transfer", "sync", "delete", "print", "clip", "opy", "map", "load", "size", "link", "read", "replace", "Copy", "gc", "share", "cp", "slice", "system", "call", "write", "clone", "create", "close", "cat", "save", "cop"], "source": ["image", "context", "ins", "inside", "scope", "store", "stream", "shell", "style", "SOURCE", "cache", "select", "si", "origin", "ource", "state", "src", "subject", "from", "wrapper", "resource", "status", "size", "table", "spec", "session", "sql", "ie", "body", "base", "parent", "sp", "reader", "template", "pse", "input", "se", "iter", "inner", "start", "sr", "Source", "sample", "ce", "site", "info", "local", "master"], "sink": ["sue", "sender", "slender", "Sinker", "Sue", "asender", "asource", "Sink", "ssink", " sinker", "slink", "slource", " sue", "ssinker", "asink", "ssource", "ssender", "sinker", "slue", " sender", "Source", "Sender", "asinker"]}}
{"id1": "1954410", "id2": "20232250", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "label": 0, "substitutes": {"doExecute": ["doExecExec", "DoExecit", "DoExecute", "doCommExec", "doExecutes", "doCommute", "doEditute", "doExecit", "doEditutes", "doEditExec", "DoExecExec", "DoExecutes", "doCommutes", "doCommit", "doEditit"], "mapping": ["mapper", "mapped", "Mapped", " mapped", "smapped", " mappings", "Mappings", "mappings", "Mapper", "smapper", " mapper", "smapping", "smappings", "Mapping"], "form": ["f", "self", "format", "path", "owner", "m", " forms", "subject", "raw", "view", "map", "session", " Form", "forms", "Form", "formed", " FORM", "orm", "sam", "parent", "FORM", "template", "config", "app", "type", "command", "fc"], "request": ["question", "application", "http", "quest", "report", "impl", "address", "def", "template", "se", "url", "host", "context", "Request", "server", "store", "instance", "view", "upload", "document", "current", "version", "remote", "command", "w", "project", "initial", "container", "Upload", "message", "allow", "user", "Exception", "resource", "post", "query", "parent", "reference", "input", "create", "model", "window", "order", "sw", "xml", "QUEST", "frame", "_", "req", "session", "this", "open", "client", "true", "reset", "first", "cont"], "response": ["reply", "output", "server", "message", "content", "print", "xml", "resp", "application", "view", "status", "re", "frame", "report", "session", "connection", "res", "document", "sp", "write", "respond", "Response", "success", "ce", "send", "result"], "errors": [" moves", " Messages", " state", " requests", " states", " sessions", " warnings", " changes", " steps", " messenger", " status", " statements", " error", " logs", " managers", "ages", " mess", " fails", " updates", " manager", " elements", " problems", " flash", " storage", " messages", " flashes", "Mess", " success"], "isMultipart": ["isMultipade", "isMultiIPade", "isMultifare", "isMultospart", "isMultosparts", "isMultifarts", "isMultipod", "isMultIPade", "isMultifart", "isMultiipart", "isMultiIPare", "isMultiIPain", "isMultiade", "isMultiipain", "isMultiparts", "isMultiipod", "isMultiplade", "isMultiarts", "isMultiIPod", "isMultiipare", "isMultifain", "isMultiipade", "isMultiplod", "isMultiplarts", "isMultIParts", "isMultospain", "isMultiiparts", "isMultiIPart", "isMultospare", "isMultipare", "isMultIPart", "isMultIPain", "isMultiart", "isMultiod", "isMultIPod", "isMultiIParts", "isMultipain", "isMultiplart", "isMultIPare"], "mailInstance": [" MailBuilder", " MailInstance", "emailance", "emailInstance", " mailance", " MailInst", "emailinstance", "mailinstance", " Mailinstance", "flexInst", "flexance", "mailInst", "emailBuilder", "mailance", "emailInst", "flexInstance", "flexinstance", " mailInst", " mailBuilder", "mailBuilder", " mailinstance"], "fields": ["phones", "rows", "terms", "flags", "days", "field", "comments", "models", "drivers", "bits", "qs", "prints", "classes", "atts", "features", "lights", "properties", "types", "packs", "orders", "files", "strings", "links", "packages", "tests", "headers", "relations", "images", "balls", "boxes", "users", "holders", "sections", "reports", "lists", "forms", "workers", "dates", "objects", "members", "services", "modules", "keys", "posts", "details", "parts", "pages", "levels", "states", "lines", "locks", "ports", "plugins", "names", "rules", "groups", "faces", "frames", "tags", "views", "checks"], "attachments": [" attachitions", "achitions", " attachements", "Attachresses", "AttachMENTS", "achements", "Attachitions", "payances", "payitions", "attachions", "Attachments", "attachitions", "acheances", "attments", "attMENTS", "payements", "attachMENTS", "attachements", "payments", "achresses", "achMENTS", " attachions", "acheements", "attensions", " attachances", "attitions", "attachances", "Attachensions", "achments", "attachresses", "attachensions", "achions", "achensions", "acheitions", " attachresses", "Attachions"], "items": ["phones", "rows", " samples", " inputs", "Items", "events", "ips", "orders", "files", "actions", "packages", "issues", "apps", " files", " images", "links", "images", " results", "reports", "cases", "objects", "members", "services", "keys", "archives", "resources", "parts", "pages", "results", "lines", "its", "ids", "names", "groups", "qs", "photos", "tests", " Items"], "iter": ["loc", "el", "ipper", "store", "gener", "upper", "er", "list", "Iterator", "tif", "each", "iterator", "order", "outer", "ait", "oper", "test", "orient", "set", "walker", "maker", "it", "writer", "li", "re", "ter", "ator", "ser", "iner", "ite", "init", "dir", "tr", "reader", "ind", "cmp", "older", "inter", "loop", "i", "former", "ner", "inner", "coll", "its", "Iter", "read", "result", "altern"], "item": ["object", "record", "entity", "detail", "status", "add", "link", "page", "attribute", "obj", "file", "change", "template", "anything", "details", "app", "row", "url", "info", "local", "module", "el", "store", "Item", "ix", "match", "instance", "addr", "claim", "entry", "it", "or", "step", "spec", "related", "key", "name", "unit", "element", "internal", "json", "type", "att", "initial", "other", "ex", "data", "er", "group", "attr", "rule", "raw", "layer", "single", "resource", "word", "up", "one", "ip", "image", "atom", "area", "order", "cell", "member", "mm", "on", "xml", "event", "zip", "inner", "stat", "job"], "aux": ["max", "av", "cu", "du", "uff", "ix", "fat", "uf", "ex", "airs", "af", "area", "us", "fax", "eu", "foo", "aus", "net", "AU", "ax", "lim", "au", "imp", "vers", "etc", "fam", "fx", "fuck", "fu", "aim", "auto", "ups", "ox", "aos", "pet", "ras", "aff", "uds", "extra", "used", "off", "abs", "mu", "tx", "aw", "ux", "buff", "pad"], "part": ["object", "par", "detail", "pair", "section", "pkg", "mod", "join", "add", "Part", "prefix", "sp", "pos", " parts", "html", "pad", "point", "local", "relation", "partial", "print", "pt", "wrapper", "step", " Part", "card", "pet", "photo", "tab", "start", "version", "tx", "temp", "PART", "patch", "p", "zone", "message", "api", "format", "group", "pre", "art", "layer", "worker", "tmp", "base", "pod", "parent", "word", "comp", "parts", "component", "top", "person", "work", "half", "list", "peer", "admin", "member", "block", "piece", "split", "inner", "party", "bound", "sample", "primary", "and", "job"], "baos": ["pois", "caos", "taos", "baoses", "booss", "vaoss", "bioses", "vaols", "caOs", "poops", "baops", "taOs", "poo", "kaoss", "caOS", "boOS", "taoss", "caoss", "waoss", "pooses", "booses", "boOs", "baols", "caols", "biOS", "tais", "bios", "tao", "bao", "taops", "kaops", "bais", "waos", "waols", "bio", "boo", "baOS", "boos", "baoss", "kaos", "poos", "kais", "pooss", "baOs", "cao", "waOs", "vaOs", "vaos", "poOS"], "body": ["rel", "output", "header", "shell", "binary", "port", "data", "message", "format", "description", "detail", "content", "business", "ody", "buffer", "tree", "subject", "ODY", "bill", "Body", "scroll", "text", "size", "post", "note", "comment", "report", "tail", "foot", "layout", "file", "base", "name", "mail", "display", "template", "loop", "title", "head", "pass", "null", "json", "default", "summary", "t", "log", "html", "send", "plain"], "preferencesInstance": ["prefferencesObj", "preffiesinstance", "preferencesinstance", "prefancesInstance", "prefancesImpl", "preffiesObj", "prefancesObj", "prefutesInstance", "prefutesinstance", "prefiesImpl", "prefiesObj", "prefferencesInstance", "preferencesObj", "prefancesinstance", "prefutesObj", "prefiesInstance", "prefferencesImpl", "preffiesInstance", "preffiesImpl", "prefferencesinstance", "prefiesinstance", "prefutesImpl", "preferencesImpl"]}}
{"id1": "12246545", "id2": "1122585", "code1": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "code2": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "label": 0, "substitutes": {"load": ["update", "cache", "launch", "boot", "sync", "process", "require", "Load", "print", "complete", "test", "set", "debug", "pack", "loader", "define", "link", "fill", "init", "dump", "loading", "construct", "build", "library", "lock", "loads", "open", "call", "check", "get", "create", "close", "config", "find", "iter", "l", "ignore", "parse", "include", "save", "download", "use", "read", "LOAD"], "url": ["org", "id", "dl", "path", "q", "err", "au", "status", "http", "nl", "link", "page", "impl", "sql", "file", "res", "address", "null", "row", "log", "util", "f", "host", "el", "ssl", "domain", "https", "pattern", "gif", "external", "string", "web", "print", "ll", "term", "ret", "browser", "ur", "item", "key", "gc", "name", "mount", "mail", "filename", "l", "json", "fail", "loc", "sl", "gl", "ls", "char", "ref", "str", "resource", "URL", "build", "base", "full", "source", "uri", "rel", "b", "location", "xml", "ul", "req", "cert", "Url", "db", "ext", "html"], "col": ["Col", "loc", "column", "num", "cal", "const", "cmd", "var", "co", "serv", "dial", "mot", "count", "icol", "il", "char", "con", " Col", "aj", "cell", "rect", "ctx", "val", "pt", "COL", "c", "ell", "coord", "seq", "soc", "pc", "pos", "cond", "no", "def", "ol", "bc", "cor", "sel", "row", "coll", "ct", "fl", "rot", "fc", "cont", "mon"], "fin": ["f", " fi", "irm", "din", "FIN", "jin", "Fin", "ran", "fw", "fat", "ini", "lan", "inn", "fil", "ln", "sn", "kin", "lin", "pen", "wid", "san", "rn", "inv", "fr", "init", "thin", "fa", "mn", "fn", "fre", "Finish", "fp", "fi", "syn", "len", "ien", "conv", "oin", "raf", "fl", "mu", "eric", "fd", "fc"], "in": ["k", "ins", "din", "irm", "el", "en", "search", "scan", "serv", "the", "IN", "ent", "inn", "con", "form", "inf", "gin", "cin", "local", "m", "mm", "bin", "val", "str", "on", "it", "ic", "from", "by", "any", "re", "add", "inv", "a", "to", "ilo", "all", "init", "thin", "nin", "mc", "within", "pic", "al", "ma", "ain", "act", "ind", "is", "inc", "no", "out", "found", "system", "rin", "i", "input", "find", "inner", "oin", "o", "isin", "at", " din", "In", "n"]}}
{"id1": "12128591", "id2": "19739421", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["update", "id", " salt", " key", " address", "Hash", "print", " sum", " equals", " message", " Hash", " hashing", " check", "dump", "hex", "code", " text", " h", "h", " body", " signature", " id", " fingerprint", " mac", " code", " version"], "data": ["image", "DATA", "rel", "value", "output", "ata", "dat", "message", "window", "secret", "content", "string", "sequence", "buffer", "any", "block", "raw", "text", "table", "password", "a", "what", "command", "batch", "this", "out", "input", "json", "mu", "bytes", "accept", "padding", "html", "hello", "info", "result", "action"], "digest": ["dese", "mdly", "mdit", " digit", "mdave", "equit", "initested", "displayested", "displayse", " digested", "mailester", "initest", " digist", "Digester", "mdse", "digist", "Digested", "equse", "Digist", "displayest", "mdests", "mdgest", "mdested", "initester", "digested", "DigEST", "digit", "digests", "redest", "deested", "mailgest", " digEST", "digse", " digse", "diggest", " digester", "Digest", "redester", "initEST", "equave", "mailly", "redly", "Digse", "deist", "redgest", "mdester", "digly", "mdest", "deest", "displayests", "Digests", "digEST", "digester", "mailest", "digave", " digave", "equest"]}}
{"id1": "17791385", "id2": "3266833", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", " cpFile", "cloneFiles", "cloneResource", " copyFiles", " cpfile", " cpFiles", "copyFiles", "copyResource", "cloneFile", " copyfile", " cpResource", "clonefile", " copyResource"], "src": ["rel", "iv", "ins", "rc", "bs", "rs", "sc", "usr", "sin", "ys", "sys", "obs", "via", "st", "sq", "sf", "sec", "from", "rl", "inst", "sit", "ser", "req", "usc", "init", "sb", "rx", "txt", "ipl", "source", "input", "cur", "sel", "start", "sur", "ctr", "sr", "Source", "ux", "ck", "cont"], "dst": ["dnd", " ddest", "wdest", "Dth", "wth", " dth", "Dnd", "Dst", "ddnd", "Ddest", "dddest", "ddst", "dth", " dnd", "dnt", "Dnt", "sdest", "wst", "wnd", "snd", "ddest", "snt", "ddnt", "sst"], "in": ["ins", "inside", "din", "en", "ze", "IN", "rec", "sin", "inn", "con", "ln", "ai", "inf", "cin", "gin", "mm", "on", "bin", "from", "ar", "ic", "st", "it", "init", "al", "ain", "act", "ind", "is", "inc", "up", "rin", "i", "input", "source", "iter", "inner", "oin", "info", "isin", "im", "min", "In"], "out": ["cn", "ot", "output", "OUT", "co", "dis", "ex", "sum", "gt", "con", "net", "io", "ne", "sys", "on", "bin", "st", "outs", "it", "by", "writer", "ou", "and", "to", "obj", "res", "po", "auto", "aos", "nt", "can", "client", "write", "up", "oss", "oe", "g", "os", "inner", "conv", "o", "t", "Out", "at", "outer", "n"], "buf": ["arr", "cmd", "ck", "var", "b", "cf", "vec", "bed", "uf", "norm", "gen", "box", "buffer", "aka", "block", "pkg", "fb", "bar", "stab", "bh", "cv", "cap", "cam", "bag", "seq", "Buff", "batch", "msg", "cp", "good", "br", "pl", "cur", "bus", "cat", "conv", "db", "tab", "Buffer", "prop", "mu", "tx", "buff", "bytes", "log", "cb"], "len": ["length", "L", "loc", "z", "el", "rel", "fun", "num", "en", "exp", "fin", "v", "ls", "lf", "dl", "count", "lic", "il", "lan", "e", "ln", "le", "lim", "str", "val", "ll", "wid", "size", "vol", "Len", "cap", "all", "seq", "nt", "pos", "ren", "no", "cmp", "h", "elt", "ld", "l", "lon", "coll", "fl", "t", "end", "compl", "lib", "n"]}}
{"id1": "9805906", "id2": "16215393", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"dump": ["update", "copy", "store", " dumps", "show", "println", " show", " dumped", "diff", "print", " debug", "debug", "load", "link", " println", "export", "init", "zip", "write", "display", " describe", "flush", "save", "stat", "download", "info", "send", "read"], "source": ["image", "scope", "copy", "store", "search", "shell", "style", "SOURCE", "script", "select", "service", "form", "ink", "sequence", "origin", "ource", "sys", "src", "from", "text", "view", "resource", "spec", "init", "sql", "file", "ie", "parent", "java", "check", "template", "input", "se", "config", "iter", "start", "Source", "sample", "site", "remote", "info", "local"], "target": ["host", "top", "copy", "output", "style", "match", "pattern", "tif", "gt", "goal", "dest", "delete", "compatible", "test", "term", "it", "table", "link", "replace", "that", "to", "bolt", "file", "proxy", "base", "arg", "current", "template", "null", "mac", "t", "next", "local", "Target", "project", "arget"], "is": ["isa", "isl", "sis", "ins", "xs", "are", "iss", "mos", "ri", "ris", "bits", "lis", "ls", "ists", "ir", "ib", "isi", "nis", "ii", "s", "si", "ai", "ys", "ms", "sys", "iso", "has", "in", "ar", "it", "ic", "bis", "tis", "ics", "ois", "ims", "init", "IS", "iris", "act", "Is", "isc", "i", "oss", "isf", "es", "abs", "ip", "ais", "its", "ist", "isin", "im", "ios"], "os": ["fs", "oos", "ot", "osi", "mos", "bs", "ows", "cs", "ros", "ls", "ose", "s", "io", "sys", "nos", "obs", "ns", "ss", "outs", "js", "or", "ants", "ds", "dos", "oses", "ts", "bos", "aos", "uts", "ox", "cos", "Os", "pos", "oS", "oss", "OS", "es", "ost", "oes", "o", "los", "css", "ols", "ps", "ios"], "done": ["disabled", "progress", "flag", " continued", "du", "started", "shown", "die", "gone", "given", "later", "ished", "ded", "complete", "checked", "did", "finished", "valid", "set", "made", "filled", "continue", "loaded", "led", "expected", "enabled", "de", "dirty", "des", "failed", " Done", "only", "Done", "found", "seen", "created", "needed", "di", "desc", "pleted", "d"]}}
{"id1": "400275", "id2": "17111859", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 0, "substitutes": {"url": ["loc", "el", "sl", "ssl", "domain", "gl", "b", "location", "ls", "dl", "pattern", "char", "external", "bel", "string", "path", "web", "ref", "un", "q", "str", "xml", "ll", "term", "resource", "http", "rl", "nl", "link", "page", "browser", "ur", "key", "sql", "URL", "impl", "file", "base", "address", "name", "mount", "get", "pl", "r", "ld", "uri", "Url", "config", "l", "cl", "default", "log", "util", "html", "job"], "in": ["f", "update", "mi", "ins", "din", "isin", "en", "again", "online", "serv", "IN", "con", "inn", "s", "ln", "ai", "cin", "gin", "on", "m", "bin", "from", "c", "login", "init", "nin", "mc", "al", "ma", "body", "reader", "name", "is", "line", "out", "check", "rin", "i", "input", "source", "inner", "oin", "l", "null", "include", "o", "vin", " din", "min", "read", "In", "n"]}}
{"id1": "19944975", "id2": "16572931", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["WriteConfig", "outputSettings", "WriteContent", "writeConfig", "outputConfiguration", " writeConfig", "outputContent", "writeSettings", " writeContent", " writeSettings", "WriteConfiguration", "writeContent", "outputConfig", "WriteSettings"], "out": ["cmd", " OUT", "output", "OUT", "b", "p", "v", "list", "ent", "con", "over", "outer", "io", "group", "print", "err", "set", "conn", "outs", "c", "writer", "OU", "table", "ou", "pretty", "to", "report", "all", "file", "res", "aos", "cast", "nt", "msg", "pool", "ch", "this", "client", "check", "up", "h", "help", "g", "null", "o", "log", "t", "free", "cm", "Out", "at", "w", "result", "n"], "url": ["loc", "f", "rel", "sl", "ssl", "domain", "gl", "location", "dl", "pattern", "char", "service", "bel", "user", "net", "path", "ref", "rect", "str", "ll", "ret", "resource", "http", "rl", "nl", "link", "key", "URL", "file", "cert", "base", "address", "name", "mount", "mail", "client", "r", "uri", "Url", "l", "abs"], "in": ["f", "ins", "din", "inside", "el", "en", "serv", "sum", "IN", "sin", "inn", "con", "user", "io", "cin", "gin", "str", "m", "bin", "on", "from", "st", "it", "and", "file", "mc", "al", "ma", "body", "none", "reader", "ind", "is", "up", "rin", "i", "input", "source", "r", "inner", "l", "null", "sample", "isin", " din", "read", "In"]}}
{"id1": "5399593", "id2": "14691829", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"encrypt": ["enode", "decode", "encrypted", "decrypted", "deccode", "ecrypt", "ecrypted", "enccode", "enrypt", "decrypt", "encode", "eccode", "ecode", "enrypted"], "plaintext": ["pretext", " plaincontext", "aininput", "ainpassword", "precontext", "plainText", " plainword", " plainText", " Plaintext", "mainText", " plainpassword", "plainpassword", "aintext", "mainword", "plaininput", " plainth", "plaincontext", "preText", " Plainpassword", "ainth", "maintext", "plainth", "maincontext", "preword", " Plainth", "plainword", " plaininput", " Plaininput"], "UnsupportedEncodingException": ["UnsupportedCompodingError", "UnsupportedEncodedEx", "UnsupportedEncoderEx", "UnsupportedEncryptionEx", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedCompoderError", "UnsupportedCompoderEx", "UnsupportedEncryptionError", "UnsupportedCompoderException", "UnsupportedEncodedException", "UnsupportedEncodedError", "UnsupportedCompodingException", "UnsupportedEncryptionException", "UnsupportedEncodingEx", "UnsupportedEncoderException", "UnsupportedCompodingEx"], "md": ["del", "cmd", "dr", "dd", "mt", "exec", " MD", "der", "mo", "red", " cmd", " mc", "sha", "nd", " ma", "mg", "mk", "med", " dd", "sd", "od", "ms", "m", "mm", "pm", "gm", "pd", "mod", "add", "ad", "mc", "mn", " Md", " mo", " mm", "df", "mp", "nt", "dm", "mand", "det", "mb", "ind", "def", "grad", "ld", "cd", "bd", "hd", "d", " m", "MD", "sm"], "raw": ["core", "sh", "strip", "data", "message", "hook", "buf", "bare", "clean", "empty", "valid", "rendered", "pack", "custom", "load", "was", " Raw", "cooked", "orig", "all", "available", "des", "known", "hex", "RAW", "out", "clear", "serial", "full", "mem", "input", "Raw", "unsigned", "json", "row", "aw", "bytes", "draw", " RAW", "read", "n"], "hash": ["ashes", "ash", "zh", "sh", "search", "id", "ASH", "sha", "sum", "message", "ssh", "total", "Hash", "proof", "has", "hidden", "cloth", "bh", "tag", "dump", "key", "ashed", "hex", "code", "tr", "name", "mask", "height", "check", "h", "hat", "html", "mac", "shadow", "unknown", "hed", "password", "component", "result"]}}
{"id1": "2668853", "id2": "7499186", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFiles2Page", "decodeFilesToFile", "decodeFile2Page", "decodeFileAsPage", "decodeFileTOPage", "decodeFiles2Files", "decodeFilesToPage", "decodeFilesToString", "decodeFileAsFile", "decodeFileTOFile", "decodeFile2File", "decodeFileAsFiles", "decodeFileToString", "decodeFileAsString", "decodeFiles2String", "decodeFileToFiles", "decodeFilesToFiles", "decodeFileTOFiles", "decodeFile2Files", "decodeFiles2File", "decodeFileTOString", "decodeFileToPage"], "infile": ["inputbase", "Inbase", "inputpath", " inbase", "innfilename", "inputfilename", "inbase", "inwhere", "outpath", "inputfile", " infilename", "outbase", "inpath", " inwhere", "Inpath", "inputwhere", "inFile", "infilename", "innfile", "innbase", "outFile", "InFile", "Infile", "innwhere", "inputFile"], "outfile": ["listfile", "listfp", "outpath", "OutFile", "Outfilename", "inpath", "outfp", "inFile", "infilename", "infp", "toFile", "tofilename", "Outpath", " outpath", "tofp", "tofile", " outFile", "Outfile", "listfilename", "outFile", "outfilename", " outfilename", "listFile"], "in": ["image", "ins", "din", "inside", "en", "pin", "ini", "IN", "inn", "con", "ai", "user", "io", "inf", "form", "cin", "gin", "on", "bin", "conn", "from", "it", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "o", "info", "isin", "im", " din", "In", "n"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "ent", "con", "ln", "net", "io", "ne", "print", "sys", "on", "it", "outs", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "ion", "can", "write", "opt", "oss", "g", "inner", "os", "flush", "o", "t", "end", "Out", "at", "w", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "queue", "phrase", "stack", "sequence", "tree", "block", "zero", "view", "table", "frame", "bar", "black", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "history", "append", "template", "memory", "number", "display", "mem", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "pe", "stream", "count", "data", "connect", "wait", "select", "through", "each", "print", "Read", "q", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "range", "query", "run", "reader", "seek", "shift", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send"], "success": [" successful", "top", "green", "crit", "same", "sufficient", " convergence", "exist", " succeeds", "security", "warning", "cont", "ratulations", "support", " succeed", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "error", "commit", "status", " successfully", " Success", "democracy", "response", "ceed", " succeeded", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "close", "release", "surv", "growth", " failure", "danger", "summary", "accept", "second", "primary", "ok", "successful", "Success", "master", " successes"]}}
{"id1": "6988216", "id2": "5138455", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" testSimpleQuestion", " testBasicContent", " executeBasicContent", " executeSimpleQuery", " executeSimpleQ", " testBasicQuery", " testBasicQuestion", " executeBasicQuestion", " executeBasicQuery", " executeBasicQ", " testQueryQ", " testQueryQuery", " testRawQuery", " testBasicQ", " testRawQuestion", " executeSimpleQuestion", " testQueryQuestion", " testQueryContent", " testRawQ", " executeSimpleContent", " testRawContent", " testSimpleQ", " testSimpleContent"], "dummySource": ["daummySource", "daummyInput", "dummiesInput", "datalParent", "udeterminedFile", "dummInput", "daatumSource", "duffySource", "dummSourceFile", "datumResource", "udummyFile", "duffySourceFile", "udummySource", "dummyParent", " duffyInput", " duffySource", " duffyContent", "dummiesResource", "daatumStore", "dancyParent", "datalContent", "daatumResource", "determinedSource", "dummySourceFile", "datalSource", "datumInput", "dummyResource", "dummyStore", "dummyInput", "udeterminedContent", "daummyResource", "udeterminedParent", "udummyContent", "dumpSource", "daummyStore", " dummyInput", "determinedContent", "dancySourceFile", "duffyContent", "dumpStore", "daatumInput", "dumpInput", "dummyFile", "dummiesSource", "determinedParent", "dancyContent", "determinedFile", "dumpResource", "udeterminedSource", "datumStore", "dancySource", "dummContent", "dancyFile", "datalFile", "dummSource", "dancyInput", "dummiesStore", " dummySourceFile", "duffyInput", "datumSource", " duffySourceFile", "udummyParent"], "os": ["fs", "oos", "et", "osi", "ot", "ats", "css", "bs", "mos", "ows", "ros", "dis", "ens", "ose", "s", "si", "io", "windows", "ys", "sys", "ms", "obs", "asis", "om", "conn", "js", "or", "ants", "ds", "dos", "oses", "socket", "ts", "oids", "ims", "des", "bos", "ori", "aos", "uts", "ox", "cos", "Os", "pos", "is", "oS", "out", "ui", "ors", "oss", "ops", "es", "ost", "oes", "o", "los", "OS", "oa", "ols", "ios"], "dummyContent": ["DummyInt", "determinedMedia", "dumpText", "dummyText", "deltaMedia", "dummyTemplate", "deltaInt", "dumpingContent", "DummyText", "dummyInt", "dynamicTemplate", "dummyContents", "dumpContent", "dumpingContents", "dumpingCode", "dummyMedia", "deltaContent", " dummyCode", "determinedInt", "dummiesTemplate", "DummyContent", "dummiesContents", " dummiesContents", "determinedText", " dummiesTemplate", "dumpInt", "deltaText", "determinedContent", "dumpMedia", "dynamicContent", "DumpText", "dummyCode", "dummiesCode", " dummyContents", "dumpingTemplate", "DumpInt", "DumpContent", "DumpMedia", "dummiesContent", " dummiesCode", "dynamicCode", "DummyMedia", " dummiesContent", "dynamicContents", " dummyTemplate"], "source": ["image", "core", "scope", "server", "store", "search", "seed", "SOURCE", "relation", "instance", "service", "sin", "s", "user", "google", "sys", "ource", "src", "space", "in", "from", "sf", "resource", "join", "table", "status", "spec", "ser", "sql", "ie", "sp", "proxy", "ace", "template", "pse", "se", "uri", "inner", "sr", "Source", "sample", "site", "series", "use", "result"], "content": ["context", "ontent", "output", "value", "license", "header", "node", "cont", "cache", "script", "data", "message", "Content", "format", "description", "path", "editor", "sequence", "tree", "section", "xml", "example", "application", "text", "article", "status", "resource", "response", "quest", "comment", "key", "expression", "document", " contents", "layout", "code", "body", "current", "txt", "template", "activity", "title", "config", "json", "version", "tx", "summary", "ext", "html", "command", "result", "action"], "qResult": ["queryResult", "dqRes", "queryResults", "iqResponse", "qresult", " qresult", " qResults", " qResponse", "QView", " qRes", "iqResult", "queryRes", "qReport", "qRes", "dqView", "qResults", "iqRes", "Qresult", "iqReport", "QResult", " qView", "qResponse", "qView", "queryResponse", "dqResult", "queryReport", "QRes", "iqResults", " qReport", "dqresult"], "results": ["assets", "roads", "rows", "ults", "terms", "ands", "Results", "values", "olds", "lections", "xes", "events", "data", "features", "runs", "chains", "items", "s", "times", "missions", "orders", "ms", "actions", "tests", "relations", "hips", "RESULTS", "ries", "users", "thumbnails", "ULTS", "products", "reports", "res", "forms", " Results", "objects", "settings", "members", "resources", "archives", "posts", "details", "children", "pages", "Contents", "versions", "its", "blocks", "photos", "views", "result"], "it": ["et", "iz", "exec", "id", "p", "v", "hit", "ait", "It", "m", "they", "in", "st", "ic", "MIT", "pit", "he", "li", "ul", "ite", "init", "op", "IT", "is", "out", "h", "i", "iter", "lit", "mit", "ip", "ci", "its", "t", "stat", "info", "at", "read", "rit"], "rSrc": [" rSsrc", "rSysource", "rSlrs", "crDesrc", "rSlrc", "rSourceRC", "rSrs", "rSourcesrc", "rSlRC", "crDessrc", "rSlcs", "rSourcerc", "rSerc", "rSecs", "rSers", " rSrs", " rSource", "rDesrs", "rSeRC", "rScs", " rSRC", "rSsrc", "crDesRC", "crSrc", "rSysrc", "crDesrs", "rSysRC", "rDessrc", "crSrs", "rSourcers", "crSRC", " rScs", "rDesrc", "rSyssrc", "crSsrc", "rSRC", "rSource", "rDesRC"], "rSrcIn": ["rSetrcOut", "rSRCin", "rSncin", "rSrsIn", "rSetrcIN", "rSldCon", "rSetsrcOut", "rSldInput", "rSetrcin", "rSetsrcIN", "rSrsIN", "rSldIN", "rSldOut", "rSsrcOut", "rSncIn", "rSRCCon", "rSldin", "rSrcIN", "rSRCIn", "rSrcInput", "rSRCOut", "rSrcin", "rSsrcIN", "rSetsrcin", "rSrsInput", "rSetrcIn", "rSldIn", "rSsrcIn", "rSncOut", "rSRCIN", "rSsrcin", "rSrsOut", "rSrcCon", "rSetsrcIn", "rSrcOut", "rSncCon", "rSsrcInput"], "actualOut": ["UALOut", "ualEnd", "ualout", " actualout", "realOut", "actuallyOut", "UALIn", "actuallyIs", "actualout", "virtualIn", "realIs", "realIn", "finalIn", " actualIn", "ualOut", "actuallyCopy", "ualBytes", " actualCopy", "actualIn", "virtualOut", "realCopy", "actualBytes", "finalout", " actualBytes", "ualIn", "actualEnd", "UALBytes", "actuallyIn", "actualIs", " actualIs", " actualEnd", "UALEnd", "finalOut", "actualCopy"]}}
{"id1": "10451698", "id2": "5299276", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["core", "move", "co", "perm", "archive", "transfer", "sync", "delete", "crop", "Cop", "continue", "clip", "opy", "map", "remove", "link", "paste", "export", "Copy", "gc", "file", "share", "proxy", "cp", "zip", "slice", "write", "split", "clone", "create", "cat", "pixel", "download", "cop"], "source": ["image", "original", "scope", "store", "shell", "style", "SOURCE", "class", "cache", "instance", "service", "sin", "index", "secure", "empty", "target", "origin", "ource", "src", "subject", "space", "from", "entry", "in", "raw", "resource", "status", "size", "table", "http", "spec", "note", "sit", "init", "sql", "query", "file", "ie", "body", "base", "directory", "parent", "none", "sp", "name", "force", "unit", "current", "template", "get", "se", "config", "create", "details", "null", "inner", "start", "Source", "ce", "site", "remote", "use", "local"], "destinationDirectory": ["destinateDirectory", "destinatedirectory", "destmentFolder", "identinationLocation", "destinationDir", "destinationdirectory", "destinationsLocation", "identinatorInternal", "destinateFolder", "destmentDirectory", " destationFolder", "destinationInternal", " destationApplication", "destinationsDirectory", "targetinationsFolder", "targetinationsDir", "destinationLocation", "identinatorDirectory", "destarationDirectory", "destinatorDirectory", "destinationsInternal", "destinationApplication", "destinationsFolder", "destationFolder", "identinationInternal", "destineFolder", "destinationsDir", "destinatorLocation", "identinatorLocation", "destarationInternal", "destationApplication", "destineApplication", "targetinationsdirectory", " destinationFolder", "destinateApplication", " destinationdirectory", "destineDirectory", "destationDirectory", "targetinationFolder", "targetinationsDirectory", "identinationDirectory", " destationDirectory", " destationdirectory", "destarationLocation", "destmentDir", "targetinationDirectory", "destinationFolder", " destinationApplication", "destmentdirectory", "destinedirectory", "targetinationdirectory", "targetinationDir", "destinatorInternal", "destinationsdirectory", "destationdirectory"], "newDir": [" newRel", "Newdir", "newsFile", "NewFile", " newFolder", "NewFolder", "newFolder", "nextDir", "newsDir", "newdir", "newRel", "nextdir", " newDirectory", "NewDir", "newsFolder", "NewDirectory", "NewRel", "newsdir", "nextFile", "nextRel", " newdir", "newsDirectory", "newDirectory"], "children": ["pres", "when", "kids", "ls", "stories", "cache", "cont", "classes", "his", "each", "may", "items", "Children", "times", "ml", "files", "packages", "many", "apps", "relations", "links", "follow", "images", "users", "all", "related", "sub", "reports", "gc", "child", "nil", "objects", "members", "services", "jobs", "modules", "keys", "ren", "resources", "details", "bc", "pages", "uploads", "desc", "parents", "ports", "unknown", "projects", "lines", "its", "ids", "names", "groups", "blocks", "these"], "i": ["you", "mi", "u", "iq", "id", "ri", "pi", "ix", "ex", "ini", "us", "ii", "si", "index", "ai", "um", "chain", "bi", "ms", "io", "q", "my", "m", "sim", "me", "in", "ki", "iu", "multi", "ic", "it", "li", "ti", "span", "j", "ij", "xi", "ims", "init", "key", "x", "hi", "ji", "ie", "uu", "base", "phi", "y", "batch", "is", "client", "ui", "gu", "iter", "g", "di", "gi", "json", "ci", "ip", "ski", "t", "remote", "qi", "point", "im", "oi", "info", "I"], "newFile": ["ewfile", "NEWfile", "createDir", "newsFile", "NEWFile", "NewFile", "newTh", "NEWTh", " newfile", "ewLe", "newsGlobal", "Newfile", "nextDir", "newsDir", "ewDir", "NewDir", "goodFile", " newSourceFile", "newsTh", "newLe", "newfile", "ewFile", "createfile", " newGlobal", "newGlobal", "NewLe", "nextfile", "newsfile", "nextFile", "goodSourceFile", "newSourceFile", "NewGlobal", "nextLe", "goodfile", "createFile", "createSourceFile", "goodDir", "NewTh", "NEWDir"], "output": ["update", "object", "stream", "online", "position", "monitor", "cut", "message", "connect", "format", "admin", "blue", "web", "net", "io", "print", "buffer", "block", "network", "text", "writer", "Output", "response", "four", "enabled", "pretty", "ilo", "export", "document", "connection", "file", "console", "auto", "result", "batch", "body", "parent", "put", "current", "open", "out", "write", "display", "client", "internal", "config", "success", "next", "exit", "outer"], "input": ["image", "initial", "operator", "exec", "rc", "Input", "back", "io", "inf", "ink", "form", "buffer", "in", "from", "raw", "it", "ic", "error", "insert", "active", "add", "upload", "storage", "init", "child", "op", "ahead", "reader", "before", "current", "open", "inc", "out", "get", "feed", "internal", "inner", "iter", "unsigned", "start", "ip", "info", "local"], "buff": ["qq", "cmd", "bl", "b", "bs", "uff", "bf", "bed", "old", "uf", "nd", "bo", "data", "buf", "box", "ff", "buffer", "xx", "nb", "bin", "text", "hold", "xff", "fb", "black", "bg", "img", "sb", "seq", "eb", "Buff", "batch", "msg", "ch", "cond", "ind", "mb", "gb", "comp", "txt", "mem", "cat", "tab", "bytes", "printf", "bb", " buf", "bound", "cb", "tt", "pb"], "read": ["length", "readable", " write", "bind", "need", " count", "en", "stream", "old", "count", "select", "each", "like", "ink", "Read", "print", "q", "give", "str", "hello", "buffer", "test", "set", "raw", "push", "text", "hold", "in", "reads", "size", "load", "tell", "add", "reading", "ready", "skip", "READ", "query", "run", "ind", "seek", "before", " Read", "height", "check", "write", "mem", "get", "d", "feed", "find", "iter", "config", "len", "start", "t", "end", "wait", "and", "index", "send", "handle"]}}
{"id1": "8921716", "id2": "10391753", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"MD5": [" mdHash", " md5", "MDHash", "SHA3", "SHA2", "SHAHash", "MD3", " MD2", " md2", "SHA5", " MDHash", " MD3", "MD2", " md3"], "text": ["translation", "context", "value", "output", "pattern", "data", "message", "select", "format", "content", "string", "path", "form", "print", "test", "buffer", "q", "str", "pt", "subject", "term", "aut", "comment", "prefix", "x", "document", "code", "nt", "msg", "act", "name", "word", "event", "out", "txt", "TEXT", "title", "input", "source", "url", "ct", "tx", "t", "ext", "log", "password", "command", "now", "Text", "read"], "UnsupportedEncodingException": ["UnsupportedDecodingEx", "UnsupportedDecoderException", "UnsupportedDecoderError", "UnsupportedDecoderEx", "UnsupportedEncoder ", "UnsupportedEncodedEx", "UnsupportedEncoderEx", "UnsupportedEncodeException", "UnsupportedDecodingError", "UnsupportedEncoderError", "UnsupportedDecodingException", "UnsupportedEncodeError", "UnsupportedEncodingError", "UnsupportedEncoding ", "UnsupportedDecoding ", "UnsupportedEncodeEx", "UnsupportedEncoded ", "UnsupportedDecoder ", "UnsupportedEncodedException", "UnsupportedEncode ", "UnsupportedEncodedError", "UnsupportedEncodingEx", "UnsupportedEncoderException"], "md": [" dist", " rand", "cmd", "dd", "dr", "mt", " done", "der", " sch", "red", "nd", "Cmd", " cmd", " mk", " ok", "deep", "mk", " def", "sd", "od", "ms", "m", "mm", "pt", "pd", "pkg", " cd", " del", "mod", " de", " exec", " df", "add", " med", "dir", "ad", "mond", "mn", "df", "mp", "dm", "mand", "det", "dig", "mb", "ind", "hash", "mail", "h", "grad", "ld", " man", "rm", "di", " ind", "ctr", "bd", " img", "hd", "d", " doc", "MD", "mg"], "md5hash": ["md4hex", "md2sum", " md3hash", "md3key", "md2Hash", " md3h", "md3hash", "md512hex", "MD2Hash", "md5hex", "MD2h", "md2hash", " md4index", "md4hash", "md5sum", " md3Hash", "md3sum", "md7sum", " md5sum", "md5key", "MD5hash", " md3sum", "md3Hash", " md5Hash", "md4h", " md4key", "md3h", "md4sum", "MD5sum", "MD2hash", "md4Hash", " md5index", "MD5h", "md7Hash", "md2h", "md5Hash", "md3index", " md5key", "md512index", "md4key", " md5hex", "md7hash", "md4index", "MD2sum", "md512key", " md4hash", "MD5Hash", "md5index", "md3hex", " md5h", "md5h", "md512hash", "md7h", " md4hex"]}}
{"id1": "7764011", "id2": "17029388", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvViewersDocument", "readScalarpvviewingDoc", "readScalarpvviewersFile", "readScalarpvviewedDoc", "readScalarpvviewerdocument", "readScalarpvviewersdocument", "readScalarpvviewingdocument", "readScalarpvViewerDocument", "readScalarpvViewerdocument", "readScalarpvviewerFile", "readScalarpvviewersDoc", "readScalarpvviewingFile", "readScalarpvViewersDoc", "readScalarpvviewersDocument", "readScalarpvviewedFile", "readScalarpvViewerDoc", "readScalarpvviewedDocument", "readScalarpvViewersdocument", "readScalarpvViewerFile", "readScalarpvviewerDoc", "readScalarpvviewingDocument", "readScalarpvViewersFile", "readScalarpvvieweddocument"], "url": ["loc", "rel", "sl", "ssl", "b", "id", "location", "ls", "dl", "data", "char", "web", "buffer", "rect", "str", "xml", "ll", "ret", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "URL", "document", "file", "res", "cert", "address", "name", "open", "mount", "mail", "r", "uri", "Url", "l", "util"], "xmlData": ["phpdata", "mlPart", "mlText", "phpContent", "jsonQuery", "xfQuery", "phpData", "xpdata", "xmlString", "xfData", "xpString", "phpText", "xpDat", "xmlPart", "phpName", " xmlQuery", "xmlContent", "xfDat", "logData", "xmlDat", "logdata", "logDat", "jsonDat", "jsonText", " xmlText", "logString", " xmlDat", "mlContent", " xmlContent", " xmldata", "xmlText", "mldata", "mlData", " xmlName", "xmlName", "xmlQuery", "xpData", "xmldata", "mlName", "jsonData", "phpPart", " xmlPart", " xmlString", "xfText"], "in": ["ins", "din", "ri", "IN", "inn", "con", "inf", "cin", "gin", "m", "bin", "from", "re", "add", "all", "as", "thin", "mc", "file", "reader", "is", "inc", "out", "rin", "doc", "i", "input", "r", "inner", "conf", "isin", "info", " din", "In"], "line": ["record", "node", "port", " Line", "detail", "ln", "lo", "le", "normal", "section", "lin", "nl", "link", "note", "page", "comment", "range", "file", "code", "change", "lock", "check", "se", "row", "log", "point", "length", "column", "pe", "online", "string", "chain", "print", "entry", "trace", "item", "no", "l", "lines", "ine", "header", "zone", "data", "message", "content", "user", "str", "continue", "raw", "inline", "Line", "stroke", "stay", "lined", "word", "source", "field", "liner", "eline", "list", "sequence", "cell", "phrase", "block", "text", "part", "frame", "piece", "force", "iter", "next", "LINE", "sample"], "cont": ["const", "crit", "cmd", "contained", "co", "exist", "contin", "count", "keep", "each", "circ", "con", "content", "chain", "any", "valid", "str", "nav", "continue", "ont", "multi", "c", "Cont", "CONT", "control", "cart", "code", "cond", "current", "cmp", "txt", "mult", "loop", "cur", "iter", "conv", "cat", "cons", "ctr", "coll", "ct", "rest", "next", "first", "compl"], "readAdp": ["readadn", " readADping", "readadj", " readADp", " readAdlp", "ReadAdr", "readAdlp", "readAdamP", "ReadADP", "readadr", "ReadAdP", "readAdamn", "readADn", " readADr", "ReadAdlp", "Readadp", "ReadAdp", "ReadADp", "readadlp", "readAdamp", " readADj", " readADP", "ReadAdj", "readAmlp", "readadP", "readInterP", "readAmr", " readAdn", " readAdr", "readAdn", "readADP", "ReadADr", "readInterj", " readAdj", " readAdping", "ReadadP", "readAmp", "Readadj", "readadping", "readAdamping", "readInterp", "readadp", "readAdping", "readInterlp", "readAdP", "ReadADlp", "readADlp", " readADn", "Readadlp", " readADlp", "readAdj", "readADr", " readAdP", "readADping", "readAmP", "readADj", "readADp", "readAdr"], "scalarpvviewerData_Adaptor": ["scalarpvviewerData2Adaptors", "scalarpvviewerData_Axorer", "scalarpvviewerData_adapter", "scalarpvviewerData2adapto", "scalarpvviewerData2adaptr", "scalarpvviewerData_Connectable", "scalarpvviewerData2adaptOR", "scalarpvviewerData_adaptable", "scalarpvviewerData_Acceptors", "scalarpvviewerData_Adaptr", "scalarpvviewerData_ArchOR", "scalarpvviewerData_Adjustor", "scalarpvviewerData_adaptor", "scalarpvviewerData_adaptors", "scalarpvviewerData_Adjustable", "scalarpvviewerData2adaptors", "scalarpvviewerData2Adapto", "scalarpvviewerData_Adr", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Connector", "scalarpvviewerData_Acceptor", "scalarpvviewerData_Adaptors", "scalarpvviewerData_Adjustors", "scalarpvviewerData_AdjustOR", "scalarpvviewerData_Adaptorer", "scalarpvviewerData2adapter", "scalarpvviewerData2adaptor", "scalarpvviewerData_adaptr", "scalarpvviewerData2Adapter", "scalarpvviewerData_Accepter", "scalarpvviewerData2Adaptor", "scalarpvviewerData_Axable", "scalarpvviewerData2AdaptOR", "scalarpvviewerData_AxOR", "scalarpvviewerData_Adapter", "scalarpvviewerData_Adapto", "scalarpvviewerData_adapto", "scalarpvviewerData_Ado", "scalarpvviewerData_AdOR", "scalarpvviewerData_Adaptable", "scalarpvviewerData_Connectors", "scalarpvviewerData_Archorer", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Ader", "scalarpvviewerData2Adaptr", "scalarpvviewerData_adaptOR", "scalarpvviewerData_Archable", "scalarpvviewerData_Ador", "scalarpvviewerData_Axor", "scalarpvviewerData_Archor", "scalarpvviewerData_adaptorer", "scalarpvviewerData_Accepto", "scalarpvviewerData_Adors"], "params_font": ["params7Font", " params2font", "params6pen", " params_tt", "params_pen", "params_template", "params2Font", " params2Font", "params___font", "params12font", " params_Font", "params_shadow", "params_system", "params12system", "params_brand", " params_ont", "params_text", "params7font", " params_text", "params6font", "pretty_pen", "params___text", "pretty_font", "params_tt", "params_style", "params7system", "params2font", "params12shadow", "params2shadow", "params_ont", "pretty_layout", "pretty_brand", "params_Font", "params6brand", " params2shadow", " params_style", "params6layout", " params2system", "params7shadow", "params___ont", " params_template", "params___tt", "params_layout", "params2system", " params_system", "params12Font", " params_shadow"], "font_size": [" font_SIZE", " font_height", " font_speed", "font_family", " font_family", " font_width", "font_height", "font_speed", " font_Size", "font_Size", "font_SIZE", "font_width"], "style": ["value", "country", "angle", "position", "mode", "script", "show", "pattern", "class", "format", "stable", "color", "margin", "Style", "state", "theme", "weight", "error", "sche", "status", "size", "estyle", "stroke", "link", "sty", "layout", "styles", "less", "family", "role", "height", " Style", "les", "shadow", "type", " styles", "padding", "css", "font", "handle"], "font_Family": ["font_Style", " fontNamefamily", "family_Style", "fontNameRole", "font_Role", "font_family", "fontNameName", " font_family", "fontTypefamily", "family_Family", " font_Role", " fontNameRole", "fontTypeRole", "family_Name", "font_Name", "family_family", "fontNameFamily", "fontNameStyle", "fontTypeFamily", "fontNamefamily", " fontNameFamily"], "globalFont": ["globalFamily", "foreignFont", "commonFontSize", "generalFontSize", "GlobalFont", "generalFloat", "globalFontSize", "localFont", "foreignFamily", "localFamily", " globalFontSize", "commonFont", "generalONT", "localFontSize", "globalONT", "globalFloat", "generalFont", "GlobalFloat", "foreignFontSize", " globalONT", " globalFloat", "GlobalFontSize", "GlobalONT", "commonFamily"], "params_pts": ["params_xt5", "params_ntm", "params_ntjs", "params_cts", "params_ntls", "params_ntis", "params2ptts", "params_ntts", "params_ptm", "params_brts", "params_ntt", "params_ntes", "params_ptes", "params2nts", "params_ptts", "params_nties", "params2ntjs", "params2pts", "params_xts", "params_ptyis", "params_ptis", "params_ptls", "params_ctts", "params_iptes", "params2nties", "params_brs", "params2ntts", "params_brjs", "params2ptjs", "params_ctm", "params_pt5", "params_ctt", "params_iptm", "params_ctes", "params_pties", "params_nts", "params_bries", "params_xtls", "params_nt5", "params_ptys", "params_xtis", "params_cties", "params_ipts", "params_ctjs", "params_ptyls", "params_ptjs", "params_iptt", "params2pties", "params_pty5", "params_ptt"], "params_data": ["args_", "param_", " paramsPar", "argsPar", "paramPar", " params_", "params_", "paramsPar"]}}
{"id1": "13362846", "id2": "16378239", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 1, "substitutes": {"setContenu": ["setcontenU", "setContensenue", "setContensenu", "setCont\u00ednue", "setContennu", "setcontenux", "setContennux", "setcontenue", "setcontensenU", "setcontensenux", "setContensenU", "setContennU", "setContenue", "setContenux", "setcontensenu", "setContennue", "setContenU", "setCont\u00ednU", "setCont\u00ednux", "setCont\u00ednu", "setcontenu", "setContensenux", "setcontensenue"], "contenuFichier": ["contenuFichtIER", "contenuFamilyichiere", "contenuFachiere", "contenuFigniere", "contenuFochier", "contenuFithorie", "contenuVichyr", "contenuFicheie", "contenuFiverieri", "contenuVechiest", "contenuFamilyichier", "contenuFileichiere", "contenuFrenchire", "contenuMicheer", "contenuFicheorie", "contenuFechiere", "contenuFuffer", "contenuFolfieri", "contenuVichiest", "contenuFuffieri", "contenuFichie", "contenuMichiere", "contenuFicheer", "contenuFrenchaire", "contenuFsechieri", "contenuFsicher", "contenuFamilyachorie", "contenuFignaire", "contenuVechyr", "contenuFiverire", "contenuFicheaire", "contenuFithie", "contenuFithiest", "contenuFechyr", "contenuFsechire", "contenuFochiere", "contenuFichiers", "contenuFchIER", "contenuFsechier", "contenuFuffier", "contenuFolfier", "contenuFochiers", "contenuFsichier", "contenuFCher", "contenuFihier", "contenuFchiere", "contenuMicheiere", "contenuMichier", "contenuVchiere", "contenuFileochiere", "contenuFChiere", "contenuFichIER", "contenuFchier", "contenuFichtie", "contenuFchie", "contenuFsichire", "contenuMichaire", "contenuFileochier", "contenuFileichie", "contenuFsrenchier", "contenuFsichaire", "contenuFichire", "contenuMicheier", "contenuFChaire", "contenuFachier", "contenuFithiere", "contenuFignier", "contenuFachorie", "contenuFechieri", "contenuFechire", "contenuFochie", "contenuFihyr", "contenuFechier", "contenuFicheiers", "contenuFachie", "contenuFechiest", "contenuFichaire", "contenuFamilyachiere", "contenuVichier", "contenuFihiest", "contenuFsrenchieri", "contenuFigner", "contenuFsrenchaire", "contenuFichyr", "contenuFolfire", "contenuFochIER", "contenuMicher", "contenuFichiest", "contenuFolfer", "contenuFsichieri", "contenuFicheiere", "contenuMicheaire", "contenuFileochie", "contenuVchier", "contenuFithier", "contenuFrenchieri", "contenuFamilyachie", "contenuFsrenchire", "contenuFsecher", "contenuFicheire", "contenuFileochiers", "contenuVichiere", "contenuFamilyachier", "contenuFichtier", "contenuFithyr", "contenuFiverier", "contenuFicher", "contenuVchIER", "contenuVechier", "contenuFicheieri", "contenuVechiere", "contenuFichorie", "contenuVichie", "contenuFihiere", "contenuFileichier", "contenuFichtiere", "contenuVchie", "contenuFamilyichie", "contenuFachiers", "contenuFrenchier", "contenuFChier", "contenuFicheier", "contenuFecher", "contenuVichIER", "contenuFiveraire", "contenuFichieri", "contenuFichiere", "contenuFuffire", "contenuFileichiers", "contenuFamilyichorie"], "fichierElectronique": ["fichierAdministroniques", "fichierAdministroniq", "fichierTransferradorie", "fichierTransferradoric", "fichierElectromie", "fichierElectroneoch", "fichierElectradorie", "fichierElectrenaire", "fichierCentronius", "fichierelectrenier", "fichierelectronique", "fichierElectronicy", "fichierElectrenius", "fichierElectrenier", "fichierElectrontipolar", "fichierElectRONius", "fichierElectradorius", "fichierElectronipolar", "fichierelectronier", "fichierElectchronoch", "fichierAdministronique", "fichierelectroniques", "fichierElectronsiq", "fichierElectromius", "fichierElectronic", "fichierElectradorique", "fichierElectronsiques", "fichierElectronaire", "fichierElectroneic", "fichierElectronticity", "fichierElectroneius", "fichierElectroneiques", "fichierElectchronique", "fichierElectroneipolar", "fichierSelectroneique", "fichierCentronique", "fichierElectronicity", "fichierTransferradorius", "fichierAdministroneiq", "fichierElectonique", "fichierElectonier", "fichierElectroneie", "fichierElectreniques", "fichierSelectronicity", "fichierTransferronius", "fichierElectroneique", "fichierElectromique", "fichierElectroneiq", "fichierElectriciq", "fichierAdministroneie", "fichierElectronier", "fichierElectronsique", "fichierElectRONicy", "fichierElectroneaire", "fichierElectronie", "fichierAdministroneique", "fichierElectronsier", "fichierElectrenicy", "fichierElectromicity", "fichierelectrenic", "fichierSelectroneicity", "fichierElectroniq", "fichierElectromaire", "fichierSelectronoch", "fichierElectchroniques", "fichierElectoniques", "fichierTransferronie", "fichierCentRONicy", "fichierElectrenic", "fichierSelectronique", "fichierElectroniques", "fichierTransferradorique", "fichierelectrenique", "fichierElectronsie", "fichierElectrontique", "fichierSelectroneiques", "fichierElectricique", "fichierElectronoch", "fichierElectronius", "fichierElectradoric", "fichierAdministroneiques", "fichierElectrontaire", "fichierSelectroniques", "fichierElectRONique", "fichierAdministronie", "fichierElectroneicity", "fichierelectreniques", "fichierElectchronius", "fichierElectricie", "fichierCentRONaire", "fichierElectRONaire", "fichierElectrenique", "fichierCentRONius", "fichierElectromipolar", "fichierElectronsicity", "fichierCentronaire", "fichierTransferronique", "fichierElectchronicy", "fichierElectronsic", "fichierSelectroneoch", "fichierElectromic", "fichierElectchronaire", "fichierCentronicy", "fichierElectronsoch", "fichierElectchronicity", "fichierTransferronic", "fichierElectonic", "fichierelectronic", "fichierElectriciques", "fichierCentRONique"], "utilisateurCourant": ["utilisateurRepresentant", "utilisateurRepresentante", "utilisateursCourant", "utilisateursGovernante", "utilisateurGovernants", "utilisateursGoverniant", "utilisateurGovernant", "utilisateurCourante", "utilisateurRepresentants", "utilisateursGovernant", "utilisateurCourants", "utilisateursCourante", "utilisateursGovernants", "utilisateurParticipante", "utilisateursCourants", "utilisateurRepresentiant", "utilisateurParticipiant", "utilisateurParticipants", "utilisateurCouriant", "utilisateursCouriant", "utilisateurParticipant", "utilisateurGovernante", "utilisateurGoverniant"], "support": ["context", "cover", "access", "know", "supp", "port", "language", "profile", "format", "feature", "please", "allow", "service", "proof", "pport", "collection", "supported", "Support", "control", "replace", "storage", "install", "cap", "prototype", "document", " Support", "share", "force", "library", "see", "SUP", "system", "trust", "help", "null", "evidence", "success", "accept", "media", "use", "history"], "ficheDocument": ["ficheMatrix", "fitimeMatrix", "facheTree", "FicheDoc", "frenchDoc", "fayeDatabase", "fcheDocument", " frenchDescription", " frenchDatabase", "fayeDoc", "fachedocument", "flicheMatrix", "hicheTransaction", "facheTransaction", "fruitTransaction", "FicheDatabase", "fiqueDescription", "facheDoc", "fruitDocument", "fliciDatabase", "foyerTree", " frenchDocument", "fifaDocuments", "bacheDatabase", "frenchTransaction", "fcheDoc", "fcheDatabase", "facheDocument", "fliciMatrix", "fichedocument", "FayeDocument", "hacheDocument", "hicheDocument", "ficheDescription", "bicheDatabase", "FayeDoc", "ficheDocuments", "facheDatabase", "foyerDoc", "fitimeDocument", "fifaDatabase", "flicheDatabase", "ficheTree", "FicheDocument", "FayeDatabase", "bicheTree", "fiqueDatabase", "ficidocument", "ficheTransaction", "fiqueDocument", "ficiDocument", "foyerDatabase", "ficiJournal", "ficiDatabase", "hichedocument", "fitimeTransaction", "FayeDocuments", "bacheTree", "fifaDocument", "hicheJournal", "fitimeDescription", "bacheDoc", "hacheTransaction", "fayeDocument", "ficiTransaction", "ficheJournal", "bicheDocument", "ficheDoc", "fitimeDatabase", " ficheDescription", "foyerDocument", "flicheTransaction", "fruitJournal", "flicheDocument", "frenchDescription", "facheJournal", "fruitdocument", "hacheJournal", "frenchDocuments", "bicheDoc", "fliciTransaction", "frenchDocument", "fliciDocument", "bacheDocument", "ficheDatabase", " ficheDatabase", "fcheTree", "frenchMatrix", "fayeDocuments", "frenchDatabase", "ficiMatrix", "fifaDoc", "hachedocument", "FicheDocuments"], "nomFichier": ["nomNolfiere", "nomUFachIER", "nomUFachery", "nomPachier", "nomPichier", "nomFilicER", "nomFolfire", "nomPFichiller", "nomPacherer", "nomFicheer", "nomFihier", "nomFicheiner", "nomFiverIER", "nomFilicier", "nomPFoilER", "nomFericanger", "nomFchire", "nomFichiller", "nomFachie", "nomFolfiere", "nomFchomer", "nomFachire", "nomFichoier", "nomUFichier", "nomFichancer", "nomPFoiljer", "nomUFichire", "nomFchiere", "nomFicheiere", "nomPichire", "nomFicheire", "nomUFachier", "nomFacher", "nomFchier", "nomFicher", "nomUFichIER", "nomPFoilier", "nomFihire", "nomFiverire", "nomFolfier", "nomFachanger", "nomFichoancer", "nomUFichery", "nomNichie", "nomFicier", "nomPFoililler", "nomFichanger", "nomFachery", "nomFicerer", "nomFoiljer", "nomPichomer", "nomFachiere", "nomFachancer", "nomPicherer", "nomPachomer", "nomNichier", "nomFichery", "nomPFichER", "nomPFichjer", "nomFicomer", "nomFoililler", "nomNichire", "nomFilicjer", "nomFichiere", "nomFichjer", "nomPFichier", "nomFachiner", "nomFolfie", "nomFachomer", "nomFchiner", "nomFacherer", "nomFihery", "nomUFachire", "nomFcherer", "nomFoilier", "nomFericIER", "nomFiverier", "nomFericancer", "nomFicherer", "nomNolfie", "nomFoilER", "nomNichiere", "nomFichomer", "nomFicire", "nomFicjer", "nomFachier", "nomFichiner", "nomNolfier", "nomFichIER", "nomFichoanger", "nomFicER", "nomFiverery", "nomFericier", "nomFachIER", "nomFichER", "nomFihIER", "nomFiliciller", "nomFiciller", "nomFichoIER", "nomFichire", "nomNolfire", "nomFichie", "nomFcher", "nomPachire", "nomFicheie", "nomFicheier"], "extension": ["protension", "expractor", "Extension", "xtensions", "strension", "xtending", "contention", "protractor", "xtension", "expention", "extention", "extitude", "strensions", "strending", "expension", "Extensions", "Extending", "extractor", "contension", "protention", "contitude", "expitude", "extending", "protitude", "extensions", "contractor"], "fichierElectroniqueExistant": ["fichierElectroniqueExistent", "fichierElectroniquePersister", "fichierElectroniqueAssistant", "fichierElectronogramLocalistent", "fichierElectroniquePersistant", "fichierElectronicityExert", "fichierElectronogramExistant", "fichierElectroniqueExiker", "fichierElectroniquePlusister", "fichierElectronogramExistance", "fichierElectroniqueAssclusive", "fichierElectronicityInert", "fichierElectroniqueExert", "fichierElectronogueExistent", "fichierElectroniqueLocalistent", "fichierElectroniqueExplert", "fichierElectronogramExclusive", "fichierElectroniqueExvant", "fichierElectroniqueLocalistant", "fichierElectroniqueLocalistance", "fichierElectroniquePlusistent", "fichierElectronogueExiker", "fichierElectroniqueInistance", "fichierElectronogueExister", "fichierElectroniqueInert", "fichierElectroniqueExplvant", "fichierElectroniqueInvant", "fichierElectroniquePlusistant", "fichierElectroniquePresentistent", "fichierElectroniqueEXvant", "fichierElectroniqueInistent", "fichierElectroniquePersiker", "fichierElectroniqueExclusive", "fichierElectroniquePersistent", "fichierElectronogramLocalistance", "fichierElectroniqueExister", "fichierElectronicityExvant", "fichierElectroniqueAssistent", "fichierElectronogueExistant", "fichierElectroniqueExplistant", "fichierElectronicityExistant", "fichierElectronogramLocalclusive", "fichierElectroniqueInistant", "fichierElectroniqueInclusive", "fichierElectroniquePresentiker", "fichierElectronicityInistant", "fichierElectroniquePresentistant", "fichierElectronicityInistance", "fichierElectroniqueExplistance", "fichierElectronoguePersistent", "fichierElectroniquePlusiker", "fichierElectroniqueExistance", "fichierElectroniqueEXistant", "fichierElectroniqueAssistance", "fichierElectroniqueEXert", "fichierElectronoguePersistant", "fichierElectronicityExistance", "fichierElectronicityInvant", "fichierElectronogramExistent", "fichierElectronoguePersister", "fichierElectroniqueEXistance", "fichierElectroniqueLocalclusive", "fichierElectronoguePersiker", "fichierElectronogramLocalistant", "fichierElectroniquePresentister"], "idIgid": ["idIgdido", "idIgids", "idIigmaddress", "idIgcido", "idIgcoid", "idIvgkey", "idIIgzido", "idIigmid", "idIigmlimit", "idAgid", "idIgaddress", "idIgzida", "idImglimit", "idAgaddress", "idIegdata", "idIvgdata", "idIvgids", "idIkgis", "idAmgis", "idIegid", "idIgcid", "idImgis", "idIIgido", "idIegkey", "idAmgid", "idImgaddress", "idImgdata", "idIkgaddress", "idIgis", "idIIgid", "idIIgzida", "idIIgida", "idIgoid", "idImgkey", "idIgcida", "idIgzoid", "idAglimit", "idAmgaddress", "idIkglimit", "idIgzid", "idImgids", "idIigmis", "idIgida", "idIgdida", "idIgdid", "idIkgid", "idImgid", "idIvgid", "idIgzido", "idIgkey", "idAgis", "idIgdata", "idIIgzoid", "idIglimit", "idAmglimit", "idIIgzid", "idIgdoid", "idIIgoid", "idIgido", "idIegids"], "inputStream": [" inputThread", "InputTime", "InputThread", "imageSteam", "helloStreamer", "outputThread", "InputSteam", "inputThread", "outputstream", " inputSteam", " inputstream", "inputStreamer", " inputLoop", "inputstream", "inputSteam", "helloStream", "imageTime", "Inputstream", "inputChannel", "outputChannel", "imageLoop", "inputLoop", "InputStream", "helloSteam", "helloChannel", "imageStream", "outputSteam", "InputLoop", " inputChannel", " inputStreamer", "outputStreamer", "inputTime", " inputTime"], "outputStream": [" outputSteam", "inputView", "webView", "sequenceStream", " outputStyle", "outputStyle", "sequenceStreamer", "inputForm", "OutputStyle", "sequenceSteam", "sequenceStyle", "OutputStream", "inputSteam", "webStream", "OutputView", " outputView", "webStreamer", "OutputSteam", "OutputForm", " outputStreamer", "writeView", "writeForm", "writeStream", "outputSteam", "outputForm", "outputView", "webSteam", "OutputStreamer", "outputStreamer", "writeSteam"], "typeMime": ["TypeMIME", "typemime", "typeSmime", "Typemme", "typeRme", "typeMme", "typeRIME", "Typemim", "typeSmIME", "TypeMime", "TypeMme", "Typemime", "typeRime", "TypeMim", "typeSmme", "typeRim", "typeMim", "typemim", "TypemIME", "typemme", "typeSmim", "typeMIME", "typemIME"], "tailleFichier": [" tailleficheie", " tailleFixies", " tailleFuzziers", " taillefichie", " tailleFixiers", " tailleFuzzie", " tailleficheier", " tailleFicheier", " tailleficheiers", " taillefichies", " tailleFixie", " tailleFuzzies", " tailleficheies", " tailleFicheies", " tailleFicheiers", " tailleFichie", " tailleFuzzier", " tailleFichies", " tailleFicheie", " taillefichier", " tailleFixier", " tailleFichiers", " taillefichiers"]}}
{"id1": "19235551", "id2": "15645004", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"handleFCLAException": ["handleFCAError", "handleFCMAError", "handleFCARequest", "handleICMARequest", "handleICMAException", "handleFCCLAImage", "handleFCLAImage", "handleICLAError", "handleFCLAError", "handleICLAException", "handleICLAImage", "handleFCAException", "handleFCAImage", "handleFCCLAException", "handleFCCLARequest", "handleFCLARequest", "handleICMAImage", "handleICLARequest", "handleFCMARequest", "handleFCMAException", "handleFCCLAError", "handleFCMAImage", "handleICMAError"], "params": ["rs", "las", "headers", "gs", "pretty", "ims", "shape", "sql", "settings", "pos", "details", "ops", "results", "includes", "ports", "versions", "ids", "param", "models", "features", "items", "files", "ctx", "spec", "requires", "reports", "layout", "vs", "styles", "keys", "conf", "tools", "errors", "lines", "plugins", "tags", "terms", "pres", "papers", "properties", "actions", "cases", "services", "modules", "posts", "parts", "steps", "config", "docs", "parents", "padding", "names", "rules", "ps", "stats", "pins", "comments", "values", "vals", "types", "pps", "packages", "options", "marks", "ams", "codes", "helps", "changes", "fixes", "members", "points", "rison", "units", "photos", "tests"], "uri": ["cli", "folder", "distance", "surface", "uid", "ri", "id", "description", "path", "bid", "http", "report", "range", "prefix", " URI", "file", "menu", "controller", "username", "local", "pi", "length", "server", "domain", "du", "doi", "archive", "io", "then", "form", "term", "volume", "direction", "browser", "init", "ori", "unit", "wiki", "filename", "version", "grab", "loc", "copy", "message", "subject", "request", "resource", "dir", "query", "library", "msg", "slice", "iri", "cue", "source", "route", "ip", "component", "processor", "near", "har", "ini", "umi", "queue", "origin", "handler", "uni", "database", "URI", "duration", "function", "force", "proxy", "directory", "phi", "ui", "i", "href", "html"], "url": ["image", "rel", "sl", "ssl", "b", "https", "location", "ls", "dl", "channel", "window", "char", "string", "web", "m", "str", "ll", "ret", "resource", "http", "rl", "nl", "link", "browser", "ur", "URL", "file", "library", "address", "open", "client", "mail", "r", "Url", "l", "null", "result"], "connection": ["image", "context", "object", "output", "server", "position", "channel", "Connection", "connect", "data", "communication", "relation", "description", "con", "process", "pointer", "generation", "database", "network", "conn", "c", "collection", "resource", "response", "page", "session", "sql", "document", "connected", "reference", "open", "client", "still", "close", "statement", "condition", " Connection", "command", "result"]}}
{"id1": "19086952", "id2": "5035872", "code1": "    public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException {\n        String fullPath = url.toString();\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        final long length = conn.getContentLength();\n        if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\");\n        return createInputStreamResponse(in, conn.getContentType(), length, connection);\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"createUrlResponse": ["createurlResponse", "createFileresponse", "createURLresponse", "createurlView", " createUrlresponse", " createUrlResp", " createURLView", "createUrlView", " createURLresponse", "createUrlResp", "createURLResp", "createURLView", " createURLResponse", "createurlResp", "createFileView", " createUrlView", "createFileResp", "createURLResponse", "createurlresponse", " createURLResp", "createUrlresponse", "createFileResponse"], "url": ["image", "loc", "host", "el", "ssl", "domain", "gl", "org", "b", "location", "ls", "dl", "char", "email", "bel", "string", "path", "web", "str", "parser", "xml", "ll", "http", "nl", "link", "browser", "ur", "sql", "URL", "document", "file", "cert", "build", "base", "address", "name", "client", "mail", "mount", "call", "pl", "get", "uri", "Url", "l", "html", "job"], "connection": ["callback", "context", "processor", "output", "server", "position", "location", "computer", "channel", "Connection", "message", "connect", "communication", "nc", "description", "thread", "relation", "window", "con", "self", "process", "handler", "generation", "database", "subject", "ctx", "network", "application", "entry", "c", "writer", "response", "link", "socket", "reason", "to", "creator", "usage", "session", "document", "builder", "directory", "intention", "pool", "connected", "controller", "current", "ion", "client", "open", "number", "config", "close", "condition", "log", "remote", "using", "command"], "fullPath": [" fullName", "Fullpath", "fullName", "partialPath", "partialPort", " fullpath", "FullPort", "partialName", "FullPath", "partialpath", " fullPort", "FullName", " fullUrl", "fullUrl", "partialUrl", "fullPort", "FullUrl", "fullpath"], "conn": ["loc", "ann", "num", "cmd", "alloc", "exec", "co", "enc", "connect", "nc", "Connection", "canon", "iw", "reg", "jp", "con", "cfg", "cell", "ns", "ctx", "resp", "c", "col", "comm", "j", "init", "pg", "res", "Conn", "obj", "cert", "nt", "connected", "ch", "cp", "open", "cur", "oss", "proc", "conv", "conf", "desc", "ct", "cb", "cont", "n"], "in": ["mi", "ins", "inside", "din", "en", "stream", "sum", "IN", "inn", "user", "inf", "gin", "cin", "m", "on", "bin", "from", "or", "and", "sql", "ad", "file", "mc", "ma", "body", "reader", "ind", "is", "inc", "out", "rin", "get", "i", "input", "inner", "isin", "In", "n"], "length": ["distance", "value", "position", " Length", "count", "data", "message", "total", "enc", "description", "string", "loss", "path", "sequence", "buffer", "duration", "offset", "HH", "text", "volume", "size", "load", "frame", "width", "impl", "shape", "left", "ength", "amount", "phi", "address", "family", "height", "h", "loop", "number", "len", "filename", "l", "type", "padding", "time", "end", "Length", "history", "result", "ENGTH"]}}
{"id1": "1362", "id2": "1966310", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["gobbleLess", "gobbleSort", "gobblingSort", "gobblingCompare", "bubblingCompare", "bubblingSort", "bubbleCompare", "bubargeLess", "bubargeSort", "bubblesCompare", "bubargeCompare", "bubbleLess", "bubblesLess", "gobbleCompare", "bubblesSort", "gobblingLess", "bubblingLess"], "a": ["f", "ia", "arr", "isa", "el", "aa", "z", "b", "p", "v", "ata", "apa", "alpha", "cache", "ea", "data", "window", "ga", "oa", "area", "list", "ae", "order", "form", "ed", "an", "aka", "ac", "au", "ab", "c", "array", "da", "trace", "va", "all", "aaa", "as", "la", "ma", "era", "act", "changes", "history", "out", "ap", "h", "aaaa", "g", "ao", "es", "eas", "app", "l", "na", "o", "t", "att", "go", "w", "A", "sa", "am"], "swapped": ["Swapping", "stickaps", "scapping", "SWaped", "Swap", " swap", " swaped", " swaps", "scapped", "snapped", "stickaped", "SWap", "wapping", "snaps", "swaps", "waps", "wapped", "scaps", "scaped", "snaped", "stickapped", " snapped", "waped", "SWapped", " snaped", "Swaped", "stickapping", "swap", " snap", "snapping", " swapping", "SWapping", "swaped", "swapping", " snapping", "Swapped"], "i": ["f", "cli", "mi", "ami", "u", "id", "pi", "ri", "ix", "ir", "ini", "ii", "us", "si", "ai", "io", "bi", "chain", "origin", "my", "m", "sim", "iso", "me", "in", "iu", "ki", "multi", "ic", "c", "it", "ei", "status", "li", "ti", "ij", "j", "xi", "uli", "init", "key", "x", "hi", "ori", "ji", "ie", "zi", "base", "phi", "y", "ind", "is", "iri", "client", "ui", "gu", "uri", "di", "oi", "gi", "ci", "ip", "t", "qi", "im", "index", "I"], "tmp": ["tg", "same", "perm", "sup", "cache", "mk", "test", "xy", "attr", "my", "ctx", "nb", "pre", "m", "gm", "amp", "tf", "sq", "clip", "pkg", "timeout", "etc", "orig", "emp", "prefix", "nom", "obj", "sam", "mut", "managed", "mp", "sp", "cmp", "comp", "txt", "cur", "td", "db", "MP", "t", "temp", "np", "lib", "tt", "result"]}}
{"id1": "6988216", "id2": "13516684", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" testSimpleQuestion", " testBasicContent", " executeBasicContent", " executeSimpleQuery", " executeSimpleQ", " testBasicQuery", " testBasicQuestion", " executeBasicQuestion", " executeBasicQuery", " executeBasicQ", " testQueryQ", " testQueryQuery", " testRawQuery", " testBasicQ", " testRawQuestion", " executeSimpleQuestion", " testQueryQuestion", " testQueryContent", " testRawQ", " executeSimpleContent", " testRawContent", " testSimpleQ", " testSimpleContent"], "dummySource": ["daummySource", "daummyInput", "dummiesInput", "datalParent", "udeterminedFile", "dummInput", "daatumSource", "duffySource", "dummSourceFile", "datumResource", "udummyFile", "duffySourceFile", "udummySource", "dummyParent", " duffyInput", " duffySource", " duffyContent", "dummiesResource", "daatumStore", "dancyParent", "datalContent", "daatumResource", "determinedSource", "dummySourceFile", "datalSource", "datumInput", "dummyResource", "dummyStore", "dummyInput", "udeterminedContent", "daummyResource", "udeterminedParent", "udummyContent", "dumpSource", "daummyStore", " dummyInput", "determinedContent", "dancySourceFile", "duffyContent", "dumpStore", "daatumInput", "dumpInput", "dummyFile", "dummiesSource", "determinedParent", "dancyContent", "determinedFile", "dumpResource", "udeterminedSource", "datumStore", "dancySource", "dummContent", "dancyFile", "datalFile", "dummSource", "dancyInput", "dummiesStore", " dummySourceFile", "duffyInput", "datumSource", " duffySourceFile", "udummyParent"], "os": ["fs", "oos", "et", "osi", "ot", "ats", "css", "bs", "mos", "ows", "ros", "dis", "ens", "ose", "s", "si", "io", "windows", "ys", "sys", "ms", "obs", "asis", "om", "conn", "js", "or", "ants", "ds", "dos", "oses", "socket", "ts", "oids", "ims", "des", "bos", "ori", "aos", "uts", "ox", "cos", "Os", "pos", "is", "oS", "out", "ui", "ors", "oss", "ops", "es", "ost", "oes", "o", "los", "OS", "oa", "ols", "ios"], "dummyContent": ["DummyInt", "determinedMedia", "dumpText", "dummyText", "deltaMedia", "dummyTemplate", "deltaInt", "dumpingContent", "DummyText", "dummyInt", "dynamicTemplate", "dummyContents", "dumpContent", "dumpingContents", "dumpingCode", "dummyMedia", "deltaContent", " dummyCode", "determinedInt", "dummiesTemplate", "DummyContent", "dummiesContents", " dummiesContents", "determinedText", " dummiesTemplate", "dumpInt", "deltaText", "determinedContent", "dumpMedia", "dynamicContent", "DumpText", "dummyCode", "dummiesCode", " dummyContents", "dumpingTemplate", "DumpInt", "DumpContent", "DumpMedia", "dummiesContent", " dummiesCode", "dynamicCode", "DummyMedia", " dummiesContent", "dynamicContents", " dummyTemplate"], "source": ["image", "core", "scope", "server", "store", "search", "seed", "SOURCE", "relation", "instance", "service", "sin", "s", "user", "google", "sys", "ource", "src", "space", "in", "from", "sf", "resource", "join", "table", "status", "spec", "ser", "sql", "ie", "sp", "proxy", "ace", "template", "pse", "se", "uri", "inner", "sr", "Source", "sample", "site", "series", "use", "result"], "content": ["context", "ontent", "output", "value", "license", "header", "node", "cont", "cache", "script", "data", "message", "Content", "format", "description", "path", "editor", "sequence", "tree", "section", "xml", "example", "application", "text", "article", "status", "resource", "response", "quest", "comment", "key", "expression", "document", " contents", "layout", "code", "body", "current", "txt", "template", "activity", "title", "config", "json", "version", "tx", "summary", "ext", "html", "command", "result", "action"], "qResult": ["queryResult", "dqRes", "queryResults", "iqResponse", "qresult", " qresult", " qResults", " qResponse", "QView", " qRes", "iqResult", "queryRes", "qReport", "qRes", "dqView", "qResults", "iqRes", "Qresult", "iqReport", "QResult", " qView", "qResponse", "qView", "queryResponse", "dqResult", "queryReport", "QRes", "iqResults", " qReport", "dqresult"], "results": ["assets", "roads", "rows", "ults", "terms", "ands", "Results", "values", "olds", "lections", "xes", "events", "data", "features", "runs", "chains", "items", "s", "times", "missions", "orders", "ms", "actions", "tests", "relations", "hips", "RESULTS", "ries", "users", "thumbnails", "ULTS", "products", "reports", "res", "forms", " Results", "objects", "settings", "members", "resources", "archives", "posts", "details", "children", "pages", "Contents", "versions", "its", "blocks", "photos", "views", "result"], "it": ["et", "iz", "exec", "id", "p", "v", "hit", "ait", "It", "m", "they", "in", "st", "ic", "MIT", "pit", "he", "li", "ul", "ite", "init", "op", "IT", "is", "out", "h", "i", "iter", "lit", "mit", "ip", "ci", "its", "t", "stat", "info", "at", "read", "rit"], "rSrc": [" rSsrc", "rSysource", "rSlrs", "crDesrc", "rSlrc", "rSourceRC", "rSrs", "rSourcesrc", "rSlRC", "crDessrc", "rSlcs", "rSourcerc", "rSerc", "rSecs", "rSers", " rSrs", " rSource", "rDesrs", "rSeRC", "rScs", " rSRC", "rSsrc", "crDesRC", "crSrc", "rSysrc", "crDesrs", "rSysRC", "rDessrc", "crSrs", "rSourcers", "crSRC", " rScs", "rDesrc", "rSyssrc", "crSsrc", "rSRC", "rSource", "rDesRC"], "rSrcIn": ["rSetrcOut", "rSRCin", "rSncin", "rSrsIn", "rSetrcIN", "rSldCon", "rSetsrcOut", "rSldInput", "rSetrcin", "rSetsrcIN", "rSrsIN", "rSldIN", "rSldOut", "rSsrcOut", "rSncIn", "rSRCCon", "rSldin", "rSrcIN", "rSRCIn", "rSrcInput", "rSRCOut", "rSrcin", "rSsrcIN", "rSetsrcin", "rSrsInput", "rSetrcIn", "rSldIn", "rSsrcIn", "rSncOut", "rSRCIN", "rSsrcin", "rSrsOut", "rSrcCon", "rSetsrcIn", "rSrcOut", "rSncCon", "rSsrcInput"], "actualOut": ["UALOut", "ualEnd", "ualout", " actualout", "realOut", "actuallyOut", "UALIn", "actuallyIs", "actualout", "virtualIn", "realIs", "realIn", "finalIn", " actualIn", "ualOut", "actuallyCopy", "ualBytes", " actualCopy", "actualIn", "virtualOut", "realCopy", "actualBytes", "finalout", " actualBytes", "ualIn", "actualEnd", "UALBytes", "actuallyIn", "actualIs", " actualIs", " actualEnd", "UALEnd", "finalOut", "actualCopy"]}}
{"id1": "3958807", "id2": "20924119", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBixedStream", "loadBbinaryStreamer", "loadEmbinaryInput", "loadBixedStreamer", "loadEmbinaryStreamer", "loadBignedFile", "loadBixedFile", "loadEmbbinaryFile", "loadBignedStreamer", "loadEmbbinaryStreamer", "loadBignedInput", "loadBinaryFile", "loadBbinaryStream", "loadEmbinaryFile", "loadBignedStream", "loadEmbinaryStream", "loadEmbbinaryInput", "loadEmbbinaryStream", "loadBixedInput", "loadBbinaryInput", "loadBbinaryFile", "loadBinaryInput", "loadBinaryStreamer"], "streamName": [" streamPath", " streamType", " streamHandle", "stringType", " streamname", "longPath", "recordNAME", "streamType", "longName", "stringName", "Streamname", "fileNAME", "recordName", "fileName", "StreamName", "recordname", "streamNAME", "filePath", "resourceNAME", "resourceName", "stringNAME", " streamNAME", "longNAME", "streamHandle", "recordHandle", "resourceType", "streamname", "streamPath", "StreamHandle", "StreamNAME"], "streamToLoad": [" stream2Read", "streamtoload", "streamTOload", "streamtoAdd", "stream2Load", "stream2Read", "stringWillLoad", "streamWillload", "streamTORead", "streamTOAdd", "stringToAdd", "stream2load", "stream2Use", "streamToUse", " stream2Use", "streamToload", "streamToAdd", " streamToRead", "streamTOLoad", "streamtoLoad", " streamToUse", "streamTOUse", "stringWillload", "streamToRead", " stream2load", " streamWillLoad", " streamToload", "stringToLoad", "streamWillAdd", " stream2Load", "streamWillLoad", "stringWillAdd", "stringToload", " streamWillload"], "sz": ["sch", " sch", "insze", "rsiz", "siz", "rsld", "Sld", " siz", " sld", "insiz", "sze", "Siz", "insch", "insz", "Sch", "rsze", "rsz", "Sz", " sze", "Sze", "sld"], "req": ["Request", "qq", "cmd", "Requ", "org", "gr", "jp", "usr", "require", "attr", "q", "ctx", "wcs", "sq", "request", "pkg", "http", "qt", "inv", "quick", "comm", "fr", "quest", "urg", "query", "res", "seq", "wx", "rx", "client", "comp", "cur", "dq", "proc", "pas", "qs", "requ"], "resp": ["rel", "fs", "cmd", "output", "exp", "esp", "Resp", "https", "p", " Resp", "serv", "RES", "dis", "gr", "jp", "rec", "content", "sys", "rend", "conn", "ret", "request", "status", "http", "re", "response", "comm", "inv", "vol", "fr", "report", "Res", "obj", "res", "sol", "body", "sp", "soc", "nt", "msg", "pos", "wx", "cmp", "client", "r", "respond", "respons", "proc", "conv", "os", "Response", "cl", "pas", "rep", "html", "compl", "wr", "result"], "out": ["cn", "ins", "ot", "output", "OUT", "co", "bs", "ex", "gt", "us", "net", "io", "sys", "sw", "in", "outs", "gs", "ou", "vol", "ts", "to", " outs", "obj", "res", "aos", "nt", "cos", "client", "oss", "conv", "os", "null", "o", "log", "t", "utt", "ws", "Out", "w", "yout", "n"], "bos": ["oos", "bs", "bits", "mos", "bones", "bes", "ubis", "bo", "banks", "bas", "bles", "bi", "ys", "sys", "nos", "obs", "bin", "bot", "js", "dos", "bat", "bis", "oids", "bh", "ts", "eros", "des", "boards", "aos", "uts", "tes", "fits", "base", "BS", "jas", "oops", "oss", "os", "bytes", "ods", "buff", "los", "ws", "ols", "ios"]}}
{"id1": "8667872", "id2": "3184073", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["update", "id", " key", "sum", " address", " identity", "string", "Hash", "print", " sum", " equals", " message", " Hash", "sign", " hashing", "dump", "hex", "code", " text", " h", "h", " body", " signature", " id", " fingerprint", " mac", " code"], "data": ["image", "DATA", "value", "output", "ata", "dat", "message", "format", "area", "secret", "content", "string", "foo", "sequence", "any", "buffer", "space", "raw", "text", "size", "what", "batch", "name", "this", "serial", "input", "json", "mu", "bytes", "padding", "sample", "html", "hello", "info", "result", "action"], "digest": ["dese", "equit", "cdested", "modester", " digested", "digment", " digist", "Digester", "cdment", "mdse", "Digment", "hashit", "cdest", "digist", "Digested", "hashEST", "equEST", "Digist", "Digge", "mdEST", "Digit", "digested", "DigEST", "digit", "cdse", " digEST", "digse", "mdist", "hashge", "equge", " digse", "digge", "modest", " digge", " digester", "deEST", "Digest", "modge", "modist", "Digse", "hashest", " digment", "deist", "mdester", "mdest", "deest", "digEST", "digester", "mdge", "equest"]}}
{"id1": "4686922", "id2": "20568568", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesToStream", "extractResources2File", "extractResourceAsfile", "extractResources2Files", "extractResource2Files", "extractResourceAsStream", "extractResources2Stream", "extractResourceFromStream", "extractResource2Stream", "extractResourceAsFile", "extractResourcesTofile", "extractResourceToFiles", "extractResourceFromFiles", "extractResourceTofile", "extractResourcesToFiles", "extractResourceToStream", "extractResourceAsFiles", "extractResourcesToFile", "extractResourceFromfile", "extractResource2File", "extractResource2file", "extractResourceFromFile", "extractResources2file"], "resourcePath": ["ResourceUrl", "ResourceName", "ResourceLocation", "templateName", "resourceUrl", "templatepath", " resourcepath", "attributePath", "attributeLocation", "uriUrl", "ResourceIn", " resourceIn", "Resourcepath", "resourcepath", "uriLocation", "uriName", "resourceIn", "uriPath", "templateIn", "templatePath", "attributeUrl", " resourceName", "attributeName", "resourceName", "resourceLocation", "ResourcePath"], "dest": ["loc", "output", "Dest", "cont", "dat", "self", "home", "target", "origin", "src", "etc", "dist", "to", "orig", "trans", "dir", "coord", "img", "nom", "des", "tmp", "sp", "parent", "this", "good", "opt", "gov", "mem", "comb", "source", "cat", "lit", "null", "desc", "decl", "prop", "rest", "end", "w", "temp", "result"], "in": ["f", "mi", "ins", "din", "inside", "id", "ini", "IN", "sin", "inn", "con", "ln", "ne", "inf", "cin", "gin", "local", "on", "m", "bin", "from", "raw", "it", "or", "resource", "re", "all", "init", "file", "mc", "al", "none", "ind", "is", "inc", "no", "up", "rin", "i", "input", "source", "r", "inner", "iter", "conf", "l", "isin", " din", "In"], "out": ["f", "cn", "ot", "output", "OUT", "en", "co", "b", "v", "again", "cache", " Out", "stable", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "ou", "col", "note", "to", "obj", "res", "aos", "tmp", "nt", "cos", "pool", "ch", "can", "client", "no", "write", "i", "oss", "conv", "inner", "os", "null", "na", "o", "t", "exit", "Out", "at", "w", "outer", "n"]}}
{"id1": "7087108", "id2": "9956095", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public void exportNotesToServer() {\n        boolean uploaded = true;\n        try {\n            File f = new File(UserSettings.getInstance().getNotesFile());\n            FileInputStream fis = new FileInputStream(f);\n            String urlString = protocol + \"://\" + UserSettings.getInstance().getServerAddress() + UserSettings.getInstance().getServerDir() + f.getName();\n            setDefaultAuthenticator();\n            URL url = new URL(urlString);\n            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n            urlc.setDoOutput(true);\n            urlc.setRequestMethod(\"PUT\");\n            OutputStream os = urlc.getOutputStream();\n            int nextByte = fis.read();\n            while (nextByte != -1) {\n                os.write(nextByte);\n                nextByte = fis.read();\n            }\n            fis.close();\n            os.close();\n            if (urlc.getResponseCode() != HttpURLConnection.HTTP_CREATED && urlc.getResponseCode() != HttpURLConnection.HTTP_NO_CONTENT) {\n                uploaded = false;\n            }\n        } catch (SSLHandshakeException e) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.sslcertificateerror\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n            uploaded = false;\n        } catch (Exception e) {\n            uploaded = false;\n        }\n        if (uploaded) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"info.notesfileuploaded\"), I18N.getInstance().getString(\"info.title\"), JOptionPane.INFORMATION_MESSAGE);\n        } else {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.notesfilenotuploaded\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }\n", "label": 0, "substitutes": {"doGet": [" doSet", " handleGet", " doGET", " handleget", "invokeGet", "invokeGET", "doGET", "doSet", " doget", "invokeget", " handleGET", " handleSet", "invokeSet", "doget"], "request": ["initial", "core", "Request", "context", "store", "server", "search", "forward", "position", "question", "model", "the", "message", "select", "instance", "begin", "each", "enter", "setup", "order", "complete", "local", "hello", "first", "subject", "xml", "application", "raw", "http", "QUEST", "re", "frame", "post", "remove", "worker", "report", "attribute", "quest", "req", "transform", "query", "document", "construct", "address", "reference", "relative", "change", "controller", "open", "call", "client", "get", " Request", "input", "create", "reset", "version", "url", "command", "info", "index", "project", "requ", "handle"], "response": ["image", "context", "onse", "reply", "output", "server", "message", "description", "print", "xml", "application", "resp", "view", "status", "http", "re", "frame", "page", "report", "render", "connection", "res", "body", "out", "write", "respons", "respond", "one", "os", "Response", "default", "success", "next", "ce", "result"], "path": ["output", "th", "value", "patch", "p", "location", "pattern", "where", "select", "string", "dest", "ath", "chain", "print", "test", "PATH", "pkg", "text", "dir", "key", "prefix", "transform", "query", "hex", "base", "relative", "name", "system", "mount", "check", "template", "full", "title", "filename", "uri", "config", "route", "url", "prop", "Path", "log", "temp", "project"], "file": ["f", "image", "object", "output", "binary", "port", "model", "channel", "bo", "relation", "fe", "disk", "e", "le", "chain", "form", "user", "real", "valid", "tree", "rule", "view", "File", "resource", "table", "load", "FILE", "bar", "spec", "upload", "to", "page", "ca", "report", "link", "bool", "key", "document", "console", "run", "library", "base", "be", "name", "word", "lock", "mail", "check", "ile", "full", "source", "filename", "db", "null", "job", "local", "result", "handle"], "in": ["ins", "din", "copy", "en", "again", "ini", "sum", "IN", "sin", "inn", "con", "s", "gin", "cin", "on", "kin", "bin", "mm", "it", "ic", "or", "and", "as", "thin", "mn", "pic", "mc", "al", "reader", "ind", "is", "inc", "out", "up", "rin", "i", "input", "source", "one", "inner", "l", "asin", "sample", "cm", "isin", "ck", " din", "read", "In"]}}
{"id1": "6457199", "id2": "3731077", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["processResponse", "processQuery", " doResponse", "processRequest", "doQuery", "doResponse", "handleRequest", "handleResponse", " doQuery", "handlerequest", "processrequest", "handleQuery", " dorequest", "dorequest"], "request": ["initial", "context", "Request", "search", "forward", "position", "question", "message", "select", "each", "setup", "user", "complete", "first", "hello", "xml", "application", "view", "re", "http", "frame", "QUEST", "report", "quest", "req", "transform", "query", "document", "address", "reference", "seek", "open", "call", "get", "input", "create", "reset", "command", "project"], "response": ["image", "context", "onse", "reply", "output", "server", "header", "position", "channel", "message", "relation", "format", "service", "content", "e", "print", "xml", "block", "resp", "application", "continue", "view", "status", "http", "re", "frame", "writer", "socket", "page", "report", "render", "document", "res", "connection", "console", "out", "write", "display", "feed", "respons", "respond", "reset", "Response", "json", "fire", "next", "exit", "release", "send", "result"], "path": ["length", "host", "context", "qualified", "core", "physical", "patch", "near", "p", "port", "location", "ex", "pattern", "message", "select", "api", "format", "where", "string", "clean", "partial", "chain", "pointer", "test", "local", "print", "raw", "PATH", "text", "pkg", "error", "trace", "method", "alias", "prefix", "dir", "transform", "key", "base", "relative", "parent", "name", "right", "binding", "mount", "template", "full", "input", "filename", "uri", "parts", "policy", "route", "json", "type", "url", "prop", "Path", "root", "log", "primary", "href", "kind", "index", "ath"], "internal": ["initial", "context", "rel", "original", "inside", "invoke", "regular", "uid", "binary", "id", "intern", " external", "standard", "api", "external", "back", "index", "origin", "normal", "real", "valid", "central", "bin", "in", "entry", "generic", "ret", "ident", "san", "inline", "alias", "orig", "init", "impl", "console", "managed", "relative", "name", "this", "inter", "virtual", "template", "skin", "Internal", "common", "inner", "identified", "url", "primary", "local"], "resource": ["image", "core", "context", "object", "record", "store", "stream", "binary", "model", "channel", "exclusive", "instance", "service", "process", "pointer", "print", "buffer", "resolution", "network", "entry", "region", "re", "socket", "range", "connection", "file", "res", "console", "library", "address", "reference", "controller", "directory", "system", "resources", "source", "create", "uri", "url", "media", "Resource", "remote", "release", "component", "local", "result", "handle"], "mimeType": [" mimesType", " mimesTypes", "maxStyle", "mIMEType", "metyName", "mimeName", "meshType", "mtimeType", "mIMEStyle", "miscTypes", "meshtype", " meshStyle", " meshName", "mtimeStyle", "Metytype", "MetyName", "metytype", " mimeStyle", "mimePolicy", "MetyTypes", " mimePolicy", "miscName", " mimetype", " meshtype", "misctype", "mimeStyle", "mimesType", "maxPolicy", "mimesStyle", "mimeTypes", "MimeTypes", "MimeType", "MetyType", "Mimetype", " mimesPolicy", "MimeName", " mimeName", "meshStyle", " mimeTypes", "maxType", "mtimetype", "meshName", "metyTypes", "mIMETypes", "mimetype", "mtimeName", " mimesStyle", "mIMEtype", "miscType", "mIMEName", "metyType", "mimesPolicy", " meshType", "mimesTypes", "metyPolicy", "maxTypes", "metyStyle"], "is": ["fs", "sis", "isl", "isa", "icks", "ins", "are", "iss", "ri", "rs", "ris", "cs", "ls", "isi", "nis", "s", "si", "gets", "ys", "obs", "iso", "has", "ism", "in", "ic", "ains", "bis", "ics", "as", "IS", "res", "iris", "Is", "mus", "isc", "i", "isf", "es", "ais", "its", "isin", "ios"], "os": ["fs", "oos", "et", "ot", "osi", "bs", "cs", "ros", "ls", "er", "us", "s", "ys", "sys", "ms", "obs", "nos", " Os", "ss", "ds", "oses", "ts", "oz", "des", "as", "bos", "res", "aos", "ox", "Os", "oS", "oss", "OS", "es", "ks", "oes", "o", "los", "css", "ols", "ps", "ios"]}}
{"id1": "20181656", "id2": "10385815", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sortRows": ["sortDrows", "sortRrows", "sortLrows", " sortRords", " sortRrows", "sortRecords", " sortLues", "sortDues", " sortLows", "sortLords", "sortDords", "sortRues", " sortLords", "sortDows", "sortRecows", "sortLows", "sortRecues", " sortLrows", " sortRues", "sortRecrows", "sortRords", "sortLues"], "rows": ["ins", "bs", "rs", "ris", "ros", "orders", "ms", "issues", "headers", "rates", "res", "results", "pages", "row", "ports", "ods", "ids", "frames", "roots", "blocks", "ges", "views", "arr", "xs", "models", "ows", "months", "items", "files", "ries", "rown", "reports", "vs", "uds", "rooms", "resources", "keys", "errors", "lines", "rices", "sheets", "terms", "ls", "maps", "events", "data", "cells", "fields", "ints", "links", "raw", "outs", "images", "forms", "heads", "cases", "modules", "tracks", "posts", "docs", "projects", "names", "rules", "groups", "history", "checks", "stats", "values", "runs", "ards", "list", "ues", "types", "packages", "relations", "users", "workers", "orts", "dates", "changes", "members", "abs", "series", "tests"], "i": ["ia", "mi", "u", "ri", "id", "v", "p", "ix", "ini", "ii", "us", "si", "e", "ai", "io", "bi", "q", "m", "in", "iu", "ki", "ic", "it", "ei", "ar", "li", "ti", "xi", "init", "hi", "ori", "ji", "ie", "zi", "phi", "is", "out", "ui", "g", "di", "gi", "ci", "ip", "pi"], "j": ["k", "rel", "z", "u", "jac", "adj", "dj", "og", "b", "v", "other", "ix", "job", "je", "jj", "jp", "kid", "jet", "er", "s", "si", "e", "user", "aj", "q", "state", "m", "err", "bot", "my", "sim", "uni", "it", "js", "jump", "by", "ret", "ja", "J", "ij", "note", "fr", "req", "jl", "obj", "kj", "x", "son", "ji", "y", "bj", "out", "br", "pr", "rem", "last", "uj", "g", "di", "l", "json", "jit", "o", "next", "jo", "im", "oj", "jc"], "temp": ["const", "tt", "perm", "dat", "alt", "tc", " tmp", "mint", "level", "tim", "clean", "test", "EMP", "buffer", "cell", "pre", "term", "mod", "status", "orig", "emp", "mp", "tmp", "base", "porary", "tr", "current", "fac", "kw", "txt", "template", "Temp", "mem", "cum", "tem", "null", "fake", "vt", "variable", "t", "local", "result"]}}
{"id1": "19849797", "id2": "7468827", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"copyFile": ["copyStream", "transferFile", "copyfile", " cpFile", " copyFiles", " cpfile", " cpFiles", "copyFiles", " copyStream", "transferStream", " cpStream", " copyfile", "transferFiles", "transferfile"], "sourceFile": ["sourcePage", " sourceTable", " sourceField", "ourceFile", " sourceLine", " sourcePath", "srcField", "srcLine", "sourcePath", "sourceLine", "srcfile", "ourcePage", "srcTable", " sourcePage", "sourceField", "srcPage", "srcFile", "ourceTable", "srcPath", "sourcefile", "sourceTable", "ourcefile", "ourcePath", "ourceField", " sourcefile", "ourceLine"], "destFile": ["srcDir", "datFiles", "destFilename", "datPlace", "optPath", "restFiles", "DestFilename", "optFilename", "declEntity", "destDir", "optDir", "restFile", "restFilename", "optEntity", "destFolder", "optFolder", "datFile", "restPlace", "destPath", "DestDir", "declDir", "destFiles", "datFilename", "destPlace", "destEntity", "DestFiles", "declFile", " destPlace", "optFile", " destFilename", "DestPath", " destDir", "srcFiles", "srcFile", "srcEntity", "DestFile", "declFolder", " destPath", " destFiles", "srcFolder", "srcPath"], "source": ["image", "update", "scope", "copy", "store", "search", "stream", "shell", "style", "SOURCE", "match", "channel", "scale", "show", "standard", "char", "service", "back", "iterator", "cause", "target", "owner", "origin", "sequence", "ource", "src", "subject", "local", "from", "in", "slave", "resource", "OURCE", "load", "score", "table", "spec", "note", "comment", "attribute", "init", "query", "console", "missing", "ie", "body", "proxy", "parent", "force", "none", "reader", "before", "check", "input", "se", "iter", "inner", "create", "start", "parse", "Source", "sample", "ce", "series", "use", "pose", "component", "index", "send", "result"], "destination": ["destinator", "noninated", "terminined", " destinated", " destinator", "separination", "restinator", "restinated", "noninator", "noninate", " destinate", "descation", "Destination", "terminination", "verinated", "decination", "decined", "verination", "Destinated", "separment", "separinated", "Destinator", "Destment", "destined", " destment", "destinate", "destation", "destificate", "Destation", " destation", "descinate", "decinated", "termininated", "descination", "destment", "nonination", "Destificate", "descinator", "termininate", "restination", "restinate", " destificate", "verificate", "separation", "decinate", "destinated", "veration", " destined", "Destinate"]}}
{"id1": "2168610", "id2": "11952735", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"update": ["num", "u", "id", "count", "diff", "state", "set", "status", "http", "load", "remove", "add", "report", "run", "change", "check", "Update", "get", "row", "save", "use", "info", "send", "value", "grade", "select", "print", "offset", "commit", "size", " UPDATE", "init", "edit", "UPDATE", "batch", "op", "updated", "put", "current", "call", "write", "find", "result", "user", "touch", "continue", "resource", " Update", "msg", "latest", "out", "up", "create", "component", "index", "draw", "now", "handle", "action", "equal", "where", "delete", "database", "insert", "ul", "fill", "login", "dates", "exit", "date"], "o": ["k", "object", "co", "p", "ooo", "mo", "bo", "fo", "oco", "onet", "e", "lo", "q", "m", "iso", "om", "c", "oo", "a", "to", "ilo", "oid", "obj", "po", "out", "ob", "h", "i", "aco", "ao", "oin", "os", "l", "t", "O", "oa", "cont", "n"], "contact": ["translation", "responsible", "country", "port", "work", "match", "transfer", "message", "char", "format", "detail", "service", "communication", "cc", "content", "charge", "fax", "form", "group", "print", "addr", "cell", "hello", "acts", "claim", "lead", "entry", "pp", "comm", "add", "control", "CONT", "report", "trans", "international", "phone", "connection", "ACT", "component", "force", "address", "act", "controller", "cp", "Contact", "consider", "panel", "client", "compliance", "check", "mail", "company", "details", "title", "display", "aco", "config", "close", "character", "l", "ct", "att", "impact", "info", "module", "conduct", "cont", "action"], "pst": ["dct", "dpsy", "pingth", "lct", "jpST", "pingct", "Prest", "pstal", "jpst", "pmt", "pingst", "Ppt", "tpstal", "psta", "preSt", "pnt", "apst", "dst", "prst", "jpmt", "pingsta", "prect", "phpnt", "vply", "ipST", "bpst", "ipSt", "Pse", "pct", "ipsta", " pset", "lST", "apost", "perest", " ply", "jpster", "tpstra", "apSt", "tpct", "phpst", "pept", "pest", " psy", " pstan", "jpSt", "pingstra", " pstra", " pST", "pSt", "phpstal", "Pct", "dpster", "ipth", " pct", "pstan", "pect", "prest", "tpst", "vpst", " pSt", "pstra", "presta", " post", "bpost", "ipmt", "preth", "epstal", "ipct", " pmt", "post", "Pst", "ply", "dpst", "psth", "pST", "pse", "jply", "psy", "jpset", "presth", "epst", "jpct", "prse", "bpstan", "ipsth", " pstal", "phpct", "vpset", " pster", " pnt", "dpt", "prST", "PST", "pingstal", "vpct", "epct", "pster", " psth", "dpct", "pth", "pingSt", "ppt", "apstan", "prct", "bpSt", "ipst", "lst", "lse", "pset", "jpsy", "drest", "epnt"]}}
{"id1": "23510383", "id2": "13891080", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": [" SaveFile", " savePackage", "createPackage", "saveApp", "createProject", "createApp", " saveApp", " SaveApp", "saveFile", " SaveProject", "createFile", " saveFile", "savePackage", " SavePackage"], "file": ["image", "id", "port", "data", "path", "e", "foo", "io", "complete", "files", "real", "in", "File", "resource", "table", "FILE", "link", "report", "dir", "base", "parent", "open", "ame", "ile", "get", "full", "filename", "create", "db", "log", "use", "info", "local", "project", "handle"], "types": ["assets", "models", "values", "sets", "classes", "events", "features", "items", "packs", "times", "files", "actions", "strings", "packages", "issues", "tests", "options", "apps", "ties", "ypes", "thumbnails", "ts", "otypes", "codes", "styles", "objects", " Types", "pes", "services", "Types", "keys", "resources", "posts", "parts", "scripts", "pages", "sites", "ports", "versions", "projects", "plugins", "ids", "names", "groups", "tags", "views"], "images": ["image", "assets", "models", "videos", "classes", "events", "files", "picture", "links", "boxes", "thumbnails", "Image", "styles", "Images", "scripts", "pages", "uploads", "versions", "tags", "media", "faces", "groups", "frames", "blocks", "photos", "views", "icons"], "trajectories": ["tractories", "Trajors", "trajory", "Trajectors", "Trajables", "tractables", "Trajectables", "tractory", "Trajectory", "tractors", "traceptories", "Trajories", "trajectables", "Trajory", "trajables", "trajories", "traceptors", "trajors", "traceptables", "trajectors", "traceptory", "Trajectories", "trajectory"], "databasesIncluded": ["databasesInglisted", "databasesedIncluded", "datadesInified", "datadesInclusion", "daturesIncluded", "daturesInlisted", "daturesInslisted", "databasesedInified", "databasesINified", "databasesInsclusion", "databasesInified", "databasesInsjected", "databasesINclusion", "databasesedInlisted", "datadesInscluded", "databasesINjected", "datadesInsified", "databasesInclusion", "datadesInsjected", "datadesIncluded", "daturesInsclusions", "databasesIngclusions", "datadesInjected", "databasesInslisted", "daturesInclusions", "databasesedInjected", "databasesInsclusions", "databasesedInclusions", "databasesInlisted", "databasesInsified", "daturesInscluded", "databasesInclusions", "databasesInscluded", "databasesedInclusion", "databasesInjected", "databasesIngcluded", "databasesINcluded", "datadesInsclusion"], "onlyLinks": ["forceLink", "forcelinks", "Onlylinks", " onlyLink", " onlylinks", "forceLinks", "OnlyLinks", "alsoLink", "onlyLink", "onlylinks", " onlyRelations", "alsoRelations", "OnlyLink", "alsoLinks", "onlyRelations", "OnlyRelations"], "index": ["initial", "update", "length", "max", "num", "nn", "loc", " Index", "position", "match", "ex", "connect", "sequence", "offset", "set", "zero", "add", "Index", "all", "x", "amount", "address", "pos", "ind", "open", "ion", "inc", "check", " sidx", "no", "number", "i", "find", "fail", "second", "end", "first", "info", "n"], "name": ["image", "id", "data", "nm", "about", "path", "string", "me", "m", "man", "Name", "table", "NAME", "prefix", "run", "base", "parent", "none", "word", "system", "ame", "full", "title", "filename", "create", "default", "named", "root", "names", "primary", "local", "n"], "format": [" Format", "cal", "mt", "value", "MAT", "style", "v", "scale", "fm", "data", "language", "pattern", "list", "color", "form", "print", "percent", "set", "term", "it", "table", "pretty", "init", "prefix", "layout", "base", "unit", "get", "parse", "default", "printf", "Format", "util", "use"], "count": ["length", "ount", "z", "num", "flag", "mark", "sum", "total", "order", "process", "err", "set", "c", "error", "size", "table", "add", "skip", "code", "amount", "depth", "found", "counter", "reset", "start", "Count"], "version": ["translation", "record", "server", "header", "v", "Version", "video", "VER", "mint", "description", "about", "database", "tree", "xml", "section", "alone", "vers", "major", "j", "page", "ver", "python", "connection", "document", "draft", "build", "parent", "java", "latest", "current", "virtual", "number", "json", "versions", "summary", "journal", "root", "release", "VERSION", "information", "result"], "writer": ["access", "output", "writers", "operator", "stream", "server", "woman", "language", "data", "window", "er", "description", "external", "service", "driver", "iterator", "order", "editor", "handler", "buffer", "print", "sw", "walker", "maker", "entry", "wrapper", "wrote", "author", "to", "creator", "report", "browser", "comment", "writ", "wright", "document", "builder", "console", "caster", "function", "connection", "reader", "client", "counter", "write", "writing", "inner", "written", "variable", "flush", "journal", "Writer", "w", "outer"], "xmlDir": ["mlFile", " xmldir", "xmlFolder", "logDirectory", "mlFolder", " xmlFolder", "imageFolder", "xmlDirectory", "xmldir", "imagedir", "logFolder", "logDir", " xmlFile", "logdir", "logFile", " xmlDirectory", "imageDirectory", "imageDir", "xmlFile", "mlDirectory", "mlDir"], "databases": ["generabase", "Datates", "Datasha", "mutasha", " datates", "Datases", " datases", " database", "baselines", "datures", "basabases", "datates", " datasha", "database", "Database", " datas", "notables", "generabases", "mutabases", "notabases", "generas", "mutables", "Datables", "notures", "notelines", "datasha", "Datas", "basables", "datelines", "mutases", "basures", "Datures", " datables", "Databases", "datas", "Datelines", "datases", "datables", "generates"], "t": ["k", "ot", "mt", "id", "v", "p", "typ", "tc", "te", "s", "e", "q", "str", "pt", "term", "it", "c", "j", "ts", "x", "y", "tr", "txt", "h", "template", "i", "tm", "ct", "o", "temp", "T", "w", "tt", "n"], "type": ["top", "object", "TYPE", "pe", "ty", "style", "p", "other", "id", "match", "class", "typ", "language", "relation", "instance", "te", "test", "rule", "ime", "error", "resource", "single", "ping", "link", "to", "ver", "tag", "key", "shape", "base", "address", "y", "this", "unit", "role", "check", "template", "title", "config", "ype", "null", "Type", "parse", "time", "tool", "root", "site", "kind", "info", "module", "result", "action"], "currentName": [" currentNames", "CurrentNames", "baseName", "currentPort", "currentDir", "baseOrder", " currentParent", "reportedTime", "CurrentLock", "CurrentDir", "updateName", "thisSet", "currentTime", "currentlyPath", "reportedDir", "reportedName", "completeName", "CurrentPath", "currentYear", "basePort", " currentOrder", "currentlySet", "currentlyKey", "currentOrder", "currentParent", "reportedParent", "currentlyName", "completeSet", "currentPath", "currentSet", "CurrentParent", "updateOrder", "currentlyTime", "reportedLock", "currentlyYear", "thisName", "CurrentName", "completeKey", " currentPort", "thisKey", "currentNames", "reportedPath", " currentFace", "currentLock", " currentDir", "currentFace", "thisYear", "baseFace", "updatePort", "currentKey", "currentlyLock", "reportedNames", "CurrentTime", "completeYear", "updateFace"], "baseCopy": ["parentCopy", "baseName", " baseName", " baseStore", "baseStore", "basiccopy", "basicCop", "parentcopy", " basecopy", "buffercopy", "BaseName", "parentCop", "basecopy", "Basecopy", "BaseCop", "baseCop", "basicStore", " baseCop", "basicCopy", "bufferCopy", "BaseCopy", "BaseStore", "bufferCop", "parentName"], "source": ["initial", "original", "scope", "store", "search", "stream", "shell", "scan", "SOURCE", "channel", "data", "select", "service", "ources", "iterator", "owner", "target", "origin", "sequence", "ource", "src", "space", "subject", "from", "resource", "join", "size", "init", "connection", "console", "base", "parent", "reader", "before", "system", "input", "se", "create", "inner", "start", "Source", "sample", "site", "local", "master"], "destination": ["Destuation", " destinated", "declination", " destructure", "destructure", "Destregation", "destregation", "datinator", "datinations", "Destination", "declinations", "Destructure", "Destinated", "destuation", "Destinations", "datination", "Destinator", " destuation", "messination", "declinator", "messinations", "messructure", "destinations", " destinations", "messinated", "messuation", "datregation", "destinated", "declregation", "destinator"], "clefs": [" CleFs", " cleFS", "CleFs", "clefits", "CLEcs", " cleFs", " clebs", "Clefs", "cleFs", " Clecs", "clebs", " Clebs", "CLEFs", " Clefits", "CLEfs", "CleFS", "Clebs", " Clefs", "Clecs", "CLEfits", "cleFS", " CleFS", "clecs", "Clefits"], "st": ["sth", "dd", "sl", "mt", "bl", "std", "sts", "sc", "sn", "str", "irst", "pt", "sw", "it", "St", "inst", "fr", "storage", "ts", "sy", "query", "sb", "sp", "bt", "est", "h", "cr", "se", "ST", "ste", "statement", "cl", "ost", " ST", "start", "ct", "ist", "rest", "stat", "stra", "tt", "sm"], "rs": ["ins", "rt", "mr", " RS", "cs", "rc", "ris", " ms", "ls", "sts", "ers", " ins", " iss", "RS", "Rs", "rys", "ds", "ts", "as", " pts", "res", " ps", " cs", "os", "ks", "rd", " sr", "ps"]}}
{"id1": "13563706", "id2": "20091126", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "DoGET", "doPut", "Doget", "doGET", "handleGET", " doget", "doget", "handleGet", " doPut", "handleget", "handlePut", "DoGet", "DoPut"], "request": ["initial", "context", "Request", "search", "forward", "position", "message", "each", "setup", "order", "path", "user", "complete", "hello", "first", "subject", "xml", "application", "view", "resource", "QUEST", "re", "frame", "http", "socket", "report", "attribute", "transform", "query", "document", "connection", "address", "reference", "directory", "parent", "event", "current", "call", "get", "input", "create", "reset", "route", "version", "url", "use", "command", "project"], "response": ["image", "reply", "output", "server", "search", "header", "position", "continue", "security", "message", "relation", "description", "format", "service", "ve", "print", "sequence", "tree", "block", "network", "resp", "application", "view", "answer", "collection", "status", "http", "zero", "frame", "report", "render", "document", "res", "connection", "console", "hash", "see", "write", "display", "respond", "foundation", "Response", "version", "fire", "json", "default", "success", "condition", "summary", "next", "example", "ce", "exit", "result"], "selectedPage": [" selectedKey", "namedPage", "selectionPage", "electedpage", "lectedFrame", "lectedItem", "singlePage", "specifiedPage", "electionFrame", "selectedKey", "singlepage", "selectItem", "namedToken", " selectedPort", "specifiedPort", "namedpage", "selectFile", "selectedDocument", "namedKey", "selectedPath", "singleFrame", "namedLine", "lectedFile", "verifiedFile", "matchedFrame", " selectedpage", "electionPage", "selectPath", "lectedPath", "selectionItem", " selectedRow", "selectPort", "selectionLine", "verifiedRow", "selectedPort", "lectedPage", " selectedFrame", "electedPage", "matchedPort", "lectedRow", "namedFrame", "electionDocument", "selectedpage", "selectedFrame", "lectedDocument", "selectedItem", " selectedLine", "selectionToken", "electedFrame", "electionPort", "selectionPort", "namedPort", "singlePort", "lectedPort", "specifiedDocument", "specifiedFrame", "matchedPage", "selectedFile", "verifiedPage", "selectedToken", "lectedpage", "selectedRow", "lectedKey", "selectedLine", "verifiedpage", "selectLine", "electedPort", "lectedToken", "lectedLine", "selectPage", " selectedFile", "selectionFile", "matchedpage", " selectedPath"], "page": ["object", "record", "node", "port", "complete", "application", "phone", "menu", "address", "be", "line", "pages", "age", "row", "url", "log", "point", "server", "office", "cache", "profile", "instance", "form", "chain", "view", "table", "to", "document", "layout", "current", "display", "number", "policy", "version", "associated", "filter", "Page", "project", "result", "p", "channel", "message", "self", "user", "group", "me", "network", "rule", "resource", "parent", "site", " Page", "image", "output", "position", "language", "window", "peer", "pointer", "phrase", "block", "pp", "collection", "frame", "force", "proxy", "pool", "client", "created", "next", "successful"], "portalRequest": ["PortaleThread", "PortaleQuery", "portalEvent", "terminalidRequest", "portualResponse", " portalCall", "portalSession", "portaleApply", "portaleFrame", "PortaleContext", "portalrequest", "portpalRequest", "terminalQuery", "portortalEvent", "PortalThread", "terminalidResponse", "portalityRequest", "portortalThread", " portaleAccess", "portralSession", "portortalQuery", "portalaCall", "PortalRequest", "portalidRequest", "portalingRequest", "terminalidSession", "portsortalEvent", "portalAccess", "portortalResponse", "portralQuery", "PortalContext", "portsalrequest", "portpalResponse", "terminalResponse", "portaleAccess", "portalingCall", "portaleSession", "portalCall", "portpalContext", "terminalidQuery", "portalidContext", "PortaleRequest", "portalidFrame", "portalerequest", "portaleQuery", "portalApply", "portsortalRequest", "portalThread", "portaleRequest", "PortalFrame", "portsalEvent", "portralRequest", "portalingAccess", "portortalrequest", "portaleContext", "portalFrame", "portalaRequest", "portalResponse", " portaleRequest", "portpalThread", " portaleCall", "PortaleResponse", " portalAccess", "portalityResponse", "portualrequest", "portalContext", "portalaAccess", "portsalRequest", "portralContext", "portralResponse", "portalingApply", "terminalRequest", "PortaleFrame", "portsalResponse", "portaleCall", "portalidQuery", "portsortalrequest", "portalityFrame", "portaleEvent", "terminalSession", "portualEvent", "portalidSession", "PortalQuery", "portsortalResponse", "portalaApply", "portaleResponse", "portaleThread", "portalityContext", "portalQuery", "portalidResponse", "portualRequest", " portalApply", " portaleApply", "portortalContext", "portortalRequest", "PortalResponse"], "pageProp": ["keyComp", "profileZip", "profileProp", "poolPro", "officePack", " pageProperty", "imageProp", " pagePriv", "agePr", "keyProperty", " pagePack", "sectionZip", "phrasePr", "keyProp", "pageProperty", "pageDef", "profilePred", "pagePr", "imagePr", "poolProp", "officeDef", "propertyDef", " pagePred", "agePro", " pageComp", "officeProp", "pagePred", "officePriv", "propertyProp", "phraseComp", "sectionPred", "propertyPack", "pageZip", " pagePr", "poolPred", "pagePro", "sectionProp", "phraseProp", "sectionPro", "agePred", "keyPr", "profilePro", "poolZip", "phraseProperty", " pageDef", "propertyPriv", "pagePack", "pagePriv", "ageProp", " pagePro", "imagePro", "pageComp", "imagePred"], "possiblePage": [" packedLine", "PossibleChild", "pbableUser", "pableTag", "PossiblyPage", "possibleLine", "possibleChild", "PossiblyCollection", "pableCollection", " possibleCollection", " possibleLine", "pibleUser", "pspecifiedpage", "pentialpage", "possiblyLine", "pbablePage", "pentialTag", "PossibleTag", "pspecifiedPage", "possiblePages", "packedLine", "pbableCollection", " possibleTag", "possibleUser", "packedCollection", "PossiblyUser", "pentialPages", "possiblyTag", "PossibleUser", "packedPage", "packedTag", "pibleChild", "pableLine", "pablePage", "pibleCollection", "PossiblyChild", "possiblepage", "pspecifiedTag", "pbableChild", "possibleCollection", "possiblyChild", "possiblyCollection", "PossibleCollection", " packedPage", "possiblyUser", "piblePage", "PossiblePage", "possibleTag", " packedCollection", "Possiblepage", "PossiblePages", "pspecifiedPages", "possiblyPage", " packedTag", "pentialPage"], "property": ["object", "value", "domain", "header", "operator", "field", "behavior", "p", "position", "location", "integer", "class", "relation", "message", "feature", "description", "service", "properties", "string", "owner", "phrase", "rue", "rule", "definition", "resource", "trace", "frame", "Property", "metadata", "attribute", "key", "expression", "function", "address", "name", "title", "config", "policy", "type", "variable", "prop", "second", "command"], "referer": ["aferential", "afener", "reterer", "relrer", "rerer", "refender", "rerier", "verrer", "reportarer", " refrer", "reener", "reeree", "reered", "refrer", "rorirect", "frer", "relender", "reonder", "relerer", "relener", "referee", "Refrer", "reportered", "reporterer", "printrier", "reerer", "rearer", "refarer", "rangeener", "requerer", "refonder", "reerential", "defered", "referential", "relering", " refirect", "refrier", "relerential", "fering", "refener", "diffonder", "differing", "retarer", "requering", "defirect", "deferer", "Referer", "afrer", "rorerer", "retered", "rederee", "fener", "rangerer", "Referee", "refering", "vererential", "retrer", "requrer", "rangeerer", "redrer", "rederer", "differer", "diffrer", "rorered", "printrer", "ferer", " refered", "refered", "printerential", "reender", "redere", "rorrer", "defrer", "refirect", "reering", "Refere", "requonder", "aferer", "printerer", "rangeender", "vererer", "refere", "verrier", "reportrer", "reere"], "e": ["f", "p", "er", "te", "ge", "ae", "eu", "E", "me", "m", "err", "eg", "error", "a", "de", "x", "ie", "ception", "event", "h", "se", "r", "oe", "g", "es", "echo", "o", "eeee", "t", "eur", "ee", "n"]}}
{"id1": "1097147", "id2": "10715601", "code1": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getContentDigest", "getContentdigests", "getMessageDigests", "getMessageDet", "getContentDigests", "getMessagedigester", "getContentDiget", "getMessageSignests", "getContentDigester", "getMessageSignest", "getMessageDester", "getContentdigest", "getContentdiget", "getMessageSignester", "getMessagedigest", "getMessageDiget", "getMessageDests", "getMessageDigester", "getContentdigester", "getMessageSignet", "getMessagediget", "getMessageDest", "getMessagedigests"], "inputs": ["Inputes", "acceptc", "selects", "patternes", "Inputs", "Inputts", "subjects", "accepts", "subjectls", "inputes", "inputp", "outputc", "selectls", "Inputls", "acceptls", "outputls", "inputc", "outputp", "acceptts", "inputts", "acceptes", "subjectc", "acceptp", "subjectp", "inputls", "selectes", "patternts", "patterns", "outputs", "outputes"], "sha": ["sh", "shell", "git", "alpha", "ho", "ha", "sum", "ssh", "api", "total", "cache", "lambda", "wal", "HA", "tar", "acl", "ya", "ac", "sq", "da", "ppa", "ja", "a", "ka", "bh", "ca", "ah", " SHA", "hi", "sam", "gc", "md", "ma", "la", "auto", "cycle", "shared", "wa", "cos", "asha", "no", "ta", "hs", "ksh", "SHA", "go", "shi", "sa"], "input": ["image", "output", "value", "field", "p", "data", "char", "Input", "string", "form", "q", "str", "set", "in", "from", "sq", "text", "c", "raw", "term", "join", "active", "add", "attribute", "prefix", "key", "batch", "lat", "word", "current", "bit", "source", "qa", "cur", "submit", "json", "ip", "sample", "qi"], "hash": ["ashes", "ash", "sh", "search", "here", "node", "style", "angle", "match", "cache", "count", "sum", "ha", "ssh", "where", "char", "color", "Hash", "print", "test", "tar", "have", "map", "score", "bh", "ah", "oh", "key", "ho", "hex", "code", "check", "hat", "her", "square", "hed", "save", "filter", "html", "handle"], "CPass": [" CPush", "CONTASS", "Cad", "CDact", "CPoss", "CPpress", "CTpass", "CPost", "PCost", "PCass", "CSoss", "CASS", "CMouch", " CPact", "cpASS", "TCass", "CCASS", "CHost", " CPpress", "cpass", "CPush", "CPix", "CHass", "CHiss", "cpact", "CONTasses", "CDass", " CPiss", "CPasses", "Couch", "CCass", "cpad", "Cush", "CPad", "CTouch", "PCiss", "CCad", "CPiss", " CPost", " CPASS", "CSass", "TCAss", "CMush", "CONTass", "Cpass", "CDoss", "CPouch", "CHASS", "CPASS", "CTad", "CSpress", "CMASS", "CPAss", "CHasses", "CSad", "CPred", "CDASS", "TCred", "CMpass", "Cact", "CMix", "PCASS", " CPAss", "CCred", "CMact", "CTass", "CONTiss", "CPpass", "cppress", "TCASS", "Cix", "Casses", "CCAss", " CPoss", "Ciss", " CPad", "CMass", "cposs", "CMad", " CPred", "CPact", "Cass", "CCix"], "h": ["k", "hr", "dr", "sh", "th", "zh", "hz", "b", "ht", "ach", "rh", "ha", "hl", "hm", "dh", "q", "err", "pp", "HH", "it", "hh", "he", "hp", "hu", "ph", "j", "bh", "ah", "oh", "H", "ho", "hi", "hex", "high", "phi", "kh", "head", "g", "eh", "hs", "t", "hd", "ih", "history"], "s": ["fs", "ins", "sl", "ats", "xs", "cs", "rs", "bs", "sts", "b", "ls", "string", "gets", "S", "ms", "ns", "strings", "sw", "ss", " ts", "str", "sq", "js", "gs", "ds", "sv", "ts", "sql", "sb", "sol", "tes", "ses", "sp", "ies", "less", "is", " parts", "als", " cs", "es", "os", "l", "hs", "its", " S", "ids", " es", "series", "qs", "ws", "ps"], "i": ["f", "mi", "u", "pi", "ix", "ini", "us", "ii", "si", "ai", "bi", "q", "m", "err", "me", "sim", "iu", "multi", "ic", "ei", "it", "status", "li", "ti", "span", "j", "ij", "init", "x", "hi", "ji", "batch", "zi", "base", "phi", "y", "ind", "ui", "g", "di", "asi", "gi", "oi", "ci", "ip", "\u0438", "o", "qi", "im", "index", "I"]}}
{"id1": "2642914", "id2": "14598566", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarJx", "addFileToTarGst", "addFileToTarGet", "addFileToTarGep", "addFileToTarGsz", "addFileToTarRx", "addFileToTarJzip", "addFileToTarBzip", "addFileToTarGp", "addFileToTarRzip", "addFileToTarJw", "addFileToTarGw", "addFileToTarGez", "addFileToTarGsp", "addFileToTarGt", "addFileToTarGezip", "addFileToTarBx", "addFileToTarGx", "addFileToTarBw", "addFileToTarJz", "addFileToTarBp", "addFileToTarRw", "addFileToTarRz", "addFileToTarGszip", "addFileToTarGzip", "addFileToTarBt", "addFileToTarBz"], "taro": ["Tolan", " targo", "Taro", "tory", "maro", "Tamo", "trary", "traro", "tary", "stoa", "Tara", " tara", "ttara", "waro", "tro", " tory", " taco", "ttosa", "troa", "stargo", "Taco", " tro", "ktrar", "retaco", "Tory", " trar", "qtolan", "thamo", "tempamo", "qtro", "trar", "marro", "tamo", "qtaro", "retaro", "warro", "stro", " tarro", "ktarro", "staco", "thosa", "Tarro", "Targo", "tosa", "tara", "retamo", "tolan", "stamo", "wargo", "tempro", "ktara", "wro", "starro", " toa", "thrar", "targo", "Tro", " tary", "temparo", "tharo", "retara", "tharro", "ktaro", " tamo", " tolan", "stary", "ttamo", "qtory", " tosa", "taco", "ttaro", "margo", "trro", "toa", "mro", "staro", "tempargo", "thara", "tarro"], "path": ["core", "th", "p", "ex", "pattern", "string", "clean", "ath", "ref", "chain", "print", "local", "m", "entry", "PATH", "text", "c", "dir", "key", "transform", "file", "name", "binding", "mount", "h", "full", "doc", "parts", "url", "Path", "root", "kind", "w", "history", "project", "pi"], "base": ["server", "b", "bf", "bare", "bas", "buffer", "basic", "normal", "bad", "absolute", "part", "based", "alias", "Base", "prefix", "file", "build", "parent", "relative", "family", "name", "binding", "extra", "check", "template", "full", "create", "common", "db", "reset", "ase", "start", "shadow", "default", "padding", "root", "pad"], "f": ["fs", "life", "ft", "b", "cf", "v", "bf", "p", "perm", "lf", "uf", "fm", "alf", "af", "fo", "elf", "fe", "e", "form", "inf", "far", "tf", "sf", "c", "fb", "fr", "fx", "fa", "xf", "file", "fg", "df", "fed", "y", "fac", "fp", "fi", "h", "fab", "i", "r", "g", "l", "fl", "t", "o", "fd", "rf", "F", "d", "w", "fc"], "entryName": ["entryname", "ryName", "EntryKey", "rowType", "EntryPath", "elementPath", "EntryName", "ryLetter", "cueKey", "elementKey", "entryLetter", "rowLetter", "rowname", "ryname", "cuename", "cueType", " entryLetter", "ryType", "elementname", "EntryType", " entryname", " entryKey", " entryType", "elementName", "cueName", "entryType", "entryKey", "rowName", "entryPath", " entryPath", "Entryname"], "goIn": [" goIns", " goin", "poIN", "poIn", "GoIN", "moInput", "geIn", "goInput", "goIN", "moIns", "moin", "GoIn", "GoOut", "moIn", "geIns", " goIN", "Goin", "goin", "poOut", "poin", " goOut", " goInput", "goIns", "gein", "GoIns", "moIN", "geInput", "goOut"], "tarEntry": [" tarItem", "warEntry", "warEnt", "warComponent", "rarEnt", " tarentry", "rarCategory", "tarComponent", "warItem", "rarComponent", "tarEnt", "rarEntry", " tarCategory", "tarentry", "rarentry", "carCategory", " tarComponent", "rarItem", "carEntry", "carentry", "tarItem", "tarCategory", "carEnt", " tarEnt"], "children": ["fs", "cloud", "cs", "kids", "ls", "stories", "cache", "hawks", "each", "items", "Children", "ml", "files", "packages", "ll", "they", "many", "follow", "balls", "ul", "users", "all", "reports", "batch", "aos", "parent", "objects", "members", "ren", "jobs", "modules", "keys", "resources", "pages", "json", "parents", "ports", "wn", "names", "groups", "los", "roots", "blocks", "ps", "these", "gall"], "child": ["Child", "id", "shell", "lf", "count", "cache", "friend", "char", "cell", "q", "cow", "ll", "block", "entry", "follow", "c", "uncle", "brother", "col", "ph", "fr", "page", "comment", "label", "key", "file", "batch", "parent", "ch", "name", "zip", "client", "last", "close", "l", "row", "pixel", "fd", "background", "job", "handle"]}}
{"id1": "12579075", "id2": "18613870", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFromSystemPro", "loadFromSystemAttribute", "loadFormSystemPro", "loadFromShellPro", "loadFormSysAttribute", "loadFromsystemProperty", "loadFormSysPro", "loadFormSystemProperty", "loadFromSysProperty", "loadFromsystemPro", "loadFromSysAttribute", "loadFromsystemProp", "loadFromSysProp", "loadFromsystemAttribute", "loadFromSystemProp", "loadFormSystemProp", "loadFormSysProperty", "loadFormSysProp", "loadFromSysPro", "loadFromShellAttribute", "loadFormSystemAttribute", "loadFromShellProp", "loadFromShellProperty"], "propertyName": ["serviceKey", "propName", "variablePath", "paramStart", "attributename", " propertyTitle", "propertyTitle", "propKey", "attributePath", "variableName", "propertyname", " propertyKey", "propname", " propertyStart", "paramName", "propertyPath", "propPath", "attributeKey", "variableKey", "paramTitle", "propertyStart", "serviceStart", "serviceTitle", "attributeName", "paramKey", "serviceName", "variablename", "propertyKey"], "urlStr": ["uriRest", "urlWr", " urlWr", "uriStr", "uriOr", "urlBr", "urlOr", " urlRes", "strStr", "URLCh", "urlCh", "uriRes", "URLBr", "uriSTR", "URLString", "urlRest", " urlString", "urlRes", " urlOr", "UrlWr", "uriWr", "urlString", "URLStr", "uriCh", "strString", " urlCh", "strOr", "UrlRes", " urlBr", "UrlRest", "uriString", " urlSTR", "UrlStr", "UrlString", "UrlSTR", "urlSTR", "strRest", "uriBr", " urlRest"], "in": ["mi", "ins", "din", "inside", "en", "again", "serv", "IN", "inn", "con", "s", "ln", "gin", "cin", "on", "bin", "conn", "from", "ic", "it", "to", "login", "init", "as", "nin", "mc", "ma", "body", "is", "inc", "out", "up", "rin", "doc", "i", "input", "win", "source", "inner", "h", "oin", "l", "asin", "t", "o", "isin", "In", "n"], "xmlDoc": ["mlFile", "imageDoc", "xfBuff", "xfFile", "xmlTree", " xmlVal", "documentTree", " xmldoc", "xfDoc", " xmlDocument", "xmlVal", "apacheRef", "xfVal", "apachedoc", " xmlRef", "xmlDocument", "imageRef", "apacheDoc", "mlDoc", "apacheDocument", " xmlFile", "imagedoc", "xmlBuff", "imageDocument", "mlBuff", "mlVal", "mlTree", " xmlTree", "documentDocument", "xmlRef", "xmlFile", " xmlBuff", "documentDoc", "documentFile", "xmldoc", "mlDocument"], "url": ["f", "u", "sl", "ssl", "gl", "b", "p", "dl", "char", "service", "bel", "google", "web", "str", "ll", "xml", "resource", "http", "rl", "re", "ul", "nl", "link", "browser", "ur", "URL", "file", "cert", "build", "base", "mount", "out", "get", "r", "lb", "uri", "Url", "still", "l", "null", "log", "job"]}}
{"id1": "873012", "id2": "15409512", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 0, "substitutes": {"url": ["loc", "el", "sl", "ssl", "domain", "gl", "b", "location", "ls", "dl", "pattern", "char", "external", "bel", "string", "path", "web", "ref", "un", "q", "str", "xml", "ll", "term", "resource", "http", "rl", "nl", "link", "page", "browser", "ur", "key", "sql", "URL", "impl", "file", "base", "address", "name", "mount", "get", "pl", "r", "ld", "uri", "Url", "config", "l", "cl", "default", "log", "util", "html", "job"], "in": ["f", "update", "mi", "ins", "din", "isin", "en", "again", "online", "serv", "IN", "con", "inn", "s", "ln", "ai", "cin", "gin", "on", "m", "bin", "from", "c", "login", "init", "nin", "mc", "al", "ma", "body", "reader", "name", "is", "line", "out", "check", "rin", "i", "input", "source", "inner", "oin", "l", "null", "include", "o", "vin", " din", "min", "read", "In", "n"]}}
{"id1": "8064604", "id2": "10391753", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"init": ["initial", "update", "bind", "prep", "dial", "connect", "hook", "setup", "set", "Init", "it", "load", "login", "register", "dump", "construct", " Init", "open", "get", "create", "config", "auth", "reset", "start", "use"], "mgr": ["cdr", "mnd", "MGr", " mdr", "Mdr", "mdr", "Mgr", "rmmg", "lGr", "cGr", "Mmg", "cmg", "rmgr", " mnd", "lgr", "rmGr", " mGr", "rmnd", " mmg", "mmg", "lnd", "mGr", "cgr", "lmg"], "cfg": [" conf", "Conf", "cf", " sch", " md", " mc", " msg", " caps", " sp", "map", " cf", " df", " config", "Config", "keys", "config", "g", "db", "conf", " sched", " cs", "ctr", " sane", "ct", " setup", " cz", "cb", " cp", " cc"], "sock": ["snip", "sip", "jsocks", "sink", "socks", "slvc", "slow", " svc", "spox", " socks", "snvc", "spock", "snock", "spocks", "jsock", "spink", "svc", "jsink", " sow", " sip", " sox", "slip", "jsox", "snow", " sink", "sow", "sox", "slock"], "_cman": ["_rctr", "_rml", "_rgr", "_cgr", "_dctr", "_rman", "_mml", " _dml", " _cml", " _dman", "_dgr", "_cctr", "_mctr", " _cgr", "_cml", "_dml", "_mgr", " _cctr", " _dgr", "_dman", " _dctr", "_mman"], "_sock": ["_svoc", "_sice", "_svq", "_rsock", "_Sock", "_rsocked", "_sek", "_csck", "_rsocket", "_dsrc", "_sourceek", "_dsck", "_sourceocked", "_csocked", "_Src", "_tock", "_rsck", "_sq", "_Socked", "_dsocks", "_lsq", "_socked", " _rsocked", " _ssock", " _sck", "_lsice", "_lsock", "_lsoc", "_sourceockey", "_csock", "_sck", "_tck", "_ssockey", " _ssocked", "_Sck", "_ssek", " _sockey", " _socked", "_spockey", "_spock", "_Socket", "_svock", " _ssockey", "_sourceock", "_ssocked", "_trc", "_svice", " _sek", " _rsck", "_spek", "_nsq", "_dsock", "_nsock", "_csocket", " _rsocket", "_soc", " _socket", "_nsice", "_socket", "_spocked", "_tocks", " _ssek", " _rsock", "_ssock", "_Socks", "_src", "_sockey", "_nsoc", "_socks"], "i": ["cli", "mi", "u", "id", "q", "err", "set", "sql", "counter", "gu", "g", "di", "gi", "mac", "ci", "\u0438", "info", "I", "k", "f", "pi", " I", "ix", "integer", "us", "e", "io", "chain", "print", "my", "m", "ki", "multi", "ic", "it", "li", "xi", "batch", "name", "is", "loop", "l", "o", "qi", "v", "p", "ex", "ity", "si", "me", "in", "iu", "c", "j", "x", "ie", "iy", "ip", "t", "index", "ami", "ini", "ii", "ai", "bi", "sim", "ti", "hi", "phi", "y", "this", "client", "ui", "im", "n"], "key": ["k", "et", "cmd", "tip", "important", "value", "KEY", "p", "ex", "sum", "char", "pair", "mk", "list", "Key", "string", "path", "foo", "chain", "print", "phrase", "test", "q", "my", "str", "entry", "by", "col", "ke", "prefix", "item", "x", "ie", "cert", "parent", "y", "ch", "cp", "word", "lock", "code", "this", "def", "client", "check", "cy", "name", "air", "title", "conf", "mac", "row", "ip", "json", "primary", "command", "index", "n"], "_sout": ["_ssout", "_ssres", " _sres", "_sco", "_svres", "_ssamp", " _sco", " _svres", " _svamp", "_sres", " _svout", "_wsres", "_wsco", " _samp", "_svco", "_wsamp", "_wsout", "_svout", "_ssco", "_svamp", "_samp", " _svco"], "_sinp": ["_senh", "_binh", "_cinP", " _sinh", " _sinm", "_sinP", " _cinP", " _cinm", "_binm", "_sinh", "_binp", "_cinp", "_binP", " _cinh", "_cinm", "_sinm", "_senP", " _cinp", "_cinh", "_senp", " _sinP", "_senm"], "seed": ["mix", "sl", "dd", "server", "store", "uid", "id", "node", "sum", "stable", "secret", "token", "sn", "then", "sudo", "sequence", "test", "delay", "random", "offset", "set", "entry", "sett", "insert", "Salt", "socket", "ser", "prefix", "dev", " seeded", "sid", "tmp", "sp", "zip", "shift", "finger", "serial", "pse", "se", "source", "feed", "iter", "db", "prime", "sel", "row", "shadow", "now", "sample", "eed", "temp", "password", "draw", "index", "slot"], "rand": ["max", "z", "dr", "rt", "Rand", "mr", "rc", "red", "round", "nd", "reg", "mk", "gen", "rev", "user", "sys", "normal", "random", "bot", "kick", "by", "add", "inv", "ro", "range", "dev", "rad", "res", "pos", "rx", "radius", "r", "rest", "rd", "spr", "and", "draw", "ng", "rot"], "hex": ["length", "wh", "mix", "sh", "exp", "cf", "com", "ex", "alpha", "rh", "hl", " Hex", "char", "color", "hook", "string", "form", "print", "random", "str", "term", "raw", "he", "hp", "ph", "password", "tex", "des", "rex", "x", "prefix", "cert", "ch", "tr", "zip", "none", "cas", "hw", "def", "kw", "pex", "h", "full", "serial", "mem", "iter", "lit", "json", "mac", "prop", "oct", "tx", "sex", "buff", "bytes", "html", "hello", "index", "temp"], "pass": ["access", "ask", "strip", "p", "sum", "task", "alt", "pair", "allow", "Pass", "gen", "secret", "process", "path", "print", "phrase", "test", "str", "ress", "val", "ass", "push", "pp", "pack", "ret", "ps", "step", "add", "gate", "prefix", "ack", "res", "act", "PASS", "name", "word", "pos", "def", "out", "wd", "reset", "conf", "fail", "pas", "parse", "rep", "pillar", "password", "press", "send", "read", "handle"], "md5": ["md45", "dig3", " Md4", " MD3", "MD2", "md_", "dig_", "dig45", " Md2", "hash23", "md3", "dig5", " md2", " MD64", "MD5", "md23", " md45", "MD23", "MD3", "md4", " md64", " md3", " MD5", "MD_", " md_", "hash3", "dig4", " md23", "MD4", " MD2", " Md5", "MD45", "hash2", " md4", "md2", "hash5", "MD64", "md64"], "hash": ["host", "ash", "hz", "header", "search", "id", "style", "sha", "rh", "sum", "alph", "total", "data", "ssh", "token", "Hash", "print", "test", "addr", "random", "password", "browser", "bolt", "cert", "flash", "name", "buster", "height", "h", "title", "hat", "her", "mac", "version", "type", "crypt", "html", "temp", "handle"], "banner": ["bininner", " bannel", "binter", "rainler", "bugner", " baner", "Baner", "scanline", "raininner", "broadinner", "bugker", "Banner", "binker", "scanter", "binner", "scanker", "broadnel", "scanner", "banker", "scannel", "Baninner", "baner", "scaninner", " banline", " baninner", "banline", "broadline", "bugter", "broadner", "rainner", " banler", "banler", "banter", "baninner", "rainer", "buginner", "Banler", "bannel"], "txt": ["wt", "tg", "rt", "tk", "writers", "words", "typ", "tch", "dat", "data", "mint", "nm", "htm", "tif", "Text", "XT", "print", "notes", "ns", "str", "kt", "xml", "text", "js", "ret", "tin", "qt", "tn", "sit", "priv", "obj", "res", "tmp", "nt", "msg", "fn", "def", "btn", "lt", "TEXT", "out", "details", "tm", "json", "xt", "ct", "tx", "t", "ext", "buff", "utt", "html", "ws", "tp", "plain", "cont"], "sname": ["same", "lsadmin", "ssnam", "snam", "spnam", "spname", "lsame", "spame", "sadmin", "spadmin", " sName", "sName", " same", "ssname", " snam", "ssame", "lsnam", "lsname", "ssadmin", "ssName"], "spass": ["spss", " spASS", "SPack", "ospss", "pswd", "osposs", "ospwd", "spwd", " spss", "ospass", "spack", " spwd", "spASS", "psss", "ospASS", "spred", "SPass", "ospred", "ospack", "psass", "SPASS", " spred", " sposs", "SPoss", "sposs", "psred", " spack"], "sseed": ["siter", "Seed", "psentry", "srandom", "sentry", "ssecret", "psecret", "wspass", "tsser", "wssel", "Sseed", "ssseed", "wsseed", "ssel", "sser", "ssser", "psseed", " siter", "pspass", "prandom", "ssiter", "peed", "tsseed", " sser", "tsiter", "pseed", "wsentry", "Srandom", "pssel", "tseed", "Ssecret"], "items": ["phones", "rows", "els", "ins", "ars", "terms", "xs", "mods", "values", "rs", "Items", "airs", "ips", "aux", "arms", "lets", "ues", "types", "times", "orders", "ms", "files", "actions", "flows", "links", "images", "boxes", "EMS", "ics", "ims", "item", "cats", "arts", "ites", "cases", "styles", "objects", "keys", "details", "ops", "pages", "results", "abs", "lines", "its", "stuff", "ids", "groups", "qs", "faces", "blocks", "amps", "stats"]}}
{"id1": "23291583", "id2": "7761195", "code1": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["fectString", "faultURL", "FetchUrl", "fetchString", "faultUrl", "FetchURL", "faulturl", "Fetchurl", "fectUrl", "fetchURL", "fecturl", "faultString", "FetchString", "fectURL", "fetchurl"], "urlString": [" urlName", "uriRest", "lString", "sslSeries", "sslStr", "Urlstring", "uristring", "urlRest", " urlStr", "urlSeries", " urlSeries", "lStr", " urlstring", "UrlRest", "uriString", "lSeries", "urlStr", "sslName", "urlstring", "urlName", "lName", "UrlString", " urlRest", "sslString"], "outException": ["OUTError", "outExample", "cnEvent", "inCondition", "outCondition", " outAddress", " OUTExample", " outEvent", " outCondition", "cnException", "OutException", "inExample", "OUTTransaction", " OUTException", "inAddress", "outAddress", " OUTEvent", "OUTExample", "OUTEvent", "OUTException", "outEvent", "outError", "OutAddress", "inEvent", "cnError", " outTransaction", "inException", "OutCondition", "cnExample", "outTransaction", " outExample", "inError", "OutEvent", " OUTTransaction"], "url": ["rel", "host", "el", "u", "sl", "ssl", "bl", "gl", "org", "b", "https", "ls", "dl", "channel", "il", "hl", "email", "char", "bel", "github", "web", "ml", "str", "ll", "xml", "pkg", "http", "rl", "ul", "nl", "link", "www", "ur", "impl", "URL", "cert", "build", "base", "address", "dll", "mount", "mail", "lt", "pl", "get", "r", "uri", "Url", "l", "hub", "log", "download", "job"], "is": ["isa", "fs", "sis", "isl", "xs", "lis", "ri", "iss", "bs", "ris", "mos", "bits", "ir", "serv", "ists", "ls", "dis", "isi", "ib", "s", "ys", "sys", "ms", "sim", "iso", "ism", "in", "has", "js", "inst", "bis", "tis", "ois", "ims", "init", "IS", "res", "eps", "vis", "Is", "ires", "isc", "i", "still", "oss", "isf", "es", "os", "ils", "abs", "ip", "ais", "its", "isin", "im", "was", "ios"], "inc": ["num", "ins", "const", "incre", "rc", "exp", "count", "ec", "enc", "sc", "dec", "integ", "rec", "INC", "cc", "inn", "ln", "inf", "acc", "ac", "err", "frac", "zero", "in", "pp", "c", "asc", "step", "add", "Inc", "dc", "occ", "width", "init", "ch", "ind", "isc", "ipl", "iter", "exc", "ctr", "include", "pad", "index", "min"], "curr": ["currc", "chn", "chR", "urr", " currs", "curR", "constrid", "grr", "Curn", "currid", " currd", "rcrs", "curn", "currb", "catrs", " currb", "contp", "grrs", "catrid", "grp", "curmr", "corl", "currd", "curp", "grrc", "contrc", "Curl", "Currid", "rcl", "chr", " currc", "rcr", "Currb", "currs", " curl", "contr", " curR", "urrc", "Curmr", "corr", "corrd", "corn", "corp", "rcmr", "chp", "Currc", "corrb", " currid", "Curr", " curn", "constrs", "contrd", "contn", "contl", "curl", " curmr", "constr", "Currs", " curp", "CurR", "catr", "Curp"], "result": ["length", "record", "output", "value", "search", "successful", "currency", "match", "cache", "data", "message", "total", "description", "list", "buf", "Result", "repl", "csv", "complete", "sequence", "buffer", "rue", "valid", "test", "pre", "phrase", "block", "term", "rendered", "RESULTS", "ret", "text", "answer", "collection", "status", "table", "response", "page", "report", "all", "prefix", "res", "batch", "tmp", "master", "this", "false", "current", "true", "memory", "cur", "r", "proc", "results", "null", "row", "success", "summary", "next", "command"], "n": ["f", "cn", "z", "num", "el", "nn", "nu", "en", "v", "p", "nc", "nm", "s", "e", "N", "ln", "ne", "un", "sn", "an", "ns", "le", "m", "ll", "c", "nor", "nl", "j", "nan", "yn", "nt", "fn", "y", "name", "ren", "nr", "no", "number", "len", "r", "i", "g", "l", "na", "gn", "t", "o", "np", "d", "ng"], "temp": ["copy", "unt", "perm", "v", "dat", "alt", "tc", " tmp", "tty", " temporary", "partial", "test", "local", "EMP", "buffer", "mm", "pt", "pre", "term", "mod", "em", "ph", "orig", " Temp", "emp", "tv", "ptr", "mp", "tmp", "porary", "tr", "current", "met", "txt", "template", "Temp", "mem", "create", "tm", "tem", "created", "fake", "tab", "variable", "make", "t", "buff", "tt"]}}
{"id1": "12066447", "id2": "19549577", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"truncate": ["trculize", "trunation", "truncation", "trculicate", "truncicate", "extvalidation", "trunate", "extuncicate", "extvalidicate", "trculation", "trvalidicate", "extvalidize", "truncize", "extuncate", "trvalidate", "trunicate", "trunize", "trculate", "trvalidation", "trvalidize", "extvalidate", "extuncation", "extuncize"], "file": ["f", "image", "object", "port", "work", "model", "class", "channel", "data", "message", "format", "path", "foo", "le", "user", "e", "io", "files", "tree", "block", "from", "or", "File", "resource", "table", "size", "frame", "FILE", "link", "spec", "to", "page", "line", "report", "range", "dir", "attribute", "run", "base", "parent", "be", "event", "name", "lock", "this", "word", "current", "out", "fp", "zip", "ile", "full", "get", "source", "filename", "create", "template", "null", "type", "time", "log", "use", "info", "local", "module", "handle"], "backupRoot": ["BackupidRoot", "backupidroot", "backureDir", "BackupFolder", "BackupRoot", "backureroot", "BackupidFolder", "backupsBox", "backupFolder", "backureRoot", "workupDir", "backumpDir", "backdownFolder", "backmpDir", "backupidBox", "workuproot", "backflowFolder", "backupDir", "backupsroot", "backmproot", "workupidBoot", "workupidHome", "backumpRoot", "backuproot", " backupidDir", "workupRoot", "backupBoot", " backupidroot", "backmpRoot", "workupBoot", "backupidFolder", "workupidDir", "backflowRoot", "BackupidDir", "backdownRoot", "backuperroot", "workupidRoot", "backupBox", "BackupDir", " backupBox", "backumpBox", "backupidDir", "backuperHome", " backuproot", "backupHome", "backuperDir", "backupidHome", "backureBoot", " backupidBox", "backureHome", "backmpBoot", " backupDir", "backumproot", "backupsDir", "backdownDir", "workupHome", " backupidRoot", "backupidBoot", "backflowDir", "backuperRoot", "backupsRoot", "backupidRoot", "workupidroot"], "df": ["f", "pdf", "dd", "dr", "fun", "cf", "bf", "du", "dx", "dt", "uf", "dl", "lf", "format", "tif", "sd", "mm", "pd", "tf", "sf", "ds", "dc", "md", "Def", "dm", "NF", "def", "dep", "dim", "DF", "db", "raf", "deb", "di", "cd", "fd", " pdf", "hd", "d", "gd", "dp"], "date": ["update", "cal", "output", "value", "Date", "when", "match", "today", "dt", "grade", "zone", "dat", "data", "message", "standard", "sum", "format", "string", "content", "ate", "due", "future", "month", "duration", "dated", "resource", " Date", "down", "frame", "note", "day", "range", "year", "tag", " day", "daily", "run", "late", "dates", "name", "event", "number", "get", "create", "age", "start", "version", "default", "time", "save", "now", "module", "days"], "zipFile": ["zipfile", "zipPath", "zipFilename", "jsonFile", "ZipFile", "ZipStream", "zipStream", "ZipPath", "zipStore", "jsonFilename", "pdffile", "zStore", "pdfPath", "Zipfile", "jsonStore", "zFilename", "logStore", "zFile", "pdfStream", "logFile", "logfile", "logPath", "zfile", "jsonfile", "logStream", "logFilename", "pdfFile"], "zos": ["sis", "z", "zan", "css", "hz", "zes", "sch", "zag", "bs", "ros", "enos", "bes", "ze", "hess", "estro", "esm", "zona", "ozo", "ss", "js", "webkit", "asar", "rez", "zen", "zers", "oses", "zik", "south", "tz", "asio", "eros", "zar", "zzle", "sol", " sands", "ses", "zi", "cos", "ez", "zer", "cz", "jas", "enz", "stice", "shed", "oss", "zon", "os", "zb", "Sax", "nz", "hs", "los", "zo", "sbm", "ones", "za", "zin"], "fis": ["ifisc", "FIs", "dfis", "foia", "dfIs", "lia", " fib", "fisc", "sfIs", "lis", "sfisc", "cfisc", "ofib", "fiib", "ofits", "cfits", "foIs", "ef\u00eds", "fiiss", "fIs", "if\u00eds", "fia", "Fis", "ofisc", "sfier", "sfis", "F\u00eds", "fiss", " fiss", "f\u00eds", "foi", "ofiss", " fois", "cfis", "sfiss", "cfiss", "li", "fiois", "sfits", "dfier", "ofis", "ifIs", "efisc", "ifis", "fiis", "Fier", "fits", "dfiss", "fi", "ofois", "fib", "Fisc", "efis", "lIs", "fier", "Fia", "Fiss", "Fi", "fois", "efIs"], "entry": ["object", "entity", "record", "office", "ry", "search", "deep", "data", "char", "description", "ent", "rance", "e", "ment", "delete", "ary", "cell", "member", "section", "xml", "set", "or", "resource", "insert", "option", "and", "add", "de", "tex", "comment", "attribute", "key", "sheet", "connection", "obj", "ie", "event", "zip", "word", "element", "ion", "def", "cue", "ace", "se", "internal", "row", "ce", "Entry", "zo", "command", "escape"], "buffer": ["length", "letter", "header", "binary", "cache", "screen", "message", "window", "char", "buf", "queue", "stack", "phrase", "sequence", "block", "zero", "view", "button", "volume", "table", "frame", "bar", "available", "page", "comment", "category", "paste", "attribute", "document", "batch", "code", "library", "base", "word", "append", "template", "memory", "iter", "variable", "Buffer", "padding", "buff", "sample", "command", "temp"], "readed": ["READd", "indexED", "indexed", "readied", "Readared", "Readied", "reded", "READed", "countED", "findED", "readared", "readableED", "counted", "readented", " readED", "indexented", "READer", " readented", "readableed", "Readed", "countd", "readd", "Reader", "reader", "counter", "indexeded", "Readd", "redented", "rededed", "ReadED", " readeded", "redED", "readableied", "findied", "readeded", "READED", "findared", "readED", "readableared", "finded"]}}
{"id1": "15262411", "id2": "16621503", "code1": "    String fetch_pls(String pls) {\n        InputStream pstream = null;\n        if (pls.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), pls);\n                } else {\n                    url = new URL(pls);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + pls);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            if (line.startsWith(\"File1=\")) {\n                byte[] foo = line.getBytes();\n                int i = 6;\n                for (; i < foo.length; i++) {\n                    if (foo[i] == 0x0d) {\n                        break;\n                    }\n                }\n                return line.substring(6, i);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"fetch_pls": ["fetch_reples", "fetch_plls", "fetch_cles", "fetch_repls", "fetch_iplts", "fetch_replls", "fetch_clls", "fetch_iples", "fetch_iplls", "fetch_ipls", "fetch_plts", "fetch_cls", "fetch_ples", "fetch_replts", "fetch_clts"], "pls": [" plits", "blss", "pats", "fls", " plos", "splls", " plS", "Pls", " plis", " plt", "PLjs", " plerences", "plos", "iplos", "bles", "blS", "pps", "plis", "plt", " ples", "bls", "paterences", "Plis", "plss", "spls", " plss", "plits", "PLs", "pljs", "ppls", "plS", "PLits", "splerences", "Plls", "ppt", "plerences", "splt", "fles", " pljs", " plls", "patls", "flS", "Plos", "plls", "ples", "PLis", "iplls", "flss", "Pljs", "Plits", "ipls"], "pstream": ["vppod", "ppod", "mpstream", "lsupp", " pline", "vpsocket", "phpream", "pssocket", "mppod", "vpstream", "ptStream", "phpstream", "ltime", "vpfile", " pmount", "lstream", "phpsocket", "ppmount", "ptstack", " psocket", "pspod", "mpsocket", "psstream", "mpfile", "phpsupp", "pline", "ppream", "pstack", " pStream", " ptime", "ptstream", "phpline", "psupp", "psocket", "Ppipe", "phpmount", "ppstream", " pchain", " psw", "phpsw", "Pstack", " pstack", "PStream", " psupp", "pfile", " ppipe", "pream", "Pstream", "psw", "ptpipe", "ppchain", "ppipe", "ptime", " pream", "pmount", "mpline", "phptime", "pchain", "pStream", "lream", "phpchain", "mpsw", "psfile"], "url": ["loc", "f", "rel", "host", "el", "u", "sl", "cal", "ssl", "gl", "org", "https", "ls", "dl", "il", "hl", "window", "email", "bel", "con", "web", "ml", "ref", "user", "str", "ll", "xml", "conn", "rl", "http", "ul", "nl", "link", "www", "browser", "ur", "URL", "cert", "address", "cp", "open", "mount", "mail", "client", "ob", "ol", "pl", "r", "Url", "deb", "l", "cl", "log", "util"], "urlc": ["charcon", "urlC", "urlcon", "UrlC", "urlct", "urlcs", " urlcon", "URLC", "httpc", "webcon", "httpcs", "URLcs", "urlcc", "URLc", "webC", "Urlc", "httpC", "charcc", "webc", "charC", "charc", "URLct", "httpct", " urlcc", "webcc", "Urlcs", "Urlct", " urlC"], "line": ["record", "ine", "pe", "value", "header", "stream", "liner", "online", "port", "channel", "eline", "message", "char", "detail", "string", "ln", "lo", "ne", "le", "print", "phrase", "cell", "sequence", "valid", "chain", "block", "lin", "entry", "continue", "ode", "text", "zero", "rule", "normal", "frame", "nl", "Line", "inline", "stay", "page", "link", "comment", "range", "note", "label", "file", "lane", "body", "msg", "none", "word", "lock", "buffer", "no", "mail", "out", "se", "iter", "l", "row", "lines", "next", "log", "LINE", "sample"], "foo": [" Foo", "axe", "bow", "binary", "bits", "bug", "something", "xxx", "bo", "fo", "yy", "area", "fax", "brace", "xy", "xx", "my", "flo", "radio", "zx", "oo", "frame", "bar", "goo", "dirty", "bool", "aaa", "prefix", "some", "lex", "ox", "beer", "wrong", "buck", "coin", "hat", "config", "tab", "pie", "apache", "mu", "stuff", "bytes", "printf", "hello"], "i": [" j", "cli", "length", "mi", "num", "ami", "u", "id", "ri", "ix", "ini", "I", "ii", "us", "si", "e", "ai", "s", "bi", "cgi", "n", "q", "m", "me", "sim", "iu", "ki", "multi", "ic", "ei", "it", "li", "ti", "j", "xi", "key", "x", "hi", "ori", "ji", "zi", "phi", "y", "pos", "is", "ui", "fi", "uri", "di", "oi", "gi", "l", "ci", "start", "\u0438", "qi", "info", "index", "pi"]}}
{"id1": "6341264", "id2": "22338097", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getServerInfo", "getResourceResource", "getResourceItem", " getJarEnt", "getJarItem", " getFileInfo", "getModuleEnt", "getServerResource", " getZipFile", "getJarInfo", "getZipEntry", "getJavaItem", "getZipItem", " getZipEntry", "getFileEntry", " getFileEntry", " getJarItem", "getZipFile", " getFileResource", " getZipItem", "getResourceEntry", "getJavaEntry", " getZipEnt", " getJarInfo", "getModuleItem", "getJarResource", "getModuleFile", "getJarEnt", "getServerItem", "getFileResource", "getServerEntry", "getJavaFile", "getZipEnt", "getFileInfo", "getJavaEnt", " getJarFile", "getJarFile", " getFileItem", "getFileItem", "getResourceInfo", " getJarResource", "getModuleEntry"], "jarName": ["sessionname", "JarN", "jarLocal", " jarKey", "jobN", "JarLocal", " jarname", "jobName", "JarName", "jarKey", "jarname", "binaryName", "jobname", "Jarname", "binaryname", "jobLocal", " jarLocal", "sessionName", "sessionKey", "binaryKey", " jarN", "jarN"], "entry": ["server", "search", "ry", "field", "archive", "data", "description", "enter", "ent", "er", "string", "e", "path", "delete", "print", "cell", "xml", "text", "resource", "comment", "jar", "key", "query", "file", "ie", "address", "name", "zip", "word", "element", "quit", "input", "uri", "row", "log", "Entry", "command", "index"], "port": ["length", "host", "server", "value", "p", "position", "count", "format", "localhost", "string", "path", "offset", "pt", "it", "limit", "priority", "socket", "width", "page", "export", "ort", "key", "connection", "address", "pc", "Port", "PORT", "pos", "eport", "age", "version", "row", "ports", "start", "ip", "type", "remote", "point", "index", "project"], "b": ["f", "ba", "u", "bl", "bs", "p", "v", "bf", "bits", "ib", "buf", "s", "bp", "e", "bas", "bi", "buffer", "nb", "bin", "ab", "c", "fb", "a", "j", "wb", "sb", "B", "xb", "eb", "emb", "base", "bt", "y", "be", "mb", "gb", "bit", "br", "ob", "h", "i", "r", "db", "l", "buff", "bb", "d", "cb", "pb"], "codebase": ["codespace", "corespace", "codebas", " codease", "codeBase", "ceBase", "cebased", " codebased", "codease", "Codebase", "Codebas", "Codespace", "codefile", "Codease", " codebas", "chespace", " codeBase", "chebase", "linkBase", "cheBase", "cease", "cebase", "linkbas", "corebase", "codebased", "chefile", "Codebased", "coreBase", "Codefile", "corefile", "CodeBase", "linkbase"], "protocol": ["pertotype", "phyix", "patol", "perticle", "protility", "protos", "prool", "patotype", "protix", "pronavior", "patocol", "cryptol", "phyility", "pertocol", "cryptotype", "prootype", "protol", "cryptication", "proavior", "cryptos", "patos", "prototype", "pronocol", "cryptocol", "proticle", "proos", "cryptix", "scheocol", "scheix", "proicle", "protavior", "cryptility", "phyication", "protication", "proocol", "pertavior", "scheility", "phyocol", "pronicle", "scheication", "pronotype"], "x": ["max", "z", "xs", " cx", "ix", "dx", "xes", "ex", "p", "mx", "xa", "xx", "xy", "ax", "n", "nex", "X", "xp", "xi", "px", "xf", "xxxxxxxx", "wx", "ox", "y", "rx", "w", "i", "tx", "t", "ux", "xc", "index", "inx", "xd"], "s2": ["s02", "ps02", " stwo", "s1", "estwo", "x02", "sv1", " slt", "pslt", "sv02", " s1", "ss3", "xlt", "ss2", "es2", "ts2", "x1", "stwo", "ps2", "ps1", "ss02", "slt", "es1", " s02", "s3", "s4", "sv2", "ts4", "ts02", "ss4", "svtwo", "ts3", "es02"], "x2": ["ax3", "x02", "x3", "ax2", "rx02", "ex1", "rx2", " x1", "ex3", "rx1", " x02", "ex2", "ax1", "x1", " x3", "ix2", "ix1", "ix02", "ex02", "ax02"], "downloadHost": ["Downloadhost", "downloadNode", "DownloadDomain", " downloadPath", "downloadPort", "DownloadUrl", "downloadPath", " downloadHead", "dumpDomain", "downloadhost", "downloadHead", "dumpUrl", " downloadhost", "transferHost", "archivehost", " downloadNode", "DownloadHead", "archiveHost", "dumphost", "downloadDomain", "dumpHost", "DownloadPath", "DownloadPort", " downloadUrl", "transferPort", "archiveUrl", " downloadPort", "dumpPath", "DownloadNode", "transferhost", "dumpNode", "DownloadHost", "archiveHead", "transferUrl", " downloadDomain", "downloadUrl"], "url": ["rel", "loc", "el", "sl", "ssl", "gl", "atl", "ls", "serv", "dl", "arl", "il", "hl", "bel", "lr", "web", "ref", "ml", "str", "ll", "ret", "http", "rl", "ul", "nl", "link", "www", "browser", "ur", "jar", "URL", "sb", "file", "obj", "build", "base", "name", "zip", "open", "call", "mount", "mail", "ob", "pl", "lb", "uri", "Url", "l", "json", "log", "download", "mil"], "jurl": ["jpUrl", "jll", "jckl", "jarUrl", " jll", "jgl", "jpurl", "jsll", "jpsl", "jjjob", "jsgl", "jjob", " jgl", "jsUrl", "jUrl", "jcurl", "jsURL", "jsurl", "jssl", "Jurl", " jjob", "zgl", "zurl", "jarname", " jURL", "Jname", "zll", "zUrl", " jsl", "jsjob", "jjURL", "jarkl", "jjUrl", "JUrl", "jname", "Jkl", "jjurl", "jkl", "jcname", "jURL", "jarurl", "jpgl", " jUrl", "jsl", "jcUrl"], "je": ["zy", "jen", "pe", "ese", "dj", "jj", "jp", "jet", "ze", "te", "ge", "ele", "ae", "e", "ve", "ne", " Je", "js", "ei", "nex", "sec", "ja", "ffe", "j", "jl", "ie", "pet", "zip", "bj", "exe", "elt", "se", "oe", "vre", "zo", "jo", "ee"], "is": ["isa", "isl", "fs", "mi", "ins", "sis", "lis", "ri", "bs", "iss", "ris", "bits", "ir", "ists", "isi", "ib", "il", "nis", "ii", "s", "si", "ai", "bi", "obs", "iso", "in", "js", "atis", "tis", "ois", "IS", "sb", "Is", "ires", "isc", "i", "es", "os", "\u00eds", "ais", "its", "ist", "isin", "im", "ios"], "bis": ["fs", "uffy", "ins", "pins", "lis", "ri", "bits", "bs", "ris", "onis", "abin", "ls", "rs", "ubis", "bes", "serv", "rots", "isi", "nis", "bi", "binary", "ns", "obs", "xy", "bil", "gs", "bps", "tis", "bh", "fr", "bos", "sb", "res", "aos", "ses", "vs", "uds", "ob", "oss", "conv", "es", "os", "ais", "its", "buff", "bytes", "rison", "bb", "sbm", "ibe", "isin", "cb", "oi", "ios"], "size": ["length", "max", "num", "iz", "pi", "Size", "mode", "count", "scale", "sum", "message", "SIZE", "ose", "ize", "ze", "capacity", "area", "si", "empty", "sn", "notice", "space", "scroll", "status", "news", "score", "re", "sv", "storage", "range", "year", "sy", "shape", "small", "body", "settings", "name", "unit", "nr", "number", "len", "se", "zie", "type", "time", "sex", "now", "sample", "use", "index", "send", "n"], "rb": ["num", "rt", "mr", "ord", "rc", "rs", "ri", "ruby", "rg", "buf", "umb", "bp", "lr", "ref", "nb", "rid", "err", "rob", "fb", "ru", "ro", "rex", "wb", "cb", "sb", "rw", "ptr", "eb", "xb", "erb", "rar", "gb", "nr", "buster", "br", "ob", "cr", "lb", "rm", "kb", "r", "db", "RB", "rss", "ctr", "rod", "ring", "rab", "rd", "bb", "rf", "bone", "pb"], "chunk": ["cpunks", "charunk", "chedoint", "charbyte", "Chunks", "chord", " chulk", " choint", " chord", " chunks", "chulk", "Chunk", "cunks", "ichunk", "chork", "ichunks", "cow", "echunks", "charoint", "cpork", "chunks", "echbyte", " chbyte", " chump", "cunk", "chedunks", "tchork", "chbyte", "tchow", "charunks", "Chulk", "chow", "chump", "cpunk", "echord", "chedump", "tchunk", "chedunk", "ichulk", "echunk", "charump", "tchunks", "choint", "cork", "cpow", "charord"]}}
{"id1": "12197169", "id2": "4562786", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 1, "substitutes": {"read": ["record", "stream", " reader", " retrieve", " reopen", "connect", " reads", " seek", "Read", " request", "load", "reading", "init", "gc", "run", "reader", "open", " Read", " recover", " ingest", "find", "close", " replay", "start", " download", "next", "log", "download", "hello"], "in": ["f", "update", "ins", "din", "record", "stream", "again", "with", "when", "message", "IN", "er", "inn", "con", "index", "io", "inf", "cin", "on", "bin", "from", "entry", "it", "via", "or", "by", "re", "and", "add", "ro", "all", "as", "file", "run", "al", "body", "at", "reader", "name", "is", "inc", "out", "check", "during", "get", "input", "r", "source", "inner", "ing", "conf", "l", "url", "o", "log", "ill", "isin", "info", " din", "In"], "line": ["record", "ine", "stream", "liner", "eline", "data", "message", "char", "detail", "string", "e", "ln", "path", "le", "chain", "lo", "sequence", "cell", "block", "lin", "entry", "text", "part", "frame", "stroke", "Line", "link", "inline", "page", "comment", "piece", "file", "lane", "body", "code", "word", "se", "l", "row", "url", "log", "sample", "LINE", "point"], "i": ["f", "cli", "mi", "z", "u", "id", "pi", "ix", "p", "v", "ii", "si", "index", "ai", "bi", "sequence", "n", "m", "me", "sim", "multi", "c", "ei", "li", "ti", "j", "xi", "to", "x", "hi", "ori", "zi", "base", "phi", "y", "ind", "is", "d", "iter", "conv", "di", "l", "ci", "t", "o", "qi", "im", "oi", "I"], "logDatum": ["logTrummy", " logDictionary", "logDoummy", "logTrum", "logdummy", "logDum", "LogDum", "logDump", "logRictionary", "logDoatum", "logBatum", "LogData", "logBump", "logDummy", " logBictionary", "logData", "logdum", "logRummy", "logdata", "logTratum", "logRump", " logBummy", " logDummy", "logBictionary", "Logdummy", "logBummy", "logTrata", "LogDatum", " logBatum", " logBump", "LogDummy", "logDictionary", "Logdata", " logDump", "logDoump", "logRatum", "logdatum", "Logdatum", "Logdum", "logDoictionary"]}}
{"id1": "23672408", "id2": "9319440", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 0, "substitutes": {"copyIconFiles": ["copyIconImages", " copyiconDocuments", " copyiconImages", "copyIndexfiles", "copyiconDocuments", " copyIconDocuments", "copyiconFiles", "copyIndexDocuments", "copyIndexImages", "copyiconfiles", "copyiconImages", " copyiconfiles", "copyIconDocuments", "copyIndexFiles", " copyIconfiles", " copyIconImages", " copyiconFiles", "copyIconfiles"], "clazz": ["CLbean", "relab", "CLazz", "crus", "clashed", " plub", "classotted", "plaz", " clashed", "cluddy", "pkgazz", "pkgashed", "colluster", " cluster", " plaz", " clbo", "clab", "classazz", "chotted", "chace", "escotted", "cluster", "pkgaz", "escazz", "chazz", "clus", "Claz", " cluddy", "club", "pkgasse", "sclace", "Clace", "crub", "callbo", "callazz", "plazz", " plazz", "relose", "Clab", "classe", "close", "sclazz", "craz", "callaz", " club", " claz", "Clbo", "descose", " clbean", "collazz", " clus", "clojure", "clbean", "clbo", "relaz", "plasse", "clotted", "descazz", " classe", "chojure", "descaz", " clace", " clojure", "plashed", "escace", "colluddy", "callace", " closer", "CLace", " clotted", "Clazz", "CLoser", "escojure", "claz", "closer", "Close", "descab", "classuster", "scloser", "relazz", "classuddy", "clace", " plus", "crazz", "sclbean", "collotted"], "i16": ["iri6", "ami16", "pi150", "ii16", "i63", "i157", "iniShort", "ri16", " i160", " i6", "pi6", "pi63", "amiShort", "ji150", " i157", "i216", "ini216", "i6", "i19", "iri2016", "ini24", "ami6", "i2016", "ami63", "liShort", "iri16", "i160", "ami2016", " i24", "i150", "li16", "li2016", "pi16", "ami19", "ii216", "ii160", "ini160", "ji16", "ami150", "ji63", "ri6", "iri157", "iShort", "ri157", "ji6", "ini19", "i24", "ini2016", " i2016", "ri2016", "ini16", "li19", " i216", "ii24"], "fileType": ["viewTYPE", "ileType", "formatType", "treetype", "webTYPE", "filetype", "coreHandler", "FILEtype", "eventType", "formtype", " filePattern", "iletype", "webTyp", "FILEName", "fieldTyp", "relationHandler", "webList", "viewtype", "treeTime", "filePattern", "fieldDef", "FileType", "fileFamily", "coreTyp", "treeTYPE", "formatTime", "fileTime", "webType", " fileTyp", "eventTYPE", " fileTime", "coreDef", "policyType", "fileTYPE", "fileHandler", "formatTYPE", "coreTYPE", "FileName", " filetype", "issueTyp", "fieldType", "fieldTYPE", " fileFormat", "eventUnit", "fileUnit", "policyTyp", "Filetype", "coreFamily", "resourceFormat", "fileTyp", "formName", "relationType", "fileFormat", "resourceUnit", "formType", "fileName", "treeType", "eventFormat", "webDef", "coreType", "relationFamily", "ileTyp", "ilePattern", "relationTyp", " fileTYPE", "fileValue", "issuetype", " fileValue", "viewType", "policyHandler", "policyFamily", "issuePattern", "eventList", "resourceTYPE", "FILEType", " fileUnit", "formatValue", "fileDef", "fileList", "viewValue", " fileList", "resourceType", "formattype", "issueType"], "desti16": ["destgi216", "destsi160", "destui160", "destsi18", "destui24", "destsi32", "resulti16", "desti2016", "destii216", " destsi18", "desti160", "resultii216", "destsi16", "resulti24", " desti18", "resultii16", "resulti2016", "resultii24", "destii24", "destui18", "destxi160", "destui32", "destxi18", " destsi16", " destsi160", "destgi16", "destxi16", "destgi2016", "destii2016", "desti24", "destui16", "destii16", "destui2016", " desti160", "desti216", "destgi24", "destxi32", " destsi32", "destui216", "desti18", "resulti216", "resultii2016"], "src": ["loc", "rel", "iv", "isl", "ins", "cli", "sl", "ssl", "std", "rc", "rs", "scan", "ls", "sc", "rg", "hl", "usr", "sync", "vr", "ln", "dest", "sn", "addr", "sys", "obs", "ctx", "bin", "rob", "via", "st", "sq", "pkg", "sec", "gs", "rl", "ibl", "etc", "inst", "nl", "sit", "ser", "bh", "bg", "req", "urg", "sub", "img", "sb", "ptr", "sol", "tmp", "sp", "rx", "cmp", "comp", "txt", "source", "syn", "cur", "bc", "inner", "input", "proc", "sel", "iter", "ctr", "rb", "sr", "desc", "rest", "cb", "fc", "cont"], "dst": ["nnd", "rcut", " dest", "derst", "tput", "ndest", "dnd", "dbl", " ddest", "Ddr", " ddr", " dmn", "rbl", "dLcut", "fst", "ddmn", " dmt", "dernd", "dLnet", "dest", "rst", "rdst", "dsnet", "Dnd", "dsot", "ngt", "Dst", "dLot", "ddnd", "ddr", "dput", "dLbl", "dLdest", "Ddest", "dermn", " dput", "dsst", "dddest", " dgt", "dsts", "dLest", "dnet", "ddst", "rdmt", " dnd", "dcut", "fdest", "tst", "dsest", " dot", "dmt", "ndsts", "rdest", " dcut", "dmn", "tgt", " dnet", "rdsts", "nput", "nst", "dot", " dsts", "dgt", "ddest", "dLst", "ndmt", "ndst", "derdest", " dbl", "fdr", "tnd", "fnd"], "i32": ["i22", "pi31", "ip31", "i31", "pi34", "ini31", "xi32", "i64", "ic64", "xi48", " i34", "i342", "isi40", "ip64", "i34", "isi64", "xi31", "ip32", " i28", "isi32", "ii342", "i28", "ic28", " i40", "ini22", "isi86", "ii34", "i86", "ip34", "ini48", "ii28", " i86", "pi32", "i48", "ic40", "ic34", "ic342", "ic32", "pi64", "xi22", "ic22", "ic31", " i64", "i40", " i342", "ii32", "ini32", "ic86", " i31", "ic48"], "desti32": ["destic34", "desti90", "DestI90", "destu90", "Desti32", "destu31", "desti34", "destic32", "destpi34", "destI31", "destI32", "destI90", "Desti256", "targetpi30", "destdi31", "destI256", "targeti31", "destpi32", "DestI256", "Desti31", "destpi31", "targeti30", "targeti32", "targetpi34", "targetpi31", "desti31", "destdi34", "targetpi32", "destpi30", "DestI31", "Desti90", "destdi32", "destic30", "destic31", "destu32", "desti30", "destdi30", "DestI32", "targeti34", "desti256", "destu256"]}}
{"id1": "1769771", "id2": "17580775", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 0, "substitutes": {"copyFile": ["copyStream", " CopyFiles", " copyLine", " copyFiles", " CopyStream", "CopyFiles", " CopyLine", "CopyFile", "copyFiles", " copyStream", "CopyStream", " CopyFile", "CopyLine", "copyLine"], "in": ["ins", "din", "el", "en", "b", "old", "ini", " input", "IN", "inn", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ic", "init", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "l", "isin", "In"], "out": ["update", "ot", "output", "OUT", "b", "v", "p", "serv", "ex", "gt", "s", "net", "io", "err", "outs", "it", "c", "ou", "to", "file", "res", "po", "op", "nt", "msg", "up", "help", "os", "l", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["insideClient", "intChan", "innCase", " inChan", "cinCommand", "inConnection", "inChan", "intCommand", "cinRoom", "inClient", "Inchannel", "inScope", "sinButton", "outConnection", "outchannel", " inCommand", "inCategory", "innButton", "sinRoom", "insideCategory", " inCase", "ainChannel", "insideChannel", "sinCommand", "InChannel", "cinChannel", "dinchannel", "ainClient", "dinChan", "intChannel", "sinChannel", "ainScope", " inConnection", " inchannel", "dinConnection", "inCase", "sinCase", "inchannel", " inClient", " inButton", "outChan", "inCommand", "dinChannel", " inScope", " inCategory", "intchannel", "InChan", " inRoom", "sinClient", "inRoom", "innChannel", "innClient", "InCommand", "ainCategory", "insideScope", "inButton"], "outChannel": ["outputCh", "aosChannel", "blockChannel", "neSection", "inChan", "blockChan", " outCh", "outSection", " outManager", "outputChan", " outchannel", "inSection", "aosMember", "cnManager", "outchannel", "outputchannel", "inCh", "outputManager", "aosSection", "cnChan", "cnChannel", "parentChan", "outMany", "blockMany", "neMember", "inMember", "outCh", "parentGate", "outputChannel", "parentMany", "inchannel", " outGate", "outChan", "outMember", "outGate", "parentChannel", " outChan", "outManager", " outMany", "neChannel", "blockGate", "aosChan", "neChan"]}}
{"id1": "22993368", "id2": "5414088", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileFileString", "decodeFileFileFiles", "decodeFileFilefile", "decodeFileFileFile", "decodeString2Files", "decodeStringTofile", "decodeFileAsFile", "decodeStringToFiles", "decodeFile2File", "decodeFileAsFiles", "decodeString2File", "decodeFileToString", "decodeFileAsString", "decodeFileTofile", "decodeFileToFiles", "decodeString2String", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFile", "decodeStringToString", "decodeString2file", "decodeFile2file"], "infile": ["isinfile", "Inbase", "frombase", "fromfilename", "inputfolder", "Infile", "Infilename", "isinname", "fromfile", "inname", "inbase", "inputfile", "outbase", "infolder", "fromFile", "inFile", "infilename", "outname", "isinFile", "inputname", "isinfolder", "outFile", "InFile", "outfilename", "outfolder", "inputFile"], "outfile": ["todir", "inFILE", "inname", "otname", "OutFile", "otFile", "otfile", " outname", "Outfilename", "outdir", "otFILE", "inFile", "infilename", "outname", "toFile", "tofilename", "outFILE", " outFILE", "indir", "tofile", " outFile", "Outfile", "Outdir", "outFile", "outfilename"], "in": ["ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "auto", "nt", "fn", "ion", "can", "write", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "paste", "attribute", "comment", "shape", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "shift", "check", "write", "before", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "scope", "sufficient", "value", "exist", " succeeds", "ratulations", "support", " succeed", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "14303294", "id2": "5808579", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getClientSalt", "toClientHash", "toServerHash", "getServerMac", "getUserSalt", "toClientSalt", "getserverSalt", "getUserPassword", "getServerSalt", "getserverMac", "toClientMac", "getServerPassword", "toServerPassword", "getClientMac", "toServerMac", "getClientHash", "getserverHash", "getClientPassword", "toServerSalt", "toClientPassword", "getUserHash", "getserverPassword", "getUserMac"], "passwordHash": ["passwordHas", "PasswordHTML", "serverSalt", "emailHTML", "swordHas", "passwordHTML", "PasswordPassword", "emailHas", "PasswordHas", "swordSalt", "swordHash", "passwordSalt", "emailHash", "serverKey", "serverHash", "PasswordHash", "PasswordKey", " passwordKey", "emailSalt", "swordHTML", " passwordPassword", "passwordKey", "serverPassword", " passwordSalt", "passwordPassword"], "PasswordSalt": [" PasswordPassword", "passwordToken", "UserSecret", "PasswordSecret", " PasswordHash", "UserSalt", " passwordToken", "UserToken", "passwordSecret", "PasswordPassword", " PasswordSecret", "UserHash", "passwordSalt", " PasswordToken", "PasswordHash", "PasswordToken", " passwordPassword", " passwordSalt", "passwordPassword"], "hash": ["ash", "copy", "value", "sh", "search", "match", "sha", "cache", "sum", "message", "total", "char", "Hash", "print", "test", "block", "map", "score", "response", "password", "report", "tag", "key", "transform", "hex", "build", "address", "dig", "shift", "mask", "height", "word", "h", "serial", "mac", "row", "json", "echo", "crypt", "filter", "sample", "log", "html", "component", "index", "result", "handle"], "digest": ["dEST", "displayested", "displayester", " digested", "displaygest", "descest", "Digester", "decse", "dester", "Digested", "descested", "dest", "displayest", "mdested", "mdEST", "decested", "digested", "DigEST", "hashester", " digEST", "descester", "digse", " digse", "diggest", " digester", "Digest", "Digse", "hashest", "dested", "hashgest", "mdester", "Diggest", "decester", "decest", "mdest", "hashested", "digEST", "digester", "descse"]}}
{"id1": "1421557", "id2": "23035537", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "5977352", "id2": "16825994", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", "cpFiles", " cpFile", " cpFolder", " copyFiles", "cpfile", " cpfile", " cpFiles", "cpFolder", "copyFiles", "copyFolder", "cpFile", " copyfile", " copyFolder"], "src": ["rel", "loc", "ins", "rc", "rs", "SOURCE", "sc", "usr", "sys", "via", "sq", "sf", "from", "st", "pkg", "sec", "rl", "inst", "sit", "ser", "orig", "req", "init", "img", "sb", "ipl", "source", "input", "cur", "start", "ctr", "sr", "Source", "rest", "cont"], "dest": ["loc", "del", "copy", "th", "port", "Dest", "cont", "dat", "self", "tif", "mk", "usr", "gt", "target", "nw", "test", "origin", "st", "tom", "etc", "dist", "sit", "spec", "them", "de", "orig", "trans", "coord", "dir", "nom", " dst", "tmp", "nt", "est", "sp", "parent", "cp", "name", "master", "none", "good", "opt", "comp", "txt", "comb", "source", "cat", "foreign", "lit", "null", "desc", "decl", "rest", "end", "temp", "result"], "bufSize": ["ufLen", "bufSIZE", "fontNum", "bufLen", "bcSize", " bufferNum", "ufSize", " bufferSIZE", " bufferSize", " bufSIZE", "ufNum", " bufLen", " bufNum", "fontSIZE", "bcNum", "ufSIZE", "bcSIZE", "fontSize", "bufNum", "bcLen"], "force": ["f", "cmd", "quote", "forced", "co", "flag", "stall", "fast", "allow", "enable", "require", "print", "form", "safe", "rule", "error", "kill", "frame", "fill", "replace", "apply", "always", "auto", "base", "only", "check", "write", "forge", "close", "raise", "reset", "Force", "forces", "default", "forcing", " Force", "ce", "remote", "use", "command", "draw", "send"], "buffer": ["length", "quote", "binary", "cache", "message", "total", "window", "buf", "device", "queue", "sequence", "phrase", "print", "tree", "stack", "block", "text", "view", "limit", "table", "frame", "paste", "attribute", "comment", "shape", "document", "batch", "library", "base", "word", "history", "template", "memory", "display", "number", "mem", "row", "variable", "Buffer", "buff", "sample", "command", "temp"], "read": ["length", "readable", "bind", "need", "pe", "record", "stream", "scan", "count", "connect", "through", "allow", "index", "print", "Read", "q", "give", "str", "valid", "set", "raw", "push", "text", "hold", "request", "reads", "size", "load", "add", "fill", "reading", "req", "range", "READ", "shape", "query", "run", "reader", "ind", "word", "open", " Read", "height", "check", "write", "before", "get", "len", "feed", "input", "find", "iter", "pass", "i", "r", "start", "row", "parse", "t", "end", "next", "wait", "hello", "im", "w", "send"], "in": ["cn", "mi", "ins", "inside", "din", "irm", "en", "co", "ini", "IN", "sin", "inn", "con", "ln", "inf", "cin", "gin", "mm", "on", "bin", "m", "from", "ar", "it", "ic", "or", "all", "init", "ma", "al", "ie", "ain", "per", "ind", "is", "inc", "check", "up", "rin", "doc", "i", "input", "get", "iter", "inner", "source", "internal", "l", "include", "t", "o", "info", "isin", "im", "local", "In", "n"], "out": ["cn", "ot", "cmd", "output", "OUT", "co", "b", "v", "again", "ex", "cache", "sum", "list", "gt", "ent", "con", "ln", "net", "io", "ne", "sys", "ns", "on", "om", "conn", "it", "outs", "or", "writer", "ou", "to", "all", "obj", "file", "aos", "op", "nt", "cos", "ch", "can", "client", "write", "up", "br", "oss", "one", "oe", "g", "os", "mit", "conv", "inner", "l", "flush", "not", "t", "o", "end", "Out", "at", "outer", "n"]}}
{"id1": "7458833", "id2": "13657103", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileToInfoFile", " copyParseFiletocodeFile", " copyParseFileToGoFiles", " copyParseFiletocodeFiles", " copyParseFiletocodeTable", " copyParseFileToInfoTable", " copyParseFileToCodeTable", " copyParseFileToGoTable", " copyParseFileToCodefile", " copyParseFileToGofile", " copyParseFileToCodeFiles", " copyParseFiletoCodefile", " copyParseFiletocodefile", " copyParseFiletoCodeTable", " copyParseFileTocodefile", " copyParseFiletoCodeFile", " copyParseFiletoCodeFiles", " copyParseFileToGoFile", " copyParseFileToInfofile", " copyParseFileTocodeFiles", " copyParseFileToInfoFiles", " copyParseFileTocodeTable", " copyParseFileTocodeFile"], "in": ["ins", "inside", "din", "en", "ir", "ini", "ze", "IN", "inn", "con", "ai", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ar", "ic", "it", "init", "ad", "al", "ain", "act", "ind", "is", "inc", "check", "up", "rin", "i", "input", "iter", "inner", "info", "isin", "im", "read", "In"], "out": ["cn", "ot", "output", "en", "OUT", "co", "v", "dis", "ex", "con", "net", "io", "ne", "sys", "n", "on", "outs", "it", "by", "writer", "ou", "and", "to", "obj", "res", "auto", "aos", "nt", "cos", "client", "check", "write", "up", "i", "oss", "one", "conv", "g", "os", "null", "inner", "o", "t", "Out", "at", "outer", "can"], "buffer": ["initial", "binary", "cache", "message", "window", "char", "buf", "queue", "phrase", "sequence", "stack", "print", "database", "block", "cell", "view", "button", "resource", "table", "frame", "bar", "bridge", "reason", "paste", "attribute", "comment", "document", "component", "batch", "history", "word", "append", "template", "memory", "display", "character", "iter", "row", "variable", "Buffer", "buff", "sample", "pad", "command", "bone", "temp", "result"], "length": ["distance", "maximum", "bow", "frequency", "present", "position", "angle", "integer", "count", "deep", "data", "message", "total", "capacity", "how", "lambda", "print", "sequence", "stop", "duration", "database", "closure", "volume", "collection", "availability", "load", "frame", "size", "join", "reading", "available", "impl", "shape", "ength", "amount", "family", "height", "binding", "full", "number", "len", "l", "enth", "start", "padding", "t", "point", "hello", "component", "Length", "history", "ENGTH"]}}
{"id1": "1698200", "id2": "9210168", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "label": 0, "substitutes": {"loginBitShare": ["loginByteshare", "loginbitshare", "loginbitShare", "loginByteStock", " loginbitShare", " loginbitStock", "loginBitshare", "loginbitStock", " loginBitshare", " loginbitshare", " loginBitStock", "loginBitStock", "loginByteShare"], "params": ["param", "pins", "terms", "pres", "caps", "comments", "rs", "pi", "p", "Parameters", "chains", "properties", "types", "photos", "pps", "mm", "parser", "acl", "options", "headers", "gs", "http", "cms", "ams", "pretty", "metadata", "requires", "settings", "cp", "changes", "services", "members", "hash", "keys", "points", "Par", "posts", "details", "parts", "config", "auth", "json", "ports", "pas", "names", "tags", "ps", "stats"], "httpclient": ["httpsconnection", "httpsClient", "httpsrequest", "httpClient", "https2", " httpClient", "ttpclient", "httpscontroller", "httpcli", " httpconnection", " http2", "Httprequest", "httpsclient", "httco", "httpco", "hyper2", "ttpClient", "hyperconnection", "HttpClient", "Httpconnection", "httpsco", "http2", "httClient", "hyperclient", "Httpclient", "hypercli", "httpconnection", "httclient", "httpcontroller", "httcontroller", " httprequest", " httpcli", "httprequest", "ttpcontroller", "httpscli", "ttpco"], "httppost": ["httppposter", " httpppost", " httpost", "httphpost", "httpperom", "httpperop", "httpplart", "httpploint", "httposter", " httppop", "httploint", "httpploster", "httplom", "httpposter", "httppppost", "httpplost", "httppart", "httplpost", "httmppost", "httplost", " httppom", "httpom", "httphoster", "httpperost", "httpppart", "httmpop", "httpop", "httmpart", " httpop", "httpppoint", "httplop", "httphoint", "httpoint", "httphost", "httpplop", "httploster", "httpart", "httpperpost", "httpost", "httplart", "httpppop", " httpom", "httppom", "httpplpost", "httppop", "httpppost", "httmpost", "httppoint"], "formparams": ["functionmembers", " formchanges", "functionauthors", " formproperties", "inputdetails", " formmembers", "formparam", "functiondetails", "batchnames", "feedparams", "formmembers", "condproperties", " formParameters", " formnames", "functionproperties", "condparams", "formtags", "inputParameters", "condsettings", "formParameters", "formederrors", "foremembers", "inputerrors", "foresettings", "feeddetails", "formdetails", "foreparams", "functionchanges", "formnames", "inputtags", "inputnames", " formdetails", "formedparams", "feedparam", "formsettings", "functionargs", "formproperties", "formargs", "foreargs", "functionparams", "inputparam", "foreauthors", "batcherrors", " formsettings", "batchparams", "inputparams", "formednames", "formedtags", "forenames", " formparam", "foreproperties", "foredetails", "feedParameters", " formargs", "formchanges", "forechanges", "batchtags", "condnames", "formauthors", "formerrors", " formauthors"], "entity": ["el", "object", "quote", "ew", "person", "security", "eme", "ity", "profile", "enc", "data", "ent", "content", "empty", "user", "form", "buffer", "ITY", "xml", "entry", "fee", "Entity", "em", "inv", "note", "ell", "metadata", "comment", "document", "orm", "body", "ee", "event", "line", "out", "template", "activity", "create", "json", "ENT", "ce", "html", "component"], "httpresponse": ["procresponse", " httpconnection", "HTTPreply", "HTTPresponse", "HTTPresp", "httpresp", "httpResponse", "HTTPresult", "HTTPResponse", " httpresult", "ttpconnection", " httpresp", "procresult", "ttpresp", "httpreply", "httpconnection", " httpResponse", " httpreply", "HTTPconnection", "httpresult", "procResponse", "ttpResponse", "procreply", "ttpresponse"], "it": ["you", "et", "el", "ot", "iz", "v", "ex", "ert", "itted", "il", "ent", "ate", "ed", "It", "st", "ic", "MIT", "he", "li", "ul", "sit", "ite", "init", "ect", "al", "est", "at", "IT", "act", "ind", "is", "itter", "rit", "i", "iter", "lit", "l", "mit", "ip", "ist", "its", "t", "im", "ut"], "escookie": ["espancel", "iseccake", "escoder", "ecue", "eccookie", "httpscookie", "eyancel", "ecancel", "escue", "occookie", "httpsookie", "occog", "escotton", "espcookie", "escancel", "ecookie", "espookie", "ectrl", "ecotton", "httpsog", "isecoder", "occoder", "Esctrl", "eycookie", "isecookie", "eccake", "eyace", "eyookie", "Escue", "escog", "iseccookie", "ecace", "espace", "desctrl", "Escookie", "descue", "ecog", "desccookie", "esccookie", "ecoder", "Esccookie", "httpsotton", "esccake", "occcookie", "descookie", "escace", "occotton", "occcake", "esctrl"]}}
{"id1": "11716816", "id2": "1188100", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"updateFile": ["UpdateContent", "UpdatePage", "downloadFile", "archiveSourceFile", "updatePage", "archiveContent", "downloadContent", "UpdateSourceFile", "archivePage", "archiveFile", "downloadPage", "UpdateFile", "updateSourceFile", "downloadSourceFile", "updateContent"], "file": ["f", "image", "output", "p", "port", "channel", "data", "message", "format", "issue", "content", "path", "e", "le", "io", "rule", "entry", "File", "resource", "table", "FILE", "link", "page", "report", "attribute", "document", "base", "name", "line", "fp", "h", "ile", "get", "source", "input", "filename", "full", "title", "db", "null", "type", "url", "t", "log", "use", "info", "local", "handle"], "IOException": ["IOProblem", " IOError", "OperationException", " IOProblem", "OperationProblem", "OperationError", "SecurityError", "SecurityException", "SecurityProblem", "IOError"], "destFile": ["destDo", " destinationFile", " destfile", "destfile", "optPlace", "destile", " destEmail", "sourceFolder", "sourceFile", " DestFile", " destile", "destDir", "tempFile", " destFolder", "tempfile", "destFolder", "optFolder", "targetDir", " DestDo", "DestPlace", "destEmail", "destPath", "sourcePath", " DestEmail", "DestDir", "destPlace", "destSourceFile", "targetFile", "DestFolder", "declFile", " destPlace", "DestSourceFile", "declSourceFile", "optFile", "Destfile", "tempDir", " destDo", "DestPath", " destDir", "DestPage", "DestFile", " destinationDo", " destSourceFile", "sourceDir", "declFolder", " destinationEmail", "targetFolder", "targetPath", " destPath", "declile", " DestDir", "destPage", "optPage", " destPage", "Destile", "tempPath", " destinationDir"], "in": ["f", " IN", "mi", "ins", "din", "inside", "en", "ini", "IN", "sin", "inn", "s", "con", "ln", "ai", "io", "inf", "ne", "gin", "cin", "local", "m", "mm", "bin", "on", "from", "raw", "it", "ic", "re", "all", "init", "edIn", "al", "ie", "ain", "act", "ind", "is", "inc", "up", "rin", "i", "input", "r", "iter", "inner", "oin", "pass", "l", "net", "info", "isin", "im", " din", "read", "In", "n"], "out": ["cn", "ot", "cmd", " OUT", "output", "OUT", "en", "co", "b", "v", "again", "ex", "channel", "cache", "jp", "gt", "s", "con", "net", "io", "ne", "outer", "sys", "chain", "conn", "outs", "it", "or", "OU", "ou", "note", "to", "obj", "aos", "nt", "cos", "ch", "msg", "fn", "ion", "client", "write", "up", "can", "no", "oss", "one", "oe", "g", "os", "conv", "null", "flush", "t", "o", "log", "Out", "at", "result", "n"]}}
{"id1": "2521141", "id2": "6188784", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "move", "cut", "archive", "transfer", "select", "sync", "ate", "delete", "crop", "io", "set", "clip", "opy", "insert", "load", "remove", "link", "upload", "replace", "export", "paste", "edit", "Copy", "file", "share", "cp", "zip", "slice", "write", "get", "source", "clone", "create", "close", "save", "download", "cop"], "from_name": ["from_no", "fromkname", "from_filename", " from_part", " from_case", "fromamefilename", "from_key", " from_names", "from_info", "fromamename", " from_key", "fromkcase", " from_filename", "fromameName", "from_resource", " from_resource", "from_case", "fromkName", "from_Name", "from_names", " from_Name", " from_info", " from_no", "fromkpart", "fromamekey", "from_part"], "to_name": ["toNameget", "tolynm", "toNamefile", "toNamename", "toNamenew", " to_nm", "eto_Name", "to7new", "eto_word", "to_number", "from_new", "to_get", "to_word", "to7name", "to_Name", "tolynumber", "from_get", "to7file", "to_nm", "eto_name", "to_new", "tolyname", "to7get", "tolyfile", " to_number"], "from_file": ["fromlyfile", " from_time", "to_dir", "from_run", "from_File", "or_name", "or_File", "from_node", "or_file", "fromlyresource", " from_do", " from_port", " from_node", "fromsname", " from_File", "from_resource", "from_port", " from_resource", "or_run", " from_type", "fromlyFile", "from_dir", "fromlynode", "fromsfile", "fromsdir", "from_type", "from_time", "from_do"], "to_file": ["TO_element", "to_dir", " to_File", "toJfile", "to_link", "to_local", "TO_port", "to_tree", " to_base", "to_base", "toJdrop", " to_block", "to_files", "toJblock", "TO_FILE", " to_dir", "that_file", " to_local", "that_link", "that_File", "to_port", "to_type", "TO_files", "to_FILE", "TO_name", "TO_file", "to_create", "from_dir", "to_File", " to_run", "to_element", "from_type", "to_block", " to_create", "to_drop", "to_run", "that_tree", "toJFile", " to_drop"], "parent": ["folder", "top", "server", "id", "holder", "p", "port", "position", "par", "base", "where", "instance", "home", "peer", "event", "path", "owner", "user", "chain", "form", "test", "percent", "tar", "Parent", "my", "tree", "block", "rule", "paren", "man", "mother", "part", "timeout", "spec", "page", "comment", "prefix", "shape", "file", "ma", "child", "sp", "directory", "pool", "params", "name", "pid", "family", "unit", "relative", "cmp", "per", "pa", "up", "client", "def", "source", "null", "desc", "parents", "default", "global", "ip", "prop", "root", "temp", "pixel", "remote", "point", "master"], "dir": ["div", "rel", "folder", "del", "loc", "dr", "dd", "cmd", "ir", "red", "self", "rec", "dict", "path", "addr", "str", "mod", "part", "vol", "dist", "init", "md", "file", "DIR", "sp", "directory", "det", "tr", "cond", "ind", "good", "def", "dep", "dim", "cur", "iter", "wd", "di", "db", "cd", "Dir", "coll", "fd", "d", "local", "module", "cont"], "from": ["fun", "store", "en", "stream", "style", "old", "with", "com", "From", "window", "ent", "con", "empty", "back", "user", "form", "io", "normal", "on", "set", "term", "st", "in", "entry", "or", "by", "error", "re", "vol", "link", "fr", "orig", "init", "query", "file", "left", "so", "ie", "base", "pos", "before", "false", "no", "out", "check", "client", "source", "se", "inner", "reset", "start", "ra", "bound", "and", "local", "func"], "to": ["eto", "top", "output", "tt", "b", "co", "too", "total", "tty", "te", "stable", "please", "token", "e", "target", "ne", "sys", "on", "will", "into", "or", "by", "toc", "table", "pretty", "ts", "that", "must", "To", "po", "TO", "op", "auto", "nt", "so", "ma", "base", "two", "no", "tto", "out", "client", "ta", "can", "null", "o", "t", "go", "ato", "pi"], "buffer": ["binary", "cache", "message", "window", "char", "buf", "queue", "stack", "phrase", "sequence", "database", "block", "entry", "button", "table", "frame", "bar", "stroke", "available", "page", "paste", "attribute", "document", "function", "batch", "base", "event", "word", "append", "template", "memory", "character", "iter", "row", "variable", "Buffer", "buff", "sample", "password", "command", "temp"], "bytes_read": ["bytes__Read", "bytes2range", " bytes_Read", "bytes_run", "bytes__range", "bytes__write", "bytes2Read", "bytes2read", "wordsynclen", "words_write", "words_report", "words_read", "bytes__read", "bytes2write", "wordsyncwrite", "bytes_range", "bytesyncread", "wordsyncread", "Bytes_read", " bytes2read", "bytesyncreport", "bytes_write", " bytes_write", " bytes2Read", " bytes2write", "Bytes_write", "words_len", "Bytes_run", "bytesynclen", "wordsyncreport", " bytes_range", " bytes2range", "bytes_Read", "bytesyncwrite", "bytes_len", "bytes_report"]}}
{"id1": "442381", "id2": "15768167", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionQuery", "doVersionsUpdate", " doVersionTest", "doBuildCheck", "doFeaturecheck", "doFeatureInfo", "doFeatureQuery", " doVersionQuery", "doImageInfo", "doFeatureCheck", " doApplicationQuery", " doVersionsTest", "doVersionsTest", "doApplicationCheck", "doFeatureUpdate", "doApplicationInfo", "doImageQuery", " doVersionUpdate", " doVersionsUpdate", " doVersioncheck", "doBuildUpdate", "doBuildcheck", "doImageCheck", "doVersionscheck", " doVersionInfo", "doVersionsCheck", "doFeatureTest", "doApplicationQuery", " doApplicationCheck", " doApplicationInfo", " doVersionscheck", "doBuildTest", "doVersionInfo", "doVersioncheck", "doImageTest", " doApplicationTest", "doVersionUpdate", "doVersionTest", " doVersionsCheck", "doApplicationTest"], "view": ["image", "update", "iew", "context", "server", "engine", "VIEW", "v", "port", "model", "show", "self", "window", "review", "ml", "form", "box", "print", "buffer", "q", "cell", "tree", "subject", "block", "eye", "http", "page", "cv", "browser", "report", "query", "document", "file", "layout", "tv", "widget", "controller", "pool", "see", "this", "lock", "call", "client", "check", "display", "h", "View", "virtual", "input", "vm", "manager", "version", "row", "html", "project", "component", "index", "views"], "url": ["loc", "rel", "f", "host", "sl", "ssl", "domain", "gl", "b", "v", "dl", "hl", "char", "bel", "ref", "str", "oul", "ll", "rl", "http", "ul", "nl", "link", "browser", "ur", "URL", "file", "build", "address", "mount", "mail", "client", "pl", "get", "lb", "r", "uri", "Url", "l", "log", "html", "job"], "in": ["f", " IN", "ins", "din", "isin", "stream", "IN", "sin", "inn", "ln", "inf", "cin", "gin", "on", "from", "init", "mn", "body", "ain", "reader", "is", "inc", "can", "out", "rin", "i", "input", "source", "inner", "l", "asin", "mat", "vin", "info", " din", "In", "n"], "bin": ["ins", "din", "jin", "bl", " bins", "lib", "binary", "b", "ran", "abin", "bed", "bn", "stock", "cache", "sin", "inn", "con", "ln", "bi", "cin", "gin", "buffer", "nb", "local", "by", "re", "spin", " Bin", "bg", "all", "session", "init", "thin", "sam", "brain", "file", "body", "cos", "reader", "out", "rin", "win", "len", "inner", "db", "conv", "obin", "rb", "bur", "buff", "cb", " din", "ebin", "mon"], "line": ["column", "cmd", "record", "ine", "field", "stream", "style", "liner", "port", "channel", "eline", "zone", "message", "char", " block", "detail", "string", "ice", "ln", "lo", "le", "chain", "print", "sequence", "cell", "section", "block", "lin", "entry", "rule", "err", "part", "status", "trace", "frame", "tile", "Line", "link", "inline", "page", "stay", "comment", "range", "key", "file", "lane", "code", "base", "word", "iter", "cat", "l", "lines", "row", "parse", "next", "log", "LINE", "sample", "point", "job"], "develBuild": ["deffbuild", "DeVELbuild", "deVELLog", "develRelease", "deVELBuilder", "Develbuild", "depoBuilt", "duvelbuild", "devBoot", "desvelbuild", "desvelRelease", "duffbuild", "depobuild", "depoLog", "develLoad", "duVELBuild", "deVELbuild", "desVELbuild", "deVELBuild", "duffBuilt", "deeltaLoad", "devbuild", "DevelLog", "develbuild", "deffBuilder", "deployBuilt", "DevelBuild", "duvelBuilt", "deffBuilt", "duffBuilder", "deployLoad", "desvelLoad", "develBuilder", "duvelBuild", "duvelBuilder", "deVELBoot", "duvelBoot", "DeVELLog", "deVELLoad", "desVELRelease", "deploybuild", "deployBuilder", "DeVELBuilt", "devBuilder", "develLog", "DevelBuilt", "duffBuild", "deployBoot", "duVELBoot", "duVELbuild", "develBuilt", "DeVELBuild", "deVELRelease", "deeltaRelease", "devBuild", "deVELBuilt", "deeltaBuild", "devBuilt", "deployRelease", "depoBuild", "desVELLoad", "devLog", "desvelBuild", "deployBuild", "deffBuild", "duVELBuilder", "deeltabuild", "develBoot", "desVELBuild"], "stableBuild": ["activeMake", " stableCraft", "activeBuild", "stableBind", " unstableLong", " unstableBuild", "stableBoot", " stableBuilder", " stableMake", " unstablebuild", "stableCraft", "confirmedBoot", "secureBuilder", "devbuild", " stablebuild", " stableBoot", " stableBind", "stablebuild", "secureBuild", "activeBuilder", " unstableBuilder", "confirmedbuild", "confirmedBuild", "stableBuilder", "securebuild", " unstableBind", "devBuilder", "secureCraft", "stableLong", "devBind", " unstableCraft", "devBuild", "devMake", "stableMake", " stableLong", "confirmedLong", "activebuild", " unstableBoot"]}}
{"id1": "21425787", "id2": "8150996", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", "transferFile", " copyByte", "CopyByte", "transferByte", " copyFiles", "CopyFiles", "copyByte", "CopyFile", "copyFiles", "Copyfile", " copyfile", "transferFiles", "transferfile"], "in": ["ins", "din", "el", "en", "b", "old", "IN", "inn", "inf", "cin", "gin", "on", "from", "ar", "ic", "it", "vin", "ie", "ind", "is", "inc", "up", "rin", "i", "input", "source", "l", "o", "isin", "In", "n"], "out": ["ot", "output", "OUT", "b", "v", "p", "ex", "gt", "ent", "s", "net", "ne", "io", "str", "err", "outs", "it", "c", "ou", "to", "po", "nt", "i", "source", "oss", "g", "help", "os", "null", "l", "t", "o", "Out", "at", "w", "n"], "sourceChannel": ["startMachine", "sourceManager", "systemMachine", " sourceClass", "inputChan", " sourceCommand", "srcCh", "ourceChan", "seedMachine", "inputCh", "systemPanel", "sourceConnection", " sourceManager", "systemChannel", "sourceCategory", "sourceCommand", "srcManager", "ourceConnection", " sourceConnection", "startPanel", "srcClass", "sourceMachine", "ourceClass", "srcChannel", " sourceCh", "srcCommand", "srcChan", "srcConnection", " sourceChan", "ourceChannel", "sourceClass", "sourceChan", "inputChannel", "seedCategory", "ourceManager", "sourceCh", "startChannel", "startCategory", "seedPanel", "seedChannel", "ourceCommand", "inputConnection", "systemCategory", "sourcePanel"], "destinationChannel": ["destinoChannel", "destinochannel", "Destinationchannel", "destationChan", "DestationChan", "destationChannel", "DestinationChan", "destinationConnection", "destinationContext", "DestinationChannel", "destinationschannel", "destinationchannel", "destensionChannel", "destensionchannel", "destinatorHandler", "DestinationConnection", "destensionChan", "DestationHandler", "DestinationHandler", "destinationHandler", "destationContext", "destinoContext", "restinationChan", "destinatedContext", "destinatedChannel", "destinoChan", "destinatedchannel", "destinatorchannel", "destinatorChan", "destationConnection", "DestensionConnection", "restinationchannel", "destinationsChan", "restinoChan", "destationchannel", "DestensionChan", "destinationsConnection", "DestationChannel", "restinoChannel", "destinationsChannel", "restinationContext", "restinationChannel", "restinoContext", "destinatorChannel", "destationHandler", "DestensionChannel", "destensionConnection", "destinatedChan", "Destensionchannel", "restinochannel", "destinationChan", "Destationchannel"]}}
{"id1": "15018553", "id2": "3536332", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"encrypt": ["encrypted", "uncode", "Encrypt", "uncrypt", " encode", " enccrypt", "enccrypt", "Enccrypt", "uncrypted", "Encrypted", "unccrypt", "encode", "Encode", " encrypted"], "text": ["translation", "value", "output", "th", "p", "v", "pattern", "data", "message", "select", "content", "string", "path", "form", "print", "phrase", "buffer", "q", "test", "str", "pt", "comment", "x", "document", "code", "nt", "msg", "act", "body", "name", "word", "txt", "TEXT", "source", "input", "title", "url", "ct", "tx", "t", "ext", "now", "password", "w", "Text", "read", "cont", "ut"], "md": ["del", "cmd", "dd", "mt", "der", "mode", "mo", " cmd", "nd", "sha", "dh", "mk", " dd", "od", "ms", "m", "mm", "err", "pm", "pd", "mod", " cd", "c", "pkg", "and", "de", "metadata", "img", "ad", "mc", "mond", "mn", "df", "mp", "msg", "dm", "mand", "det", "hash", "mb", "ind", "dig", "cmp", "h", "mem", "doc", "grad", "ld", "rm", "di", "cd", "mac", "bd", "ct", "t", "hd", "d", "MD", "mg"], "md5hash": ["md2sum", " md3hash", "md2Hash", " md3h", "md3hash", "md5hex", " md2hash", "md3sha", "md2cloth", "md2hash", " md3Hash", "md5sum", "md3sum", " md2sum", "md512sha", " md5sum", " md3sum", "md3Hash", " md5Hash", " md2cloth", "md3h", " md3sha", " md5cloth", "md2h", "md5Hash", " md5sha", "md2sha", "md2hex", "md5cloth", " md5hex", "md3hex", "md512sum", "md512Hash", " md5h", "md5h", " md2hex", "md512h", "md512hash", "md5sha", "md3cloth"]}}
{"id1": "10214218", "id2": "8024375", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["decryption", "decode", "encrypted", "decrypted", "Encrypt", " encode", "Encryption", "encryption", "Encrypted", "decrypt", "encode", " encryption", "Encode", " encrypted"], "plaintext": [" PlainText", "pretext", " plaincontext", "prepassword", "plainprotein", "richtext", " plainterm", "richprotein", "preterm", "plainText", " plainText", "longText", " Plaintext", " plainpassword", "plainpassword", "longcontext", "richcontext", " plainprotein", "longprotein", "plainterm", "plaincontext", "preText", " Plainpassword", "longtext", " Plainterm", "richText"], "md": ["del", "cmd", "dr", "dd", "mt", "der", "mo", "red", " mc", "nd", "mg", "dh", "mk", "med", "e", "od", "ms", "m", "mm", "esm", "me", "pd", "mod", "metadata", "mc", "mn", " mo", "managed", "mp", "nt", "msg", "dm", "mand", "det", "mb", "ind", "dig", "mem", "doc", "grad", "ld", "rm", "deb", "cd", "mac", "bd", "hd", "d", "ng", "MD", "sm"], "raw": ["original", "value", "sh", "stream", "data", "message", "hook", "buf", "bare", "clean", "box", "random", "valid", "rendered", "pack", "custom", "array", "rew", " Raw", "cooked", "orig", "all", "available", "known", "hex", "base", "RAW", "good", "extra", "out", "clear", "full", "input", "Raw", "unsigned", "row", "unknown", "aw", "bytes", "draw", " RAW", "result", "n"], "hash": ["ashes", "ash", "sh", "zh", "search", "id", "ASH", "sha", "cache", "rh", "sum", "message", "total", "ssh", "Hash", "print", "proof", "has", "hidden", "array", "bh", "alert", "tag", "key", "hex", "cert", "code", "tr", "mask", "height", "check", "h", "html", "json", "mac", "shadow", "hed", "href", "password", "result", "handle"]}}
{"id1": "4531653", "id2": "8024375", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"md5": ["md7", "MD7", "MD4", "md3", "MD3", "md4", " md4", "MD5", "sha5", "sha7", " md7", " md3", "sha4", "sha3"], "data": ["image", "DATA", "value", "output", "id", "ata", "sha", "cache", "dat", "message", "format", "content", "string", "foo", "any", "hello", "valid", "block", "raw", "text", "table", "a", "command", "batch", "msg", "name", "this", "no", "txt", "serial", "input", "os", "json", "type", "padding", "bytes", "mu", "html", "d", "info", "now", "result"], "md": ["pdf", "cmd", "dd", "mt", "amd", "der", "red", "nd", "dh", "mk", "sd", "od", "ms", "m", "mm", "pm", "pd", "sm", "mod", "da", "ds", "de", "dir", "mc", "mn", "df", "managed", "mp", "nt", "msg", "dm", "mand", "det", "ind", "mb", "ld", "rm", "db", "di", "cd", "bd", "hd", "d", "MD", "mg"]}}
{"id1": "2668853", "id2": "17996547", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFiles2Page", "decodeFilesToFile", "decodeFile2Page", "decodeFileAsPage", "decodeFileTOPage", "decodeFiles2Files", "decodeFilesToPage", "decodeFilesToString", "decodeFileAsFile", "decodeFileTOFile", "decodeFile2File", "decodeFileAsFiles", "decodeFileToString", "decodeFileAsString", "decodeFiles2String", "decodeFileToFiles", "decodeFilesToFiles", "decodeFileTOFiles", "decodeFile2Files", "decodeFiles2File", "decodeFileTOString", "decodeFileToPage"], "infile": ["inputbase", "Inbase", "inputpath", " inbase", "innfilename", "inputfilename", "inbase", "inwhere", "outpath", "inputfile", " infilename", "outbase", "inpath", " inwhere", "Inpath", "inputwhere", "inFile", "infilename", "innfile", "innbase", "outFile", "InFile", "Infile", "innwhere", "inputFile"], "outfile": ["listfile", "listfp", "outpath", "OutFile", "Outfilename", "inpath", "outfp", "inFile", "infilename", "infp", "toFile", "tofilename", "Outpath", " outpath", "tofp", "tofile", " outFile", "Outfile", "listfilename", "outFile", "outfilename", " outfilename", "listFile"], "in": ["image", "ins", "din", "inside", "en", "pin", "ini", "IN", "inn", "con", "ai", "user", "io", "inf", "form", "cin", "gin", "on", "bin", "conn", "from", "it", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "o", "info", "isin", "im", " din", "In", "n"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "ent", "con", "ln", "net", "io", "ne", "print", "sys", "on", "it", "outs", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "ion", "can", "write", "opt", "oss", "g", "inner", "os", "flush", "o", "t", "end", "Out", "at", "w", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "queue", "phrase", "stack", "sequence", "tree", "block", "zero", "view", "table", "frame", "bar", "black", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "history", "append", "template", "memory", "number", "display", "mem", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "pe", "stream", "count", "data", "connect", "wait", "select", "through", "each", "print", "Read", "q", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "range", "query", "run", "reader", "seek", "shift", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send"], "success": [" successful", "top", "green", "crit", "same", "sufficient", " convergence", "exist", " succeeds", "security", "warning", "cont", "ratulations", "support", " succeed", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "error", "commit", "status", " successfully", " Success", "democracy", "response", "ceed", " succeeded", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "close", "release", "surv", "growth", " failure", "danger", "summary", "accept", "second", "primary", "ok", "successful", "Success", "master", " successes"]}}
{"id1": "13666876", "id2": "13886238", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"transformSingleFile": ["processsinglefile", "transformMultiFile", "transformSimpleRecord", "TransformSingleFile", "transformSimpleModel", "transformsingleRecord", "processSingleFile", "TransformSingleModel", "transformMultiFiles", "transformOnefile", "TransformSimpleRecord", "processsingleSourceFile", "transformOneFile", "TransformSimpleFile", "TransformSingleRecord", "processsingleFile", "transformMultiModel", "transformOneSourceFile", "transformSimpleFile", "transformSingleModel", "transformMultifile", "processSingleFiles", "transformSingleFiles", "transformSinglePage", "transformsinglePage", "transformOneFiles", "transformMultiSourceFile", "TransformSimplePage", "transformsingleSourceFile", "processSingleSourceFile", "transformSingleRecord", "transformSinglefile", "transformsingleModel", "transformsingleFile", "TransformSimpleModel", "transformsinglefile", "transformMultiPage", "transformsingleFiles", "TransformSinglePage", "transformMultiRecord", "transformSimplePage", "processsingleFiles", "processSinglefile", "transformSingleSourceFile"], "xed": ["exed", "rxeds", "txED", "uxied", "passed", "wxED", "wxied", " xented", "xred", "rxED", "txed", "xeds", "wxented", "rxer", "passED", "passEd", "Xeded", "uxed", "Xer", "pxeded", "xeded", "exeds", "xented", "txer", "pxED", "pxeds", " xred", "rxed", "exeded", "wxed", " xED", " xEd", " xied", "exED", "xED", "pxed", "Xed", "xEd", "txeds", "wxred", "xied", "wxEd", "xer", "passred", "uxED", "XED", "Xeds", "uxented"], "node": ["image", "object", "entity", "seed", "scene", "channel", "stage", "feature", "process", "tree", "set", "entry", "ode", "view", "array", "resource", "station", "map", "load", "post", "link", "note", "de", "day", "range", "component", "our", "directory", "parent", "event", "right", "word", "name", "no", "line", "hand", "create", "one", "Node", "row", "edge", "remote", "and", "job", "index", "n"], "dob": ["adob", "Dob", "adab", "drob", "diab", "dab", "diob", "dobar", " dobb", "adobar", "adoy", "doy", "drobb", "drab", "diobb", "diod", "Dab", "Dobar", "Doy", " dobar", " doy", "dobb", " dod", "dod", "drod", " dab"], "mySrc": ["mySfc", "myInsrc", "mySelsrc", " mySRC", "myAsource", "mySources", "myDesRC", " mySfc", "myAsrc", "mySsrc", "mySourcerc", "mySingRC", "myDesources", "MySRC", "mySRC", "myInssrc", "mySingrc", "myAsRC", "MySsrc", " mySsrc", "mySelRC", "myDessrc", "mySourceRC", "myAssrc", "mySingfc", "MySource", "mySingsrc", "myDesrc", "MySrc", "mySource", "MySources", "myInsRC", "mySourceource", "myInsfc", "mySourcesrc", "mySelources", "mySelrc"], "mySrcF": ["mySrcC", "mySsrcFP", "mySsrcI", "mySsrcF", "mySsrcO", "mySufV", "myMourceO", "mySsrcV", "mySrtF", "myMourceV", "mySrcI", "mySourceFP", "mySRCI", "mySourceF", "myMrcFP", "mySufFP", "mySRCC", "mySourceO", "mySRCP", "mySsrcC", "myMrcV", "myMourceFP", "mySsrcP", "mySufF", "mySRCF", "myMrcF", "mySrcV", "mySrcP", "myMourceF", "mySufO", "mySrcFP", "myMrcO", "mySrtC", "mySourceV", "mySrtP", "mySrtI", "mySrcO"], "myOutF": ["myArtL", "myInC", "MyOutFile", " myoutC", " myOutFile", "myOutFs", "myOutDF", "myOutputE", "MyInFile", "myOutE", " myoutV", "myOffE", " myoutL", "mysNetW", "myOffFile", "myInV", " myOutDF", "myOutputFile", "myArtW", "MyOutFs", " myoutF", "myInF", "myObjFile", "myOutC", "myoutC", "myOutputDF", " myNetF", " myOutC", "myInFile", "mysNetFL", "MyOutV", "myOutL", "mysNetL", "myOutFile", "myoutL", "myNetE", "myInL", "myInFs", "myoutF", "myOutputFs", " myNetE", "mysOutF", "myCoF", "MyInV", "myOutputF", "myOutputC", "myOutFL", "myNetDF", "myNetFL", "myObjV", "myObjF", "myNetW", " myOutL", "myCoW", "myOutputV", "MyInF", "myoutV", "myOutW", "myOutputL", "myArtF", " myOutV", "myNetFile", "myOffDF", " myOutE", "myArtFL", " myNetDF", "mysOutL", "mysOutFL", " myNetFile", "myOutV", "myOffF", "MyOutF", "myNetL", "myObjFs", "myCoFL", "myNetF", "MyInFs", "myCoL", "mysNetF", "mysOutW"], "co": ["loc", "cover", "cal", "ck", "copy", "cs", "cu", "ico", "mo", "com", "cache", "yes", "nc", "fo", "cc", "con", "lo", "io", "ko", "flo", "c", "cod", "col", "fc", "ca", "cv", "ro", "coord", "roc", "oc", "ho", "gc", "obj", "po", "CO", "Co", "so", "ror", "cos", "soc", " Co", "no", "ace", "wo", "aco", "ctrl", "cl", "ci", "coll", "cho", "o", "xc", "ce", "cm", "go", "lc", "cop", "can"], "x3dvFile": ["x3dvFilename", "x3dvString", "x3davFilename", "x3dVPath", "x3dtfile", "x3dVfile", "x3dbString", "x3davPath", "x3cdVFilename", "x3pdvfile", "x3dVFile", "x3davFile", "x3dvsPath", "x3pdbString", "x3cdvFilename", "x3pdbFile", "x3dtString", "x3cdVPath", "x3pdbFilename", "x3dbfile", "x3dvPath", "x3pdvFile", "x3dbFilename", "x3cdVFile", "x3pdvString", "x3dvsFilename", "x3dvfile", "x3dVFilename", "x3dtFile", "x3dVString", "x3cdvFile", "x3dbFile", "x3dtFilename", "x3pdvFilename", "x3dvsFile", "x3pdbfile", "x3cdvPath"], "fis": ["frisi", "flis", " fisi", "fris", " fiss", "fiss", "fliz", "fires", " fiz", "flires", "biss", "bis", "fisi", "fileis", "frie", "friss", " fires", "fie", "fileiz", "bie", "fileiss", "fiz", "bisi", "fileires", "fliss", " fie"], "gzos": ["gaos", "ggoes", "gzoss", "gtnos", "goss", "gzo", "gzies", "ziposs", "gzops", "ggies", "ggos", "ggops", "gtoes", "sslo", "gsnos", "gtos", "zops", "gos", "gzaos", "sslos", "sslaos", "zos", "gsoss", "zipops", "gtoss", "zies", "zoss", "zipos", "gzoes", "zipnos", "gznos", "zoes", "gties", "zaos", "gsops", "gsos", "zo", "go", "gtops", "ssloss"], "buf": ["max", "arr", "cmd", "var", "b", "cf", "vec", "uf", "box", "ref", "buffer", "aka", "block", "raw", "pkg", "fb", "bar", "cap", "cv", "orig", "cam", "img", "cb", "bag", "seq", "wb", "Buff", "batch", "emb", "cast", "good", "br", "mem", "bus", "cur", "cat", "conv", "tab", "rb", "Buffer", "mu", "buff", "bytes", "font"], "ret": ["et", "cmd", "rt", "ft", "mt", "ry", "v", "red", "alt", "aux", "gt", "back", "repl", "ref", "print", "test", "Ret", "pret", "val", "err", "continue", " Ret", "re", "ter", "obj", "res", "ptr", "cert", "nt", "tr", "arg", "out", "def", "elt", "inter", "len", "r", "iter", "RET", "ctr", "end", "ext", "rets", "att", "deg", "cont"]}}
{"id1": "19584877", "id2": "14054923", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "21821404", "id2": "2676365", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "label": 0, "substitutes": {"getWebPage": ["downloadWebPages", "getDebugpage", "downloadWebpage", "getwebUrl", "getwebPages", "downloadwebPage", "getWebpage", "getLiveUrl", "getWebPages", "getDebugUrl", "downloadWebPage", "getDebugPages", "getLivePage", "getDebugPage", "getWebUrl", "downloadwebPages", "getLivePages", "getwebpage", "downloadWebUrl", "downloadwebpage", "getwebPage", "downloadwebUrl", "getLivepage"], "urlObj": [" urlOb", "uriCtrl", "urlCtrl", "Urlobj", " urlObject", "UrlCtrl", "httpOb", " urlobj", "httpObj", "uriobj", "urlObject", "urlobj", "urlOb", "logObject", "urlInd", " urlCtrl", "urlInfo", "httpObject", " urlOnce", " urlInd", " urlInfo", "UrlObj", "uriObj", "uriObject", "logInfo", "logOb", "logObj", "UrlObject", "UrlOnce", "httpInfo", "uriOnce", "uriInd", "urlOnce", "UrlInd"], "content": ["core", "context", "object", "ontent", "value", "output", "header", "comments", "data", "message", "Content", "equ", "format", "empty", "string", "clean", "complete", "sequence", "buffer", "str", "section", "continue", "raw", "wrapper", "text", "article", "view", "load", "response", "reason", "page", "comment", "document", "layout", "result", "body", "code", "address", "current", "txt", "write", "template", "display", "source", "title", "ext", "ce", "articles", "html", "cm", "command", "temp", "read", "cont"], "is": ["fs", "ese", "ri", "id", "rs", "ris", "when", "ists", "his", "ms", "err", "has", "ism", "re", "bis", "sit", "IS", "res", "be", "se", "es", "ais", "its", "not", "plays", "lis", "iss", "are", "being", "string", "e", "web", "chain", "iso", "or", "Is", "name", "isa", "isl", "other", "s", "in", "c", "internet", "tis", "iris", "out", "isc", "does", "isf", "os", "\u00eds", "ist", "isin", "was", "ios", "sis", "ot", "ir", "more", "isi", "where", "nis", "net", "sys", "by", "rys", "sels", "a", "ire", "ois", "as", "mis", "were", "ians", "i", "and", "job"], "reader": ["dr", "ipper", "stream", "ri", "liner", "dra", "ader", "ocker", "er", "iterator", "io", "handler", "editor", "buffer", "parser", "in", "loader", "writer", "runner", "reading", "ser", "ro", "file", "per", "Reader", "rar", "rr", "ner", "r", "iter", "inner", "anger", "row", "roller", "iper", "read"], "line": ["el", "column", "record", "ine", "liner", "online", "eline", "zone", "message", "char", "email", "detail", "e", "string", "ln", "le", "lo", "print", "sequence", "cell", "section", "block", "lin", "entry", "text", "part", "frame", "nl", "Line", "stroke", "inline", "page", "link", "comment", "range", "label", "piece", "file", "lane", "lined", "word", "l", "row", "LINE", "sample", "point"]}}
{"id1": "13757855", "id2": "7981642", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "label": 0, "substitutes": {"process": ["processor", "Process", "task", "format", "processing", "load", "step", "add", "replace", "apply", "render", "transform", "run", "build", "execute", "call", "write", "display", "loop", "create", "proc", "parse", "save", "filter", "project", "handle"], "tpl": [" tPL", "tmpp", "tpp", " tph", "ptplates", "timbl", "atplate", "stopl", "stplate", "teruple", "tempr", "stbl", "ttopl", "ttpg", "tsPL", " tpp", "tuple", "tpg", "tmplates", "ttbl", "Tplates", "tmplate", "timspl", " turtle", " tld", "tPL", "typl", "tyurtle", "tsurtle", "templ", "tplug", "Tbl", "stplug", "tpr", "tld", "Tplate", "ttpl", "temPL", "itpl", "tplate", "terplate", "otbl", " tplates", "stspl", "turtle", " tplate", "timpl", "itbl", "tyPL", "timplate", "tmbl", "timplug", "itPL", "atuple", "stpg", "tspl", "ttPL", "topl", "ptbl", "TPL", "tmPL", "terld", "Tspl", "Tph", "tbl", " tuple", "tsbl", "Tpr", "atld", "otplate", "ptpl", "tembl", "ttplug", "itplate", "tspr", " tbl", "Tpp", "otpl", "tplates", "tph", "Tld", "timopl", "ptld", "stpl", "otld", "ttph", "terpl", "tmpl", "timpg", "atpl", "Tpl"], "model": ["el", "object", "record", "models", "product", "node", "M", "data", "content", "ml", "m", "tree", " Model", "md", "document", "file", "Document", "base", "parent", "Model", "log", "html", " models", "module", "project"], "packageName": [" packageFamily", "groupNames", "groupName", "packagename", "Packagename", "viewClass", " packageClass", "packageRoot", "pkgVersion", "PackageName", " packagename", "pkgNames", "groupFamily", "packageVersion", "groupVersion", "PackageClass", " packageVersion", " packageRoot", "PackageRoot", "packageNames", "pkgFamily", "packageClass", "pkgName", " packageNames", "viewName", "viewRoot", "packageFamily", "viewname"], "outFileName": ["infilePath", " outFileTime", " outFileType", "outImagename", "outFilenameType", " outFilenameType", "outDirPath", "outFileNames", "outFilePath", "outFilenameNames", " outTableSize", "outStreamNames", " outTablePath", " outfileNames", "outFName", " outFileChain", "outfileNames", " outFilenamePath", " outFilenameSize", "outImageSize", "outfilename", "outStreamType", "outTableSize", "outDirName", "outFileChain", "outTablePath", "outDirTime", "infileNames", " outFilePath", " outfileName", "outStreamTime", "outfileType", "outTableType", " outFilenameName", "outFileSize", "outTablename", "outFPath", " outFilenameChain", "outFilenamePath", " outFilenamename", "outFilenameTime", "inFileTime", "outImagePath", "infileName", " outTableTime", " outFilename", "outFname", "outTableTime", "outfileTime", "inFileType", "infileTime", " outFileNames", "outStreamPath", "outStreamName", "outTableName", "inFileName", "outfilePath", "outFilenamename", "outFilename", "inFilePath", "outfileName", " outfilename", "outDirSize", "outFilenameSize", "outFileType", "inFileNames", "outTableChain", " outFileSize", "outFNames", "outFilenameName", " outfilePath", "outFilenameChain", "outImageName", " outTableName", "outFileTime", "outfileChain", "infileType"], "xsltParam": ["xsqlParam", "xsmlParam", "xsslParam", "xmlConf", "xmlParameter", "xsltConf", "xltParam", "xsmlParameter", "xsltParameter", "xsmlConf", "xltParameter", "xmlParam", "xsqlConf", "xsslParameter", "xsqlParameter", "xsslConf", "xltConf"], "artifact": ["arifacts", " artificate", "partifacts", "anifacts", "ardifacts", " artifacts", "ardifact", "arifact", "anificial", "artifacts", "artificial", "ardificial", "ardificate", " artificial", "artificate", "partifact", "Artifact", "Artifacts", "anifact", "anificate"], "destinationPath": ["estinationPath", "destigationChain", "chaininatedPath", "destinoHost", "destensionPoint", "destinatorChain", "origininationNow", "destesticSystem", "destinationName", "destinateChain", "destinationUrl", "chaininationDisk", "destociationPoints", "desturationPath", " destociationpath", "delinationPath", "estinationName", "DestinationPod", "destensionHost", "DestensionPath", "destesticPath", "destinationTarget", "destventionPath", "destinationSystem", "destigationPath", "destinantTemp", "generinationPath", "destinoName", "destinateAt", "destinantPod", "destositoryHost", "destinatorPath", "destionPath", "estinationPart", "destositoryParent", "DestinationHost", "termininationTarget", "destinationPart", "destinoPoint", "destinoKey", "destinateDir", "delinatePoints", "destensionPath", "identinateKey", "destinateName", "termininerJar", "desturationJar", "descositoryParent", "identinateChain", "destATIONParent", "destionPoint", "destesticJar", "descositoryHost", "DestificationDir", "destacementTime", "estinoKey", "estionpath", "destociationHost", "destociationHome", "destacementName", "destinateTarget", "destociationForm", "chaininationHome", "destinatePoints", "destensionTemp", "destinateJar", "destensionDir", "desticationPath", "destationDir", "destinationDriver", "destinateTime", "destinationDisk", "DestinationUrl", "delinateForm", "delinatePath", "desturationTarget", "destinatedTarget", "destinerpath", "destationHost", "destinationParent", " destinationpath", " destociationTarget", "estationPart", "identinationPath", "estationHost", "estinationDir", "descinationParent", "origininatedPath", "generinateAt", "generinatePath", "destinationNow", "destinationKey", "destinatorHost", "descositoryPath", "destociationPath", "destationPart", "destinateForm", "destinationChain", "destationPath", "destinationPod", "destitutionPATH", "destinatorPoint", "estinationPATH", "DestensionDir", "destacementPath", "desticationTemp", "destATIONPath", "termininerTarget", "desturationpath", "DestensionTemp", "destinateSystem", "destregationDisk", "destinateNow", "destinerHost", "destociationpath", "estinationpath", "destociationDir", "destificationUrl", "destositoryPath", "estinationTime", "descinationHost", "DestificationLocation", "destinatorpath", "origininatedChain", "destinateLocation", "destinatedDriver", "destinerDir", "chaininatedHome", "desticationPod", "destificationLocation", "chaininationPath", "destinateLog", "termininationPath", "origininationChain", "identinateInfo", "DestensionHost", "destinationDir", "estationDir", "destificationDir", "destinantDir", "destinationpath", "destinatorKey", "estinationPoint", "destitutionPath", "destesticAt", "destinationLocation", "estinoPath", "destranceLog", "destinationTemp", "origininatedForm", "identinationChain", "generinateJar", "destinatedChain", "DestificationPath", "estinationHost", "destinationPort", "identinationKey", "estionPoint", "destificationPath", "estionPath", "destitutionpath", "termininerpath", "destinateInfo", "DestensionPoint", "generinationSystem", "destrancePath", "destociationDisk", "destensionPod", "destATIONPort", "destinerPath", "DestinationTemp", "DestinationDir", "identinatePath", "destigationNow", "destinateUrl", "destinationPoint", "destociationLog", "destinatedInfo", "destitutionPoint", "estinationKey", "destregationPath", "destinatedDisk", "destventionDisk", "DestensionPod", "DestinationPath", "destinerAt", "destionpath", "destinationInfo", "destventionHome", "destinatorParent", "origininatedNow", "destationLocation", "destinationTime", "destinatedpath", "destationUrl", "DestificationUrl", "estationPath", "destinatorPATH", "destinoDir", "destinerPart", "destociationTarget", "destositoryPort", "origininationPath", "destinationForm", "descinationPort", "destinerTarget", "destinationJar", "destinationHome", " destinationTarget", "destociationDriver", "termininerPath", "destinatePart", "destventionDriver", "destinatedKey", "destinateKey", "chaininationDriver", "estionPATH", "destinatorInfo", "destinatePath", "delinationPoints", "destranceForm", "delinationLog", "destinerSystem", "destinationAt", "delinateLog", "destionPATH", "descinationPath", "destinatedNow", "DestinationLocation", "generinationAt", "destinateHost", "chaininatedDriver", "destinerJar", "chaininatedDisk", "destregationTarget", " destociationPath", "descositoryPort", "termininationJar", "identinationInfo", "destinatepath", "destATIONHost", "generinateSystem", "destigationForm", "destociationPoint", "destinationPoints", "destinationLog", "destinatedPath", "destinationHost", "destinatorPort", "origininationForm", "destinoTime", "termininationpath", "destinatedForm", "destinantPath", "destinoPath", "destinationPATH", "destrancePoints", "estinoName", " destinationDisk", " destociationDisk", "generinationJar", "estinoTime", "destinatedHome", "desticationDir", "DestinationPoint", "destacementKey", "destregationpath", "delinationForm"], "in": ["f", " IN", "ins", "din", "id", "IN", "io", "m", "bin", "c", "file", "reader", "doc", "i", "input", "r", "inner", "l", "t", "o", "d", "info", "w", "In", "n"], "out": ["cn", "f", "ins", "u", "cmd", "output", "go", "OUT", "co", "gr", "v", "b", "p", "dis", "ex", "screen", "ger", "println", "cache", "list", "gen", "s", "con", "e", "ln", "net", "io", "cfg", "print", "sys", "err", "conn", "raw", "outs", "it", "or", "c", "writer", "ou", "inv", "to", "report", "all", "obj", "res", "file", "aos", "nt", "msg", "ch", "nr", "can", "client", "write", "up", "inner", "oe", "conf", "null", "l", "os", "o", "log", "t", "Out", "w", "outer", "n"], "root": ["initial", "context", "scope", "node", "id", "p", "println", "New", "data", "chain", "group", "tree", "m", "table", "de", "_", "dir", "dump", "impl", "Root", "child", "parent", " roots", "name", "def", "graph", "r", "config", "se", "create", "json", "start", "parents", "ok", "roots", "Template"]}}
{"id1": "22410173", "id2": "22855019", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static MessageService getMessageService(String fileId) {\n        MessageService ms = null;\n        if (serviceCache == null) init();\n        if (serviceCache.containsKey(fileId)) return serviceCache.get(fileId);\n        Properties p = new Properties();\n        try {\n            URL url = I18nPlugin.getFileURL(fileId);\n            p.load(url.openStream());\n            ms = new MessageService(p);\n        } catch (Exception e) {\n            ms = new MessageService();\n        }\n        serviceCache.put(fileId, ms);\n        return ms;\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyStream", "transferFile", "copyfile", "cpFiles", " cpFile", "cpfile", " cpFiles", " cpfile", "cpStream", "copyFiles", "cpFile", "transferStream", " cpStream", "transferFiles", "transferfile"], "source": ["original", "scope", "copy", "search", "seed", "style", "SOURCE", "scene", "service", "s", "target", "origin", "ource", "src", "space", "me", "subject", "from", "resource", "spec", "init", "query", "file", "so", "sp", "parent", "base", "template", "input", "se", "iter", "start", "Source", "site", "sample", "ce", "local"], "dest": ["loc", "del", "crit", "search", "exp", "Dest", "home", "usr", "way", "target", "nw", "test", "origin", "src", "pub", "st", "it", "tom", "dist", "de", "them", "that", "orig", "trans", "des", "dir", "img", "nom", "pot", "tmp", "est", "sp", "master", "good", "lit", "null", "desc", "rest", "d", "temp", "deg", "cont"], "in": [" IN", "mi", "ins", "din", "inside", "en", "co", "pin", "ini", " input", "IN", "sin", "inn", "con", "ai", "net", "ln", "inf", "cin", "gin", "an", "m", "n", "bin", "on", "from", "conn", "it", "ar", "or", "vin", "re", "and", "ca", "all", "init", "al", "ma", "ain", "ch", "ind", "is", "inc", "client", "up", "rin", "doc", "i", "input", "win", "inner", "r", "iter", "l", "internal", "ci", "isin", "local", "read", "In", "can"], "out": ["cn", "ot", "cmd", "output", "en", "OUT", "co", "again", "v", "dis", "ex", "channel", "sum", "ent", "gt", "con", "user", "net", "io", "ne", "chain", "un", "ns", "on", "ac", "conn", "it", "outs", "OU", "ou", "nl", "note", "to", "obj", "aos", "nt", "cos", "ch", "ion", "can", "write", "off", "client", "up", "oss", "rem", "inner", "conv", "os", "null", "na", "not", "o", "t", "log", "Out", "at", "w", "outer", "n"]}}
{"id1": "17901739", "id2": "12783713", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"setMembers": ["getMember", "setMember", " setMethods", "initMethods", "setmembers", "initMember", "initmembers", "getMethods", "getMembers", "setMethods", "initMembers", "getmembers", " setmembers", " setMember"], "url": ["loc", "f", "sl", "ssl", "gl", "ls", "dl", "hl", "github", "lr", "web", "ref", "acl", "ll", "conn", "loader", "resource", "rl", "http", "ul", "nl", "link", "socket", "browser", "ur", "impl", "URL", "connection", "file", "base", "address", "open", "client", "pl", "lb", "r", "uri", "Url", "l"], "reader": ["stream", "upper", "er", "iterator", "driver", "io", "handler", "parser", "in", "loader", "writer", "rl", "resource", "load", "runner", "http", "reading", "ator", "ro", "range", "redo", "file", "console", "rr", "Reader", "rar", "client", "older", "ner", "r", "iter", "inner", "uri", "anger", "row", "roller", "rot", "read"], "buffer": ["stream", "detail", "buf", "stack", "button", "reason", "note", "page", "comment", "report", "expression", "line", "template", "ob", "null", "row", "bb", "length", "cache", "profile", "back", "string", "chain", "print", "entry", "trace", "table", "document", "batch", "body", "display", "vector", "memory", "Buffer", "summary", "background", "filter", "command", "initial", "binary", "channel", "data", "message", "format", "raw", "available", "prototype", "base", "word", "append", "source", "input", "buff", "bytes", "pause", "password", "history", "output", "b", "position", "window", "thread", "queue", "sequence", "program", "phrase", "database", "block", "text", "bridge", "frame", "function", "iter", "sample", "html"], "pattern": ["expr", "column", "pdf", "patch", "operator", "field", "sharp", "style", "p", "match", "model", "format", "TERN", "service", "pat", "process", "path", "net", "group", "print", "phrase", "parser", "xml", "network", "rule", "entry", "lead", "ping", "map", "step", "pretty", "pal", "prefix", "shape", "expression", "function", "prot", "operation", "system", "client", "def", "problem", "quant", "template", "graph", "png", " Pattern", "find", "policy", "variable", "period", "Pattern", "sample", "password", "command"], "matcher": ["tagcher", "matpatch", "patternatcher", "mitifier", "recher", "compatcher", "cather", "Mather", "selectcher", "matacher", "mutchers", "matchher", "matchatcher", "catter", "selectger", "compter", "matchcher", "matherer", "matched", "reherer", "mither", "Matcher", " matched", "selectpatch", "Matifier", "mather", "patifier", "Matver", "patterncher", "patternher", "patver", "reger", "matchers", "patacher", "matter", "matchifier", "metver", "matifier", " matatcher", "mutherer", " matifier", "metporter", " matter", "matener", "patatcher", "tagacher", " matver", "tagter", "patternched", "patporter", "selectherer", "metatcher", "matchched", "mutifier", "mitcher", "matporter", "mutpatch", "matchener", "compcher", "Matatcher", " matporter", "catver", "repatch", "mitter", "patter", "matchchers", "matver", "metcher", "Matter", "mutger", "patchers", "matchter", "tagener", "matger", "catcher", "mutcher", "muther", "matchacher", "Matchers", "pather", "patener", "patcher", "matatcher", " mather", "compchers"], "erg": ["eng", "ENG", "rog", "clus", "og", "org", "ivic", "der", "igor", "agog", "ert", "ger", "olog", "er", "reg", "rah", "erm", "ocr", "eg", "erick", "kr", "ager", "gae", "erc", "ERG", "ather", "agogue", "peror", "agame", "gent", "auc", "roc", "urg", "mont", "ere", "omer", "era", "uber", "arag", "staff", "enz", "eret", "inal", "\u00e9r", "eh", "alg", "iac", "her", "ero", "eric", "erd", "ric", "jer", "sg", "eur", "enger", "ung", "igator", "hung"], "start": ["ify", "style", "target", "diff", "delay", "state", "set", "add", "range", "middle", "before", "check", "get", "pad", "starting", "point", "send", "store", "seed", "match", "started", "back", "enable", "addr", "stop", "offset", "st", "entry", "it", "error", "size", "step", "init", "key", "name", "ind", "starter", "close", "find", "wind", "end", "result", "max", "sum", "begin", "valid", "art", "base", "seek", "shift", "source", "head", "play", "make", "rest", "ish", "pause", "kind", "draw", "index", " Start", "handle", "top", "position", "show", "window", "like", "origin", "from", "part", "fill", "Start", "this", "open", "client", "iter", "reset", "next", "first"], "von": ["ley", "bra", "jen", "hon", "vati", "ton", "onis", "mint", "avan", "viol", "nie", "don", "won", "ln", "onder", "endon", "vette", "san", "den", "ideon", "van", "ona", "innie", "iann", "son", "mond", "mont", "mun", "john", "melon", "vil", "vard", "umen", "ldon", "vine", "ston", "vid", "tan", "vi", "aven", "ivan", "zon", "ano", "lon", "ben", "leen", "irin", "rison", "oni", "vin", "bott", "mon"], "bis": ["fs", "bra", "ends", "pins", "jin", "ennis", "lis", "bs", "mos", "ris", "onis", "bits", "udi", "fin", "bes", "lie", "ls", "rots", "eni", "nis", "nes", "bles", "bid", "bi", "alli", "cin", "xy", "obs", "bil", "js", "dos", "bat", "mes", "tis", "south", "fr", "prefix", " bos", "antis", "bos", "beta", "vs", "cos", "phis", "idis", "mis", "pos", "ldon", "non", "is", "inter", "vy", "oss", "zon", "iter", "lon", "ben", "fps", "ni", "its", "rison", "los", "zo", "isin", "oi"], "m_strComponents": ["m_strcomports", "m_strCompors", "m_strMessages", "m_intCompages", "m_strMessorts", "m_brCompances", "m_brComports", "m_strContors", "m_strPackorts", "m_intComponents", "m_strChors", "m_intCompors", "m_strcompages", "m_strContonents", "m_intcomports", "m_strMessonents", "m_strcomponents", "m_strCommances", "m_brChonents", "m_strCommonents", "m_intcompors", "m_strCompances", "m_strPackonents", "m_strCompages", "m_brChances", "m_intComports", "m_strChances", "m_strContages", "m_brChors", "m_strCommors", "m_brChorts", "m_strContorts", "m_brComponents", "m_strcompors", "m_strPackors", "m_intcompages", "m_strPackances", "m_strComports", "m_strCommorts", "m_strMessors", "m_strChonents", "m_intcomponents", "m_strChorts", "m_brCompors"], "m_strPriorities": ["m_strSpecificities", "m_strPrioritives", "m_strPerity", "m_strRankies", "m_strPriorites", "m_stringPriorities", "m_strPosies", "m_stringPriorings", "m_strSpecificity", "m_stringPosies", "m_strPosings", "m_strPosites", "m_stringPriorifiers", "m_strRankities", "m_stringPosity", "m_strRankifiers", "m_strSpecificites", "m_stringPrioritives", "m_strPrefies", "m_strPriority", "m_strRankings", "m_strPosity", "m_stringPriority", "m_strPosifiers", "m_strPriorifiers", "m_strPrefifiers", "m_stringPosings", "m_stringPositives", "m_strSpecificitives", "m_strPerities", "m_stringPriorites", "m_stringPriories", "m_stringPosifiers", "m_strPrefings", "m_strPriories", "m_strPrefities", "m_strPeritives", "m_strPositives", "m_stringPosites", "m_strPriorings", "m_stringPosities", "m_strPosities", "m_strPerites"]}}
{"id1": "17999474", "id2": "13657103", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAsfile", "getBoxFromLocal", "getBoxFromFile", "getZipAsPath", "getZipAsLocal", "getBoxAsfile", "getBoxFromfile", "getZipToFile", "getZipToPath", "getZipInfile", "getZipFromfile", "getZipInFile", "getZipFromLocal", "getBoxAsPath", "getBoxAsLocal", "getBoxAsFile", "getZipInLocal", "getZipFromPath", "getZipToLocal", "getBoxFromPath", "getZipInPath", "getZipTofile", "getZipFromFile"], "digOb": ["digOB", "chemOB", "DigObj", " digOB", "gradOb", "DigObject", " digEx", "DigOB", " digOcc", "chemEx", "divObject", " digObj", "DigOb", "digOcc", "divOcc", "chemObj", " digObject", "DigEx", "digObject", "gradOB", "digEx", "digObj", "chemOb", "gradObject", "gradObj", "divObj", "divOb", "DigOcc"], "folderName": ["folderSize", "foldername", "FolderNames", "folderNames", "folderKey", " foldername", "foldname", "FolderName", "fileKey", "foldName", "fileName", "foldPath", "fileSize", " folderSize", "foldNames", " folderKey", " folderPath", " folderNames", "Foldername", "foldSize", "fileNames", "foldKey", "folderPath", "FolderPath"], "tmpFolder": ["cmpDir", " tmpDir", "mpDirectory", "mpfolder", "mpFolder", "tmpDirectory", "tempDirectory", "mpParent", "tmpParent", "tempFolder", " tmpfolder", "tmpDir", "cmpfolder", "tempDir", "cmpParent", "tempParent", "cmpFolder", " tmpDirectory", "mpDir", "tempfolder", "tmpfolder"], "zip": ["f", "cloud", "folder", "z", "pdf", "drop", "quote", "exp", "sea", "wrap", "cf", "archive", "zone", "content", "csv", "box", "form", "io", "test", "tar", "gz", "xml", "entry", "pack", "pkg", "post", "col", "link", "Zip", "upload", "install", "jar", "report", "bag", "file", "sheet", "tmp", "library", "body", "sp", "proxy", "pool", "lock", "mail", "template", "feed", "se", "json", "row", "ip", "ow", "sample", "temp", "project"], "out": ["ins", "copy", "output", "OUT", "en", "co", "v", "serv", "ex", "list", "ent", "us", "s", "ln", "net", "io", "print", "set", "in", "outs", "it", "OU", "writer", "ou", "inv", "to", "all", "res", "auto", "aos", "tmp", "sp", "cos", "check", "up", "write", "i", "oss", "one", "conv", "inner", "os", "null", "flush", "o", "t", "Out", "n"]}}
{"id1": "18891988", "id2": "7458833", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getFile": ["getFilename", "getfile", "selectfile", "GetFilename", "selectFilename", "createfile", "GetFile", "createFilename", "selectString", "getString", "createFile", "selectFile", "Getfile", "GetString", "createString"], "serviceName": ["libraryNames", "serviceCode", "ServiceName", "libraryFamily", "serverCode", "ServiceNames", "serverType", " serviceNames", " serviceFamily", "ServiceFamily", "serviceFamily", "serviceType", "libraryType", " serviceCode", "ServiceCode", "serverName", "ServiceType", "serviceNames", "libraryName", " serviceType"], "wsdlLocation": ["wslLoc", "awsdURL", "awsolURL", "wlFolder", "wlPath", "wslLocation", "wssdFolder", "wssdLocation", "wsDLlocation", "awsdlLocation", "wsollocation", "wsdlocation", "wslPath", "wsdlURL", "awsolLocation", "wsolLocation", "wssdURL", "wsdLoc", "wsolURL", "wsDLLoc", "awsdLocation", "wdlLoc", "wssdlocation", "wdlPath", "wsdllocation", "wsdLocation", "awsdlURL", "wsdlLoc", "wsDLFolder", "wsDLURL", "wlLocation", "awsdlocation", "awsdLoc", "awsollocation", "awsdlLoc", "awsolLoc", "wdlFolder", "awsdllocation", "wssdLoc", "wsdlPath", "wsdlFolder", "wlLoc", "wsDLPath", "wsolLoc", "wslFolder", "wdlLocation", "wsDLLocation", "wssdPath", "wsdURL"], "endpoint": ["Endpoint", " endport", "idpoint", "startword", "endport", " endPoint", "startPoint", "endPoint", "beginpoints", "Endport", "endpoints", "beginword", " endline", "beginpoint", "idline", "bindpoint", "bindPoint", "idPoint", "EndPoint", "Endpoints", "Endword", "startpoints", "bindport", "endword", "startpoint", "endline", "bindpoints", "beginPoint", " endpoints", "startline", "idpoints"], "fileLocation": ["fileLoc", "documentLoc", "filelocation", " fileLoc", "Filelocation", "FilePosition", "documentPosition", " filePosition", "filePosition", "documentlocation", " filelocation", "documentLocation", "FileLocation", "FileLoc"], "tempDir": ["TempDirectory", "tmpUrl", "TempFolder", "Tempdir", " tempDirectory", "TempPath", "tempDirectory", "tmpDirectory", " tempPath", "TempDir", "TempUrl", "tempFolder", " tempUrl", "tmpFolder", "tmpDir", "tempdir", " tempFolder", " tempdir", "tempUrl", "tmpPath", "tmpdir", "tempPath"], "url": ["f", "loc", "rel", "sl", "ssl", "gl", "https", "location", "ls", "dl", "il", "window", "char", "service", "bel", "github", "web", "un", "m", "str", "ll", "conn", "ret", "http", "li", "re", "ul", "nl", "link", "socket", "browser", "ur", "URL", "cert", "build", "base", "cp", "open", "mount", "mail", "up", "pl", "cr", "r", "ctrl", "uri", "Url", "l", "sur", "job"], "WSDLFile": ["WNDDLFilename", "WHDLfile", "WSDLLType", "WSDMLFILE", "WSDDLFILE", "WSDLLString", "WNDDLFILE", "WIDDLType", "WSDLfile", "WSDQLFile", "WNDLfile", "WIDLfile", "WSDELFilename", "WHDLFILE", "WHDDLFILE", "WSDMLfile", "WIDLString", "WIDDLString", "WSDLLfile", "WIDLFile", "WNDLFile", "WSDDLFile", "WNDDLfile", "WIDLType", "WHDDLFile", "WSDQLfile", "WSDLFilename", "WSDLLFILE", "WSDLSFile", "WIDDLFile", "WIDDLfile", "WSDQLFILE", "WSDELfile", "WSDELFILE", "WHDLFile", "WHDDLfile", "WSDLType", "WSDELFile", "WSDMLFile", "WNDLFilename", "WSDDLfile", "WSDLSfile", "WSDDLFilename", "WSDLLFilename", "WSDDLType", "WSDLLFile", "WSDDLString", "WSDLFILE", "WNDDLFile", "WNDLFILE", "WSDLSType", "WSDLSString", "WSDLString"], "tmpWSDLFile": ["tmpWSDlFilename", "tmpWSDlfile", "tmpWSDlFiles", "tmpWSDLLFiles", "tmpWSDLDfile", "tmpWSDLLFilename", "tmpWNDDLFiles", "tmpWNDLFile", "tmpWIDDLFILE", "tmpWSDDLfile", "tmpWSDLFiles", "tmpWSDDLFile", "tmpWSDlFile", "tmpWSDLFILE", "tmpWIDLFilename", "tmpWSDLFilename", "tmpWSDLLFile", "tmpWNDLfile", "tmpWSDDLFilename", "tmpWNDDLFile", "tmpWSDLLFILE", "tmpWSDLDFilename", "tmpWNDLFilename", "tmpWNDDLFilename", "tmpWIDDLFilename", "tmpWNDDLfile", "tmpWIDLFile", "tmpWIDLfile", "tmpWSDDLFiles", "tmpWIDDLFile", "tmpWSDLfile", "tmpWNDLFiles", "tmpWSDDLFILE", "tmpWSDLLfile", "tmpWIDLFILE", "tmpWSDLDFile", "tmpWIDDLfile", "tmpWSDLDFILE"], "inputFile": ["inputDo", " inputFILE", "outputStream", "Inputfile", "tmpPlace", "inputPlace", "intfile", "errorfile", "indexFile", "InputFiles", "InputDo", "clientFILE", "InputFILE", " inputDo", "tmpFILE", "inputFiles", " inputSourceFile", "outputFILE", "inputfile", "inputPath", "indexFILE", "InputPath", "intFile", " inputPath", "clientFiles", "tmpStream", "inputSourceFile", "inFile", "tmpfile", "interfacefile", "errorFile", "tmpSourceFile", " inputfile", "inputStream", "indexStream", " inputFiles", "interfaceFile", "errorFILE", "infile", " inputPlace", "inputFILE", "outputFile", "intFILE", "inDo", "errorStream", "inPath", "clientPath", "interfacePlace", "outputfile", "InputStream", "InputFile", "interfaceSourceFile", "clientFile", "indexfile", "intFiles"], "tmpFile": ["empFILE", "mpFiles", "tempFiles", "tempFILE", "tmpFILE", "inputfile", "mpfile", "tempFile", "tempfile", "tmpfile", " tmpfile", "empfile", "tempFilename", "inputFILE", "empFilename", " tmpFiles", "empFile", "mpPath", "tmpFiles", "inputFilename", "tmpPath", "mpFile", " tmpPath", "tmpFilename", "tempPath"], "in": ["mi", "ins", "din", "en", "stream", "ri", "id", "ini", "cont", "IN", "sin", "inn", "ln", "ai", "io", "inf", "cin", "bin", "from", "conn", "it", "c", "ic", "ar", "inv", "init", "file", "ain", "ch", "ind", "is", "inc", "client", "rin", "input", "r", "source", "inner", "t", "o", "isin", "In", "n"], "out": ["output", "OUT", "en", "co", "ex", "cache", "we", "net", "io", "ne", "group", "sys", "buffer", "on", "conn", "outs", "c", "by", "OU", "writer", "ou", "inv", "to", "all", "connection", "file", "obj", "auto", "aos", "tmp", "pool", "ch", "lock", "this", "can", "client", "write", "oss", "conv", "ao", "os", "conf", "null", "o", "t", "log", "cm", "Out", "at", "w", "outer", "n"], "con": ["cn", "num", "cal", "const", "co", "cf", "ran", "com", "tc", "nc", "connect", "ws", "ln", "un", "cin", "conn", "c", "sec", "re", "Con", "login", "connection", "mc", "Conn", "ain", "fn", "cos", "ch", "cp", "soc", "CON", "cur", "win", "conv", "cone", "conf", "exc", "cons", "cm", "acon", "fc", "func", "can"], "fileLength": [" fileFontSize", "fileLen", "objectFontSize", "channelFontSize", "objectSize", "FILEDuration", "FILELength", "ileLen", "fileDuration", " fileDuration", "channelSize", "ileSize", " fileSize", "channelLength", "objectDuration", "fileSize", "ileLength", "objectLength", "fileFontSize", " fileLen", "ileDuration", "channelDuration", "FILESize", "FILELen"], "channelIn": ["clientIN", "channeledIn", "clientSet", "channelSet", "chanOut", "ChannelOut", "clientin", " channelIN", "channelIN", "ChannelIN", "ChannelSet", "channelin", "clientIn", "chanIN", "consoleIN", "ChanneledIn", " channeledIn", "Channelin", "ChannelIn", "consoleOut", "consoleIn", "chanSet", "chanIn", "clientOut", "consoleedIn", " channelin"], "channelOut": ["courseOut", " channelConn", "consoleOUT", "chanConn", "ChannelOUT", "channelConn", "chanout", "chanOut", "ChannelOut", "channelOUT", "courseOUT", " channelout", "courseIn", "consoleout", "ChannelIn", "consoleOut", "ChannelConn", "consoleIn", "chanIn", "channelout", "courseout", " channelOUT", "Channelout"], "tmpDocument": ["npMedia", "tempdocument", "tmdocument", "tpDocument", "tmDocument", " tmpDocuments", "mpdocument", "tmpMedia", "mpDocument", "cpdocument", "tpFile", "npDocuments", "mkdocument", "tpMedia", "mkDoc", "cpDoc", "mkDocument", "tmDoc", "mpDoc", " tmpMedia", " tmpDoc", "tpDocuments", "npDocument", "tempDoc", " tmpdocument", "npFile", "tmpdocument", "cpDocument", "tmpDoc", "tmpDocuments", "tempDocument"], "nl1": ["sol1", "sol2", "ln9", "NL0", "NL1", "nelOne", "ln2", "ln0", "sol0", "nel6", "NL2", "NL9", "pel1", "ln3", "ln1", "nlOne", "ln6", "rn3", "nel3", "nr01", "nl01", "nl9", "ln01", "rnOne", "nl6", "sol9", "nl2", "rn6", "nl3", "pelOne", "nr1", "nrOne", "nl0", "rn1", "nel1", "pel01", "lnOne"], "i": ["k", "cli", "mi", "ami", "u", "id", "ri", "pi", "v", "ix", "ini", "I", "us", "ii", "si", "ai", "io", "bi", "ms", "m", "me", "sim", "multi", "ic", "it", "li", "ti", "a", "j", "span", "xi", "ij", "ims", "init", "key", "x", "hi", "ori", "ji", "ie", "y", "is", "ui", "di", "gi", "ci", "ip", "mu", "\u0438", "o", "qi", "info", "index", "n"], "node1": [" nodeOne", "node001", " node2", "Node001", "component0", " node91", "node91", "ode2", "layer91", "node0", "n0", "ode1", "Node0", "layer0", "ode0", "n91", "componentOne", "layer1", " node0", "ode001", "component1", "n1", "component2", "Node1", "layerOne", "Node2", " node001", "NodeOne", "nOne", "nodeOne", "node2"], "tmpOut": ["TempOUT", "cmpOut", "npIn", "mpObj", "tmpIn", "mpIn", "TempIn", "npOut", "mpOut", " tmpout", "cmpout", " tmpOUT", "empout", "npObj", "tempIs", "tmpout", "mpout", "TempObj", "tmpOUT", "tempOUT", "tmpObj", "TempOut", "empIs", " tmpObj", "cmpIn", "tempObj", "tempout", "tempIn", "tempOut", "empOut", "npout", " tmpIs", "tmpIs", " tmpIn"], "retVal": ["Retval", "returnValue", " retval", "RetValue", "retValue", "retTrue", "returnVal", "retval", "RetTrue", "returnTrue", " retValue", "RetVal", "returnval", " retTrue"]}}
{"id1": "5125848", "id2": "14502142", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"combineJs": ["CombineJs", "combINEJs", "combinateJs", "ComboseJs", "combinejs", "ComboseLink", "combINELink", "combineJS", "CombineJS", "combinateJS", "combINEJS", "ComboseJS", "combinatejs", "combineLink", "CombineLink", "combosejs", "combINEjs", "comboseJs", "Combinejs", "combinateLink", "comboseJS", "Combosejs", "comboseLink"], "base": ["host", " based", "server", "domain", "b", "id", "data", "api", "bas", "bid", "origin", "buffer", "absolute", "from", " basis", "re", "bottom", "based", "page", "Base", "prefix", "file", "address", " bases", "relative", " Base", "template", "source", "uri", "db", "reset", "ase", "start", "root", "site", "bound", "local"], "linkJs": ["LinkJS", "LinkJs", " linkScript", "linkjs", " linkLinks", "Linkjs", "linkedScript", "inkTags", "linkScript", "inkLinks", "inkScript", " linkTags", " linkJS", "LinkTags", "linkedLinks", "inkjs", "inkJS", "linkTags", "inkJs", "linkedJS", " linkjs", "linkLinks", "linkedJs", "linkJS"], "newFiles": ["newDocuments", "nextFiles", "newLinks", "newfiles", "linkFiles", "nextfiles", " newLinks", "nextDocuments", " newDocuments", "linkDocuments", "linkLinks", "nextLinks", " newfiles", "linkfiles"], "dir": ["div", "rel", " Dir", "folder", "loc", "fs", "dd", "dr", "id", " d", "ir", "DB", "dl", "mk", "disk", "area", "diff", "ref", "addr", "sys", "local", "tar", " directory", "pkg", "mod", "vol", "md", "file", "DIR", "auto", "tmp", "directory", "dm", "zip", "lock", "good", "def", "dep", "out", "doc", "done", "created", "wd", "db", "di", "manager", "cd", "desc", "Dir", "root", "fd", "temp", "d", "lib", "module"], "name": [" bar", " logger", " cleaner", " start", " os", " foo", " scanner", " vm", " tmp", " karma", " msg", " report", " dummy", " info", " self", " filename", " b", " manager", " parser", " browser", " prefix", " err", " rebuild", " names", " str", " db", " res", " loader", " log"], "minDir": [" minJar", "minDb", "smallDb", "miniTier", "MinNet", "smallDir", " minPref", "minTrans", "mainDir", "sortDir", "minNet", " minTier", "minuteDir", "skinLoc", " minNet", "smallFile", "miniDir", "MinFile", " minTrans", "skinDb", "minuteDar", "miniTrans", "mainLoc", "thinTier", "minPref", "MinDir", "minTier", "thinJar", "maindir", "thinDir", "minFile", " minDar", " minRel", "miniJar", "minRel", "minDar", "minuteRel", "minJar", " minFile", "smallLoc", "mainDb", "minutePref", "thinTrans", "smallNet", "sortDar", "mindir", "smalldir", "sortRel", "skinDir", "skindir", "minLoc", "sortPref"], "combineFile": ["coordineWriter", "comboiceMessage", "combINESet", "combinefile", "cominateMessage", "cominateFile", "combineSet", "coordINEFile", "comineMessage", "cominateEmail", "combineEmail", "combinerFile", "combosefile", "cominatefile", "combinSet", "comineFile", "combinerfile", "cominefile", "comboseWriter", "combinateFile", "comineEmail", "combinatefile", "combINEWriter", "combineMessage", "comboiceFile", "combinfile", "coordINESet", "comboseSet", "combINEFile", "comboiceEmail", "combinerEmail", "combinWriter", "coordINEfile", "coordinefile", "combINEfile", "comboseFile", "comboicefile", "coordINEWriter", "coordineFile", "combinateEmail", "combinFile", "combinerMessage", "coordineSet", "combinateMessage"], "concatFile": ["conCatFilename", "convertTable", "convertFilename", "concatDir", "concapFiles", "conatfile", "concFilename", "conCatDir", "concatTable", "concapfile", "covertTable", "conCatFile", "comcDir", "comcatDir", "conatFile", "cocatTable", "comcatFile", "covertFile", "covertfile", "cocatfile", "comcFile", "comcatFilename", "convertfile", "conatFiles", "concatfile", "concatFiles", "covertFiles", "concapFile", "conatTable", "concapTable", "concDir", "convertDir", "convertFiles", "comcFilename", "cocatFile", "concatFilename", "concFile", "cocatFiles", "convertFile"], "combineWriter": ["combineWrite", "combieFile", "declineReader", "combineReader", "combieReader", "combinateReader", "Combinewriter", "combinateWrite", "combinewriter", "combinateCounter", "combenCounter", "declinateFile", "combieWrite", "ComboseWriter", "declineFile", "combenwriter", "comboseWriter", "combinateFile", "ComboseCounter", "declinateReader", "combineCounter", "declinateWriter", "CombineWriter", "combenWriter", "comboseReader", "declineWriter", "comboseWrite", "Combosewriter", "comboseCounter", "comboseFile", "combosewriter", "declineWrite", "declinateWrite", "CombineCounter", "combinatewriter", "combinateWriter", "combieWriter", "combenWrite", "CombineWrite", "ComboseWrite"], "concatWriter": ["conatReader", "convertWrite", "conatWriter", "cocatWrite", "comvertWriter", "comvertReader", "conatFile", "comcatFile", "concatsReader", "convertReader", "conatWrite", "coatFile", "cocatWriter", "convertWriter", "cocatReader", "comvertFile", "concatsWrite", "coatWrite", "comcatReader", "comvertWrite", "concatsFile", "cocatFile", "concatsWriter", "concatReader", "coatReader", "comcatWriter", "coatWriter", "comcatWrite", "concatWrite", "convertFile"], "fails": ["fils", " focks", "frailing", "Failing", "focks", "facails", "failing", "facailed", "frailed", "mailing", "ifailed", "malls", "lailed", "mailed", "facocks", "Fails", "ifocks", "frils", "Failed", "mocks", "failed", "facailing", "ifails", "Fils", " failed", "frails", "lails", "lailing", "falls", "mails", "lalls", "lils", " falls", "ifailing", " failing"], "link": ["loc", "node", "mark", "match", "script", "linked", "task", "self", "relation", "ln", "ink", "links", "embed", "set", "push", "follow", "c", "li", "load", "map", "add", "inline", "skip", "child", "share", "code", "address", "open", "line", "check", "display", "Link", "source", "close", "l", "log", "remote"], "path": ["image", "loc", "id", "style", "p", "location", "match", "pattern", "data", "format", "string", "ref", "src", "str", "entry", "PATH", "text", "resource", "join", "alias", "prefix", "key", "file", "hex", "relative", "template", "full", "source", "input", "uri", "route", "prop", "Path", "root", "href", "kind", "ath"], "url": ["loc", "host", "rel", "sl", "ssl", "gl", "id", "location", "ls", "il", "hl", "char", "string", "web", "ref", "lr", "addr", "str", "ll", "request", "resource", "http", "li", "ul", "nl", "browser", "ur", "URL", "build", "address", "this", "mount", "mail", "get", "source", "r", "uri", "Url", "l", "abs", "null", "href", "html"], "inputStream": ["InputStyle", "InputTime", " inputSet", "InputSteam", "outputStyle", "inSet", "outputstream", "inTime", " inputstream", " inputSteam", "inStream", "inputSteam", "inputstream", "Inputstream", "instream", "inputStyle", " inputStyle", "InputSet", "InputStream", "outputSteam", "inputSet", "inputTime", " inputTime"], "jsFile": ["JsPath", "jFile", "jsPath", "cssFilename", "cssfile", "jPath", " jsTable", "cssTable", "jName", " jsPath", "javascriptPath", " jsName", "jsfile", "cssFile", "javascriptName", "Jsfile", "javascriptFile", "jsFilename", "jFilename", "JsFilename", " jsfile", "javascriptFilename", "javascriptfile", "jsName", "cssPath", "JsFile", "jsTable", " jsFilename", "javascriptTable"], "fileName": ["filePath", "getPath", "filename", "FileHash", "getHash", " fileHash", "fileHash", "FilePath", "FileName", "Filename", "getname", "getName", " filename", " filePath"], "outputStream": [" outputSteam", " outputStyle", "OutputSet", "Outputstream", " outputForm", "outputStyle", "inputForm", "OutputStyle", "outputstream", "OutputStream", "inputSteam", "inputstream", " outputstream", "OutputSteam", "OutputForm", "inputStyle", "writestream", "writeSet", "outputSet", "writeStream", "outputSteam", "outputForm", " outputSet", "writeSteam"], "first": ["initial", "top", "same", "important", "self", "fast", "each", "index", "then", "front", "sort", "stack", "real", "valid", "continue", "st", "natural", "quick", "must", "all", "seconds", "send", "only", "master", "latest", "false", "current", "true", "open", "ind", "last", "unique", "start", "default", "success", "second", "fourth", "next", "prev", "First", "third", "primary", "now"], "reader": ["core", "context", "mr", "stream", "rc", "rator", "data", "er", "iterator", "driver", "io", "handler", "buffer", "parser", "wrapper", "loader", "layer", "writer", "rl", "resource", "http", "runner", "ro", "builder", "file", "rr", "rar", "Reader", "this", "ner", "r", "input", "inner", "rer", "row", "read", "ocr"], "jsCompressor": ["jsCompression", "cssComposer", "jsCompiler", "jscomposer", "jscompiler", "jsComposer", "jsRepressor", "jsBuffoser", "cssCompressor", "cssRepressor", "jsBuffiler", "jsBuffressor", "jscompressor", "cssCompiler", "cssCompression", "jsRepiler", "jsReposer", "cssRepiler", "cssRepression", "jsRepression", "jscompression", "cssReposer", "jsBuffression"], "s": ["fs", "ats", "xs", "words", "cs", "ls", "ens", "pers", "ers", "S", "ns", "ms", "ss", "gs", "ds", "ts", "tes", "eds", "y", "ies", "less", "is", "full", "details", "parts", "ings", "es", "os", "l", "lines", "hs", "t", "ids", "qs", "tags", "ps"], "s1": ["ls1", " s3", "ls0", "pers1", "esFirst", "idFirst", "s0", "ys0", "s81", "ls3", "id2", "id1", " s81", "es2", "es9", "ls81", "ys81", "ps1", "s9", "ps0", "pers0", "es1", "s3", "ys3", "sFirst", "id9", " s0", "ys1"], "i": ["ia", "mi", "id", "ri", "p", "pi", "v", "ity", "ii", "us", "ai", "iti", "io", "bi", "um", "iat", "iu", "it", "ic", "li", "j", "ori", "ie", "y", "ch", "is", "ion", "ui", "di", "ig", "ip", "ci", "ati", "ifier", "o", "im", "oi", "I"], "s2": ["s02", "sSecond", "tes2", "es02", "SSecond", "S02", "gs2", "ss22", "s22", "z02", "msTwo", "z2", "tesTwo", "gsSecond", "Stwo", "S2", "ss2", "ssTwo", "gs02", "es2", "tes1", "zSecond", "stwo", "ms2", "gstwo", "ztwo", "es1", "tes02", "ms22", "esTwo", "ms02", "sTwo", "ss02"], "i1": ["e4", "e2", "it01", "eOne", "itOne", "p1", "it2", "i0", "p01", "a1", "it0", "aOne", "i01", "a2", "pOne", "o1", "a01", "p2", "i2", "it1", "p4", "it4", "o0", "o4", "e1", "oOne", "p0", "i4", "iOne"]}}
{"id1": "11082670", "id2": "20073619", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 1, "substitutes": {"lookupFutureEvents": ["lookupAsyncEvents", "lookUpAsyncEvent", "lookupPastServices", "lookupLatestEvents", "lookUpFutureServices", "lookupAsyncUsers", "lookupAsyncEvent", "lookUpAsyncUsers", "lookupLatestEvent", "lookUpAsyncServices", "lookUpAsyncEvents", "lookUpFutureUsers", "lookupFutureServices", "lookupPastEvent", "lookUpFutureEvent", "lookUpFutureEvents", "lookupPastUsers", "lookupAsyncServices", "lookupFutureEvent", "lookupPastEvents", "lookupFutureUsers", "lookupLatestUsers", "lookupLatestServices"], "groupIdentifier": [" groupidentifer", "groupSpecificification", "groupidentifier", "groupIdentifiers", "groupIdifer", "groupSpecificifer", "groupSpecificifier", "groupSpecificificate", "groupidentifer", " groupidentifier", "groupIdifiers", " groupidentification", "groupIdifier", "groupIdentificate", " groupidentificate", "groupIdification", " groupIdifer", "groupidentificate", "groupidentification", "groupSpecification", "groupSpecifiers", "groupidentifiers", " groupIdifier", "groupIdificate", " groupIdification", " groupIdentificate", " groupIdifiers", " groupIdentification", " groupIdentifer", " groupIdentifiers", "groupSpecifier", "groupSpecifer", "groupIdentification", "groupIdentifer"], "json": ["javascript", "jj", "stats", "data", "message", "total", "api", "format", "list", "properties", "string", "csv", "form", "print", "state", "database", "tree", "xml", "network", "raw", "request", "js", "it", "join", "status", "response", "j", "pretty", "note", "metadata", "sv", "report", "alert", "sql", "query", "document", "gc", "son", "kj", "hex", "batch", "params", "zip", "jack", "JSON", "details", "lost", "human", "journal", "log", "html", "now", "pi"], "requestUrl": ["RequestWar", "responseLink", "serviceStr", " requestWar", " requestURL", "responseUr", "requestURL", "serviceURL", "requestStr", "responseUrl", "serviceUrl", "serviceWar", " requestLink", "RequestStr", " requestUr", "RequestUr", "responseURL", " requestStr", "requestUr", "requestWar", "requestLink", "RequestURL", "RequestUrl", "RequestLink"], "url": ["f", "rel", "host", "sl", "ssl", "b", "p", "dl", "char", "github", "web", "io", "ref", "str", "ll", "ret", "resource", "http", "re", "ul", "nl", "link", "socket", "browser", "ur", "URL", "sb", "res", "build", "base", "address", "open", "mount", "mail", "get", "r", "input", "uri", "Url", "l"], "in": ["f", "ins", "din", "ssl", "mr", "b", "again", "doc", "IN", "er", "inn", "con", "ln", "io", "cin", "gin", "buffer", "on", "bin", "from", "raw", "ic", "re", "and", "all", "impl", "file", "mc", "body", "reader", "is", "inc", "line", "out", "ob", "get", "input", "r", "iter", "inner", "source", "conf", "l", "log", "isin", "info", " din", "In"], "inputLine": ["configRow", "outputLINE", "readLine", "outputline", " inputRow", " inputline", "firstline", "readStream", "readline", "outputEntry", "outputRow", " inputCell", "firstRow", "inputRow", " inputEntry", "firstLine", "outputLine", "inputLINE", "inputStream", "configEntry", "inputCell", "InputLine", "readRow", "Inputline", " inputStream", "InputStream", "outputCell", "InputRow", "configLINE", "firstCell", "inputline", "inputEntry", " inputLINE", "configLine"], "events": ["assets", "views", "rows", "ents", "videos", "items", "types", "actions", "issues", "devices", "options", "sections", "reports", "forms", "objects", "dates", "services", "archives", "pages", "es", "errors", "versions", "Events", "names", "groups", "history", "tests"], "jsonObj": ["jsonobj", "JSONObject", "jsonCons", "xmlEx", "xmlObj", "JSONEx", "javascriptEx", "xmlCons", " jsonobj", " jsonEx", "javascriptObject", "sonEx", "xmlObject", "jsonObject", "jsonEx", " jsonObject", "javascriptObj", "JSONCons", "sonObj", "JSONobj", "sonobj", "JSONObj", "javascriptCons", "sonObject"], "results": ["assets", "roads", "rows", "terms", "ults", "rings", "Results", "values", "features", "vals", "runs", "items", "orders", "ms", "issues", "artifacts", "roots", "RESULTS", "images", "users", "thumbnails", "rates", "products", "sections", "reports", "res", "lists", "forms", "objects", "idents", "resources", "posts", "finals", "details", "games", "docs", "ings", "pages", "errors", "lines", "versions", "its", "successful", "blocks", "photos", "tests"], "i": ["f", "cli", "mi", "ami", "u", "iq", "id", "ri", "ix", "ini", "I", "ii", "us", "si", "ai", "io", "bi", "chain", "print", "yi", "m", "sim", "me", "ki", "ic", "it", "ei", "multi", "li", "ij", "j", "xi", "x", "hi", "ori", "ji", "batch", "phi", "y", "is", "ui", "di", "gi", "ci", "ip", "o", "info", "qi", "im", "index", "pi"], "result": ["folder", "context", "record", "runtime", "output", "product", "search", "mate", "currency", "match", "class", "profile", "relation", "message", "data", "detail", "pair", "feature", "dict", "Result", "process", "description", "complete", "test", "valid", "first", "duration", "rule", "entry", "wrapper", "definition", "answer", "status", "table", "response", "report", "document", "res", "function", "total", "latest", "true", "reverse", "full", "details", "done", "created", "manager", "associated", "success", "primary", "successful", "remote"], "e": ["u", "entity", "ec", "te", "ev", "le", "err", "eg", "eff", "re", "ke", "ef", "de", "be", "h", "se", "g", "es", "d", "ee", "f", "el", "pe", "exp", "ent", "ge", "ae", "ate", "ve", "ne", "m", "entry", "it", "or", "element", "ue", "l", "o", "eeee", "end", "eur", "ine", "en", "p", "v", "die", "email", "er", "s", "eu", "me", "c", "j", "x", "ie", "create", "one", "oe", "t", "et", "b", "ome", "ze", "ed", "E", "ei", "em", "a", "ade", "y", "event", "r", "ce", "n"], "myDate": ["myUser", " myData", "mineD", "amiDate", " myD", "amiBody", " myWrite", "morningWrite", "mysUser", " myEvent", "myBody", "thisWrite", " myDat", "thisDay", "mysTime", "miDate", "amiDat", "amiD", "mysEvent", "myDat", "MyTime", "mysData", "amiWrite", "mysDate", "myEvent", "morningD", "miUser", "myWrite", "myDay", " myDay", " myTime", "mineDate", "morningBody", "MYTime", "morningDate", "miDay", "amiDay", "myData", "MyDate", "mysDay", "thisDat", "thisDate", "miTime", "miEvent", "myTime", "miData", "MYCart", "myD", "MYDate", "mineTime", " myCart", "MYD", "mineCart", "myCart", " myUser", " myBody", "MyDay"], "time": ["context", "etime", "runtime", "mt", "value", "id", "zone", "data", "message", "tc", "instance", "format", "string", "tim", "TIME", "test", "ime", "text", "c", "timeout", "trace", "join", "clock", "year", "hour", "code", "name", "event", "before", "shift", "template", "title", "tm", "timer", "start", "type", "Time", "t", "info", "date", "tt"], "tz": ["loc", "z", " ss", "etime", " ns", "tk", " td", "dt", "Zone", " os", "zone", "tc", "etz", " dd", "ns", " zones", " zone", "webkit", "hh", " xx", "etc", "ts", " dst", "cond", " z", "tm", "os", "local", "tt"]}}
{"id1": "12236729", "id2": "14502142", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" duplicate", " delete", "transfer", " Copy", " seek", " upload", " paste", " append", " restore", " transfer", " dup", "paste", " join", "Copy", " operate", " merge", "cp", " recover", " cat", " copying", " download", " replicate", " combine", " move", " parallel", " cp", "read", " clone"], "inputFile": [" inputPost", " inputile", "configPath", " inputDir", "argumentfile", "argumentFile", "outputPath", "inputfile", "inputPath", "outputDir", "outputile", " inputPath", "inputPost", "configPost", "inFile", " inputfile", "configFile", "inPath", "inDir", "inputDir", "argumentPath", "argumentPost", "inputile", "configfile", "inile"], "outputFile": ["outDir", " outputDir", "writePlace", "outputPath", " outputFilename", "inputfile", "inputPath", "outputDir", "targetDir", "writeFilename", "writeFile", "outPath", "outputPlace", "outfile", "targetfile", " outputPlace", "targetFile", "outPlace", "outFilename", "outputfile", "outputFilename", "inputDir", "writeDir", "targetPath", "outFile"], "in": ["ins", "din", "inside", "en", "ri", "old", "ir", "ini", "ze", "IN", "sin", "inn", "con", "ai", "inf", "cin", "gin", "on", "bin", "from", "ic", "it", "all", "init", "al", "per", "reader", "ind", "is", "inc", "up", "rin", "i", "input", "iter", "inner", "isin", "info", " din", "min", "read", "In"], "out": ["cn", "ot", "output", "en", "OUT", "co", "v", "dis", "ex", "cache", "con", "user", "net", "io", "ne", "print", "sys", "n", "on", "outs", "it", "by", "writer", "ou", "to", "obj", "res", "aos", "auto", "nt", "cos", "client", "check", "write", "one", "g", "os", "null", "flush", "o", "end", "log", "Out", "at", "outer", "can"], "c": ["k", "f", "z", "u", "cs", "v", "cu", "rc", "cf", "count", "cache", "ec", "nc", "char", "unc", "cc", "con", "arc", "chain", "ac", "C", "cod", "cap", "x", "mc", "gc", "code", "cos", "pc", "ch", "uc", "cp", "current", "i", "r", "cr", "bc", "character", "conf", "l", "cd", "cl", "ct", "t", "ce", "cm", "d", "cb", "lc", "cont", "n"]}}
{"id1": "6421904", "id2": "3767903", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addRecord": ["addDocument", "newRecord", "newrecord", "writeDocument", "writerecord", "Addrecord", "newFile", "addrecord", "addFile", "writeFile", "writeRecord", "newDocument", "AddDocument", "AddFile", "AddRecord"], "input": ["image", "initial", "context", "stream", "p", "data", "format", "Input", "content", "io", "q", "m", "in", "from", "it", "request", "error", "table", "add", "upload", "base", "address", "reader", "this", "open", "current", "out", "is", "up", "get", "source", "config", "start", "media", "w"], "temporary": ["tmemp", "temient", "tempient", "timarily", "comporal", "comperature", "remporal", "comarily", "temppty", "temutable", "timtemp", "tymediate", "timporary", "tenarily", "tytemp", "temptemp", "Temporary", "stemperature", "sememp", "theperature", "tememp", "tempcreated", "temputable", "typor", "comporary", "timmediate", "tmporal", "temtemp", "tenporary", "stporary", "stemporal", "semporal", "tenperature", "stporal", "temperature", "rempty", " temporal", "themediate", "Temperature", "memperature", "temmanent", "tyutable", "tmutable", "semperature", "timutable", "timmanent", "temmediate", "temarily", "remcreated", "typoral", "memporal", "tempperature", "transperature", "tmpor", "stemporary", "stperature", "theporal", "tempty", "tempor", "stemmanent", "tmporary", "transmanent", "tmperature", "transporary", "memporary", "Temporal", "temcreated", "tenporal", "stemp", "tmient", "remporary", "temporal", "theporary", "memutable", "timporal", "temppor", "semporary", " temcreated", "tyient", "typorary", "transporal", "tempporary", "tempporal", "typerature", "timperature", " tempty", "Temutable"], "tempId": ["currentIs", "uniqueK", "poraryPart", "poraryUrl", "stemId", "uniqueUrl", "templateIs", "fakeId", "fakeID", "poraryID", "uniqueIs", "tempK", "fakeRef", "templateId", "stemUrl", "poraryRef", "tempIs", "templateID", "TempUrl", "fakePart", "templateUrl", "TempID", "stemID", "poraryId", "currentK", "templateRef", "tempRef", "templateK", "currentId", "tempID", "uniqueId", "tempUrl", "templatePart", "TempId", "currentUrl", "tempPart"], "length": ["L", "maximum", "readable", "value", "present", "position", "location", "count", "data", "message", "total", "capacity", "SIZE", "description", "string", "content", "path", "sequence", "buffer", "n", "duration", "offset", "text", "volume", "limit", "supported", "load", "size", "loaded", "available", "width", "all", "shape", "ength", "code", "amount", "name", "height", "full", "number", "len", "filename", "l", "json", "version", "type", "default", "time", "padding", "bytes", "end", "Length", "read", "ENGTH"], "digest": ["Digig", "Diger", "identester", " digested", "digig", " diger", " digist", "Digester", "fingerested", "modested", "digist", "Digested", "fingerester", "Digist", "identested", "moder", "mdested", "modEST", "digested", "DigEST", " digEST", "diger", "signester", "modest", "signest", " digester", "Digest", "fingerEST", "identig", "signist", "mdig", "identest", "mdester", "mdest", "signested", "digEST", "digester", "fingerest"], "output": ["image", "you", "object", "stream", "other", "cut", "channel", "data", "message", "web", "net", "io", "outer", "generation", "buffer", "icon", "network", "hidden", "application", "Output", "response", "ou", "four", "to", "that", "ilo", "page", "connection", "console", "auto", "body", "none", "put", "see", "open", "current", "client", "out", "write", "display", "no", "source", "unsigned", "next", "o", "exit", "result"], "file": ["entity", "record", "id", "old", "port", "il", "path", "le", "target", "buffer", "http", "link", "page", "comment", "report", "run", "line", "fp", "h", "get", "null", "url", "log", "info", "local", "module", "f", "same", "value", "relation", "e", "io", "form", "print", "chain", "files", "tree", "entry", "error", "File", "table", "FILE", "upload", "to", "document", "child", "body", "name", "place", "filename", "common", "type", "remote", "temp", "result", "binary", "channel", "class", "data", "message", "format", "user", "real", "valid", "rule", "in", "resource", "single", "dir", "library", "base", "word", "out", "ile", "full", "source", "create", "handle", "image", "action", "work", "block", " File", "al", "this", "db", "stat"], "parent": ["folder", "holder", "p", "port", "ger", "relation", "path", "owner", "Parent", "m", "tree", "block", "rule", "from", "wrapper", "man", "mother", "part", "to", "dir", "shape", "ma", "child", "op", "tmp", "base", "pool", "sp", "per", "name", "this", "line", "out", "source", "g", "null", "ip", "parents", "global", "root", "master"], "now": ["loc", "onew", "dd", "here", "ord", "exp", "NOW", "present", "when", "yes", "sum", "tim", "aj", "then", "diff", "mm", "sw", "set", "amp", "from", "zero", "st", "size", "post", "ready", "day", "recent", "always", "fx", "since", "draw", "before", "mb", "current", "after", "gov", "cmp", "system", "off", "full", "done", "null", "time", "aw", "ow", "omp", "ct", "wait", "date", "Now"]}}
{"id1": "13362846", "id2": "14758866", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setcontenU", "setContensenue", "setContensenu", "setCont\u00ednue", "setContennu", "setcontenux", "setContennux", "setcontenue", "setcontensenU", "setcontensenux", "setContensenU", "setContennU", "setContenue", "setContenux", "setcontensenu", "setContennue", "setContenU", "setCont\u00ednU", "setCont\u00ednux", "setCont\u00ednu", "setcontenu", "setContensenux", "setcontensenue"], "contenuFichier": ["contenuFichtIER", "contenuFamilyichiere", "contenuFachiere", "contenuFigniere", "contenuFochier", "contenuFithorie", "contenuVichyr", "contenuFicheie", "contenuFiverieri", "contenuVechiest", "contenuFamilyichier", "contenuFileichiere", "contenuFrenchire", "contenuMicheer", "contenuFicheorie", "contenuFechiere", "contenuFuffer", "contenuFolfieri", "contenuVichiest", "contenuFuffieri", "contenuFichie", "contenuMichiere", "contenuFicheer", "contenuFrenchaire", "contenuFsechieri", "contenuFsicher", "contenuFamilyachorie", "contenuFignaire", "contenuVechyr", "contenuFiverire", "contenuFicheaire", "contenuFithie", "contenuFithiest", "contenuFechyr", "contenuFsechire", "contenuFochiere", "contenuFichiers", "contenuFchIER", "contenuFsechier", "contenuFuffier", "contenuFolfier", "contenuFochiers", "contenuFsichier", "contenuFCher", "contenuFihier", "contenuFchiere", "contenuMicheiere", "contenuMichier", "contenuVchiere", "contenuFileochiere", "contenuFChiere", "contenuFichIER", "contenuFchier", "contenuFichtie", "contenuFchie", "contenuFsichire", "contenuMichaire", "contenuFileochier", "contenuFileichie", "contenuFsrenchier", "contenuFsichaire", "contenuFichire", "contenuMicheier", "contenuFChaire", "contenuFachier", "contenuFithiere", "contenuFignier", "contenuFachorie", "contenuFechieri", "contenuFechire", "contenuFochie", "contenuFihyr", "contenuFechier", "contenuFicheiers", "contenuFachie", "contenuFechiest", "contenuFichaire", "contenuFamilyachiere", "contenuVichier", "contenuFihiest", "contenuFsrenchieri", "contenuFigner", "contenuFsrenchaire", "contenuFichyr", "contenuFolfire", "contenuFochIER", "contenuMicher", "contenuFichiest", "contenuFolfer", "contenuFsichieri", "contenuFicheiere", "contenuMicheaire", "contenuFileochie", "contenuVchier", "contenuFithier", "contenuFrenchieri", "contenuFamilyachie", "contenuFsrenchire", "contenuFsecher", "contenuFicheire", "contenuFileochiers", "contenuVichiere", "contenuFamilyachier", "contenuFichtier", "contenuFithyr", "contenuFiverier", "contenuFicher", "contenuVchIER", "contenuVechier", "contenuFicheieri", "contenuVechiere", "contenuFichorie", "contenuVichie", "contenuFihiere", "contenuFileichier", "contenuFichtiere", "contenuVchie", "contenuFamilyichie", "contenuFachiers", "contenuFrenchier", "contenuFChier", "contenuFicheier", "contenuFecher", "contenuVichIER", "contenuFiveraire", "contenuFichieri", "contenuFichiere", "contenuFuffire", "contenuFileichiers", "contenuFamilyichorie"], "fichierElectronique": ["fichierAdministroniques", "fichierAdministroniq", "fichierTransferradorie", "fichierTransferradoric", "fichierElectromie", "fichierElectroneoch", "fichierElectradorie", "fichierElectrenaire", "fichierCentronius", "fichierelectrenier", "fichierelectronique", "fichierElectronicy", "fichierElectrenius", "fichierElectrenier", "fichierElectrontipolar", "fichierElectRONius", "fichierElectradorius", "fichierElectronipolar", "fichierelectronier", "fichierElectchronoch", "fichierAdministronique", "fichierelectroniques", "fichierElectronsiq", "fichierElectromius", "fichierElectronic", "fichierElectradorique", "fichierElectronsiques", "fichierElectronaire", "fichierElectroneic", "fichierElectronticity", "fichierElectroneius", "fichierElectroneiques", "fichierElectchronique", "fichierElectroneipolar", "fichierSelectroneique", "fichierCentronique", "fichierElectronicity", "fichierTransferradorius", "fichierAdministroneiq", "fichierElectonique", "fichierElectonier", "fichierElectroneie", "fichierElectreniques", "fichierSelectronicity", "fichierTransferronius", "fichierElectroneique", "fichierElectromique", "fichierElectroneiq", "fichierElectriciq", "fichierAdministroneie", "fichierElectronier", "fichierElectronsique", "fichierElectRONicy", "fichierElectroneaire", "fichierElectronie", "fichierAdministroneique", "fichierElectronsier", "fichierElectrenicy", "fichierElectromicity", "fichierelectrenic", "fichierSelectroneicity", "fichierElectroniq", "fichierElectromaire", "fichierSelectronoch", "fichierElectchroniques", "fichierElectoniques", "fichierTransferronie", "fichierCentRONicy", "fichierElectrenic", "fichierSelectronique", "fichierElectroniques", "fichierTransferradorique", "fichierelectrenique", "fichierElectronsie", "fichierElectrontique", "fichierSelectroneiques", "fichierElectricique", "fichierElectronoch", "fichierElectronius", "fichierElectradoric", "fichierAdministroneiques", "fichierElectrontaire", "fichierSelectroniques", "fichierElectRONique", "fichierAdministronie", "fichierElectroneicity", "fichierelectreniques", "fichierElectchronius", "fichierElectricie", "fichierCentRONaire", "fichierElectRONaire", "fichierElectrenique", "fichierCentRONius", "fichierElectromipolar", "fichierElectronsicity", "fichierCentronaire", "fichierTransferronique", "fichierElectchronicy", "fichierElectronsic", "fichierSelectroneoch", "fichierElectromic", "fichierElectchronaire", "fichierCentronicy", "fichierElectronsoch", "fichierElectchronicity", "fichierTransferronic", "fichierElectonic", "fichierelectronic", "fichierElectriciques", "fichierCentRONique"], "utilisateurCourant": ["utilisateurRepresentant", "utilisateurRepresentante", "utilisateursCourant", "utilisateursGovernante", "utilisateurGovernants", "utilisateursGoverniant", "utilisateurGovernant", "utilisateurCourante", "utilisateurRepresentants", "utilisateursGovernant", "utilisateurCourants", "utilisateursCourante", "utilisateursGovernants", "utilisateurParticipante", "utilisateursCourants", "utilisateurRepresentiant", "utilisateurParticipiant", "utilisateurParticipants", "utilisateurCouriant", "utilisateursCouriant", "utilisateurParticipant", "utilisateurGovernante", "utilisateurGoverniant"], "support": ["context", "cover", "access", "know", "supp", "port", "language", "profile", "format", "feature", "please", "allow", "service", "proof", "pport", "collection", "supported", "Support", "control", "replace", "storage", "install", "cap", "prototype", "document", " Support", "share", "force", "library", "see", "SUP", "system", "trust", "help", "null", "evidence", "success", "accept", "media", "use", "history"], "ficheDocument": ["ficheMatrix", "fitimeMatrix", "facheTree", "FicheDoc", "frenchDoc", "fayeDatabase", "fcheDocument", " frenchDescription", " frenchDatabase", "fayeDoc", "fachedocument", "flicheMatrix", "hicheTransaction", "facheTransaction", "fruitTransaction", "FicheDatabase", "fiqueDescription", "facheDoc", "fruitDocument", "fliciDatabase", "foyerTree", " frenchDocument", "fifaDocuments", "bacheDatabase", "frenchTransaction", "fcheDoc", "fcheDatabase", "facheDocument", "fliciMatrix", "fichedocument", "FayeDocument", "hacheDocument", "hicheDocument", "ficheDescription", "bicheDatabase", "FayeDoc", "ficheDocuments", "facheDatabase", "foyerDoc", "fitimeDocument", "fifaDatabase", "flicheDatabase", "ficheTree", "FicheDocument", "FayeDatabase", "bicheTree", "fiqueDatabase", "ficidocument", "ficheTransaction", "fiqueDocument", "ficiDocument", "foyerDatabase", "ficiJournal", "ficiDatabase", "hichedocument", "fitimeTransaction", "FayeDocuments", "bacheTree", "fifaDocument", "hicheJournal", "fitimeDescription", "bacheDoc", "hacheTransaction", "fayeDocument", "ficiTransaction", "ficheJournal", "bicheDocument", "ficheDoc", "fitimeDatabase", " ficheDescription", "foyerDocument", "flicheTransaction", "fruitJournal", "flicheDocument", "frenchDescription", "facheJournal", "fruitdocument", "hacheJournal", "frenchDocuments", "bicheDoc", "fliciTransaction", "frenchDocument", "fliciDocument", "bacheDocument", "ficheDatabase", " ficheDatabase", "fcheTree", "frenchMatrix", "fayeDocuments", "frenchDatabase", "ficiMatrix", "fifaDoc", "hachedocument", "FicheDocuments"], "nomFichier": ["nomNolfiere", "nomUFachIER", "nomUFachery", "nomPachier", "nomPichier", "nomFilicER", "nomFolfire", "nomPFichiller", "nomPacherer", "nomFicheer", "nomFihier", "nomFicheiner", "nomFiverIER", "nomFilicier", "nomPFoilER", "nomFericanger", "nomFchire", "nomFichiller", "nomFachie", "nomFolfiere", "nomFchomer", "nomFachire", "nomFichoier", "nomUFichier", "nomFichancer", "nomPFoiljer", "nomUFichire", "nomFchiere", "nomFicheiere", "nomPichire", "nomFicheire", "nomUFachier", "nomFacher", "nomFchier", "nomFicher", "nomUFichIER", "nomPFoilier", "nomFihire", "nomFiverire", "nomFolfier", "nomFachanger", "nomFichoancer", "nomUFichery", "nomNichie", "nomFicier", "nomPFoililler", "nomFichanger", "nomFachery", "nomFicerer", "nomFoiljer", "nomPichomer", "nomFachiere", "nomFachancer", "nomPicherer", "nomPachomer", "nomNichier", "nomFichery", "nomPFichER", "nomPFichjer", "nomFicomer", "nomFoililler", "nomNichire", "nomFilicjer", "nomFichiere", "nomFichjer", "nomPFichier", "nomFachiner", "nomFolfie", "nomFachomer", "nomFchiner", "nomFacherer", "nomFihery", "nomUFachire", "nomFcherer", "nomFoilier", "nomFericIER", "nomFiverier", "nomFericancer", "nomFicherer", "nomNolfie", "nomFoilER", "nomNichiere", "nomFichomer", "nomFicire", "nomFicjer", "nomFachier", "nomFichiner", "nomNolfier", "nomFichIER", "nomFichoanger", "nomFicER", "nomFiverery", "nomFericier", "nomFachIER", "nomFichER", "nomFihIER", "nomFiliciller", "nomFiciller", "nomFichoIER", "nomFichire", "nomNolfire", "nomFichie", "nomFcher", "nomPachire", "nomFicheie", "nomFicheier"], "extension": ["protension", "expractor", "Extension", "xtensions", "strension", "xtending", "contention", "protractor", "xtension", "expention", "extention", "extitude", "strensions", "strending", "expension", "Extensions", "Extending", "extractor", "contension", "protention", "contitude", "expitude", "extending", "protitude", "extensions", "contractor"], "fichierElectroniqueExistant": ["fichierElectroniqueExistent", "fichierElectroniquePersister", "fichierElectroniqueAssistant", "fichierElectronogramLocalistent", "fichierElectroniquePersistant", "fichierElectronicityExert", "fichierElectronogramExistant", "fichierElectroniqueExiker", "fichierElectroniquePlusister", "fichierElectronogramExistance", "fichierElectroniqueAssclusive", "fichierElectronicityInert", "fichierElectroniqueExert", "fichierElectronogueExistent", "fichierElectroniqueLocalistent", "fichierElectroniqueExplert", "fichierElectronogramExclusive", "fichierElectroniqueExvant", "fichierElectroniqueLocalistant", "fichierElectroniqueLocalistance", "fichierElectroniquePlusistent", "fichierElectronogueExiker", "fichierElectroniqueInistance", "fichierElectronogueExister", "fichierElectroniqueInert", "fichierElectroniqueExplvant", "fichierElectroniqueInvant", "fichierElectroniquePlusistant", "fichierElectroniquePresentistent", "fichierElectroniqueEXvant", "fichierElectroniqueInistent", "fichierElectroniquePersiker", "fichierElectroniqueExclusive", "fichierElectroniquePersistent", "fichierElectronogramLocalistance", "fichierElectroniqueExister", "fichierElectronicityExvant", "fichierElectroniqueAssistent", "fichierElectronogueExistant", "fichierElectroniqueExplistant", "fichierElectronicityExistant", "fichierElectronogramLocalclusive", "fichierElectroniqueInistant", "fichierElectroniqueInclusive", "fichierElectroniquePresentiker", "fichierElectronicityInistant", "fichierElectroniquePresentistant", "fichierElectronicityInistance", "fichierElectroniqueExplistance", "fichierElectronoguePersistent", "fichierElectroniquePlusiker", "fichierElectroniqueExistance", "fichierElectroniqueEXistant", "fichierElectroniqueAssistance", "fichierElectroniqueEXert", "fichierElectronoguePersistant", "fichierElectronicityExistance", "fichierElectronicityInvant", "fichierElectronogramExistent", "fichierElectronoguePersister", "fichierElectroniqueEXistance", "fichierElectroniqueLocalclusive", "fichierElectronoguePersiker", "fichierElectronogramLocalistant", "fichierElectroniquePresentister"], "idIgid": ["idIgdido", "idIgids", "idIigmaddress", "idIgcido", "idIgcoid", "idIvgkey", "idIIgzido", "idIigmid", "idIigmlimit", "idAgid", "idIgaddress", "idIgzida", "idImglimit", "idAgaddress", "idIegdata", "idIvgdata", "idIvgids", "idIkgis", "idAmgis", "idIegid", "idIgcid", "idImgis", "idIIgido", "idIegkey", "idAmgid", "idImgaddress", "idImgdata", "idIkgaddress", "idIgis", "idIIgid", "idIIgzida", "idIIgida", "idIgoid", "idImgkey", "idIgcida", "idIgzoid", "idAglimit", "idAmgaddress", "idIkglimit", "idIgzid", "idImgids", "idIigmis", "idIgida", "idIgdida", "idIgdid", "idIkgid", "idImgid", "idIvgid", "idIgzido", "idIgkey", "idAgis", "idIgdata", "idIIgzoid", "idIglimit", "idAmglimit", "idIIgzid", "idIgdoid", "idIIgoid", "idIgido", "idIegids"], "inputStream": [" inputThread", "InputTime", "InputThread", "imageSteam", "helloStreamer", "outputThread", "InputSteam", "inputThread", "outputstream", " inputSteam", " inputstream", "inputStreamer", " inputLoop", "inputstream", "inputSteam", "helloStream", "imageTime", "Inputstream", "inputChannel", "outputChannel", "imageLoop", "inputLoop", "InputStream", "helloSteam", "helloChannel", "imageStream", "outputSteam", "InputLoop", " inputChannel", " inputStreamer", "outputStreamer", "inputTime", " inputTime"], "outputStream": [" outputSteam", "inputView", "webView", "sequenceStream", " outputStyle", "outputStyle", "sequenceStreamer", "inputForm", "OutputStyle", "sequenceSteam", "sequenceStyle", "OutputStream", "inputSteam", "webStream", "OutputView", " outputView", "webStreamer", "OutputSteam", "OutputForm", " outputStreamer", "writeView", "writeForm", "writeStream", "outputSteam", "outputForm", "outputView", "webSteam", "OutputStreamer", "outputStreamer", "writeSteam"], "typeMime": ["TypeMIME", "typemime", "typeSmime", "Typemme", "typeRme", "typeMme", "typeRIME", "Typemim", "typeSmIME", "TypeMime", "TypeMme", "Typemime", "typeRime", "TypeMim", "typeSmme", "typeRim", "typeMim", "typemim", "TypemIME", "typemme", "typeSmim", "typeMIME", "typemIME"], "tailleFichier": [" tailleficheie", " tailleFixies", " tailleFuzziers", " taillefichie", " tailleFixiers", " tailleFuzzie", " tailleficheier", " tailleFicheier", " tailleficheiers", " taillefichies", " tailleFixie", " tailleFuzzies", " tailleficheies", " tailleFicheies", " tailleFicheiers", " tailleFichie", " tailleFuzzier", " tailleFichies", " tailleFicheie", " taillefichier", " tailleFixier", " tailleFichiers", " taillefichiers"]}}
{"id1": "5441579", "id2": "5998352", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"createPseudoUUID": ["createPseudoUuid", "createPseudoRandomUID", "createPseudoUID", "createPseanRandomID", "createPseudoUniqueuid", "createPseanUID", "createPseudoUniqueID", "createPseudoRandomId", "createPseanRandomUID", "createPseudoUUUID", "createPseanUId", "createPseudoUId", "createPseudoUUId", "createPseudoRandomID", "createPseanUUID", "createPseudoRandomuid", "createPseudoUniqueId", "createPseanRandomuid", "createPseudoUniqueUID", "createPseanUuid", "createPseudoUUuid", "createPseanRandomId"], "messageDigest": [" messageDiger", "messageDrise", "messageDesignist", "messageDriest", "messageDigests", "messageDigested", " messageDigment", "messageMacest", " messageDesignest", "numberDesignests", "messageDist", " messageDesignester", "messageMacse", "messageDests", "messageDesignest", "messagedigist", "numberDesignist", "numberDesignest", " messageDigested", "messageDesignests", "numberDigest", "messageHasests", "messagedigse", " messageDigifier", " messageDigester", "messagediger", "messageLocest", " messageDesignist", "numberDesignester", "messageDest", "messageHasest", "messageHasist", " messagedigest", "messagedigested", "messageLocment", " messagedigifier", "messageDesignse", "messageDigester", "messagedigest", "messageDiger", " messageDigse", "messageDigment", "messageDriist", "numberDigests", "messageDigse", "messageLocse", "messageMacested", " messageDesignse", "messageDesignester", " messagedigment", "messageMacer", "messageDester", " messageDigist", "messagedigifier", "messagedigester", "messageDigifier", "numberDigester", "numberDigist", "messagedigment", "messageDriester", " messagedigse", "messageLocifier", "messageDigist", "messageHasester"], "localHost": ["Localhost", "localServer", "LocalServer", "localAddress", "localhost", "LocalHost", "remoteHost", "remoteAddress", "localPort", "localhosthost", "LocalPort", " localPort", "localhostHost", " localAddress", " localhost", " localServer", "localhostPort", "remotehost", "remotePort", "LocalAddress", "localhostServer"], "digestBytes": ["digestedBs", "Diggestbytes", " digestKeys", "DigestParts", "diggeAttributes", " digestedbytes", "digestBs", "mixestedbytes", "DigestServices", "digestedParts", "mixestAttributes", "digestServices", " digestResults", "digesterBs", "digESTBytes", "mixestArgs", "digestParts", "digestExamples", "mixestedArgs", "digetParts", " digestedBytes", "digesterResults", "mixestedServices", "digistanceKeys", "digesterValues", " digestArgs", "Digestbytes", "diggestExamples", "digestValues", "digestedResults", "diggestbytes", "digESTArgs", "digstBytes", "digestArgs", "digesterArgs", " digestValues", "digestAttributes", "digstParts", "diggestBytes", "digistanceBytes", "DiggestBytes", "digESTLinks", "diggeParts", "digesterLinks", "diggeBytes", "digetbytes", "digstServices", "digesterbytes", "digesterParts", "digestKeys", "diggeServices", "digetBytes", "mixestedBytes", "digestbytes", "digstAttributes", " digestedValues", "mixestedAttributes", "mixestbytes", "digestedServices", "digesterBytes", "DigestBytes", "digistanceExamples", "diggestParts", "mixestedParts", "digestedbytes", "drivenestBytes", "digestedArgs", "digESTValues", "digestedAttributes", "digestedLinks", "drivenesterValues", "drivenestBs", "diggestServices", "digESTbytes", "mixestedLinks", "digestedValues", " digestExamples", "mixestLinks", "DiggestServices", "digestResults", "mixestServices", "drivenestParts", "diggestKeys", "digestLinks", "drivenesterBs", " digestbytes", "digestedBytes", " digestParts", "mixestBytes", "digetServices", "DiggestParts", "mixestParts", "drivenestValues", "drivenesterParts", "drivenesterBytes"], "sb": ["sth", "sl", "ssl", "sh", "abb", "b", "bs", "shell", "bf", "bn", "SB", "jp", "ib", "sd", "bp", "sn", "obb", "nb", "src", "sw", "esm", "gob", "rob", "sf", "bps", "fb", "ibl", "bis", "tn", "sv", "bh", "storage", "stab", "bg", "wb", "pg", "sam", "gc", "eb", "sp", "bt", "erb", "lp", "gb", "bj", "bash", "lb", "ctrl", "kb", "db", "zb", "pb", "ub", "rb", "sg", "bb", "sbm", "cb", "sa"]}}
{"id1": "21425787", "id2": "8801436", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", "transferFile", " copyByte", "CopyByte", "transferByte", " copyFiles", "CopyFiles", "copyByte", "CopyFile", "copyFiles", "Copyfile", " copyfile", "transferFiles", "transferfile"], "in": ["ins", "din", "el", "en", "b", "old", "IN", "inn", "inf", "cin", "gin", "on", "from", "ar", "ic", "it", "vin", "ie", "ind", "is", "inc", "up", "rin", "i", "input", "source", "l", "o", "isin", "In", "n"], "out": ["ot", "output", "OUT", "b", "v", "p", "ex", "gt", "ent", "s", "net", "ne", "io", "str", "err", "outs", "it", "c", "ou", "to", "po", "nt", "i", "source", "oss", "g", "help", "os", "null", "l", "t", "o", "Out", "at", "w", "n"], "sourceChannel": ["startMachine", "sourceManager", "systemMachine", " sourceClass", "inputChan", " sourceCommand", "srcCh", "ourceChan", "seedMachine", "inputCh", "systemPanel", "sourceConnection", " sourceManager", "systemChannel", "sourceCategory", "sourceCommand", "srcManager", "ourceConnection", " sourceConnection", "startPanel", "srcClass", "sourceMachine", "ourceClass", "srcChannel", " sourceCh", "srcCommand", "srcChan", "srcConnection", " sourceChan", "ourceChannel", "sourceClass", "sourceChan", "inputChannel", "seedCategory", "ourceManager", "sourceCh", "startChannel", "startCategory", "seedPanel", "seedChannel", "ourceCommand", "inputConnection", "systemCategory", "sourcePanel"], "destinationChannel": ["destinoChannel", "destinochannel", "Destinationchannel", "destationChan", "DestationChan", "destationChannel", "DestinationChan", "destinationConnection", "destinationContext", "DestinationChannel", "destinationschannel", "destinationchannel", "destensionChannel", "destensionchannel", "destinatorHandler", "DestinationConnection", "destensionChan", "DestationHandler", "DestinationHandler", "destinationHandler", "destationContext", "destinoContext", "restinationChan", "destinatedContext", "destinatedChannel", "destinoChan", "destinatedchannel", "destinatorchannel", "destinatorChan", "destationConnection", "DestensionConnection", "restinationchannel", "destinationsChan", "restinoChan", "destationchannel", "DestensionChan", "destinationsConnection", "DestationChannel", "restinoChannel", "destinationsChannel", "restinationContext", "restinationChannel", "restinoContext", "destinatorChannel", "destationHandler", "DestensionChannel", "destensionConnection", "destinatedChan", "Destensionchannel", "restinochannel", "destinationChan", "Destationchannel"]}}
{"id1": "21979462", "id2": "6890417", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURL2JSON", " downloadURLoString", " downloadurloText", " downloadURL2String", " downloadURL2Bytes", " downloadURL2Text", " downloadurltoJSON", " downloadURLToString", " downloadURLToText", " downloadURLToJSON", " downloadURLoJSON", " downloadurloJSON", " downloadurltoText", " downloadURLtoJSON", " downloadurloBytes", " downloadurloString", " downloadURLtoText", " downloadURLoBytes", " downloadurltoBytes", " downloadurltoString", " downloadURLoText", " downloadURLToBytes", " downloadURLtoBytes"], "url": ["sl", "ssl", "domain", "gl", "id", "location", "ls", "dl", "char", "bel", "web", "ref", "un", "rect", "ll", "ret", "resource", "http", "ul", "link", "all", "ur", "browser", "URL", "file", "run", "uu", "base", "address", "name", "mount", "mail", "uri", "Url", "l", "log", "job"], "in": ["ins", "din", "copy", "again", "sum", "IN", "er", "inn", "con", "ai", "io", "inf", "cin", "gin", "on", "bin", "from", "ic", "it", "or", "by", "re", "and", "all", "thin", "mc", "mn", "al", "ma", "reader", "ind", "is", "inc", "check", "out", "up", "i", "input", "inner", "oin", "conf", "ill", "isin", "info", "read", "In"], "sb": ["ssl", "b", "bs", "bf", "bn", "SB", "ib", "sd", "bp", "nb", "rob", "gob", "sq", "sf", "ab", "bis", "bh", "bg", "xb", "wb", "sam", "gc", "eb", "sp", "bt", "erb", "lp", "gb", "bj", "mb", "pa", "sk", "lb", "kb", "db", "zb", "bsp", "pb", "bd", "ub", "rb", "sg", "bb", "cb", "sa"], "str": ["div", "arr", "del", "expr", "sl", "dr", "bl", "exec", "b", "gr", "p", "sts", "ls", "STR", "dat", "char", "list", "Str", "string", "s", "chain", "print", "err", "m", "pt", "st", "block", "set", "text", "part", "re", "vol", "comm", "j", "fr", "comment", "req", "obj", "sp", "msg", "ch", "tr", "def", "comp", "txt", "br", "i", "r", "cur", "bc", "syn", "source", "l", "iter", "cat", "t", "next", "cont", "n"]}}
{"id1": "20623709", "id2": "335223", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"split": ["copy", "scan", "scale", "count", "transfer", "format", "disk", "sync", "process", "part", "join", "map", "upload", "share", "batch", "Split", "seek", "slice", "unit", "open", "lock", "append", "write", "parse", "align", "use", "read"], "targetDirectory": ["baseDirectory", " targetdirectory", "testDirect", "baseDir", "baseFile", "TargetDirectory", "TargetFolder", " targetLocation", "localdirectory", "TargetLocation", "targetMemory", "localDir", " targetFolder", " targetDir", "testDir", "targetdirectory", "targetLocation", "targetDir", "baseDirect", "baseMemory", "Targetdirectory", "baseFolder", "targetFile", " targetMemory", "testLocation", " targetFile", "localFile", "TargetDirect", "testDirectory", "TargetDir", "targetDirect", " targetDirect", "localDirectory", "targetFolder", "TargetMemory", "basedirectory"], "prefix": ["fixed", "pres", "p", "ix", "pattern", "format", "localhost", "path", "pre", "zero", "pkg", "Pref", "status", "size", "alias", "key", "tag", "FIX", " suffix", "base", "directory", "fixes", "name", "this", "fix", "template", "title", "username", "filename", "uri", "version", "type", "padding", "division", "root", "password", "command", "index", "PRE", "pi"], "maxUnitBases": ["maxUnityAliades", "maxUnityLicas", "maxUnityLounds", "maxUnityBounds", "maxUnityLases", "maxUnitReplases", "maxUnitChases", "maxUnitReplounds", "maxUnitChias", "maxUnityBases", "maxUnityAliias", "maxUnitBounds", "maxUnitChounds", "maxUnitBades", "maxUnitbades", "maxUnitBicas", "maxUnitReplicas", "maxUnitbias", "maxUnityAliases", "maxUnitLages", "maxUnityBages", "maxUnitReplages", "maxUnitLases", "maxUnitAliases", "maxUnitChades", "maxUnitChages", "maxUnitLicas", "maxUnityBicas", "maxUnitAliias", "maxUnitbounds", "maxUnitAliounds", "maxUnitLounds", "maxUnitChicas", "maxUnityLages", "maxUnitBias", "maxUnityBades", "maxUnitbases", "maxUnitAliades", "maxUnityAliounds", "maxUnitBages", "maxUnityBias"], "maxUnitEntries": ["maxUnityEntries", "maxUnitEntryries", "maxUnitErires", "maxUnitentries", "maxUnitEntryrys", "maxUnitIntegriers", "maxUnityentries", "maxUnitErrys", "maxUnitIntegires", "maxUnitIntegrys", "maxUnitentrs", "maxUnitEntryires", "maxUnityEntrys", "maxUnitEntryriers", "maxUnityentrys", "maxUnityEntires", "maxunitEntries", "maxunitEntrs", "maxUnityentrs", "maxunitEntires", "maxUnityentires", "maxUnitEntrys", "maxUnitentires", "maxUnitEntriers", "maxunitEntrys", "maxUnitEntires", "maxUnitEntrs", "maxUnityEntrs", "maxUnitErrs", "maxUnitIntegries", "maxUnitentrys", "maxUnitErries"], "fis": [" fi", " fii", "Fis", " fiss", "fiss", "vic", "fic", "ifci", "ifii", "fii", "ifis", " fic", "Fic", "vis", "fi", "Fci", "viss", "vi", "Fiss", "Fi", "Fii", "ific"], "fci": ["tcu", "cfai", "mii", "Fini", "tco", "Fco", " fii", "cfini", "Fis", "cfco", "cfic", "cfis", "cfico", " fai", "tii", "fic", "mci", " fcu", "tci", "fcu", "cfci", "fii", "mco", "fico", " fic", "Fic", "mcu", "fai", "Fci", "Fico", "fini", " fico", " fini", "Fai"], "fos": ["yaos", "wos", "foss", " faos", "floss", "Foss", "yios", "Faos", "wios", "ybos", " foss", "fbos", "wbos", "flaos", "FOS", "yos", "flos", "fOS", "faos", "waos", "Fos", "flOS", " fios", " fOS", "fios", " fbos"], "fco": ["pco", "Foco", "pci", "Fco", " fcos", "tco", "Fcon", " fdo", "cdo", "tcos", " fso", "pcos", "fso", "Fso", "cso", "toco", "pso", "Fcos", "fcos", "Fdo", " fcon", "ccon", "tdo", "fcon", "Fci", "cco", "fdo", " foco", "foco"], "buffer": ["length", "callback", "record", "binary", "holder", "position", "match", "cache", "channel", "data", "message", "window", "char", "buf", "order", "queue", "sequence", "stack", "database", "phrase", "block", "print", "entry", "button", "timeout", "limit", "table", "black", "bridge", "note", "comment", "document", "function", "batch", "library", "address", "event", "append", "template", "memory", "source", "iter", "reset", "row", "Buffer", "flush", "padding", "buff", "filter", "sample", "pause", "command", "index", "temp", "read", "result", "complete"], "currentBasesCount": ["currentBasedCount", "currentBasedCode", "currentbasesCount", "currentBasedLength", "currentBadesLength", "currentbasesLength", "currentbaseCount", "currentbasesCode", "currentBadesCode", "currentBaseCode", "currentBaseLength", "currentbaseCode", "currentbaseLength", "currentBaseCount", "currentBasesLength", "currentBadesCount", "currentBasesCode"], "currentEntriesCount": ["currentEntrsCount", "currentEntrysCount", "currentEntriesCode", "currentEntriesFlag", "currentEntiesFlag", "currentEntiesCount", "currentEntiesCode", "currentEntrysCode", "currentEntrsCode", "currentEntrysFlag", "currentEntrsFlag"], "targetCount": ["argetCount", " targetAmount", " targetInfo", "targetNum", "argetInfo", "TargetInfo", "TargetCount", "argetNum", "TargetAmount", "TargetNum", "argetAmount", " targetNum", "targetInfo", "targetAmount"], "fastaChannel": ["fastityChan", "fastpaButton", "fastoChan", " fastaQueue", "fastoProvider", "fastaiQueue", "fastityQueue", "fastoChannel", "fastityStream", " fastaButton", "fastoConnection", "fastoQueue", " fastaChan", "fastaProvider", "fastpaConnection", "fastityChannel", "fastaButton", " fastaProvider", " fastaStream", "fastaConnection", "fastaQueue", " fastoStream", "fastaStream", "fastaiStream", "fastaiChannel", "fastaiChan", "fastpaChannel", "fastoStream", "fastaChan", "fastpaProvider", "fastoButton", " fastoQueue", " fastoChan", " fastaConnection", " fastoChannel"], "totalSeqCount": ["totalSegCounter", "totalSeQCount", "totalSeqsSize", "totalSeQCounter", "totalSeqsCounter", "totalSeqsCode", "totalSeQCode", "totalSeqCode", "totalSegSize", "totalSegCount", "totalSegCode", "totalSeqSize", "totalSeqCounter", "totalSeQSize", "totalSeqsCount"], "totalResiduesCount": ["totalResiduationsCode", "totalResIdueCount", "totalResidusCount", "totalResIduesCode", "totalResidusCode", "totalResiduesFlag", "totalResIduesCount", "totalResIduesFlag", "totalResidueCount", "totalResiduationsCount", "totalResidueCode", "totalResidueFlag", "totalResIdueFlag", "totalResiduationsFlag", "totalResIdueCode", "totalResidusFlag", "totalResiduesCode"], "prevTime": ["parThread", "parTime", " previousThread", "parT", " prevThread", " previousT", " prevT", " previousTime", "prevThread", "prevT"], "fastaFileSize": ["fastaFilesLength", "fastaReaderLength", "fastATableLength", "fastaFileName", "fastaTableSize", "fastoFileLength", "fastATableName", "fastaFilesHeight", "fastATableHeight", "fastAFileHeight", "fastoFileSIZE", "fastATableSize", "fastaChainSIZE", "fastoTableSize", "fastaFileLength", "fastaFilesName", "fastaChainLength", "fastaTableHeight", "fastafileSize", "fastoTableOwner", "fastAFileLength", "fastafileSIZE", "fastoTableSIZE", "fastAFileSize", "fastaReaderName", "fastaFileOwner", "fastaReaderHeight", "fastaTableOwner", "fastaChainOwner", "fastaReaderSize", "fastaFilesSize", "fastoTableLength", "fastoFileSize", "fastaTableName", "fastaFileHeight", "fastaTableLength", "fastafileOwner", "fastaChainSize", "fastAFileName", "fastafileLength", "fastaFileSIZE", "fastaTableSIZE", "fastoFileOwner"], "fastaFileReadOffset": ["fastaFilesLoadLength", "fastaFilereadOrder", "fastaFilereadOffset", "fastaPageReadOffset", "fastaFileInputLocation", "fastaFileInputPosition", "fastaPageReadOrder", "fastaFileWriteOffset", "fastaFileWriteAmount", "fastaChainReadPosition", "fastaFilesReadLength", "fastaFileReaderoffset", "fastaFileReadLocation", "fastaFilesReadAmount", "fastaFileViewAmount", "fastaFileReadOrder", "fastaFilereadAmount", "fastaFileCurrentoffset", "fastaFileInputAmount", "fastaFileCurrentLocation", "fastaFileViewPos", "fastaPageLoadPos", "fastaFileReadLength", "fastaFileCurrentPosition", "fastaFileInputoffset", "fastaFilesLoadOffset", "fastaPageLoadOffset", "fastaChainReadOffset", "fastaFileReadAmount", "fastaFileWriteOrder", "fastaChainReadoffset", "fastaFilesReadOffset", "fastaChainCurrentOffset", "fastaFilesLoadAmount", "fastaFilesLoadOrder", "fastaPageReadPos", "fastaChainCurrentoffset", "fastaFileCurrentOffset", "fastaChainCurrentLocation", "fastaFileReadPos", "fastaFileInputOrder", "fastaFileLoadLength", "fastaFileViewOrder", "fastaFileReaderPosition", "fastaPageLoadAmount", "fastaChainReadLocation", "fastaFileLoadOrder", "fastaFileWriteLength", "fastaFileLoadOffset", "fastaPageReadAmount", "fastaFileReaderOffset", "fastaFileLoadAmount", "fastaFileLoadPos", "fastaFileInputLength", "fastaFileInputOffset", "fastaFileReadoffset", "fastaFileViewOffset", "fastaFilesReadOrder", "fastaFileReaderLocation", "fastaFileReadPosition", "fastaPageLoadOrder", "fastaChainCurrentPosition", "fastaFilereadPos"], "partitionStartOffset": ["partitionEndOff", "partitionStartPoint", "partitonStartingPosition", "partitionEndPosition", "partitonStartOff", "partitionDataPoint", "partitonStartOffset", "partitionStartPosition", "partitonStartingOff", "partitionStartingPoint", "partitionDataOff", "partitionDataPosition", "partitionStartOff", "partitionStartingOff", "partitionStartingPosition", "partitionEndPoint", "partitionDataOffset", "partitonStartingOffset", "partitionStartingOffset", "partitonStartPoint", "partitonStartPosition", "partitonStartingPoint"], "bufferSize": ["bufLength", "tableSIZE", "tableName", " bufferCode", "buffLength", "bufSIZE", "bufferSIZE", "sequenceSize", "bufferName", "tableSize", "buffSIZE", "sequenceLength", "buffName", " bufferSIZE", " bufferLength", "sequenceSIZE", "bufferCode", "BufferSIZE", "buffSize", "bufferLength", "bufCode", "BufferName", "sequenceCode", "BufferLength", "BufferSize", "tableLength", "bufSize"], "fastaBuffer": ["fastmaBuffer", "fastoStore", "wildanBuff", "fastmaBuilder", "fastmaStore", "fastoCounter", " fastoCounter", "fasteBuffer", "fastcaRequest", "FastaBuffer", "fastasBuilder", "FastmaBuffer", "fasteMemory", "fastoRequest", "fastasQueue", "fastasRequest", " fastaDB", " fastaBuilder", "fastasStore", "fastalCounter", "fastalBuff", "wildanCache", "fastasCache", "fastoBuff", "fastmaCache", "FastmaRequest", "fastuMemory", "fastalBuffer", "fastaMemory", "fastaCache", "fastaBuff", "fastaBuilder", "FastmaBuff", "fastasBuff", "wildaBuff", " fastoQueue", "wildaBuffer", "fastanCache", "fasteDB", "fastoBuffer", "FastaRequest", "fastsaBuff", " fastoBuffer", "fastcaBuffer", "fastcaCache", "fastasBuffer", "FastaBuff", "fastanBuffer", "fastmaBuff", "FastmaStore", " fastaCache", "fastalQueue", "wildanBuffer", "fastsaBuffer", " fastaCounter", "fastcaBuff", "fastaDB", "fastmaRequest", "fastaRequest", "fastuDB", "fastmaQueue", "fastasCounter", "wildanRequest", "fastanBuff", "fastanRequest", "wildaRequest", "wildaCache", "fastsaQueue", "FastaStore", "fastmaChannel", " fastaQueue", "fastaCounter", " fastaBuff", "fastoQueue", "fasteBuff", " fastaMemory", "fastaStore", "fastsaChannel", "fastaQueue", "fastuBuffer", " fastoBuff", "fastuBuff"], "fastaReadState": ["fastoReaderSTATE", "fastoReadStatus", "fastoReadSTATE", "fastaLoadType", "fastoReaderStatus", "fastaLoadStatus", "fastaLoadSTATE", "fastaReadSTATE", "fastaReaderType", "fastaCurrentStatus", "fastoReaderType", "fastoReadType", "fastaReadStatus", "fastaCurrentSTATE", "fastaReadType", "fastoReaderState", "fastaReaderState", "fastaCurrentType", "fastaReaderStatus", "fastaLoadState", "fastaCurrentState", "fastaReaderSTATE", "fastoReadState"], "nBytes": ["numNs", " nbytes", " nItems", "NItems", "nNs", "nsbytes", "NParts", "nBlocks", "nbytes", "nrBytes", "noBlocks", "NKeys", "NBytes", " nParts", "nItems", "nrItems", "numBlocks", "Nbytes", " nNs", "nrKeys", " nBlocks", "noNs", "nParts", "nKeys", " nWords", "noBytes", "numBytes", "numbytes", "nWords", "NWords", "nsBytes", "nrbytes", " nKeys", "nsWords", "nsParts", "nobytes"]}}
{"id1": "732800", "id2": "22801734", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createInputstream", " createOutSteam", " createInputstream", "createInputStream", "createOutputFile", " createFilestream", " createFileFile", " createInputFile", " createOutputFile", " createInputStream", " createFileSteam", " createOutputstream", " createOutstream", " createOutputSteam", "createInputFile", " createFileStream", " createOutStream", "createInputSteam", " createInputSteam", "createOutputSteam", " createOutFile", "createOutputstream"], "inFile": [" infile", "dinPath", "ninFilename", "dinPort", "inputPath", " inPort", " inDir", "outPath", "outfile", "inputPort", "infile", "inPort", "inPath", "inDir", " inPath", "outFilename", "dinDir", "inputDir", "inFilename", "dinFile", " inFilename", "ninfile", "ninFile", "ninPath", "inputFile"], "outFile": ["outPort", "OutFile", "exFilename", "newPlace", "newFile", "OutFilename", "toPort", "outputPlace", "toFilename", "outfile", "toFile", "newfile", "exfile", "infile", "outputFile", "inPort", "outPlace", "outFilename", "outputfile", "outputFilename", "inFilename", "newFilename", "tofile", "exPlace", "Outfile", "exFile", "OutPort"], "k_blockSize": ["k4BlockName", "k4BlockCount", "k_batchCount", "k_byteName", "k_BlockLength", "k4BlockSize", "k_BlockSize", "k_BlockCount", "k4blockCount", "k_batchSize", "k_blockCount", "k_byteCount", "k_BlockTime", "k_byteStyle", "k_batchTime", "k2blockCount", "k_byteTime", "k2byteCount", "k_BlockName", "k4blockName", "k_byteSize", "k2blockSize", "k_blockStyle", "k2blockLength", "k2byteTime", "k4BlockStyle", "k_blockName", "k_BlockStyle", "k2byteSize", "k_blockLength", "k_blockTime", "k4blockStyle", "k2blockTime", "k_batchLength", "k4blockSize", "k2byteLength", "k_byteLength"], "byteCount": ["bitCode", "blockCheck", "byteCounter", "charCount", "charLength", " bytePtr", "bitLength", "bytePtr", "wordSize", "byteLength", " byteCounter", "byteCode", " bytecount", "byteN", "blockLength", "byteSize", "bbCount", "blockCounter", "wordCount", "charcount", "bitCounter", "wordN", "bitCount", "bitN", "linecount", "lineLength", "bytecount", "wordCode", "bbSize", "bbCode", "bitCheck", "byteCheck", "linePtr", "bitSize", " byteCheck", "charPtr", "bbN", "lineCount", " byteLength", "blockCount"], "buf": ["arr", "cmd", "bl", "b", "exp", "vec", "bn", "uf", "alph", "queue", "buffer", "str", "ctx", "block", "raw", "pkg", "cv", "bg", "cap", "img", "bag", "fg", "seq", "Buff", "batch", "cast", "msg", "txt", "mem", "doc", "cur", "bc", "conv", "db", "proc", "cat", "ctr", "Buffer", "rb", "tx", "buff", "bytes", "cb", "pb"], "ofp": ["Ofd", "Ofp", "ofd", "owlp", "ofpa", " ofpa", " ofl", "Ofpa", "ofl", "OFP", "Ofl", " ofP", "OFp", "OfP", "owld", "owlP", "OFl", "ofP", " ofd", "owlpa", "OFd"], "zos": ["zy", "sis", "z", "osi", "zh", "zes", "hz", "sbm", "zag", "sch", "bs", "std", "enos", "bes", "jp", "ze", "ws", "hess", "LOS", "zona", "zen", "webkit", "gs", "rez", "js", "zers", "south", "zik", "tis", "socket", "eros", "init", "zzle", "python", "amia", "zi", "cos", "ez", "zer", "zip", "cz", "jas", "settings", "esa", "rose", "oss", "zon", "psy", "es", "os", "zb", "zu", "nz", "rss", "ossus", "los", "zo", "css", "zl", "ps", "za", "zin"], "osw": ["sysW", "osswx", " osW", "ossrw", "ossW", "oswx", "opace", " osd", "isw", "osssw", "osew", "cosw", "owa", "osiwa", "sysrw", "oswd", "osswd", "iswx", "osiw", "ossw", "osws", "osiW", "aoswd", "aosew", "aosd", "ospace", "osd", "isW", " oswx", "aoswa", "sysw", "cosew", "osipace", "syswd", "issw", "aosws", "cosd", "cosws", "osrw", "aosrw", "aosw", "oswa", " ossw", "ow", "aospace", " osws", "oW", " osew", "aosW", "osW"], "bw": ["abew", " bx", "obwt", "nbew", " bwl", "abw", "rbw", "wbw", "pbz", "pbwy", "wbz", "sbz", "pbw", "wbwp", "bz", " bex", "pbwb", "pbwt", "wbem", "bwt", "bsw", " bsw", "abwe", "rbws", "bbem", "bbws", "wbwt", "bbz", "obz", "bwy", "wbx", " bwp", " bz", "bbex", "bbx", "bewl", "bew", "bbwp", " bem", "pbew", "nbwy", "bewk", "obwb", "nbw", "obw", "bbend", "bwk", "nbwe", "bwp", " bend", "bwl", "obsw", "bem", "bwb", "sbwt", " bwt", "bwe", "wbend", "bws", "bbwt", "obwk", " bwk", "rbz", "bend", "pbwe", "abwy", "bex", "bbw", "bx", "rbex", "sbw", "besw", " bws", "obwl", "sbwb"], "zot": ["zipot", "zipiat", "Zit", "Zott", "ziat", "ziot", "Zot", "zipiot", "zerot", "zott", "ziphot", " zor", "zero", "zerhot", "zote", "zerote", " zote", " zhot", " ziat", " zonet", "zeror", "zoonet", "zonet", " ziot", "zeriat", "zeronet", "zor", "Zote", "zerit", "zoor", "zoot", "zeriot", " zo", "zerott", "zhot", " zott", "zo", "zoo"], "ifp": [" ifth", " ifP", "ifP", "Ifth", "isP", " ifr", "iwr", "ihd", "isth", "iwd", "ihtp", "isjp", "ihp", "ifr", " ifjp", "Ifjp", " ifd", "ifth", " iftp", "isp", "iwp", "IfP", "Ifp", "ihr", "ifjp", "iftp", "iwtp", "ifd"], "zis": ["izis", "ziinit", " zi", "zic", "zois", "zipis", "zisa", "izisa", " zisc", "zoisa", "zipIS", "ziss", "zeris", "izisc", "zinit", "zisc", "zoiss", "ezisc", "ezis", " ziss", "iziss", " zIS", "zi", " zic", "zIS", "zeric", "ziis", "izinit", "ezi", "eziss", "zoinit", "zerIS", "zipic", "izi", "ziiss", "ziisa"], "isr": ["iosstr", "sisrc", " isrc", "isalpr", "issrc", " isrs", "isscr", "iossr", "siscr", "isstr", "sisrs", "isrs", "ispr", "itsr", "issrs", "sisr", "itspr", "iscr", "isalstr", "isrc", "issr", "itsstr", "isalsr", "iospr", " iscr", "isalr", "iosr", "itssr"], "br": ["hr", "rel", "yr", "ba", "dr", "bm", "mr", "bl", "b", "gr", "bf", "bn", "Fr", "BR", "bp", "vr", "lr", " Br", "bi", "str", "kr", "js", "shr", "bro", "fr", "bh", "obl", "Br", "ber", "ptr", "bt", "tr", "bj", "pr", "cr", "r", "ctr", "rb", "bd", "sr", "wr"], "zit": ["zlit", " zite", "zipist", "cziti", "oziti", "ziIt", "czunit", "zipite", " zip", "zipIT", "ziti", " zIT", "lexIt", "zeop", "zeot", "czip", "ezite", " zop", "ozunit", "ozip", "ezlit", "lexit", "czop", "zIT", "ziIT", "zop", "czot", "czit", "izip", "zite", "zeit", "zeip", "ziplit", "lexist", "zIt", "ozit", "zipIt", "zip", "ezit", "zist", "zipit", "ezIT", "ziist", "lexIT", "izit", "zunit", "ziit", "iziti", "izunit", " zlit"]}}
{"id1": "20929570", "id2": "2807585", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"toMd5": ["toMMD512", "toMdHash", "toDm5", "toMm5", "toDmHash", "toMmdHash", "toDd512", "toMmd512", "toMm4", "toDd5", "toMm512", "toMd4", "toDdHash", "toDd4", "toMd512", "toMMD4", "toMmd4", "toMMD5", "toMmHash", "toMmd5", "toDm512", "toMMDHash", "toDm4"], "str": ["arr", "b", "p", "v", "STR", "data", "enc", "char", "Str", "string", "e", "s", "print", "in", "st", "text", "c", "it", "a", "obj", "sp", "msg", "wr", "ch", "name", "this", "out", "txt", "br", "cr", "r", "input", "ctr", "t", "utt", "w", "n"], "messageDigest": ["messageDefester", "applicationDigested", "messageDecests", " messageDiger", "applicationdigester", "Messagedigse", "messageDigests", "messageDigested", "applicationDigest", "MessageDigest", "messagedigEST", "messageDesignest", "messagedigist", "messageDigert", "messageDecse", "messagemdert", "messageDesignests", "messagedigse", " messageDigester", " messageDse", "messagediger", "MessageDigests", "messageDest", "MessageDigester", "Messagedigest", " messageDert", "applicationdigested", "applicationDigse", "messagedigested", "applicationdigse", "messageDesignested", " messageDest", "MessageDiger", "messageDesignse", "messageDigester", "messageDiger", "messagedigest", "messageDert", " messageDigse", "messagemdest", "MessagedigEST", "applicationDigester", "messageDefer", "messagemdester", "messageDigEST", "messageDefist", "applicationdigest", "messageDefest", "messagemdse", "messageDigse", " messageDester", "messagedigests", "messageDesignester", "messageDester", " messageDigert", " messageDigist", "Messagediger", "messageDse", "messageDecested", "messagedigester", "Messagedigester", "messageDecest", "messageDecester", "messageDefEST", "Messagedigests", "MessageDigEST", "messagedigert", "messageDigist", "MessageDigse"], "byteArray": ["byteList", "byteString", "seBuffer", " byteBuffer", "bytesArray", " byteRAY", "byteAddress", "entityList", "byteLength", "viewStream", "resourceArray", "basicarray", "bytesLength", "bytearray", " byteString", " byteAddress", "basicList", "viewBuffer", " byteList", "viewArray", "basicAddress", "fieldRAY", "seArray", " byteStream", " bytearray", "byteStream", "helloArray", "entityarray", "fieldArray", "resourceBuffer", "resourceStream", "bytesRAY", "byteRAY", "fieldLength", "bytesString", "basicBuffer", "entityBuffer", "helloBuffer", "bytesAddress", " byteLength", "byteBuffer", "basicArray", "entityArray", "basicString"], "md5StrBuff": ["md5BuffBuff", "md5StBuff", "md8StrComp", "md4Strbuff", "md5RatVert", "md7StringBuff", "md5ObjBuff", "md8RatBuffer", "md4StringBuff", "md4StrPref", "md5RatBuff", "md8StrBuff", "md5StrBu", "md5StBu", "md7StrBuff", "md5ObjBuffer", "md5Stbuff", "md5StBuffer", "md5StringDb", "md7StringBu", "md5TextCop", "md7Stringbuff", "md5BuffPref", "md7StrBu", "md5RatComp", "md65StrCop", "md8StrVert", "md5StringCop", "md5StringComp", "md5StrPref", "md5strbuff", "md5BuffDb", "md5StringBuff", "md4StringPref", "md8StrBuffer", "md65TextComp", "md7StrPref", "md5strBuffer", "md8RatBuff", "md5Buffbuff", "md5TextBuffer", "md5StringBuffer", "md5StrVert", "md65StrComp", "md65StrBuffer", "md5strBu", "md5StringPref", "md7Strbuff", "md5strComp", "md5TextComp", "md65TextBuffer", "md5StrDb", "md5StrCop", "md5StrBuffer", "md65StrBuff", "md8RatVert", "md5StCop", "md4StrDb", "md8RatComp", "md5StringBu", "md5StComp", "md5strDb", "md65TextBuff", "md5Strbuff", "md5ObjVert", "md5TextBuff", "md5ObjComp", "md4StringDb", "md5RatBuffer", "md5Stringbuff", "md5StPref", "md4Stringbuff", "md5strBuff", "md65TextCop", "md5strVert", "md7StringPref", "md5strPref", "md5StrComp", "md4StrBuff"], "i": ["cli", "mi", "u", "go", "v", "ix", "ex", "ini", "gravity", "I", "list", "us", "s", "si", "e", "ai", "ii", "io", "chain", "bi", "cgi", "n", "q", "my", "m", "me", "in", "ki", "iu", "ic", "it", "ei", "multi", "c", "status", "li", "major", "ti", "a", "j", "xi", "x", "hi", "ji", "batch", "phi", "y", "ind", "slice", "is", "ui", "h", "gu", "uri", "conv", "di", "gi", "l", "json", "ci", "ip", "t", "o", "info", "im", "index", "pi"]}}
{"id1": "2521141", "id2": "16388708", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "move", "cut", "archive", "transfer", "select", "sync", "ate", "delete", "crop", "io", "set", "clip", "opy", "insert", "load", "remove", "link", "upload", "replace", "export", "paste", "edit", "Copy", "file", "share", "cp", "zip", "slice", "write", "get", "source", "clone", "create", "close", "save", "download", "cop"], "from_name": ["from_no", "fromkname", "from_filename", " from_part", " from_case", "fromamefilename", "from_key", " from_names", "from_info", "fromamename", " from_key", "fromkcase", " from_filename", "fromameName", "from_resource", " from_resource", "from_case", "fromkName", "from_Name", "from_names", " from_Name", " from_info", " from_no", "fromkpart", "fromamekey", "from_part"], "to_name": ["toNameget", "tolynm", "toNamefile", "toNamename", "toNamenew", " to_nm", "eto_Name", "to7new", "eto_word", "to_number", "from_new", "to_get", "to_word", "to7name", "to_Name", "tolynumber", "from_get", "to7file", "to_nm", "eto_name", "to_new", "tolyname", "to7get", "tolyfile", " to_number"], "from_file": ["fromlyfile", " from_time", "to_dir", "from_run", "from_File", "or_name", "or_File", "from_node", "or_file", "fromlyresource", " from_do", " from_port", " from_node", "fromsname", " from_File", "from_resource", "from_port", " from_resource", "or_run", " from_type", "fromlyFile", "from_dir", "fromlynode", "fromsfile", "fromsdir", "from_type", "from_time", "from_do"], "to_file": ["TO_element", "to_dir", " to_File", "toJfile", "to_link", "to_local", "TO_port", "to_tree", " to_base", "to_base", "toJdrop", " to_block", "to_files", "toJblock", "TO_FILE", " to_dir", "that_file", " to_local", "that_link", "that_File", "to_port", "to_type", "TO_files", "to_FILE", "TO_name", "TO_file", "to_create", "from_dir", "to_File", " to_run", "to_element", "from_type", "to_block", " to_create", "to_drop", "to_run", "that_tree", "toJFile", " to_drop"], "parent": ["folder", "top", "server", "id", "holder", "p", "port", "position", "par", "base", "where", "instance", "home", "peer", "event", "path", "owner", "user", "chain", "form", "test", "percent", "tar", "Parent", "my", "tree", "block", "rule", "paren", "man", "mother", "part", "timeout", "spec", "page", "comment", "prefix", "shape", "file", "ma", "child", "sp", "directory", "pool", "params", "name", "pid", "family", "unit", "relative", "cmp", "per", "pa", "up", "client", "def", "source", "null", "desc", "parents", "default", "global", "ip", "prop", "root", "temp", "pixel", "remote", "point", "master"], "dir": ["div", "rel", "folder", "del", "loc", "dr", "dd", "cmd", "ir", "red", "self", "rec", "dict", "path", "addr", "str", "mod", "part", "vol", "dist", "init", "md", "file", "DIR", "sp", "directory", "det", "tr", "cond", "ind", "good", "def", "dep", "dim", "cur", "iter", "wd", "di", "db", "cd", "Dir", "coll", "fd", "d", "local", "module", "cont"], "from": ["fun", "store", "en", "stream", "style", "old", "with", "com", "From", "window", "ent", "con", "empty", "back", "user", "form", "io", "normal", "on", "set", "term", "st", "in", "entry", "or", "by", "error", "re", "vol", "link", "fr", "orig", "init", "query", "file", "left", "so", "ie", "base", "pos", "before", "false", "no", "out", "check", "client", "source", "se", "inner", "reset", "start", "ra", "bound", "and", "local", "func"], "to": ["eto", "top", "output", "tt", "b", "co", "too", "total", "tty", "te", "stable", "please", "token", "e", "target", "ne", "sys", "on", "will", "into", "or", "by", "toc", "table", "pretty", "ts", "that", "must", "To", "po", "TO", "op", "auto", "nt", "so", "ma", "base", "two", "no", "tto", "out", "client", "ta", "can", "null", "o", "t", "go", "ato", "pi"], "buffer": ["binary", "cache", "message", "window", "char", "buf", "queue", "stack", "phrase", "sequence", "database", "block", "entry", "button", "table", "frame", "bar", "stroke", "available", "page", "paste", "attribute", "document", "function", "batch", "base", "event", "word", "append", "template", "memory", "character", "iter", "row", "variable", "Buffer", "buff", "sample", "password", "command", "temp"], "bytes_read": ["bytes__Read", "bytes2range", " bytes_Read", "bytes_run", "bytes__range", "bytes__write", "bytes2Read", "bytes2read", "wordsynclen", "words_write", "words_report", "words_read", "bytes__read", "bytes2write", "wordsyncwrite", "bytes_range", "bytesyncread", "wordsyncread", "Bytes_read", " bytes2read", "bytesyncreport", "bytes_write", " bytes_write", " bytes2Read", " bytes2write", "Bytes_write", "words_len", "Bytes_run", "bytesynclen", "wordsyncreport", " bytes_range", " bytes2range", "bytes_Read", "bytesyncwrite", "bytes_len", "bytes_report"]}}
{"id1": "7757297", "id2": "21438069", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"submit": ["update", "launch", "format", "process", "form", "print", "request", "post", "upload", "apply", "login", "report", "sub", "edit", "run", "execute", "open", "display", "input", "close", "create", "Submit", "accept", "save", "download", " submission", "send"], "uri": ["ri", "id", "du", "doi", "location", "campus", "message", "description", "path", "origin", "URI", "subject", "term", "resource", "http", "link", "report", "ur", "prefix", " URI", "range", "URL", "file", "course", "address", "directory", "msg", "name", "iri", "ui", "wiki", "source", "i", "filename", "title", "href", "password", "info", "pi"], "Exception": ["Warning", "Exit", "Failure", "Connection", "Class", "Result", "Default", "EX", "Error", "E", "Event", "API", "X", "Message", "Document", "ception", "Throw", "null", "Response", "Application", "Status", "T"], "encodedrdf": ["encodedrdl", "encuredrf", "encodedrdfs", "encodeddrp", "encodedwsl", "encodedrtf", "encuredrp", "encuredrdl", "encodingrsl", "encodedrtfs", "encodeddrl", "encodingrsf", "encodingrdf", "encodedwsfs", "encodedridl", "encodedwsfx", "encodedrtfx", "encodedrdp", "encodeddrfc", "encodedridfc", "encuredrdp", "encodedrsfs", "encodingrdfs", "encodedwsf", "encodeddrf", "encuredrdf", "encuredrl", "encodedrfc", "encodedrdfx", "encuredrdfc", "encodingrsfx", "encodedrsf", "encodedrsfx", "encodedridf", "encodingrsfs", "encodedrsl", "encodedrtl", "encodedrf", "encuredrfc", "encodingrdfx", "encodedrp", "encodedrdfc", "encodingrdl", "encodedrl", "encodedridp"], "url": ["loc", "sl", "ssl", "b", "p", "https", "location", "ls", "service", "con", "web", "m", "str", "ll", "conn", "resource", "http", "li", "ul", "nl", "link", "socket", "browser", "ur", "URL", "file", "sb", "cert", "build", "base", "address", "name", "open", "client", "mount", "r", "Url", "l", "log"], "connection": ["context", "server", "output", "https", "established", "position", "channel", "Connection", "connect", "relation", "communication", "message", "description", "con", "web", "io", "handler", "generation", "database", "network", "conn", "in", "entry", "application", "c", "resource", "writer", "response", "link", "socket", "creator", "session", "document", "function", "connected", "open", "ion", "client", "number", "ticket", "still", "statement", "l", "condition", "using", "command", "index", "result", "n"], "lastUser": ["latestAuthor", "latestCategory", "LastDate", "latestDate", "LastCategory", "LastAuthor", "lastCategory", "lastAuthor", " lastCategory", "latestUser", "lastDate", " lastDate", "LastUser", " lastAuthor"], "out": ["cmd", "output", "server", "OUT", "co", "gr", "v", "p", "serv", "ex", "screen", "cache", "window", "format", "list", "ent", "con", "net", "io", "chain", "print", "sys", "err", "set", "in", "raw", "conn", "outs", "it", "timeout", "writer", "table", "ou", "inv", "pretty", "to", "report", "all", "init", "query", "obj", "res", "aos", "nt", "pool", "ch", "client", "write", "up", "line", "txt", "check", "rem", "inner", "help", "conv", "null", "json", "conf", "o", "log", "Out", "at", "cont", "n"]}}
{"id1": "17947246", "id2": "14733078", "code1": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"readURL": [" readURI", "parseURI", "loadUrl", "loadURI", " readUR", "readUR", "readUrl", "parseURL", " readUrl", "readURI", "parseUrl", "loadUR", "loadURL", "parseUR"], "urlLocation": [" urlLoc", "URLAddress", "urlAddress", " urlName", "itemLocation", "itemUrl", "URLPath", "lValue", "URLName", "UrlAddress", "httpLoc", "UrlLocation", "UrlLoc", "UrlName", "fileLoc", "URLLocation", "itemLoc", "urlDescription", "httpLocation", " urlAddress", "URLDescription", "urlUrl", "UrlUrl", " urlPath", "UrlDescription", "fileLocation", "URLLoc", "lLocation", "httpLocated", "UrlPath", "urlLoc", " urlDescription", " urlValue", "urlValue", "lLoc", "httpPath", "UrlLocated", "filePath", "lLocated", "urlName", "URLUrl", "lPath", "urlLocated", " urlLocated", "UrlValue", "fileLocated", "itemPath", "urlPath"], "headers": ["terms", "pins", "pres", "writers", "caps", "comments", "drivers", "values", "flags", "qs", "events", "vals", "fields", "builders", "properties", "authors", " trailers", "ers", "types", "weights", "orders", "files", "strings", "ilers", "options", "ctors", "images", "http", "users", "holders", "codes", "ppers", "heads", "workers", "body", "styles", "members", "services", "keys", "ors", "h", "details", "parts", "head", "pages", "lines", "ports", "ids", "names", "html", "frames", "ters", "blocks", "checks"], "c": ["f", "u", "b", "cs", "v", "p", "co", "cache", "ec", "enc", "tc", "nc", "cc", "con", "e", "cin", "ctx", "m", "C", "j", "dc", "ca", "gc", "mc", " C", "code", "h", "cur", "r", "bc", "g", "config", "l", " ec", "ct", "t", "o", "d", "cb", "fc", " cc", "n"], "url": ["loc", "rel", "host", "u", "sl", "ssl", "bl", "gl", "b", "https", "location", "ls", "dl", "il", "hl", "bel", "path", "web", "ln", "lr", "ml", "un", "str", "ll", "xml", "rl", "http", "ul", "nl", "link", "ur", "URL", "cert", "base", "address", "open", "mount", "mail", "ob", "pl", "r", "Url", "l", "null", "cl", "t", "n"], "conn": ["cn", "loc", "nn", "ann", "cmd", "ssl", "exec", "en", "org", "co", "fin", "lang", "https", "Connection", "connect", "nc", "enc", "self", "canon", "jp", "cc", "con", "secure", "net", "cfg", "addr", "sys", "ns", "ctx", "on", "err", "resp", "pkg", "nec", "http", "comm", "j", "socket", "yn", "gate", " con", "init", "pg", "sql", "connection", "obj", "Conn", "res", "wp", "cert", "nt", "msg", "ch", "cp", "open", "client", "out", "txt", "ob", "cur", "syn", "close", "conv", "auth", "db", "conf", "proc", "ct", "log", "ws", "cb"], "istream": ["ISTrace", "ostrom", "instroll", "ISTream", "inststream", "istroll", "iptREAM", "distroll", "oststream", "distrom", "ostroll", "iptstream", "iptrace", "ostrace", "istrace", "ostream", "instrom", "instream", "iptream", "istREAM", "ISTREAM", "distream", "ISTstream", "ostREAM", "istrom", "iststream", "diststream"], "i": ["k", "cli", "mi", "ami", "u", "id", "ri", "pi", "ix", "ini", "us", "ii", "si", "e", "ai", "bi", "print", "ms", "yi", "my", "m", "sim", "me", "iu", "multi", "ic", "ei", "li", "ij", "a", "j", "ti", "xi", "init", "x", "hi", "ori", "ji", "ie", "phi", "y", "name", "ind", "is", "ui", "di", "oi", "gi", "ci", "ip", "\u0438", "info", "qi", "im", "index", "I"], "header": ["host", "context", "column", "dr", "ssl", "server", "field", "holder", "format", "detail", "er", "peer", "string", "token", "content", "buffer", "state", "subject", "block", "section", "rule", "wrapper", "request", "layer", "part", "http", "table", "option", "response", "argument", "method", "frame", "metadata", "comment", "attribute", "tag", "heading", "item", "prefix", "Header", "hex", "hash", "name", "line", "txt", "h", "property", "title", "source", "head", "version", "row", "variable", "padding", "filter", "hd", "first", "info", "history", "handle"], "key": ["k", "et", "column", "important", "search", "var", "KEY", "field", "id", "match", "sum", "where", "feature", "pair", "description", "Key", "cookie", "token", "owner", "print", "attr", "member", "set", "entry", "pkg", "by", "part", "col", "ke", "link", "label", "attribute", "tag", "item", "ek", "prefix", "query", "ox", "hash", "name", "element", "title", "source", "variable", "index"], "value": ["initial", "field", "values", "v", "message", "total", "select", "description", "pair", "string", "csv", "print", "test", "state", "sequence", "buffer", "val", "block", "entry", "bottom", "label", "attribute", "des", "python", "comment", "function", "widget", "VALUE", "name", "hash", "unit", "element", "true", "number", "ue", "html", "version", "variable", "default", "password", "hello", "Value", "result"], "data": ["DATA", "values", "p", "ata", "cache", "buf", "content", "pointer", "sequence", "str", "text", "size", "a", "body", "code", "extra", "def", "meta", "results", "type", "next", "bytes", "info", "result", "action"], "curPos": ["curLoc", " errPos", " cursorLoc", "curPtr", "curpos", " cursorpos", " cursorPos", " errPtr", " curpos", " curPtr", " cursorPtr", " errpos", " curLoc", " errLoc"], "contentLength": ["ContentType", "byteLength", "contentSize", "ContentOffset", "ContentSize", " contentType", "contentType", "bytePoint", " contentOffset", " contentlength", "contentlength", "contentOffset", "ContentPoint", "byteOffset", "byteType", "contentPoint", " contentPoint", " contentSize", "bytelength", "ContentLength", "Contentlength"], "byteSize": ["byteCount", "binaryType", "ByteCount", " byteType", "imageLength", "bytesize", "byteLength", "bytesSize", "binarySize", "bytesLength", "bytesInfo", "byteLen", "Bytesize", "imageSize", "byteInfo", " byteInfo", "ByteLen", " byteCount", "byteType", "binaryLen", " byteLen", "bytesCount", "ByteLength", "bytessize", "ByteInfo", "imageCount", "imagesize", "ByteSize", " byteLength", "ByteType", "binaryLength"]}}
{"id1": "23118425", "id2": "22560224", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"encrypt": ["enryption", "decryption", "decipher", "encrypted", "decrypted", "Encrypt", "Encipher", "Encryption", "encipher", "Encrypted", "enrypt", "decrypt", "enipher", "encryption", "enrypted"], "plaintext": [" PlainText", "plainstring", " plaintxt", "publicth", "realtxt", "plainText", " plainText", "realText", " Plaintext", " plainpassword", "plainpassword", "broadtxt", "realstring", "publictext", "publicText", " plainth", "broadText", " Plainpassword", "plaintxt", "publicpassword", "broadstring", "plainth", "broadtext", " Plainth", " plainstring", "realtext"], "md": ["del", "cmd", "dd", "dr", "mt", "gr", "der", "mo", "red", " mc", "nd", "mg", "dh", "mk", "sd", " dd", "med", "od", "ms", "m", "mm", "esm", "pd", "mod", "ds", "metadata", "ad", "mc", "mn", " Md", "managed", "df", "mp", "nt", "msg", "dm", "det", "ind", "mb", "good", "dig", "material", "doc", "grad", "ld", "rm", "deb", "cd", "bd", "hd", "d", "MD", "sm"], "raw": ["core", "original", "sh", "ng", "data", "message", "hook", "buf", "bare", "clean", "random", "valid", "rendered", "pack", "custom", "rew", " Raw", "cooked", "orig", "available", "all", "known", "hex", "RAW", "extra", "out", "clear", "full", "mem", "input", "Raw", "unsigned", "json", "row", "unknown", "aw", "bytes", "html", "draw", "w", " RAW", "n"], "hash": ["ashes", "ash", "sh", "search", "id", "ASH", "sha", "rh", "sum", "message", "total", "ssh", "Hash", "print", "proof", "has", "cloth", "bh", "alert", "tag", "dump", "key", "ashed", "hex", "tr", "name", "mask", "height", "check", "h", "html", "json", "mac", "shadow", "hed", "href", "password", "component", "handle"]}}
{"id1": "22977189", "id2": "17286898", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"in": ["ins", "din", "inside", "are", "ri", "ini", "ze", "IN", "inn", "con", "ln", "user", "io", "inf", "cin", "gin", "on", "bin", "from", "raw", "it", "ic", "ar", "ro", "init", "reader", "ind", "is", "inc", "up", "rin", "get", "i", "input", "r", "iter", "inner", "conf", "ill", "read", "In"], "out": ["ot", "cmd", "output", "OUT", "en", "b", "co", "v", "port", "cache", "screen", "list", "gt", "con", "net", "io", "chain", "print", "sys", "n", "on", "set", "conn", "outs", "ret", "it", "by", "writer", "timeout", "or", "news", "j", "note", "to", "all", "report", "obj", "res", "result", "auto", "aos", "tmp", "nt", "console", "pool", "client", "write", "bit", "mem", "full", "i", "rem", "inner", "db", "os", "null", "l", "conv", "flush", "not", "o", "end", "log", "Out", "at", "w", "outer", "can"], "line": ["column", "entity", "ine", "header", "style", "online", "match", "eline", "message", "char", "string", "ice", "ln", "user", "le", "chain", "print", "sequence", "cell", "valid", "block", "lin", "entry", "rule", "text", "error", "frame", "inline", "Line", "link", "stroke", "page", "day", "comment", "key", "file", "lane", "code", "base", "lined", "name", "word", "character", "iter", "l", "row", "next", "LINE", "point", "date", "n"]}}
{"id1": "3046085", "id2": "11865906", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"s": ["f", "b", "p", "rs", "v", "ls", "data", "string", "e", "S", "ns", "q", "str", "m", "ss", " ts", "strings", "text", "js", "c", "gs", "a", "name", "is", "h", "i", "r", "g", "es", "os", "its", "t", "w", "ps", "n"], "tokenizer": ["dateizable", "okenifier", "tokeniser", "nodeizer", "templateisher", "okenizable", "webitor", "tokenitor", "tokenifier", "okenzer", "serialzer", "tokenizable", "nodeisher", "tokenized", "valueizer", "operatorized", "okenner", "toolizer", "kinizer", "terminization", "valueizable", " tokenener", "terminizer", "terminiter", "tokenzie", "Tokenzer", "Tokenize", "nodeized", "operatorizer", "templateization", "operatorazer", "tokenizers", "templateer", "terminisher", "terminitor", "okeniser", "tokenization", "okenizer", "tokenener", "Tokener", "okeniner", "nodeization", "dateizer", "okenazer", "terminiser", "tokenzer", "okenitor", "toolizers", "templatezer", " tokenzer", "terminazer", "templateizer", " tokenoser", "okenzie", "serialize", "Tokenizers", " tokener", " tokenizable", "Tokenifier", "okenoser", " tokenisher", "valueisher", "operatorisher", "tokenisher", "tokeniter", "terminize", "tokeniner", "datezer", " tokenzie", "tokener", "toolize", "serializer", "okeniter", "dateize", "Tokenisher", "operatoriser", " tokenization", "webizable", "kinizers", "okenisher", "operatorization", "webizer", "webisher", "webization", "okenize", "Tokenizer", "tokenize", "serializable", "tokenoser", "okenener", "Tokenization", "Tokenner", "tokenner", "toolzer", "operatoriter", "kinzer", "webize", "operatorzie", "Tokenener", "Tokenized", " tokeniner", "terminizable", " tokenifier", "operatoriner", "tokenazer", "valueoser", "kinize", "templateizable", " tokenner"], "title": ["tip", "important", "id", "position", "displayText", "profile", "total", "description", "itled", "Title", "phrase", "art", "term", "lead", "text", "article", "part", "author", "table", "itle", "note", "metadata", "label", "prefix", "tag", "holiday", "name", "template", "source", "filename", "meta", "story", "version", "type", "summary", "t", "primary", "horse"], "artist": ["image", "folder", "object", "gallery", "person", "position", "voice", "archive", "audio", "user", "player", "Artist", "picture", "art", "rank", "part", "volume", "author", "album", "metadata", "creator", "attribute", "tag", "item", "track", "assisted", "directory", "music", "song", "chapter", "username", "source", "photo", "associated", "adult", "component", "project"], "location": ["loc", "folder", "translation", "near", "country", "position", "zone", "language", "feature", "description", "area", "origin", "Location", "direction", "comment", "phone", "shape", "layout", "address", "directory", "reference", "activity", "place", "source", "time", "media", "gallery", "local"], "rating": ["frequency", "genre", "scale", "profile", "playing", "average", "rated", "weight", "ranking", "rank", "boarding", "score", "rates", "metadata", "Rating", "confidence", "race", "library", "music", "erate", "meta", "credit", "training", "fps", "scoring", "rate", "media", "movie"], "overplay": ["overcast", "Overplay", "Overgrade", "appride", "appplay", "override", "appgrade", " overcast", "Override", "overgrade", " overgrade", "Overcast", " override", "appcast"], "temp": ["loc", "output", "encrypted", "texture", "cache", " tmp", " temporary", "empty", "partial", "test", "buffer", "set", "generated", "term", "orig", " Temp", "emp", "prefix", "key", "tmp", "base", "porary", "flash", "name", "current", "unit", "template", "Temp", "source", "memory", "mem", "tm", "tem", "created", "Temperature", "fake", "null", "type", "time", "now", "local", "stem"], "tags": ["assets", "terms", "flags", "Tags", "words", "comments", "atts", "lights", "fields", "stars", "types", "nets", "weights", "files", "strings", "links", "packages", "options", "relations", "marks", "images", "balls", "thumbnails", "reports", "lists", "styles", "dates", "keys", "tracks", "ags", "details", "parts", "pages", "lines", "names", "groups", "stats"], "bytes": ["rows", "terms", "words", "comments", "values", "bits", "bs", "videos", "classes", "ips", "vals", "fields", "gets", "files", "Bytes", "gs", "images", "bps", "seconds", "tes", "services", "gb", "mb", "keys", "loads", "len", "parts", "pages", "es", "lines", "uploads", "ids", "groups", "frames", "blocks"], "hasher": ["hasHer", " hashed", "haser", "havehers", " hasDR", "hater", " hasger", "Haser", "hahers", "hadter", " hader", " hadher", "hashed", "hashers", "haster", "haspher", "haveher", " haster", "hascher", " hasHer", "hydger", "Hashed", " haspher", "hadher", "Haspher", "hasger", "Haster", " hadter", " haser", " hashers", "hadhed", "hadger", "haveter", "hadpher", "hydHer", "hasDR", "haest", "haveest", "haher", " hascher", "hydcher", "hydher", "Hasher", "HasDR", " hadDR", "hasest", "hadcher", "hadHer", " hasest"]}}
{"id1": "12236729", "id2": "11377441", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" duplicate", " delete", "transfer", " Copy", " seek", " upload", " paste", " append", " restore", " transfer", " dup", "paste", " join", "Copy", " operate", " merge", "cp", " recover", " cat", " copying", " download", " replicate", " combine", " move", " parallel", " cp", "read", " clone"], "inputFile": [" inputPost", " inputile", "configPath", " inputDir", "argumentfile", "argumentFile", "outputPath", "inputfile", "inputPath", "outputDir", "outputile", " inputPath", "inputPost", "configPost", "inFile", " inputfile", "configFile", "inPath", "inDir", "inputDir", "argumentPath", "argumentPost", "inputile", "configfile", "inile"], "outputFile": ["outDir", " outputDir", "writePlace", "outputPath", " outputFilename", "inputfile", "inputPath", "outputDir", "targetDir", "writeFilename", "writeFile", "outPath", "outputPlace", "outfile", "targetfile", " outputPlace", "targetFile", "outPlace", "outFilename", "outputfile", "outputFilename", "inputDir", "writeDir", "targetPath", "outFile"], "in": ["ins", "din", "inside", "en", "ri", "old", "ir", "ini", "ze", "IN", "sin", "inn", "con", "ai", "inf", "cin", "gin", "on", "bin", "from", "ic", "it", "all", "init", "al", "per", "reader", "ind", "is", "inc", "up", "rin", "i", "input", "iter", "inner", "isin", "info", " din", "min", "read", "In"], "out": ["cn", "ot", "output", "en", "OUT", "co", "v", "dis", "ex", "cache", "con", "user", "net", "io", "ne", "print", "sys", "n", "on", "outs", "it", "by", "writer", "ou", "to", "obj", "res", "aos", "auto", "nt", "cos", "client", "check", "write", "one", "g", "os", "null", "flush", "o", "end", "log", "Out", "at", "outer", "can"], "c": ["k", "f", "z", "u", "cs", "v", "cu", "rc", "cf", "count", "cache", "ec", "nc", "char", "unc", "cc", "con", "arc", "chain", "ac", "C", "cod", "cap", "x", "mc", "gc", "code", "cos", "pc", "ch", "uc", "cp", "current", "i", "r", "cr", "bc", "character", "conf", "l", "cd", "cl", "ct", "t", "ce", "cm", "d", "cb", "lc", "cont", "n"]}}
{"id1": "20247400", "id2": "4118412", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"in": ["ins", "din", "isin", "ze", "IN", "inn", "con", "ai", "net", "io", "inf", "gin", "cin", "on", "bin", "from", "it", "init", "file", "ind", "is", "inc", "check", "up", "rin", "i", "input", "source", "inner", "and", "info", " din", "In"], "out": ["ins", "ot", "cmd", "output", "OUT", "b", "other", "ex", "screen", "println", "we", "list", "gt", "con", "ln", "net", "io", "ne", "print", "sys", "str", "err", "outs", "it", "or", "writer", "OU", "ou", "to", "report", "dir", "obj", "auto", "msg", "name", "line", "write", "client", "check", "oss", "r", "os", "null", "t", "log", "o", "exit", "Out", "at", "w", "outer", "n"], "buffer": ["length", "processor", "output", "header", "b", "binary", "position", "match", "cache", "channel", "data", "message", "total", "window", "buf", "queue", "stack", "phrase", "sequence", "database", "block", "view", "limit", "trace", "table", "size", "bridge", "bar", "available", "comment", "attribute", "key", "shape", "document", "function", "batch", "library", "address", "event", "history", "append", "template", "memory", "source", "display", "se", "iter", "clear", "db", "variable", "Buffer", "flush", "buff", "filter", "sample", "pause", "command", "component", "index", "temp", "result"]}}
{"id1": "5125848", "id2": "6840241", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"combineJs": ["CombineJs", "combINEJs", "combinateJs", "ComboseJs", "combinejs", "ComboseLink", "combINELink", "combineJS", "CombineJS", "combinateJS", "combINEJS", "ComboseJS", "combinatejs", "combineLink", "CombineLink", "combosejs", "combINEjs", "comboseJs", "Combinejs", "combinateLink", "comboseJS", "Combosejs", "comboseLink"], "base": ["host", " based", "server", "domain", "b", "id", "data", "api", "bas", "bid", "origin", "buffer", "absolute", "from", " basis", "re", "bottom", "based", "page", "Base", "prefix", "file", "address", " bases", "relative", " Base", "template", "source", "uri", "db", "reset", "ase", "start", "root", "site", "bound", "local"], "linkJs": ["LinkJS", "LinkJs", " linkScript", "linkjs", " linkLinks", "Linkjs", "linkedScript", "inkTags", "linkScript", "inkLinks", "inkScript", " linkTags", " linkJS", "LinkTags", "linkedLinks", "inkjs", "inkJS", "linkTags", "inkJs", "linkedJS", " linkjs", "linkLinks", "linkedJs", "linkJS"], "newFiles": ["newDocuments", "nextFiles", "newLinks", "newfiles", "linkFiles", "nextfiles", " newLinks", "nextDocuments", " newDocuments", "linkDocuments", "linkLinks", "nextLinks", " newfiles", "linkfiles"], "dir": ["div", "rel", " Dir", "folder", "loc", "fs", "dd", "dr", "id", " d", "ir", "DB", "dl", "mk", "disk", "area", "diff", "ref", "addr", "sys", "local", "tar", " directory", "pkg", "mod", "vol", "md", "file", "DIR", "auto", "tmp", "directory", "dm", "zip", "lock", "good", "def", "dep", "out", "doc", "done", "created", "wd", "db", "di", "manager", "cd", "desc", "Dir", "root", "fd", "temp", "d", "lib", "module"], "name": [" bar", " logger", " cleaner", " start", " os", " foo", " scanner", " vm", " tmp", " karma", " msg", " report", " dummy", " info", " self", " filename", " b", " manager", " parser", " browser", " prefix", " err", " rebuild", " names", " str", " db", " res", " loader", " log"], "minDir": [" minJar", "minDb", "smallDb", "miniTier", "MinNet", "smallDir", " minPref", "minTrans", "mainDir", "sortDir", "minNet", " minTier", "minuteDir", "skinLoc", " minNet", "smallFile", "miniDir", "MinFile", " minTrans", "skinDb", "minuteDar", "miniTrans", "mainLoc", "thinTier", "minPref", "MinDir", "minTier", "thinJar", "maindir", "thinDir", "minFile", " minDar", " minRel", "miniJar", "minRel", "minDar", "minuteRel", "minJar", " minFile", "smallLoc", "mainDb", "minutePref", "thinTrans", "smallNet", "sortDar", "mindir", "smalldir", "sortRel", "skinDir", "skindir", "minLoc", "sortPref"], "combineFile": ["coordineWriter", "comboiceMessage", "combINESet", "combinefile", "cominateMessage", "cominateFile", "combineSet", "coordINEFile", "comineMessage", "cominateEmail", "combineEmail", "combinerFile", "combosefile", "cominatefile", "combinSet", "comineFile", "combinerfile", "cominefile", "comboseWriter", "combinateFile", "comineEmail", "combinatefile", "combINEWriter", "combineMessage", "comboiceFile", "combinfile", "coordINESet", "comboseSet", "combINEFile", "comboiceEmail", "combinerEmail", "combinWriter", "coordINEfile", "coordinefile", "combINEfile", "comboseFile", "comboicefile", "coordINEWriter", "coordineFile", "combinateEmail", "combinFile", "combinerMessage", "coordineSet", "combinateMessage"], "concatFile": ["conCatFilename", "convertTable", "convertFilename", "concatDir", "concapFiles", "conatfile", "concFilename", "conCatDir", "concatTable", "concapfile", "covertTable", "conCatFile", "comcDir", "comcatDir", "conatFile", "cocatTable", "comcatFile", "covertFile", "covertfile", "cocatfile", "comcFile", "comcatFilename", "convertfile", "conatFiles", "concatfile", "concatFiles", "covertFiles", "concapFile", "conatTable", "concapTable", "concDir", "convertDir", "convertFiles", "comcFilename", "cocatFile", "concatFilename", "concFile", "cocatFiles", "convertFile"], "combineWriter": ["combineWrite", "combieFile", "declineReader", "combineReader", "combieReader", "combinateReader", "Combinewriter", "combinateWrite", "combinewriter", "combinateCounter", "combenCounter", "declinateFile", "combieWrite", "ComboseWriter", "declineFile", "combenwriter", "comboseWriter", "combinateFile", "ComboseCounter", "declinateReader", "combineCounter", "declinateWriter", "CombineWriter", "combenWriter", "comboseReader", "declineWriter", "comboseWrite", "Combosewriter", "comboseCounter", "comboseFile", "combosewriter", "declineWrite", "declinateWrite", "CombineCounter", "combinatewriter", "combinateWriter", "combieWriter", "combenWrite", "CombineWrite", "ComboseWrite"], "concatWriter": ["conatReader", "convertWrite", "conatWriter", "cocatWrite", "comvertWriter", "comvertReader", "conatFile", "comcatFile", "concatsReader", "convertReader", "conatWrite", "coatFile", "cocatWriter", "convertWriter", "cocatReader", "comvertFile", "concatsWrite", "coatWrite", "comcatReader", "comvertWrite", "concatsFile", "cocatFile", "concatsWriter", "concatReader", "coatReader", "comcatWriter", "coatWriter", "comcatWrite", "concatWrite", "convertFile"], "fails": ["fils", " focks", "frailing", "Failing", "focks", "facails", "failing", "facailed", "frailed", "mailing", "ifailed", "malls", "lailed", "mailed", "facocks", "Fails", "ifocks", "frils", "Failed", "mocks", "failed", "facailing", "ifails", "Fils", " failed", "frails", "lails", "lailing", "falls", "mails", "lalls", "lils", " falls", "ifailing", " failing"], "link": ["loc", "node", "mark", "match", "script", "linked", "task", "self", "relation", "ln", "ink", "links", "embed", "set", "push", "follow", "c", "li", "load", "map", "add", "inline", "skip", "child", "share", "code", "address", "open", "line", "check", "display", "Link", "source", "close", "l", "log", "remote"], "path": ["image", "loc", "id", "style", "p", "location", "match", "pattern", "data", "format", "string", "ref", "src", "str", "entry", "PATH", "text", "resource", "join", "alias", "prefix", "key", "file", "hex", "relative", "template", "full", "source", "input", "uri", "route", "prop", "Path", "root", "href", "kind", "ath"], "url": ["loc", "host", "rel", "sl", "ssl", "gl", "id", "location", "ls", "il", "hl", "char", "string", "web", "ref", "lr", "addr", "str", "ll", "request", "resource", "http", "li", "ul", "nl", "browser", "ur", "URL", "build", "address", "this", "mount", "mail", "get", "source", "r", "uri", "Url", "l", "abs", "null", "href", "html"], "inputStream": ["InputStyle", "InputTime", " inputSet", "InputSteam", "outputStyle", "inSet", "outputstream", "inTime", " inputstream", " inputSteam", "inStream", "inputSteam", "inputstream", "Inputstream", "instream", "inputStyle", " inputStyle", "InputSet", "InputStream", "outputSteam", "inputSet", "inputTime", " inputTime"], "jsFile": ["JsPath", "jFile", "jsPath", "cssFilename", "cssfile", "jPath", " jsTable", "cssTable", "jName", " jsPath", "javascriptPath", " jsName", "jsfile", "cssFile", "javascriptName", "Jsfile", "javascriptFile", "jsFilename", "jFilename", "JsFilename", " jsfile", "javascriptFilename", "javascriptfile", "jsName", "cssPath", "JsFile", "jsTable", " jsFilename", "javascriptTable"], "fileName": ["filePath", "getPath", "filename", "FileHash", "getHash", " fileHash", "fileHash", "FilePath", "FileName", "Filename", "getname", "getName", " filename", " filePath"], "outputStream": [" outputSteam", " outputStyle", "OutputSet", "Outputstream", " outputForm", "outputStyle", "inputForm", "OutputStyle", "outputstream", "OutputStream", "inputSteam", "inputstream", " outputstream", "OutputSteam", "OutputForm", "inputStyle", "writestream", "writeSet", "outputSet", "writeStream", "outputSteam", "outputForm", " outputSet", "writeSteam"], "first": ["initial", "top", "same", "important", "self", "fast", "each", "index", "then", "front", "sort", "stack", "real", "valid", "continue", "st", "natural", "quick", "must", "all", "seconds", "send", "only", "master", "latest", "false", "current", "true", "open", "ind", "last", "unique", "start", "default", "success", "second", "fourth", "next", "prev", "First", "third", "primary", "now"], "reader": ["core", "context", "mr", "stream", "rc", "rator", "data", "er", "iterator", "driver", "io", "handler", "buffer", "parser", "wrapper", "loader", "layer", "writer", "rl", "resource", "http", "runner", "ro", "builder", "file", "rr", "rar", "Reader", "this", "ner", "r", "input", "inner", "rer", "row", "read", "ocr"], "jsCompressor": ["jsCompression", "cssComposer", "jsCompiler", "jscomposer", "jscompiler", "jsComposer", "jsRepressor", "jsBuffoser", "cssCompressor", "cssRepressor", "jsBuffiler", "jsBuffressor", "jscompressor", "cssCompiler", "cssCompression", "jsRepiler", "jsReposer", "cssRepiler", "cssRepression", "jsRepression", "jscompression", "cssReposer", "jsBuffression"], "s": ["fs", "ats", "xs", "words", "cs", "ls", "ens", "pers", "ers", "S", "ns", "ms", "ss", "gs", "ds", "ts", "tes", "eds", "y", "ies", "less", "is", "full", "details", "parts", "ings", "es", "os", "l", "lines", "hs", "t", "ids", "qs", "tags", "ps"], "s1": ["ls1", " s3", "ls0", "pers1", "esFirst", "idFirst", "s0", "ys0", "s81", "ls3", "id2", "id1", " s81", "es2", "es9", "ls81", "ys81", "ps1", "s9", "ps0", "pers0", "es1", "s3", "ys3", "sFirst", "id9", " s0", "ys1"], "i": ["ia", "mi", "id", "ri", "p", "pi", "v", "ity", "ii", "us", "ai", "iti", "io", "bi", "um", "iat", "iu", "it", "ic", "li", "j", "ori", "ie", "y", "ch", "is", "ion", "ui", "di", "ig", "ip", "ci", "ati", "ifier", "o", "im", "oi", "I"], "s2": ["s02", "sSecond", "tes2", "es02", "SSecond", "S02", "gs2", "ss22", "s22", "z02", "msTwo", "z2", "tesTwo", "gsSecond", "Stwo", "S2", "ss2", "ssTwo", "gs02", "es2", "tes1", "zSecond", "stwo", "ms2", "gstwo", "ztwo", "es1", "tes02", "ms22", "esTwo", "ms02", "sTwo", "ss02"], "i1": ["e4", "e2", "it01", "eOne", "itOne", "p1", "it2", "i0", "p01", "a1", "it0", "aOne", "i01", "a2", "pOne", "o1", "a01", "p2", "i2", "it1", "p4", "it4", "o0", "o4", "e1", "oOne", "p0", "i4", "iOne"]}}
{"id1": "1122585", "id2": "20939940", "code1": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"copyImageFile": ["copyImagesfile", "copyImagePhoto", "cpimageHeader", "cpimageFile", "copyimagefile", "cpimagefile", "cpImagePhoto", "cpImagefile", "copyItemImagePhoto", "cpImageHeader", "copyImagesHeader", "copyimageFile", "copyimageHeader", "copyImagefile", "cpImageFile", "copyImagesPhoto", "cpimagePhoto", "copyItemImageFile", "copyItemImageHeader", "copyImagesFile", "copyItemImagefile", "copyImageHeader", "copyimagePhoto"], "urlString": ["uriRest", "uriStr", "imageStr", "imagestring", "linkRest", " urlChain", "urlService", "linkStr", "imageRest", "urlChain", "uristring", "urlRest", " urlService", "UrlService", "uriChain", "imageString", "uriService", "UrlRest", "uriString", "linkString", "urlStr", "urlstring", "UrlString", "linkstring", "UrlChain", " urlRest"], "filePath": [" filepath", "outputStream", "resourcePath", " FileName", "resourcePATH", "Filepath", "outputPath", "givenPATH", " FilePATH", "givenpath", " filePATH", "filepath", "givenPath", " Filepath", "outputPATH", " FilePath", "resourcepath", "fileStream", "fileName", "resourceStream", "FilePath", " fileName", "FilePATH", "FileName", "filePATH", "givenStream", "outputpath"], "destination": [" destinated", "destignment", "srcinate", "methodository", "combation", "combination", " destinate", "portinator", "delination", "terminignment", "Destinity", "destinate", "destificate", "destation", "identinator", "destachment", "combinator", "destension", " destificate", "destinated", "combinity", "Destinate", "identinate", "continate", " destachment", " destension", "Destination", "commentinate", "Destension", "portension", "portation", "srcinator", "terminachment", "destository", " destository", "srcination", "identension", " destacement", "delinated", "identination", "destinator", "destinity", "terminaration", "targetination", " destinator", "terminository", "identinated", "methodination", "delinator", "contination", "commentination", " destribution", "portinated", "portinity", "delribution", "srcificate", "methodinator", "destacement", "srcacement", "termininator", "targetinated", "srcaration", "targetribution", "terminination", " destignment", "Destinator", "destaration", "contension", "Destation", "methodachment", "srcignment", "portination", "commentacement", "continator", "destribution", "commentificate", "targetinator", " destaration"], "destination_file": ["destination__name", "destinator_port", "destination_no", "destATION____file", "destATION____name", "destinator_full", "destinator_ile", "destination_table", "destATION_file", "destination____name", "destinator___name", "destociation_file", "destATION____no", "destination_dir", "destination____no", "destination____file", "destination_name", "destination_port", "destinator_File", "destinator_table", "destociation_ile", "destation_ile", "destination_library", "destination_ile", "destATION____entity", "destation_file", "destinator_file", "destination__full", "destination___ile", "destATION_entity", "destinator___file", "destination__ile", "destociation_library", "destinator___full", "destination_File", "destination_entity", "destinator___ile", "destociation_dir", "destinator_FILE", "destation_File", "destATION_no", "destinator_dir", "destination___name", "destination_FILE", "destation_name", "destination___file", "destinator_name", "destination___full", "destination__file", "destination____entity", "destATION_name", "destination_full"], "inLine": [" inliner", "binLine", "Inline", " inline", "binline", "inString", "inliner", "Inliner", " inString", "binString", "InString", "binliner", "InLine", "inline"], "dest_name": ["destinationName", "decl_file", "img_data", "dest__Name", "decl_name", " dest__filename", "dest_lock", "dest_Name", "dest_file", "dest_filename", " dest_call", "img_Name", "dest__filename", "dest_word", "ident_entry", "dest_key", "ident_word", "destationName", "destationname", "dest_call", " dest_names", "destnfile", "dest__NAME", " dest__name", "img_file", "decl_ma", "destJNAME", "Dest_key", "destJterm", "Dest_san", "ident_name", "destinalword", "dest_data", " dest_NAME", "dest_entry", " dest_file", "desttkey", "destopname", "Dest_system", "dest__name", " dest__NAME", "destinationfile", " dest__Name", "src_file", "destinalname", "dest_ma", "destopdescription", "dest_NAME", "dest_path", "Dest_name", "destinalfile", "destationcall", "Dest_file", " dest_path", "destDdescription", "dest_size", "src_filename", " dest_lock", "destDsan", "Dest_Name", "dest_system", "destJsize", "desttName", "dest_term", "dest_ame", "dest_description", "destDname", "destationnames", " dest_Name", " dest_filename", "dest_san", "Dest_description", "destinalma", " dest_size", "dest__ame", "destopsan", "destinationname", " dest_ame", "desttname", " dest_term", "src_Name", "decl_word", "desttsystem", "src_name", "destnname", "destJname", "destinationfilename", "img_name", "dest_names", "destndescription"], "buffer": ["length", "update", "value", "stream", "binary", "b", "cache", "channel", "data", "message", "window", "char", "buf", "device", "queue", "phrase", "stack", "sequence", "database", "block", "raw", "text", "FFER", "table", "frame", "bar", "page", "paste", "comment", "shape", "document", "function", "batch", "base", "address", "append", "memory", "source", "feed", "iter", "row", "variable", "Buffer", "parse", "buff", "sample", "password", "command", "read", "result"], "bytes_read": ["bytes2Read", "bytes67read", "bytes_mix", " bytes_readable", " bytes2readable", "bytes_reading", "bytes67write", "bytes_write", " bytes_write", "bytes_Read", " bytes_Read", " bytes_length", "bytes67mix", "bytes2readable", "bytes2length", " bytes_count", "bytes2read", "bytes_count", "Bytes_write", "bytes_send", "Bytes_mix", "Bytes_send", "bytes_readable", "Bytes_read", " bytes2read", "bytes67send", "bytes_length", " bytes2Read", "bytes2reading", " bytes2reading", " bytes_reading"], "last_offset": [" last_index", "last_position", "last_page", "last_index", "Last_pointer", " last_name", "last_name", "Last_offset", "last__name", "last_start", "Last_page", "last__index", " last_start", "last_Offset", "Last_Offset", "last___offset", "last__offset", "last___Offset", "last__Offset", "last_pointer", "last___position", "last_flag", "Last_flag", "Last_position", " last_Offset", "last___pointer"], "offset": ["alt", "empty", "section", "set", "scroll", "article", "tile", "alias", "attribute", "prefix", "address", "pos", "after", "unsigned", "OFF", "pad", "point", "length", "Offset", "offs", "store", "iterator", "addr", "entry", "error", "volume", "size", "option", "table", "step", "key", "left", "auto", "batch", "name", "no", "element", "start", "type", "associated", "end", "original", "other", "onet", "timeout", "offer", "inline", "always", "amount", "seek", "shift", "mask", "ace", "append", "off", "padding", "component", "index", "slot", "et", "output", "field", "position", "location", "window", "order", "pointer", "origin", "part", "frame", "skip", "operation", "inner", "reset", "next", "bound", "outer"], "imageFile": ["photofile", " imageStream", " imagefile", "Imagefile", "ImagePlace", "mediafile", "messageFile", "mediaSourceFile", "imageReader", "messageReader", "ImageFile", "picturefile", "messagefile", "mediaStream", "pictureStream", "mediaFile", "picturePlace", "photoReader", "imageSourceFile", " imagePlace", "pictureFile", " imageReader", "imageStream", "ImageStream", "imagePlace", "photoFile", "photoStream", "imagefile", "messageStream", "ImageSourceFile", " imageSourceFile"], "url": ["f", "rel", "image", "sl", "ssl", "gl", "b", "dl", "gif", "hl", "api", "char", "bel", "github", "google", "web", "ml", "q", "str", "ll", "resource", "http", "rl", "re", "ul", "nl", "link", "browser", "ur", "impl", "URL", "build", "base", "address", "open", "mount", "mail", "up", "get", "r", "uri", "Url", "l", "abs", "html"], "parentdir": ["parentdirectory", " parentDir", "childfolder", "parentlib", "parentir", "childdiv", "parenfolder", "childDir", "parenir", " parentdirectory", " parentdict", "childdir", "Parentdir", "childir", "rootfolder", "tmpdirectory", "parentdiv", "Parentdirectory", "rootdiv", "childlib", "rootdir", "Parentdict", "parentDir", "tmpDir", "parentfolder", "parentdict", "parendiv", "tmpdict", "childdirectory", " parentlib", "rootir", "ParentDir", "Parentlib", "tmpdir", "parendir"]}}
{"id1": "17999474", "id2": "8788371", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAsfile", "getBoxFromLocal", "getBoxFromFile", "getZipAsPath", "getZipAsLocal", "getBoxAsfile", "getBoxFromfile", "getZipToFile", "getZipToPath", "getZipInfile", "getZipFromfile", "getZipInFile", "getZipFromLocal", "getBoxAsPath", "getBoxAsLocal", "getBoxAsFile", "getZipInLocal", "getZipFromPath", "getZipToLocal", "getBoxFromPath", "getZipInPath", "getZipTofile", "getZipFromFile"], "digOb": ["digOB", "chemOB", "DigObj", " digOB", "gradOb", "DigObject", " digEx", "DigOB", " digOcc", "chemEx", "divObject", " digObj", "DigOb", "digOcc", "divOcc", "chemObj", " digObject", "DigEx", "digObject", "gradOB", "digEx", "digObj", "chemOb", "gradObject", "gradObj", "divObj", "divOb", "DigOcc"], "folderName": ["folderSize", "foldername", "FolderNames", "folderNames", "folderKey", " foldername", "foldname", "FolderName", "fileKey", "foldName", "fileName", "foldPath", "fileSize", " folderSize", "foldNames", " folderKey", " folderPath", " folderNames", "Foldername", "foldSize", "fileNames", "foldKey", "folderPath", "FolderPath"], "tmpFolder": ["cmpDir", " tmpDir", "mpDirectory", "mpfolder", "mpFolder", "tmpDirectory", "tempDirectory", "mpParent", "tmpParent", "tempFolder", " tmpfolder", "tmpDir", "cmpfolder", "tempDir", "cmpParent", "tempParent", "cmpFolder", " tmpDirectory", "mpDir", "tempfolder", "tmpfolder"], "zip": ["f", "cloud", "folder", "z", "pdf", "drop", "quote", "exp", "sea", "wrap", "cf", "archive", "zone", "content", "csv", "box", "form", "io", "test", "tar", "gz", "xml", "entry", "pack", "pkg", "post", "col", "link", "Zip", "upload", "install", "jar", "report", "bag", "file", "sheet", "tmp", "library", "body", "sp", "proxy", "pool", "lock", "mail", "template", "feed", "se", "json", "row", "ip", "ow", "sample", "temp", "project"], "out": ["ins", "copy", "output", "OUT", "en", "co", "v", "serv", "ex", "list", "ent", "us", "s", "ln", "net", "io", "print", "set", "in", "outs", "it", "OU", "writer", "ou", "inv", "to", "all", "res", "auto", "aos", "tmp", "sp", "cos", "check", "up", "write", "i", "oss", "one", "conv", "inner", "os", "null", "flush", "o", "t", "Out", "n"]}}
{"id1": "13757855", "id2": "13333160", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"process": ["processor", "Process", "task", "format", "processing", "load", "step", "add", "replace", "apply", "render", "transform", "run", "build", "execute", "call", "write", "display", "loop", "create", "proc", "parse", "save", "filter", "project", "handle"], "tpl": [" tPL", "tmpp", "tpp", " tph", "ptplates", "timbl", "atplate", "stopl", "stplate", "teruple", "tempr", "stbl", "ttopl", "ttpg", "tsPL", " tpp", "tuple", "tpg", "tmplates", "ttbl", "Tplates", "tmplate", "timspl", " turtle", " tld", "tPL", "typl", "tyurtle", "tsurtle", "templ", "tplug", "Tbl", "stplug", "tpr", "tld", "Tplate", "ttpl", "temPL", "itpl", "tplate", "terplate", "otbl", " tplates", "stspl", "turtle", " tplate", "timpl", "itbl", "tyPL", "timplate", "tmbl", "timplug", "itPL", "atuple", "stpg", "tspl", "ttPL", "topl", "ptbl", "TPL", "tmPL", "terld", "Tspl", "Tph", "tbl", " tuple", "tsbl", "Tpr", "atld", "otplate", "ptpl", "tembl", "ttplug", "itplate", "tspr", " tbl", "Tpp", "otpl", "tplates", "tph", "Tld", "timopl", "ptld", "stpl", "otld", "ttph", "terpl", "tmpl", "timpg", "atpl", "Tpl"], "model": ["el", "object", "record", "models", "product", "node", "M", "data", "content", "ml", "m", "tree", " Model", "md", "document", "file", "Document", "base", "parent", "Model", "log", "html", " models", "module", "project"], "packageName": [" packageFamily", "groupNames", "groupName", "packagename", "Packagename", "viewClass", " packageClass", "packageRoot", "pkgVersion", "PackageName", " packagename", "pkgNames", "groupFamily", "packageVersion", "groupVersion", "PackageClass", " packageVersion", " packageRoot", "PackageRoot", "packageNames", "pkgFamily", "packageClass", "pkgName", " packageNames", "viewName", "viewRoot", "packageFamily", "viewname"], "outFileName": ["infilePath", " outFileTime", " outFileType", "outImagename", "outFilenameType", " outFilenameType", "outDirPath", "outFileNames", "outFilePath", "outFilenameNames", " outTableSize", "outStreamNames", " outTablePath", " outfileNames", "outFName", " outFileChain", "outfileNames", " outFilenamePath", " outFilenameSize", "outImageSize", "outfilename", "outStreamType", "outTableSize", "outDirName", "outFileChain", "outTablePath", "outDirTime", "infileNames", " outFilePath", " outfileName", "outStreamTime", "outfileType", "outTableType", " outFilenameName", "outFileSize", "outTablename", "outFPath", " outFilenameChain", "outFilenamePath", " outFilenamename", "outFilenameTime", "inFileTime", "outImagePath", "infileName", " outTableTime", " outFilename", "outFname", "outTableTime", "outfileTime", "inFileType", "infileTime", " outFileNames", "outStreamPath", "outStreamName", "outTableName", "inFileName", "outfilePath", "outFilenamename", "outFilename", "inFilePath", "outfileName", " outfilename", "outDirSize", "outFilenameSize", "outFileType", "inFileNames", "outTableChain", " outFileSize", "outFNames", "outFilenameName", " outfilePath", "outFilenameChain", "outImageName", " outTableName", "outFileTime", "outfileChain", "infileType"], "xsltParam": ["xsqlParam", "xsmlParam", "xsslParam", "xmlConf", "xmlParameter", "xsltConf", "xltParam", "xsmlParameter", "xsltParameter", "xsmlConf", "xltParameter", "xmlParam", "xsqlConf", "xsslParameter", "xsqlParameter", "xsslConf", "xltConf"], "artifact": ["arifacts", " artificate", "partifacts", "anifacts", "ardifacts", " artifacts", "ardifact", "arifact", "anificial", "artifacts", "artificial", "ardificial", "ardificate", " artificial", "artificate", "partifact", "Artifact", "Artifacts", "anifact", "anificate"], "destinationPath": ["estinationPath", "destigationChain", "chaininatedPath", "destinoHost", "destensionPoint", "destinatorChain", "origininationNow", "destesticSystem", "destinationName", "destinateChain", "destinationUrl", "chaininationDisk", "destociationPoints", "desturationPath", " destociationpath", "delinationPath", "estinationName", "DestinationPod", "destensionHost", "DestensionPath", "destesticPath", "destinationTarget", "destventionPath", "destinationSystem", "destigationPath", "destinantTemp", "generinationPath", "destinoName", "destinateAt", "destinantPod", "destositoryHost", "destinatorPath", "destionPath", "estinationPart", "destositoryParent", "DestinationHost", "termininationTarget", "destinationPart", "destinoPoint", "destinoKey", "destinateDir", "delinatePoints", "destensionPath", "identinateKey", "destinateName", "termininerJar", "desturationJar", "descositoryParent", "identinateChain", "destATIONParent", "destionPoint", "destesticJar", "descositoryHost", "DestificationDir", "destacementTime", "estinoKey", "estionpath", "destociationHost", "destociationHome", "destacementName", "destinateTarget", "destociationForm", "chaininationHome", "destinatePoints", "destensionTemp", "destinateJar", "destensionDir", "desticationPath", "destationDir", "destinationDriver", "destinateTime", "destinationDisk", "DestinationUrl", "delinateForm", "delinatePath", "desturationTarget", "destinatedTarget", "destinerpath", "destationHost", "destinationParent", " destinationpath", " destociationTarget", "estationPart", "identinationPath", "estationHost", "estinationDir", "descinationParent", "origininatedPath", "generinateAt", "generinatePath", "destinationNow", "destinationKey", "destinatorHost", "descositoryPath", "destociationPath", "destationPart", "destinateForm", "destinationChain", "destationPath", "destinationPod", "destitutionPATH", "destinatorPoint", "estinationPATH", "DestensionDir", "destacementPath", "desticationTemp", "destATIONPath", "termininerTarget", "desturationpath", "DestensionTemp", "destinateSystem", "destregationDisk", "destinateNow", "destinerHost", "destociationpath", "estinationpath", "destociationDir", "destificationUrl", "destositoryPath", "estinationTime", "descinationHost", "DestificationLocation", "destinatorpath", "origininatedChain", "destinateLocation", "destinatedDriver", "destinerDir", "chaininatedHome", "desticationPod", "destificationLocation", "chaininationPath", "destinateLog", "termininationPath", "origininationChain", "identinateInfo", "DestensionHost", "destinationDir", "estationDir", "destificationDir", "destinantDir", "destinationpath", "destinatorKey", "estinationPoint", "destitutionPath", "destesticAt", "destinationLocation", "estinoPath", "destranceLog", "destinationTemp", "origininatedForm", "identinationChain", "generinateJar", "destinatedChain", "DestificationPath", "estinationHost", "destinationPort", "identinationKey", "estionPoint", "destificationPath", "estionPath", "destitutionpath", "termininerpath", "destinateInfo", "DestensionPoint", "generinationSystem", "destrancePath", "destociationDisk", "destensionPod", "destATIONPort", "destinerPath", "DestinationTemp", "DestinationDir", "identinatePath", "destigationNow", "destinateUrl", "destinationPoint", "destociationLog", "destinatedInfo", "destitutionPoint", "estinationKey", "destregationPath", "destinatedDisk", "destventionDisk", "DestensionPod", "DestinationPath", "destinerAt", "destionpath", "destinationInfo", "destventionHome", "destinatorParent", "origininatedNow", "destationLocation", "destinationTime", "destinatedpath", "destationUrl", "DestificationUrl", "estationPath", "destinatorPATH", "destinoDir", "destinerPart", "destociationTarget", "destositoryPort", "origininationPath", "destinationForm", "descinationPort", "destinerTarget", "destinationJar", "destinationHome", " destinationTarget", "destociationDriver", "termininerPath", "destinatePart", "destventionDriver", "destinatedKey", "destinateKey", "chaininationDriver", "estionPATH", "destinatorInfo", "destinatePath", "delinationPoints", "destranceForm", "delinationLog", "destinerSystem", "destinationAt", "delinateLog", "destionPATH", "descinationPath", "destinatedNow", "DestinationLocation", "generinationAt", "destinateHost", "chaininatedDriver", "destinerJar", "chaininatedDisk", "destregationTarget", " destociationPath", "descositoryPort", "termininationJar", "identinationInfo", "destinatepath", "destATIONHost", "generinateSystem", "destigationForm", "destociationPoint", "destinationPoints", "destinationLog", "destinatedPath", "destinationHost", "destinatorPort", "origininationForm", "destinoTime", "termininationpath", "destinatedForm", "destinantPath", "destinoPath", "destinationPATH", "destrancePoints", "estinoName", " destinationDisk", " destociationDisk", "generinationJar", "estinoTime", "destinatedHome", "desticationDir", "DestinationPoint", "destacementKey", "destregationpath", "delinationForm"], "in": ["f", " IN", "ins", "din", "id", "IN", "io", "m", "bin", "c", "file", "reader", "doc", "i", "input", "r", "inner", "l", "t", "o", "d", "info", "w", "In", "n"], "out": ["cn", "f", "ins", "u", "cmd", "output", "go", "OUT", "co", "gr", "v", "b", "p", "dis", "ex", "screen", "ger", "println", "cache", "list", "gen", "s", "con", "e", "ln", "net", "io", "cfg", "print", "sys", "err", "conn", "raw", "outs", "it", "or", "c", "writer", "ou", "inv", "to", "report", "all", "obj", "res", "file", "aos", "nt", "msg", "ch", "nr", "can", "client", "write", "up", "inner", "oe", "conf", "null", "l", "os", "o", "log", "t", "Out", "w", "outer", "n"], "root": ["initial", "context", "scope", "node", "id", "p", "println", "New", "data", "chain", "group", "tree", "m", "table", "de", "_", "dir", "dump", "impl", "Root", "child", "parent", " roots", "name", "def", "graph", "r", "config", "se", "create", "json", "start", "parents", "ok", "roots", "Template"]}}
{"id1": "693636", "id2": "8135072", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createNewCart", " createNewOrder", "createZeroProduct", "createZeroCart", "createThisOrder", " createEmptyProduct", "createNewTransaction", "createThisCart", "createZeroOrder", "createNewProduct", " createEmptyOrder", " createNewProduct", "createThisProduct", "createEmptyProduct", "createThisTransaction", "createZeroTransaction", "createEmptyOrder", " createNewTransaction", "createEmptyTransaction", " createNewCart", " createEmptyTransaction", "createNewOrder"], "SHOPPING_ID": ["SHOPPTINGIDNAME", "SHOPPING_UID", "SHOPPINGITIDs", "SHOPPAP_ID", "SHOPPOTINGIDs", "SHOPPTING_NAME", "SHOPPINGIDIDS", "SHOPPAP_UID", "SHOPPINGPID", "SHOPPING_NAME", "SHOPPOTINGUID", "SHOPPINGVALID", "SHOPPIP_ID", "SHOPPTINGIDID", "SHOPPING_Id", "SHOPPINGITNUM", "SHOPPING_id", "SHOPPING_VID", "SHOPPINGIdVID", "SHOPPOT_IDs", "SHOPPINGPIDs", "SHOPPINGITUID", "SHOPPIP_id", "SHOPPOT_UID", "SHOPPTING_VID", "SHOPPINGPUID", "SHOPPAP_IDS", "SHOPPOT_NUM", "SHOPPING_IDs", "SHOPPINGINGIDS", "SHOPPINGITID", "SHOPPING_NUM", "SHOPPTING_URL", "SHOPPOTINGID", "SHOPPINGIDUID", "SHOPPINGIDURL", "SHOPPING_IDS", "SHOPPINGINGIDs", "SHOPPTINGIDURL", "SHOPPINGIDNAME", "SHOPPINGIDVID", "SHOPPTING_ID", "SHOPPINGINGNUM", "SHOPPINGIdURL", "SHOPPOT_ID", "SHOPPINGVALid", "SHOPPING_URL", "SHOPPOTINGNUM", "SHOPPINGVALUID", "SHOPPTINGIDVID", "SHOPPINGIDId", "SHOPPIP_UID", "SHOPPINGPNUM", "SHOPPINGINGId", "SHOPPINGINGID", "SHOPPINGINGUID", "SHOPPAP_Id", "SHOPPINGIdID", "SHOPPINGIDID", "SHOPPINGIdNAME"], "con": ["cn", "cover", "const", "cal", "en", "co", "cf", "ran", "rc", "com", "ex", "dial", "bo", "connect", "nc", "cc", "ln", "un", "ctx", "conn", "c", "pen", "re", "col", "Con", "ca", "bon", "pg", "connection", "mc", "Conn", "po", "gc", "ain", "cos", "pool", "ch", "cp", "pc", "ren", "soc", "CON", "open", "client", "cur", "win", "ctrl", "cat", "conv", "db", "conf", "cons", "coll", "ct", "xc", " conn", "fc", "cont", "can"], "insert_cart": ["import___pt", "import___controller", " insert2pt", "insert2controller", "insert_controller", "import_pot", "import_controller", "insert_art", "import_pt", "insert_start", "entry_art", "insertingpt", "insertTheprogress", "insert2pot", "insertMemart", "insertingart", " insert_cod", "insertPcart", "entry_cart", "entryMemprogress", "import_Cart", "insert2cart", "insert_article", "insertPart", "insertPpt", " insert2quant", "import_art", "insertThecart", "insertMemarticle", "insert_pt", "entryMemarticle", "entry_progress", "entryMemcart", "insertTheart", "insertptquant", "insert2article", "insert2Cart", "insert_quant", " insert_start", "entry_article", "insertMemprogress", "insert_progress", "insert2progress", "import___art", "insert_cod", "import___cart", "import_cart", "insert2start", "insertptart", "insert2quant", " insert2start", "insert_Cart", "insertMemcart", "insertPTquant", " insert2cod", "insert2pt", "insert___pt", "entryMemart", " insert2cart", " insert_quant", "insert___cart", "insertingstart", " insert_art", "insertPTart", "insert2cod", "insertThearticle", "insert2art", "insertptcod", "insertPcontroller", " insert_pt", "insertPTcart", " insert2art", "insert___art", "insertPTcod", "insertptcart", "insert_pot", "insert___controller", "insertingcart"]}}
{"id1": "19738435", "id2": "339517", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["match", "format", "pair", "service", "process", "parser", "xml", "request", "layer", "resource", "load", "link", "replace", "transform", "shape", "document", "arse", "file", "construct", "build", "slice", "se", "create", "proc", "json", "read", "handle"], "url": ["loc", "host", "el", "u", "sl", "ssl", "gl", "id", "https", "location", "ls", "dl", "char", "localhost", "string", "github", "path", "web", "ref", "q", "str", "parser", "ll", "xml", "term", "conn", "resource", "http", "nl", "link", "page", "browser", "ur", "impl", "sql", "URL", "document", "file", "build", "base", "address", "name", "open", "mount", "client", "input", "uri", "Url", "l", "abs", "util"], "target": ["context", "top", "object", "scope", "record", "container", "output", "node", "other", "model", "pattern", "instance", "path", "owner", "group", "tree", "term", "collection", "resource", "table", "to", "metadata", "report", "layout", "nt", "parent", "name", "template", "source", "graph", "type", "t", "root", "component", "local", "Target", "project", "result", "arget"], "parseURL": ["arsePage", "arseSR", "arseUrl", " parsePage", "buildSR", " parseSR", "parseSR", "arseURL", "buildURL", "parsePage", "parseUrl", "buildUrl", "buildPage", " parseUrl"], "connection": ["context", "established", "position", "channel", "Connection", "connect", "nc", "relation", "communication", "description", "con", "generation", "database", "network", "conn", "entry", "application", "c", "resource", "writer", "response", "link", "socket", "creator", "session", "document", "connected", "directory", "open", "ion", "client", "still", "character", "uri", "created", "cone", "condition", "command", "result"], "charset": ["CHarsat", "charsetter", "cheresset", "chereset", "CHARSets", "chactersET", "CHarsets", "chagnheet", "chARSets", "chasset", "chatset", "chasheet", "chresset", "CHarsetter", "charasheet", "chARSat", "chactersetter", "charsets", "charsset", "charaset", "chasET", "chearset", "charsat", "CHarset", "charsect", "chagnET", "cheresets", "chagnet", "chatsets", "chagnset", "charsET", "chearsset", "chearsect", "chatsset", "CHARSetter", "chararset", "chararsET", "chreset", "chARSet", "chararsset", "charasset", "chararsheet", "chactersect", "cheresect", "charsheet", "chacterset", "chatsect", "chactersset", "charasET", "chearsets", "CHARSat", "chactersat", "chresect", "chactersheet", "CHARSet", "chARSetter", "chaset", "chactersets", "chresets"], "reader": ["context", "readable", "processor", "stream", "red", "upper", "data", "message", "iterator", "driver", "io", "handler", "buffer", "parser", "entry", "loader", "layer", "resource", "writer", "runner", "reading", "document", "builder", "file", "Reader", "rar", "event", "client", "ner", "input", "r", "iter", "inner", "source", "uri", "row", "read"]}}
{"id1": "3024987", "id2": "6188784", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Decoded"], "in": [" IN", "mi", "ins", "din", "inside", "copy", "p", "ini", "cont", "data", "IN", "sin", "inn", "con", "Input", "inf", "gin", "cin", "m", "ac", "bin", "mm", "from", "it", "init", "as", "mc", "act", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "iter", "l", "isin", "info", "local", "read", "In", "n"], "reader": ["dr", "mr", "red", "data", "ocker", "er", "iterator", "driver", "io", "handler", "Larry", "buffer", "phrase", "parser", "loader", "writer", "rl", "reading", "ro", "req", "query", "file", "rr", "rar", "Reader", "rx", "per", "ner", "r", "input", "iter", "inner", "oe", "rise", "row", "rot", "read"], "baout": ["boout", "BAin", "caos", "beanout", "cain", "baouts", "beanin", "caouts", " baot", "oaos", "haouts", "beanouts", "caout", "haout", "yares", "oaout", "hain", "BAot", "yain", "bares", "baos", " bain", "yaot", "bain", "oain", "caOut", "BAout", "boos", "haOut", "oaOut", "boOut", "boin", " bares", "baOut", "BAres", "beanOut", "baot", "yaout"], "out": ["cn", "update", "cmd", "copy", "output", " OUT", "OUT", "b", "ex", " os", "bo", " Out", "stable", "gt", "con", "net", "ne", "io", "sys", "outs", "OU", " bout", "ou", "to", "all", " outs", "res", "auto", "batch", "cos", "client", "oss", "conv", "ao", "os", "null", " output", "o", "t", "Out", "outer", "n"], "bytes": ["pdf", "terms", "words", "comments", "binary", "bs", "bits", "values", "videos", "classes", "data", "cells", "ips", "vals", "gets", "files", "strings", "issues", "Bytes", "outs", "raw", "gs", "bps", "reads", "users", "pieces", "des", "letters", "reports", "ites", "tes", "seconds", "ies", "objects", "services", "latest", "resources", "parts", "ings", "pages", "es", "results", "lines", "les", "versions", "its", "unks", "names", "groups", "faces", "units", "frames", "blocks", "ones"]}}
{"id1": "442381", "id2": "8770016", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionQuery", "doVersionsUpdate", " doVersionTest", "doBuildCheck", "doFeaturecheck", "doFeatureInfo", "doFeatureQuery", " doVersionQuery", "doImageInfo", "doFeatureCheck", " doApplicationQuery", " doVersionsTest", "doVersionsTest", "doApplicationCheck", "doFeatureUpdate", "doApplicationInfo", "doImageQuery", " doVersionUpdate", " doVersionsUpdate", " doVersioncheck", "doBuildUpdate", "doBuildcheck", "doImageCheck", "doVersionscheck", " doVersionInfo", "doVersionsCheck", "doFeatureTest", "doApplicationQuery", " doApplicationCheck", " doApplicationInfo", " doVersionscheck", "doBuildTest", "doVersionInfo", "doVersioncheck", "doImageTest", " doApplicationTest", "doVersionUpdate", "doVersionTest", " doVersionsCheck", "doApplicationTest"], "view": ["image", "update", "iew", "context", "server", "engine", "VIEW", "v", "port", "model", "show", "self", "window", "review", "ml", "form", "box", "print", "buffer", "q", "cell", "tree", "subject", "block", "eye", "http", "page", "cv", "browser", "report", "query", "document", "file", "layout", "tv", "widget", "controller", "pool", "see", "this", "lock", "call", "client", "check", "display", "h", "View", "virtual", "input", "vm", "manager", "version", "row", "html", "project", "component", "index", "views"], "url": ["loc", "rel", "f", "host", "sl", "ssl", "domain", "gl", "b", "v", "dl", "hl", "char", "bel", "ref", "str", "oul", "ll", "rl", "http", "ul", "nl", "link", "browser", "ur", "URL", "file", "build", "address", "mount", "mail", "client", "pl", "get", "lb", "r", "uri", "Url", "l", "log", "html", "job"], "in": ["f", " IN", "ins", "din", "isin", "stream", "IN", "sin", "inn", "ln", "inf", "cin", "gin", "on", "from", "init", "mn", "body", "ain", "reader", "is", "inc", "can", "out", "rin", "i", "input", "source", "inner", "l", "asin", "mat", "vin", "info", " din", "In", "n"], "bin": ["ins", "din", "jin", "bl", " bins", "lib", "binary", "b", "ran", "abin", "bed", "bn", "stock", "cache", "sin", "inn", "con", "ln", "bi", "cin", "gin", "buffer", "nb", "local", "by", "re", "spin", " Bin", "bg", "all", "session", "init", "thin", "sam", "brain", "file", "body", "cos", "reader", "out", "rin", "win", "len", "inner", "db", "conv", "obin", "rb", "bur", "buff", "cb", " din", "ebin", "mon"], "line": ["column", "cmd", "record", "ine", "field", "stream", "style", "liner", "port", "channel", "eline", "zone", "message", "char", " block", "detail", "string", "ice", "ln", "lo", "le", "chain", "print", "sequence", "cell", "section", "block", "lin", "entry", "rule", "err", "part", "status", "trace", "frame", "tile", "Line", "link", "inline", "page", "stay", "comment", "range", "key", "file", "lane", "code", "base", "word", "iter", "cat", "l", "lines", "row", "parse", "next", "log", "LINE", "sample", "point", "job"], "develBuild": ["deffbuild", "DeVELbuild", "deVELLog", "develRelease", "deVELBuilder", "Develbuild", "depoBuilt", "duvelbuild", "devBoot", "desvelbuild", "desvelRelease", "duffbuild", "depobuild", "depoLog", "develLoad", "duVELBuild", "deVELbuild", "desVELbuild", "deVELBuild", "duffBuilt", "deeltaLoad", "devbuild", "DevelLog", "develbuild", "deffBuilder", "deployBuilt", "DevelBuild", "duvelBuilt", "deffBuilt", "duffBuilder", "deployLoad", "desvelLoad", "develBuilder", "duvelBuild", "duvelBuilder", "deVELBoot", "duvelBoot", "DeVELLog", "deVELLoad", "desVELRelease", "deploybuild", "deployBuilder", "DeVELBuilt", "devBuilder", "develLog", "DevelBuilt", "duffBuild", "deployBoot", "duVELBoot", "duVELbuild", "develBuilt", "DeVELBuild", "deVELRelease", "deeltaRelease", "devBuild", "deVELBuilt", "deeltaBuild", "devBuilt", "deployRelease", "depoBuild", "desVELLoad", "devLog", "desvelBuild", "deployBuild", "deffBuild", "duVELBuilder", "deeltabuild", "develBoot", "desVELBuild"], "stableBuild": ["activeMake", " stableCraft", "activeBuild", "stableBind", " unstableLong", " unstableBuild", "stableBoot", " stableBuilder", " stableMake", " unstablebuild", "stableCraft", "confirmedBoot", "secureBuilder", "devbuild", " stablebuild", " stableBoot", " stableBind", "stablebuild", "secureBuild", "activeBuilder", " unstableBuilder", "confirmedbuild", "confirmedBuild", "stableBuilder", "securebuild", " unstableBind", "devBuilder", "secureCraft", "stableLong", "devBind", " unstableCraft", "devBuild", "devMake", "stableMake", " stableLong", "confirmedLong", "activebuild", " unstableBoot"]}}
{"id1": "10385815", "id2": "23370621", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" duplicate", "move", "transfer", "sync", "csv", "delete", "Cop", "clip", "opy", "cop", "load", "upload", "replace", "paste", "Copy", "file", "cp", "slice", "write", "clone", "create", "cat", "rm", " copying", "save", "download", "read"], "fileFrom": ["fileObject", "fileA", "projectInitial", "FileTo", "sampleStart", "inputTo", "projectFrom", "ileObject", "inputForm", "inputObject", "projectStart", "FileForm", "projectA", "FileFrom", "ileFrom", "ileForm", " fileA", "sampleA", "sampleFrom", " fileInitial", "ileTo", "fileStart", "fileInitial", "fileForm", " fileStart", "sampleInitial", "FileObject", "inputFrom"], "fileTo": ["FileTo", "FileTO", " fileDest", " fileTO", "modelDest", "ileDest", "modelTO", "fileDest", "ileTarget", "File2", " fileTarget", "modelTarget", "ile2", "FileTarget", "modelTo", "FileDest", "ileTo", " file2", "file2", "fileTO", "fileTarget"], "inputStream": ["imageStreamer", "audioStream", " inputSource", "activeStreamer", "imageSteam", "activeStream", "activeSteam", "importChannel", "sourceStream", "imagestream", "audioSteam", "InputSteam", "audiostream", "sourceChannel", "importStream", " inputSteam", "inputStreamer", "activeChannel", "inputSteam", "inputstream", "audioStreamer", "InputSource", "InputChannel", "sourceSource", "sourceSteam", "importFile", "InputStreamer", "importSteam", " inputFile", "InputStream", "inputSource", "eventSteam", "InputFile", "imageStream", "eventStream", "eventstream", "imageChannel", "eventStreamer", "inputFile"], "outputStream": [" outputSteam", "displaystream", "displayStream", "displaySteam", "outputString", "Outputstream", "webFile", "writeSocket", "OutputFile", "outputstream", "OutputChannel", "resultStream", " outputString", "OutputStream", "inputString", "inputSteam", "outputSocket", "resultChannel", "inputstream", "webStream", "OutputSteam", "outputFile", "resultSocket", "webString", " outputFile", "webChannel", "writeStream", "outputSteam", "webSteam", "displayChannel", " outputSocket", "resultSteam", "writeChannel", "writeSteam"], "inputChannel": ["currentCategory", "readChan", "InputCamera", "InputChan", "readChannel", "inputChan", "createSteam", " inputChain", "localChannel", "currentChannel", "operatorChannel", "readableConnection", "outputChan", "operatorConnection", "inputChain", "operatorStream", " inputSteam", "readableChan", " inputConnection", "readChain", "inputSteam", "createChan", "currentChain", "localChan", "inputCamera", "InputChannel", "readCategory", "currentChan", "InputStream", "inputCategory", " inputCategory", "outputSteam", "operatorCamera", "inputConnection", "createChannel", "createStream", " inputChan", " inputCamera", "outputConnection", "readableChannel", "localConnection", "InputConnection"], "outputChannel": ["updatechannel", "outputCategory", "outputContext", "outputChan", "writeContext", "Outputchannel", "outputchannel", "OutputChannel", "OutputCategory", "putStream", "OutputChan", "OutputStream", "writeConnection", "putChan", " outputContext", " outputchannel", "successChannel", "hiddenchannel", "OutputContext", "successchannel", "updateCategory", " outputConnection", "hiddenCategory", "hiddenChan", "updateChan", "hiddenChannel", "successConnection", "OutputConnection", "successStream", " outputChan", "updateChannel", "outputConnection", "writeChan", "putChannel", "writeChannel", "putchannel"]}}
{"id1": "10504714", "id2": "12055086", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getByUrpi", "getByUpi", "getFromUrURI", "getFromUris", "getFromIURI", "getFromUrris", "getByUrURI", "getByUri", "getFromUURI", "getFromUpi", "getByUris", "getFromOURI", "getByUURI", "getFromOris", "getFromIri", "getFromIris", "getByUrris", "getFromUrri", "getFromOri", "getFromIpi", "getFromUrpi", "getByUrri", "getFromOpi"], "url": ["loc", "host", "u", "ssl", "b", "id", "https", "location", "ls", "dl", "pattern", "hl", "char", "string", "path", "web", "ref", "q", "rect", "str", "xml", "ll", "http", "ul", "nl", "link", "page", "ur", "URL", "file", "build", "base", "address", "name", "mount", "mail", "ob", "full", "pl", "r", "uri", "Url", "l", "json", "cl", "util", "remote", "html", "result"], "connection": ["context", "server", "engine", "established", "position", "channel", "Connection", "relation", "connect", "communication", "message", "con", "io", "generation", "database", "network", "conn", "application", "entry", "c", "collection", "resource", "http", "response", "link", "socket", "session", "document", "builder", "connected", "directory", "open", "ion", "client", "character", "still", "uri", "close", "cone", "statement", "creation", "condition", "command", "opening"], "bin": ["jiang", "din", "output", "inning", "binary", "b", "ran", "abin", "bn", "bean", "data", "sin", "inn", "con", "ln", "bi", "cin", "buffer", "gin", "cgi", "bank", "in", "tin", "spin", " Bin", "browser", "sam", "file", "body", "soc", "rin", "win", "skin", "bian", "len", "obin", "bytes", "vin", "ebin", "n"], "jaxbContext": ["jaxccontext", "jAXpManager", "jaxbcontext", "jAXbcontext", "jaxcFactory", "javbFactory", "jaxcContext", "javccontext", "javcContext", "jaxbaManager", "jaxpForm", "jaxbFactory", "jAXbContext", "jaxBManager", "jAXbInstance", "jaxbacontext", "jaxbcForm", "jaxbForm", "jaxBContext", "jaxBInstance", "javbContext", "jaxbManager", "jaxbcContext", "jaxbInstance", "jaxBcontext", "jAXpContext", "jaxpFactory", "jaxpcontext", "jaxbcFactory", "jaxbaInstance", "jAXpInstance", "jaxbccontext", "jaxpInstance", "jaxpContext", "jAXpcontext", "jAXbManager", "javbForm", "jaxcForm", "javbcontext", "javcForm", "jaxpManager", "jaxbaContext", "javcFactory"], "unmarshaller": ["unmeshcalller", "unmarshAlller", "unmarsharsger", "unmarsharser", "unmapperellter", "unmarsharster", "unmeshaller", "unmarshAller", "unmarshcallers", "unmarshalr", "unmapperallter", "unmapperallger", "unmarshAllrer", "unmeshallr", "unmarshallter", "unmappereller", "unmeshcaller", "unmeshallers", "unmarshalller", "unmarshcallr", "unmapperellrer", "unmarshellter", "unmeshcallr", "unmeshalller", "unmarshcaller", "unmarshAllter", "unmarshellrer", "unmarsharsrer", "unmeshcallers", "unmarsheller", "unmarshaler", "unmarshallr", "unmarshallrer", "unmarshAllers", "unmarshAllger", "unmarshallers", "unmarshalers", "unmarshcalller", "unmapperallrer", "unmarshellger", "unmarshAllr", "unmarshallger", "unmapperellger", "unmapperaller"]}}
{"id1": "23510383", "id2": "19096138", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": [" SaveFile", " savePackage", "createPackage", "saveApp", "createProject", "createApp", " saveApp", " SaveApp", "saveFile", " SaveProject", "createFile", " saveFile", "savePackage", " SavePackage"], "file": ["image", "id", "port", "data", "path", "e", "foo", "io", "complete", "files", "real", "in", "File", "resource", "table", "FILE", "link", "report", "dir", "base", "parent", "open", "ame", "ile", "get", "full", "filename", "create", "db", "log", "use", "info", "local", "project", "handle"], "types": ["assets", "models", "values", "sets", "classes", "events", "features", "items", "packs", "times", "files", "actions", "strings", "packages", "issues", "tests", "options", "apps", "ties", "ypes", "thumbnails", "ts", "otypes", "codes", "styles", "objects", " Types", "pes", "services", "Types", "keys", "resources", "posts", "parts", "scripts", "pages", "sites", "ports", "versions", "projects", "plugins", "ids", "names", "groups", "tags", "views"], "images": ["image", "assets", "models", "videos", "classes", "events", "files", "picture", "links", "boxes", "thumbnails", "Image", "styles", "Images", "scripts", "pages", "uploads", "versions", "tags", "media", "faces", "groups", "frames", "blocks", "photos", "views", "icons"], "trajectories": ["tractories", "Trajors", "trajory", "Trajectors", "Trajables", "tractables", "Trajectables", "tractory", "Trajectory", "tractors", "traceptories", "Trajories", "trajectables", "Trajory", "trajables", "trajories", "traceptors", "trajors", "traceptables", "trajectors", "traceptory", "Trajectories", "trajectory"], "databasesIncluded": ["databasesInglisted", "databasesedIncluded", "datadesInified", "datadesInclusion", "daturesIncluded", "daturesInlisted", "daturesInslisted", "databasesedInified", "databasesINified", "databasesInsclusion", "databasesInified", "databasesInsjected", "databasesINclusion", "databasesedInlisted", "datadesInscluded", "databasesINjected", "datadesInsified", "databasesInclusion", "datadesInsjected", "datadesIncluded", "daturesInsclusions", "databasesIngclusions", "datadesInjected", "databasesInslisted", "daturesInclusions", "databasesedInjected", "databasesInsclusions", "databasesedInclusions", "databasesInlisted", "databasesInsified", "daturesInscluded", "databasesInclusions", "databasesInscluded", "databasesedInclusion", "databasesInjected", "databasesIngcluded", "databasesINcluded", "datadesInsclusion"], "onlyLinks": ["forceLink", "forcelinks", "Onlylinks", " onlyLink", " onlylinks", "forceLinks", "OnlyLinks", "alsoLink", "onlyLink", "onlylinks", " onlyRelations", "alsoRelations", "OnlyLink", "alsoLinks", "onlyRelations", "OnlyRelations"], "index": ["initial", "update", "length", "max", "num", "nn", "loc", " Index", "position", "match", "ex", "connect", "sequence", "offset", "set", "zero", "add", "Index", "all", "x", "amount", "address", "pos", "ind", "open", "ion", "inc", "check", " sidx", "no", "number", "i", "find", "fail", "second", "end", "first", "info", "n"], "name": ["image", "id", "data", "nm", "about", "path", "string", "me", "m", "man", "Name", "table", "NAME", "prefix", "run", "base", "parent", "none", "word", "system", "ame", "full", "title", "filename", "create", "default", "named", "root", "names", "primary", "local", "n"], "format": [" Format", "cal", "mt", "value", "MAT", "style", "v", "scale", "fm", "data", "language", "pattern", "list", "color", "form", "print", "percent", "set", "term", "it", "table", "pretty", "init", "prefix", "layout", "base", "unit", "get", "parse", "default", "printf", "Format", "util", "use"], "count": ["length", "ount", "z", "num", "flag", "mark", "sum", "total", "order", "process", "err", "set", "c", "error", "size", "table", "add", "skip", "code", "amount", "depth", "found", "counter", "reset", "start", "Count"], "version": ["translation", "record", "server", "header", "v", "Version", "video", "VER", "mint", "description", "about", "database", "tree", "xml", "section", "alone", "vers", "major", "j", "page", "ver", "python", "connection", "document", "draft", "build", "parent", "java", "latest", "current", "virtual", "number", "json", "versions", "summary", "journal", "root", "release", "VERSION", "information", "result"], "writer": ["access", "output", "writers", "operator", "stream", "server", "woman", "language", "data", "window", "er", "description", "external", "service", "driver", "iterator", "order", "editor", "handler", "buffer", "print", "sw", "walker", "maker", "entry", "wrapper", "wrote", "author", "to", "creator", "report", "browser", "comment", "writ", "wright", "document", "builder", "console", "caster", "function", "connection", "reader", "client", "counter", "write", "writing", "inner", "written", "variable", "flush", "journal", "Writer", "w", "outer"], "xmlDir": ["mlFile", " xmldir", "xmlFolder", "logDirectory", "mlFolder", " xmlFolder", "imageFolder", "xmlDirectory", "xmldir", "imagedir", "logFolder", "logDir", " xmlFile", "logdir", "logFile", " xmlDirectory", "imageDirectory", "imageDir", "xmlFile", "mlDirectory", "mlDir"], "databases": ["generabase", "Datates", "Datasha", "mutasha", " datates", "Datases", " datases", " database", "baselines", "datures", "basabases", "datates", " datasha", "database", "Database", " datas", "notables", "generabases", "mutabases", "notabases", "generas", "mutables", "Datables", "notures", "notelines", "datasha", "Datas", "basables", "datelines", "mutases", "basures", "Datures", " datables", "Databases", "datas", "Datelines", "datases", "datables", "generates"], "t": ["k", "ot", "mt", "id", "v", "p", "typ", "tc", "te", "s", "e", "q", "str", "pt", "term", "it", "c", "j", "ts", "x", "y", "tr", "txt", "h", "template", "i", "tm", "ct", "o", "temp", "T", "w", "tt", "n"], "type": ["top", "object", "TYPE", "pe", "ty", "style", "p", "other", "id", "match", "class", "typ", "language", "relation", "instance", "te", "test", "rule", "ime", "error", "resource", "single", "ping", "link", "to", "ver", "tag", "key", "shape", "base", "address", "y", "this", "unit", "role", "check", "template", "title", "config", "ype", "null", "Type", "parse", "time", "tool", "root", "site", "kind", "info", "module", "result", "action"], "currentName": [" currentNames", "CurrentNames", "baseName", "currentPort", "currentDir", "baseOrder", " currentParent", "reportedTime", "CurrentLock", "CurrentDir", "updateName", "thisSet", "currentTime", "currentlyPath", "reportedDir", "reportedName", "completeName", "CurrentPath", "currentYear", "basePort", " currentOrder", "currentlySet", "currentlyKey", "currentOrder", "currentParent", "reportedParent", "currentlyName", "completeSet", "currentPath", "currentSet", "CurrentParent", "updateOrder", "currentlyTime", "reportedLock", "currentlyYear", "thisName", "CurrentName", "completeKey", " currentPort", "thisKey", "currentNames", "reportedPath", " currentFace", "currentLock", " currentDir", "currentFace", "thisYear", "baseFace", "updatePort", "currentKey", "currentlyLock", "reportedNames", "CurrentTime", "completeYear", "updateFace"], "baseCopy": ["parentCopy", "baseName", " baseName", " baseStore", "baseStore", "basiccopy", "basicCop", "parentcopy", " basecopy", "buffercopy", "BaseName", "parentCop", "basecopy", "Basecopy", "BaseCop", "baseCop", "basicStore", " baseCop", "basicCopy", "bufferCopy", "BaseCopy", "BaseStore", "bufferCop", "parentName"], "source": ["initial", "original", "scope", "store", "search", "stream", "shell", "scan", "SOURCE", "channel", "data", "select", "service", "ources", "iterator", "owner", "target", "origin", "sequence", "ource", "src", "space", "subject", "from", "resource", "join", "size", "init", "connection", "console", "base", "parent", "reader", "before", "system", "input", "se", "create", "inner", "start", "Source", "sample", "site", "local", "master"], "destination": ["Destuation", " destinated", "declination", " destructure", "destructure", "Destregation", "destregation", "datinator", "datinations", "Destination", "declinations", "Destructure", "Destinated", "destuation", "Destinations", "datination", "Destinator", " destuation", "messination", "declinator", "messinations", "messructure", "destinations", " destinations", "messinated", "messuation", "datregation", "destinated", "declregation", "destinator"], "clefs": [" CleFs", " cleFS", "CleFs", "clefits", "CLEcs", " cleFs", " clebs", "Clefs", "cleFs", " Clecs", "clebs", " Clebs", "CLEFs", " Clefits", "CLEfs", "CleFS", "Clebs", " Clefs", "Clecs", "CLEfits", "cleFS", " CleFS", "clecs", "Clefits"], "st": ["sth", "dd", "sl", "mt", "bl", "std", "sts", "sc", "sn", "str", "irst", "pt", "sw", "it", "St", "inst", "fr", "storage", "ts", "sy", "query", "sb", "sp", "bt", "est", "h", "cr", "se", "ST", "ste", "statement", "cl", "ost", " ST", "start", "ct", "ist", "rest", "stat", "stra", "tt", "sm"], "rs": ["ins", "rt", "mr", " RS", "cs", "rc", "ris", " ms", "ls", "sts", "ers", " ins", " iss", "RS", "Rs", "rys", "ds", "ts", "as", " pts", "res", " ps", " cs", "os", "ks", "rd", " sr", "ps"]}}
{"id1": "6963063", "id2": "4164833", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"mas": ["mons", "oos", "masters", "rums", "pres", "mos", "makes", "ris", "sts", "bs", "ists", "phas", "dal", "las", "alis", "ales", "mad", "bas", "amas", "aus", "wal", "ms", "ints", "nets", "asis", "marks", "vers", "mares", "sels", "boxes", "mes", "ares", "tis", "ams", "ims", "as", "men", "lists", "ma", "aos", "mont", "vs", "phis", "mast", "stal", "mis", "lands", "ras", "jas", "ames", "cas", "ias", "als", "mus", "finals", "pse", "MAS", "mails", "eas", "asks", "pas", "mers", "rices", "Mas", "stro", "ums", "sa", "mon"], "sort": ["store", "search", "ord", "port", "scale", "alpha", "sup", "alt", "rol", "sum", "lower", "s", "index", "order", "test", "val", "weight", "Sort", "it", "rank", "status", "score", "orted", "label", "trans", "ort", "orting", "dir", "late", "share", "orts", "send", "tmp", "ORT", "tr", "pos", "lock", "ind", "cmp", "su", "rm", "l", "start", "desc", "default", "orter", "ist", "save", "use", "first", "lib", "min"], "j": ["k", "ia", "z", "adj", "dj", "v", "other", "job", "jj", "jp", "ge", "jc", "aj", "q", "m", "it", "js", "jump", "ja", "J", "ij", "fr", "jl", "obj", "x", "kj", "ji", "ie", "at", "ind", "lock", "jas", "bj", "nr", "pr", "br", "is", "uj", "g", "json", "jit", "jo", "im", "oj", "n"], "i": ["cli", "mi", "id", "ri", "port", "status", "gu", "g", "di", "asi", "gi", "ci", "ni", "\u0438", "info", "I", "pi", "ia", "ix", "php", "iti", "io", "chain", "m", "iso", "ki", "multi", "it", "ic", "ret", "li", "xi", "init", "ori", "ji", "ind", "is", "fi", "fire", "qi", "si", "me", "iu", "in", "ie", "zi", "iii", "iri", "iy", "uri", "ip", "ish", "ami", "wi", "iq", "ir", "ini", "ii", "ai", "bi", "origin", "yi", "sim", "ei", "ij", "ti", "hi", "phi", "ui", "iter", "im", "oi"]}}
{"id1": "17161805", "id2": "2168610", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"encode": ["enode", "uncode", "ensforce", "ensode", "ensprocess", "encprocess", "unode", "unprocess", "enccode", "encforce", "enprocess", "Encode", "enforce", "Enode", "unforce", "enscode", "Enforce"], "plaintext": ["formmessage", "pronth", "plainText", " plainText", "ainmessage", " plaindata", "formtext", "mainText", "mainth", "aintext", "aindata", "mainlat", "pronlat", " plainth", "formText", "pronText", "formdata", "maintext", "plainth", "prontext", " plainlat", "plainmessage", "plainlat", " plainmessage", "plaindata", "ainText"], "md": ["del", "pdf", "cmd", "dd", "dr", "mt", " MD", "amd", "der", "mo", "red", "sha", "mg", "dh", "mk", "sd", "med", "od", "ms", "m", "mm", "pm", "pd", "mod", "add", "mc", "mn", " Md", "df", "managed", "mp", "nt", "msg", "dm", "mand", "det", "ind", "mb", "grad", "ld", "cd", "bd", "hd", "d", "ng", "MD", "sm"], "raw": ["cmd", "value", "sh", "strip", "wrap", "message", "derived", "stable", "buf", "bare", "clean", "modified", "valid", "rendered", "pack", "custom", "map", "cooked", " Raw", "orig", "des", "hex", "RAW", "def", "serial", "full", "mem", "input", "Raw", "unsigned", "inner", "json", "row", "unknown", "aw", "bytes", "bound", " RAW", "read", "n"]}}
{"id1": "8747840", "id2": "4468255", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["move", "transfer", " Copy", "sync", "csv", "delete", "clip", "map", "load", "add", "link", "upload", "paste", "Copy", "gc", " mirror", "cp", "slice", "write", "clone", "create", "cat", " copying", "save", " replicate", "download", " cp", "read"], "src": ["rel", "iv", "ins", "rc", "bs", "rs", "sc", "usr", "sin", "sys", "obs", "via", "st", "sq", "sf", "pkg", "sec", "from", "inst", "sit", "ser", "req", "init", "urg", "img", "sb", "rx", "txt", "ipl", "source", "input", "syn", "cur", "start", "sur", "ctr", "sr", "Source", "cont"], "dest": ["loc", "del", "th", "https", "Dest", "self", "mk", "gt", "usr", "way", "target", "nw", "test", "origin", "mm", "pub", "st", "dist", "spec", "sit", "orig", "req", "trans", "des", "nom", "tmp", "nt", "est", "master", "good", "opt", "source", "null", "decl", "pas", "rest", "end", "d", "temp", "deg", "cont"], "in": ["ins", "din", "inside", "en", "id", "rc", "old", "ze", "IN", "inn", "con", "ln", "ai", "inf", "cin", "gin", "mm", "on", "bin", "from", "ar", "ic", "it", "init", "impl", "al", "ain", "ind", "inc", "up", "rin", "source", "input", "i", "iter", "inner", "info", "isin", "im", "In"], "out": ["ot", "output", "en", "OUT", "co", "p", "dis", "ex", "sum", "gt", "con", "over", "net", "io", "ne", "sys", "n", "on", "err", "bin", "conn", "outs", "it", "by", "writer", "ou", "to", "obj", "res", "auto", "aos", "nt", "ch", "client", "write", "oss", "g", "inner", "os", "conv", "not", "o", "t", "end", "Out", "at", "outer", "can"], "buf": ["arr", "cmd", "bl", "b", "bs", "vec", "bed", "uf", "data", "gen", "box", "ref", "queue", "buffer", "aka", "str", "block", "pkg", "fb", "col", "bar", "stab", "bh", "cv", "cap", "cam", "bag", "fg", "seq", "Buff", "batch", "msg", "mb", "good", "used", "br", "bus", "cat", "conv", "db", "tab", "rb", "Buffer", "mu", "prop", "buff", "bytes", "log", "cb", "temp"], "c": ["k", "z", "b", "cs", "co", "rc", "cu", "cf", "count", "cache", "ec", "dec", "nc", "unc", "cc", "jc", "m", "ac", "C", "cod", "a", "dc", "ca", "gc", "mc", " C", "code", "cos", "ch", "cp", "uc", "call", "i", "cr", "bc", "conf", "l", "cd", "ci", "ct", "t", "ce", "cm", "d", "cb", "lc", "fc", "cont", "n"]}}
{"id1": "3266833", "id2": "14758866", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"is": ["isa", "isl", "sis", "fs", "lis", "iss", "bits", "bs", "ris", "serv", "ists", "isi", "us", "s", "sys", "any", "iso", "has", "in", "bis", "ois", "init", "as", "IS", "iris", "Is", "isc", "get", "i", "parts", "isf", "os", "ais", "its", "isin", "info", "was", "ios"], "name": ["image", "length", "value", "search", "id", "position", "location", "class", "data", "self", "format", "description", "admin", "string", "path", "order", "sequence", "normal", "term", "in", "Name", "part", "size", "alias", "NAME", "prefix", "key", "handle", "file", "body", "base", "parent", "code", "word", "family", "current", "this", "ame", "template", "number", "title", "source", "filename", "create", "get", "i", "null", "version", "type", "default", "url", "named", "names", "info", "local", "n"], "contentType": ["mediaControl", "ContentType", "ContentTypes", "messageTypes", "fileQuery", " contentLength", " contenttype", "messageQuery", " contentUnit", "mediaUnit", "contentQuery", " contentControl", "mediatype", "messageControl", "messageType", "mediaType", "contentLength", "fileTypes", "fileLength", "contentUnit", "messageUnit", " contentTypes", "messagetype", "contentTypes", "contentControl", "messageLength", "mediaLength", "ContentLength", "mediaTypes", "fileType", "Contenttype", "mediaQuery", "contenttype"], "index": ["image", "max", "length", "update", "num", "access", "value", "id", "position", "dx", "count", "exclusive", "level", "instance", "list", "content", "si", "path", "test", "sequence", "sort", "offset", "fee", "error", "timeout", "size", "Index", "prefix", "key", "x", "batch", "code", "address", "pos", "axis", "ind", "slice", "open", "lock", "depth", "height", "number", "i", "create", "find", "start", "type", "row", "success", "action", "info", "n"], "extension": ["protension", "xtend", "extend", "extention", "extitude", "contension", "protention", "protitude", "xtention", "xtension", "contention", "contitude", "protend", "contend", "xtitude"], "isImage": ["isMedia", "isItemImage", "hasMedia", "areFile", " isFile", "areItemImage", "isaImage", "needsImage", "needsPhoto", "isPhoto", "isoFile", "ISPicture", "needsFile", "hasImage", "isoImage", "isoMedia", "wasimage", "isoItemImage", "ISImage", "hasFile", "isaimage", "wasFile", "isimage", "areImage", "needsMedia", "needsimage", "isFile", "isPicture", " isItemImage", "areMedia", "isaPhoto", "needsPicture", "ISimage", "isaPicture", "hasimage", "wasMedia", "wasImage", "ISPhoto", " isMedia"], "isAux": ["isaux", "isAndaux", "isinPaux", "isAaux", "isAcux", "isNAUX", "isauxe", "isiAuxe", "isAuxe", "isAiox", "isinAUX", "isAult", "isAUX", "isAcx", "isiOAaux", "isOAxx", "isiAux", "isiAaux", "isinPaUX", "isAmp", "isPaUX", "wasAUX", "isiAiox", " isCAUX", " isCAux", "isaiox", "isCAiox", "isNAux", "isAx", " isAx", "isCAUX", "isinPaaux", "isAAult", "isSAaux", "isSAux", "isPaux", "wasAult", "isAAUX", "isNAmp", "isiOAiox", "isOAUX", "wasAAux", "isOAiox", " isAUX", "isPaaux", "isCAaux", "isSAmp", " isCAx", "isiOAux", "isAxx", "isNAaux", "wasAux", "isiOAuxe", "isOAult", "isAAxx", "isAAux", "wasAAxx", "isAndux", "isAndx", "isinAaux", "isaaux", "wasAAult", "isPamp", "isinAux", "isOAux", "wasAAUX", "isOAuxe", " isCAaux", "isAcaux", "isinPamp", "wasAxx", "isCAux", "isCAx", "isAndUX", "isOAaux", "isAcUX", "isinAmp", " isAaux", "isSAUX", "isCAuxe"], "out": ["cn", " OUT", "output", "go", "OUT", "co", "b", "p", "v", "port", "ex", "cache", "we", "sum", " Out", "list", "ent", "boot", "con", "order", "user", "net", "io", "chain", "sys", "in", "conn", "outs", "it", "by", "timeout", "OU", "vol", "to", "all", "gc", "res", "result", "auto", "batch", "tmp", "nt", "aos", "pool", "cos", "pos", "lock", "this", "ion", "up", "oss", "conv", "os", "null", " output", "o", "t", "log", "Out", "at", "w", "outer", "n"], "bufferedImage": ["renderingImages", "bufferredImage", "buffererImages", "buffererVideo", "bufferredImages", "renderedImage", "bufferingImages", "bufferredimage", "buffererimage", "renderingimage", "bufferedimage", "bufferingimage", "bufferingVideo", "bufferedImages", "renderedimage", "bufferingImage", "renderedImages", "bufferedVideo", "renderedVideo", "bufferredVideo", "renderingImage", "buffererImage", "renderingVideo"], "inputStream": ["InputView", "outputStream", "inputView", "outputSteam", "inputSteam", "outputstream", "Inputstream", "currentstream", "outputView", "InputSteam", "currentView", "currentStream", "currentSteam", "inputstream", "InputStream"]}}
{"id1": "7911686", "id2": "16142024", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " CopyFiles", "copyfile", " cpFile", " cpFiles", " cpfile", " CopyStream", "CopyFiles", "CopyFile", "copyFiles", "CopyStream", "Copyfile", " CopyFile", " cpStream", " Copyfile"], "source": ["image", "core", "scope", "store", "search", "seed", "style", "SOURCE", "scene", "service", "string", "target", "ink", "origin", "sequence", "ource", "src", "me", "subject", "iso", "from", "resource", "status", "spec", "init", "query", "file", "body", "base", "parent", "template", "input", "se", "start", "Source", "site", "sample", "remote"], "destination": ["spacement", "declination", "spino", "combination", "combinations", "identinations", "destino", "declinations", "combacement", "declinated", "combino", "spination", "identinator", "declinator", "combinated", "combinator", "destinations", "declacement", "destacement", "declino", "spinated", "identination", "identino", "destinated", "destinator"], "in": ["f", " IN", "mi", "ins", "din", "inside", "isin", "exec", "en", "co", "pin", "ini", "IN", "sin", "inn", "con", "s", "ai", "net", "ln", "cin", "gin", "an", "local", "n", "bin", "from", "conn", "it", "or", "by", "re", "to", "ca", "login", "all", "init", "al", "ma", "ain", "ind", "is", "inc", "client", "no", "up", "rin", "doc", "input", "win", "i", "inner", "r", "internal", "l", "include", "t", "vin", "im", "index", "min", "read", "In", "can"], "out": ["cn", "ot", "cmd", "output", "OUT", "en", "co", "b", "v", "serv", "ex", "channel", "cache", "gt", "ent", "con", "user", "net", "ne", "io", "un", "sys", "ns", "on", "conn", "outs", "it", "or", "ou", "note", "to", "obj", "file", "result", "op", "aos", "nt", "cos", "msg", "ch", "can", "client", "write", "up", "no", "rem", "oss", "one", "inner", "conv", "os", "null", "na", "not", "t", "o", "Out", "at", "w", "outer", "n"]}}
{"id1": "21488868", "id2": "23035537", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "11475527", "id2": "659316", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDatafromurl", "addTextFormURL", "addTextFromurl", "addTextFormurl", "addDatafromLocation", "addDataTourl", "addDataToLocation", "addTextFromURL", "addDataFormUrl", "addDataFormurl", "addTextFormUrl", "addDatafromUrl", "addDataFromLocation", "addDataFormURL", "addTextFromLocation", "addTextFormLocation", "addTextFromUrl", "addDataToURL", "addDatafromURL", "addDataFromurl", "addDataFromUrl", "addDataFormLocation", "addDataToUrl"], "theurl": [" theURL", "heURL", " thefile", "teuri", "teurl", "thloader", "theUrl", " theloader", "thfile", " theuri", "teURL", "thurl", " theUrl", "thefile", "TheURL", "Theuri", "theURL", "heUrl", "theuri", "hefile", "TheUrl", "heuri", "heloader", "Theurl", "heurl", "thUrl", "teUrl", "theloader"], "line": ["record", "ine", "header", "node", "liner", "online", "eline", "zone", "message", "char", "email", "string", "ln", "ice", "le", "chain", "print", "sequence", "cell", "valid", "block", "lin", "entry", "rule", "text", "status", "frame", "inline", "Line", "stroke", "link", "page", "day", "comment", "lane", "code", "lined", "name", "source", "ner", " inline", "l", "row", "LINE", "sample", "point"], "in": ["f", "mi", "ins", "din", "en", "id", "again", "pin", "old", "serv", "IN", "inn", "con", "ai", "lo", "inf", "cin", "gin", "ac", "bin", "conn", "st", "it", "ic", "or", "from", "init", "mc", "phys", "ma", "al", "ain", "reader", "is", "inc", "open", "out", "rin", "win", "input", "i", "source", "inner", "r", "proc", "l", "oin", "include", "o", "t", "isin", "read", "In", "n"], "data": ["DATA", "stream", "ata", "cache", "dat", "dec", "window", "content", "iterator", "user", "io", "buffer", "raw", "text", "da", "join", "writer", "size", "a", "query", "ad", "file", "body", "pipe", "reader", "this", "client", "out", "def", "feed", "input", "bus", "next", "d", "info", "read", "result"], "e": ["f", "ine", "pe", "b", "p", "v", "ex", "ec", "ze", "er", "te", "ge", "ae", "ele", "eu", "ve", "le", "ne", "ed", "E", "m", "err", "me", "entry", "c", "error", "or", "re", "a", "de", "x", "ie", "y", "be", "event", "element", "h", "ue", "i", "se", "r", "g", "oe", "es", "o", "eeee", "t", "ce", "d", "ee", "n"]}}
{"id1": "18374478", "id2": "20685385", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 1, "substitutes": {"updateUser": [" updateByte", " updateMe", "putUser", "updateUse", "uploadMe", " updateCommon", "insertUser", "setUser", " updateAccount", "putCommon", "insertGroup", "geUse", "uploadUser", " updateUsers", "setUse", "uploadUsers", "updateMe", "putuser", "makeUser", " updateuser", " updateUSER", "putUse", "geUser", "updateOne", "geuser", "uploadUse", "updateAccount", "insertUsers", "updateUsers", "setuser", "insertAccount", "updateuser", "putUsers", "putByte", "uploadCommon", "putOne", "UpdateUsers", "uploadUSER", "updateGroup", "makeOne", "putUSER", "makeByte", "UpdateGroup", "UpdateAccount", "gePer", "makeUsers", " updatePer", " updateOne", "updateUSER", "updateCommon", " updateGroup", "uploaduser", "UpdateUser", "updateByte", " updateUse", "updatePer", "putMe", "setPer"], "user": ["update", "host", "u", "object", "record", "uid", "other", "v", "job", "sum", "message", "profile", "char", "data", "instance", "usr", "admin", "content", "token", "owner", "form", "USER", "device", "order", "valid", "me", "rule", "by", "author", "part", "post", "use", "users", "add", "re", "table", "resource", "usage", "ver", "report", "item", "key", "connection", "file", "base", "ud", "per", "name", "word", "this", "used", "client", "usa", "up", "display", "get", "username", "account", "config", "row", "version", "util", "password", "User", "info", "module", "result", "plugin"], "conn": ["ann", "cmd", "org", "port", "enc", "cc", "gen", "err", "pkg", "Con", "link", "socket", "dc", "pg", "obj", "res", "Conn", "wp", "nt", "cp", "oss", "cat", "wd", "log", "info", "wr", "ssl", "co", "com", "dt", "typ", "jp", "addr", "ctx", "pt", "yn", "oc", "gc", "ch", "close", "conv", "conf", "cons", "pas", "cm", "cb", "cn", "bind", "quote", "mt", "exec", "bo", "die", "connect", "nc", "con", "cfg", "apt", "resp", "c", "priv", "mc", "out", "t", "handle", "rel", "lang", "cf", "Connection", "iw", "net", "ns", "pub", "col", "comm", "gate", " con", "req", "connection", "cert", "pool", "act", "open", "client", "cur", "db", "ctr", "wn", "coll", "ct", "ce", "tp", "cont", "n"], "autoCommit": ["autoComit", "autoCollcommit", "autoRemend", "AutoDebit", "AutoDebort", "autoQue", "anoActivmit", "autoCompe", "anoCommort", "autoRemmit", "autoDebcommit", "autoCommcommit", "autoCompmit", " autoCompit", "anoCommlate", "autoCommort", "autoDebit", "autoComort", "autoCommmit", "autoDebort", "autoQuit", "autoCollmit", "autoReme", "AutoDebmit", "autoComcommit", "autoCompend", " autoCompe", "AutoCommmit", "anoCommit", "autoDeblate", "AutoDebcommit", "autoComlate", "anoActivit", " autoCompmit", " autoCommend", "autoCollort", "autoActivort", "AutoCommit", "autoRemit", "autoQuend", "autoActivlate", "autoCollit", "anoActivort", "AutoCommort", "autoCompit", " autoCommmit", " autoCompend", "autoQumit", "autoActivmit", "autoComme", "autoCommlate", " autoComme", "autoDebmit", "anoCommmit", "AutoCommcommit", "autoActivit", "anoActivlate", "autoCommend"], "deleteRoles": ["deleteResroups", "detailRroups", "deleteResles", "deleteTanguages", "deleteGroups", " deleteResols", "deleteRadoids", "detailRoles", "deleteEroles", "deleteGoles", "detailCorroups", "deleteRles", "deleteranguages", "deleteGles", "deleteRadols", "deleteResoids", "deleterroups", "deleteRroups", " deleteResroups", "detailCoroles", "deleterules", " deleteRroups", "deleteCorules", "detailRules", "deleteToles", "deleteRoids", " deleteRles", "detailCorules", "deleteCorroups", " deleteRols", "deleteCoroles", "deleteRanguages", "deleteResoles", "deleteNroups", "deleteNles", "deleteResols", "deleteTules", "deleteCoranguages", "deleteErles", " deleteResoids", "deleteEroids", "deleteRadles", "detailCoranguages", " deleteRoids", "deleteGols", "deleteRules", "deleteTroups", "deleteroles", " deleteResoles", "deleteRols", "deleteNols", "deleteErols", " deleteResles", "detailRanguages", "deleteNoles", "deleteRadoles"], "insertRoles": ["insertRepliders", "insertCodes", "deletePows", "stepReploles", "insertPights", "insertRobrots", "insertRobels", "insertGodes", "insertPows", "InsertRodes", "stepReplroups", "insertReploles", "insertRodes", "insertNodes", "insertResodes", "insertRsles", "insertRles", "insertRiders", "insertLoles", "insertNhips", "insertReships", "insertColes", "stepRodes", "sequenceRrots", "insertRels", "insertNoles", "insertCights", "deletePights", "insertLroups", "insertRhips", "deleteRights", "insertRrots", "InsertRoles", "sequenceRobrots", "sequenceRobels", "insertRsrots", "insertNles", "deletePodes", "stepRepliders", "InsertRhips", "insertResles", "insertReplroups", "InsertRles", "insertRows", "insertGiders", "deleteRodes", "insertRights", "stepReplodes", "insertRobles", "insertPoles", "deletePoles", "insertRroups", "insertPodes", "stepRiders", "deleteRows", "insertGoles", "insertRsels", "sequenceRles", "sequenceRoles", "sequenceRels", "stepRroups", "insertResoles", "insertCows", "insertLiders", "stepRoles", "insertReplodes", "sequenceRobles", "insertLodes", "insertRsoles", "sequenceRoboles", "insertRoboles", "insertGroups"], "role": ["rel", "hole", "pe", "ole", "office", "node", "country", "zone", "rol", "relation", "profile", "char", "feature", "te", "peer", "rice", "le", "cell", "block", "rule", "entry", "part", "resource", "rl", "slave", "hero", "col", "ro", "range", "label", "tag", "oval", "family", "right", "tro", "word", "def", "r", "aco", "Role", "row", "type", "ule", "ce", "password"]}}
{"id1": "17296916", "id2": "620855", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"logging": ["debugging", "Logging", "LogStorage", " logStorage", " logger", "debuging", "Loging", " loging", "debugger", "logger", "Logger", "loging", "debugStorage", "logStorage"], "wrap": ["store", "ew", "work", "we", "message", "window", "format", "grow", "web", "box", "nw", "chain", "form", "me", "sw", "safe", "wrapper", "pack", "use", "add", "link", "wra", "W", "gate", "shape", "x", "xf", "python", "ad", "rap", "transform", "force", "build", "wx", "wa", "sp", " wrapped", "zip", "word", "inter", "get", "wire", "create", "find", "reset", "start", "parse", "ow", "wind", "aw", "root", "pad", "ws", "w", "read", " wrapper", "handle"], "buffer": ["quote", "reply", "output", "store", "header", "surface", "binary", "flag", "position", "cache", "bo", "screen", "profile", "message", "window", "buf", "queue", "print", "phrase", "complete", "database", "sequence", "block", "face", "wrapper", "view", "layer", "button", "trace", "writer", "table", "size", "frame", "bar", "bridge", "note", "report", "attribute", "document", "builder", "console", "batch", "body", "base", "library", "directory", "reference", "flash", "word", "line", "append", "ob", "template", "display", "memory", "iter", "reset", "row", "Buffer", "buff", "bb", "command", "pb"], "encoding": ["cododer", "enryption", "coding", "enaling", "enumlanguage", "cododed", "cryption", "coder", "Encoder", "enumoding", "enging", "enclanguage", "ecoding", "Encryption", "cododing", "encging", "enoding", "encoded", "ecoded", "caling", "enumoder", "codryption", "encoder", "encaling", "enoded", "cging", "enumging", "ecoder", "Encoding", "encryption", "enoder", "ecryption", "enlanguage", "clanguage", "Encaling"], "getEncoding": ["getEnling", "getEnoding", "getEncging", "getencling", "getOrigination", " getEncination", "getEncling", "getExpoding", "getExpression", "getEncryption", " getEnoding", "getEnination", "getEnryption", "getEnging", "getencging", "getExpryption", " getEnination", "getOrigryption", "getEnression", " getEnling", "getEncression", "getencoding", " getEncryption", "getOrigoding", "getEncination", "getencryption", " getEncging", "getencination", "getencression", "getOrigling", " getEncression", "getExpging", " getEncling", " getEnging", " getEnression", " getEnryption"], "headers": ["pins", "terms", "pres", "writers", "header", "caps", "comments", "values", "rs", "drivers", "fields", "builders", "chains", "properties", "authors", "ers", "weights", "ilers", "relations", "ctors", "images", "boxes", "users", "holders", "limits", "codes", "ppers", "reports", "heads", "params", "styles", "objects", "members", "modules", "keys", "head", "ports", "ids", "names", "groups", "frames", "ters", "blocks", "tags", "checks"], "is": ["isa", "isl", "fs", "sis", "ins", "osi", "lis", "iss", "bs", "ri", "ris", "dis", "ists", "isi", "nis", "us", "si", "ys", "sys", "ms", "obs", "iso", "has", "in", "ic", "or", "bis", "tis", "ois", "ims", "as", "IS", "iris", "mis", "Is", "isc", "ui", "isd", "does", "i", "isf", "os", "\u00eds", "ip", "ais", "its", "ist", "isin", "was", "ios"], "bos": ["fs", "oos", "tops", "bs", "bits", "ows", "bones", "cs", "bes", "ubis", "bo", "stats", "banks", "isi", "lets", "bas", "windows", "bi", "ys", "sys", "nos", "obs", "ms", "bot", "bin", "js", "ots", "dos", "ps", "bis", "tis", "oids", "bh", "ts", "eros", "des", "boards", "aos", "uts", "tes", "fits", "soc", "cos", "ses", "jas", "oops", "uds", "ui", "oss", "os", "ods", "bytes", "los", "pod", "ols", "ones", "ios"], "e": ["f", "en", "p", "v", "ex", "er", "ge", "ae", "ev", "ate", "le", "ne", "ed", "E", "err", "m", "me", "c", "error", "re", "a", "de", "x", "ie", "h", "se", "r", "i", "g", "es", "oe", "exc", "o", "t", "eeee", "d", "ee", "n"]}}
{"id1": "8046691", "id2": "8430178", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["detrieveFile", "retractFile", "detrievedImage", "detrievedFile", "retireLink", "retractLocal", "retrievedLocal", "retrievedLink", "detrieveLink", "retrievedImage", "retrievedFile", "detrieveImage", "retractLink", "detrievedLocal", "retrieveImage", "retractImage", "detrieveLocal", "retireImage", "detrievedLink", "retireFile", "retireLocal", "retrieveLink", "retrieveLocal"], "url": ["image", "host", "f", "el", "u", "sl", "ssl", "id", "location", "ls", "dl", "arl", "char", "bel", "string", "path", "web", "ref", "ml", "un", "rect", "str", "m", "ll", "resource", "http", "rl", "nl", "ur", "URL", "file", "run", "build", "base", "address", "cp", "name", "call", "get", "pl", "uri", "Url", "l", "abs", "row", "remote", "job"], "link": [" reload", "stream", "style", "dl", "linked", "detail", "path", "ment", "le", "set", "pack", "status", "load", "add", " check", "page", "tag", "file", "cp", "lock", "line", "def", "check", "Link", "get", "log", "download", "info", "lib", "local", " load", "ssl", " jump", " lock", "relation", "entry", "error", "li", "sign", "init", "key", "mail", "write", "loop", "l", "type", "remote", "ls", "task", "self", "message", " block", "ink", " relay", "links", "network", "loader", "post", "query", "share", "build", "library", "msg", "base", "ld", "light", "tool", "go", "index", " delay", "master", "handle", "image", "rel", "mark", " LINK", "list", "thread", "ml", "block", "map", "install", "label", "system", "open", "let", "db"], "httpConn": ["hoverConnection", "ttpSyn", "httpCmd", "internalCt", "ttpConnection", "ttpConnect", "realConnect", " httpConnect", "htmlCt", " httpCon", "hoverCon", "httpconn", "socketConnect", "httpCon", "httpsConn", "socketConn", "httpCons", "ttpconn", " httpConnection", "httpsCons", "httpConnect", "ttpCt", "httpsCon", "realCt", "appConnect", "socketconn", "httpsConnect", "htmlConnect", " httpconn", "HttpConn", "internalConnection", " httpCmd", "realConn", "localconn", "hoverCons", "HttpConnect", "httpsConnection", "hoverConn", "ttpCmd", "ttpCon", "httpsconn", "appConn", "appConnection", "HttpCon", "realconn", "internalCon", "httpSyn", "htmlConn", "ttpCons", "internalConnect", "hoverConnect", "HTTPConn", "internalconn", "httpCt", "localConn", "socketConnection", "ttpConn", "localCon", "httpsCmd", "httpConnection", "HttpConnection", "htmlconn", "hoverCt", " httpSyn", "internalConn", "hoverSyn", "HTTPConnect", "appconn", "HTTPCon", " httpCons", "HTTPCons", " httpCt", "localConnection"], "outs": ["ches", "uns", "ins", "offs", "ends", "ats", "tops", "bs", "bits", "ows", "sets", "ls", "qs", "ips", "cells", "vals", "lets", "s", "gets", "nets", "nos", "obs", "ns", "gs", "ds", "boxes", "ts", "ims", " out", "lists", "aos", "orts", "eps", "fits", "uts", "cos", "dates", "aps", "uds", "out", "als", " layouts", "ops", "os", "uploads", "ks", "locks", "ports", "its", "aches", " outputs", " ops", "yout", "plays", "checks", "ios"], "bins": ["binn", "bans", "blkins", "hins", "blouts", "lids", "bobs", "rkins", "rans", "linn", "louts", "blans", "lins", " bids", " bkins", "binos", "bin", "lin", "blids", "lobs", "wouts", "wobs", "bids", "blins", "wins", "routs", " bans", "houts", " binos", "blinos", "win", "rins", "hin", "hobs", "linos", "bkins", " binn", "blinn"], "bouts": [" bonds", "Bouts", "wbaos", "Bins", "obbs", "fbouts", "bbyout", "bonds", "wout", "obyout", "fbbs", "bout", " baos", "wbouts", "waints", "baos", "Baints", " bout", "bbins", " baints", "wouts", "wbonds", "fbyout", "fbins", "wins", "waos", "bbouts", "wbout", "byout", "obins", "bbs", "baints", "obouts", "wonds", "Baos", "bbbs"], "postData": [" postBody", "POSTDat", " postDATA", "postsDATA", "PostBody", "postDat", " postBytes", "POSTdata", "PostQuery", "postdata", " postdata", "postsBytes", "PostBytes", "PostData", "postBody", " postDat", "POSTQuery", "postsdata", "formDat", "postBytes", "POSTBody", " postQuery", "formdata", "formData", "postDATA", "postQuery", "POSTBytes", "POSTData", "PostDATA", "formDATA", "Postdata", "POSTDATA", "postsData"], "mimePattern": ["mimesPattern", "mIMEPattern", " muxpattern", "metyTemplate", "metyPattern", " muxTemplate", "mimesTemplate", "smimePattern", "smetyPattern", "smimeFormat", "smetyFormat", " mimeTemplate", "mIMEpattern", "mimesFormat", "muxpattern", "muxTemplate", "smetypattern", "mimeTemplate", "metyFormat", "mimepattern", "mimeFormat", "muxPattern", " mimepattern", "mIMEFormat", "smimepattern", "metypattern", " muxPattern", "mimespattern"], "matcher": ["dismatch", "patter", "patch", " mature", "match", "Matter", "matching", "Matcher", " matmatch", "Mather", " matching", " matter", "Match", "mather", "matches", " match", "statcher", "Matching", "disches", "pather", "Matmatch", "stather", " matches", "statching", "disure", "patcher", "Mature", " mather", "matter", "mature", "discher", "statter", "matmatch", "Matches"], "byteBuffer": ["byteBuilder", " byteBuff", "Bytebuffer", " byteVar", " byteFFER", "wordMatrix", "noteBuffer", "letterbuffer", "charBuff", "noteBuff", " bytebuffer", " byteBuilder", "charVar", "ByteBuff", "charBuilder", "noteBuilder", "bytebuffer", "bBuffer", "bbuffer", "charBuffer", "wordbuffer", "byteVar", "byteFrame", "ByteBuffer", "wordFrame", "bBuff", " byteFrame", "byteFFER", "byteMatrix", "letterMatrix", "letterFrame", "noteVar", "bFFER", "ByteFFER", "wordBuffer", " byteMatrix", "letterBuffer", "byteBuff"], "count": ["length", "max", "ount", "core", "num", "more", "cache", "sum", "total", "char", "list", "cc", "buffer", "acc", "err", "val", "continue", "c", "C", "size", "add", "cap", "comment", "all", "cycle", "child", "force", "code", "nt", "amount", "result", "ch", "batch", "ind", "depth", "current", "found", "counter", "check", "call", "loop", "number", "len", "last", "find", "iter", "conf", "start", "ctr", "Count", "first", "index", "read", "cont", "n"]}}
{"id1": "13757855", "id2": "18489832", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"process": ["processor", "Process", "task", "format", "processing", "load", "step", "add", "replace", "apply", "render", "transform", "run", "build", "execute", "call", "write", "display", "loop", "create", "proc", "parse", "save", "filter", "project", "handle"], "tpl": [" tPL", "tmpp", "tpp", " tph", "ptplates", "timbl", "atplate", "stopl", "stplate", "teruple", "tempr", "stbl", "ttopl", "ttpg", "tsPL", " tpp", "tuple", "tpg", "tmplates", "ttbl", "Tplates", "tmplate", "timspl", " turtle", " tld", "tPL", "typl", "tyurtle", "tsurtle", "templ", "tplug", "Tbl", "stplug", "tpr", "tld", "Tplate", "ttpl", "temPL", "itpl", "tplate", "terplate", "otbl", " tplates", "stspl", "turtle", " tplate", "timpl", "itbl", "tyPL", "timplate", "tmbl", "timplug", "itPL", "atuple", "stpg", "tspl", "ttPL", "topl", "ptbl", "TPL", "tmPL", "terld", "Tspl", "Tph", "tbl", " tuple", "tsbl", "Tpr", "atld", "otplate", "ptpl", "tembl", "ttplug", "itplate", "tspr", " tbl", "Tpp", "otpl", "tplates", "tph", "Tld", "timopl", "ptld", "stpl", "otld", "ttph", "terpl", "tmpl", "timpg", "atpl", "Tpl"], "model": ["el", "object", "record", "models", "product", "node", "M", "data", "content", "ml", "m", "tree", " Model", "md", "document", "file", "Document", "base", "parent", "Model", "log", "html", " models", "module", "project"], "packageName": [" packageFamily", "groupNames", "groupName", "packagename", "Packagename", "viewClass", " packageClass", "packageRoot", "pkgVersion", "PackageName", " packagename", "pkgNames", "groupFamily", "packageVersion", "groupVersion", "PackageClass", " packageVersion", " packageRoot", "PackageRoot", "packageNames", "pkgFamily", "packageClass", "pkgName", " packageNames", "viewName", "viewRoot", "packageFamily", "viewname"], "outFileName": ["infilePath", " outFileTime", " outFileType", "outImagename", "outFilenameType", " outFilenameType", "outDirPath", "outFileNames", "outFilePath", "outFilenameNames", " outTableSize", "outStreamNames", " outTablePath", " outfileNames", "outFName", " outFileChain", "outfileNames", " outFilenamePath", " outFilenameSize", "outImageSize", "outfilename", "outStreamType", "outTableSize", "outDirName", "outFileChain", "outTablePath", "outDirTime", "infileNames", " outFilePath", " outfileName", "outStreamTime", "outfileType", "outTableType", " outFilenameName", "outFileSize", "outTablename", "outFPath", " outFilenameChain", "outFilenamePath", " outFilenamename", "outFilenameTime", "inFileTime", "outImagePath", "infileName", " outTableTime", " outFilename", "outFname", "outTableTime", "outfileTime", "inFileType", "infileTime", " outFileNames", "outStreamPath", "outStreamName", "outTableName", "inFileName", "outfilePath", "outFilenamename", "outFilename", "inFilePath", "outfileName", " outfilename", "outDirSize", "outFilenameSize", "outFileType", "inFileNames", "outTableChain", " outFileSize", "outFNames", "outFilenameName", " outfilePath", "outFilenameChain", "outImageName", " outTableName", "outFileTime", "outfileChain", "infileType"], "xsltParam": ["xsqlParam", "xsmlParam", "xsslParam", "xmlConf", "xmlParameter", "xsltConf", "xltParam", "xsmlParameter", "xsltParameter", "xsmlConf", "xltParameter", "xmlParam", "xsqlConf", "xsslParameter", "xsqlParameter", "xsslConf", "xltConf"], "artifact": ["arifacts", " artificate", "partifacts", "anifacts", "ardifacts", " artifacts", "ardifact", "arifact", "anificial", "artifacts", "artificial", "ardificial", "ardificate", " artificial", "artificate", "partifact", "Artifact", "Artifacts", "anifact", "anificate"], "destinationPath": ["estinationPath", "destigationChain", "chaininatedPath", "destinoHost", "destensionPoint", "destinatorChain", "origininationNow", "destesticSystem", "destinationName", "destinateChain", "destinationUrl", "chaininationDisk", "destociationPoints", "desturationPath", " destociationpath", "delinationPath", "estinationName", "DestinationPod", "destensionHost", "DestensionPath", "destesticPath", "destinationTarget", "destventionPath", "destinationSystem", "destigationPath", "destinantTemp", "generinationPath", "destinoName", "destinateAt", "destinantPod", "destositoryHost", "destinatorPath", "destionPath", "estinationPart", "destositoryParent", "DestinationHost", "termininationTarget", "destinationPart", "destinoPoint", "destinoKey", "destinateDir", "delinatePoints", "destensionPath", "identinateKey", "destinateName", "termininerJar", "desturationJar", "descositoryParent", "identinateChain", "destATIONParent", "destionPoint", "destesticJar", "descositoryHost", "DestificationDir", "destacementTime", "estinoKey", "estionpath", "destociationHost", "destociationHome", "destacementName", "destinateTarget", "destociationForm", "chaininationHome", "destinatePoints", "destensionTemp", "destinateJar", "destensionDir", "desticationPath", "destationDir", "destinationDriver", "destinateTime", "destinationDisk", "DestinationUrl", "delinateForm", "delinatePath", "desturationTarget", "destinatedTarget", "destinerpath", "destationHost", "destinationParent", " destinationpath", " destociationTarget", "estationPart", "identinationPath", "estationHost", "estinationDir", "descinationParent", "origininatedPath", "generinateAt", "generinatePath", "destinationNow", "destinationKey", "destinatorHost", "descositoryPath", "destociationPath", "destationPart", "destinateForm", "destinationChain", "destationPath", "destinationPod", "destitutionPATH", "destinatorPoint", "estinationPATH", "DestensionDir", "destacementPath", "desticationTemp", "destATIONPath", "termininerTarget", "desturationpath", "DestensionTemp", "destinateSystem", "destregationDisk", "destinateNow", "destinerHost", "destociationpath", "estinationpath", "destociationDir", "destificationUrl", "destositoryPath", "estinationTime", "descinationHost", "DestificationLocation", "destinatorpath", "origininatedChain", "destinateLocation", "destinatedDriver", "destinerDir", "chaininatedHome", "desticationPod", "destificationLocation", "chaininationPath", "destinateLog", "termininationPath", "origininationChain", "identinateInfo", "DestensionHost", "destinationDir", "estationDir", "destificationDir", "destinantDir", "destinationpath", "destinatorKey", "estinationPoint", "destitutionPath", "destesticAt", "destinationLocation", "estinoPath", "destranceLog", "destinationTemp", "origininatedForm", "identinationChain", "generinateJar", "destinatedChain", "DestificationPath", "estinationHost", "destinationPort", "identinationKey", "estionPoint", "destificationPath", "estionPath", "destitutionpath", "termininerpath", "destinateInfo", "DestensionPoint", "generinationSystem", "destrancePath", "destociationDisk", "destensionPod", "destATIONPort", "destinerPath", "DestinationTemp", "DestinationDir", "identinatePath", "destigationNow", "destinateUrl", "destinationPoint", "destociationLog", "destinatedInfo", "destitutionPoint", "estinationKey", "destregationPath", "destinatedDisk", "destventionDisk", "DestensionPod", "DestinationPath", "destinerAt", "destionpath", "destinationInfo", "destventionHome", "destinatorParent", "origininatedNow", "destationLocation", "destinationTime", "destinatedpath", "destationUrl", "DestificationUrl", "estationPath", "destinatorPATH", "destinoDir", "destinerPart", "destociationTarget", "destositoryPort", "origininationPath", "destinationForm", "descinationPort", "destinerTarget", "destinationJar", "destinationHome", " destinationTarget", "destociationDriver", "termininerPath", "destinatePart", "destventionDriver", "destinatedKey", "destinateKey", "chaininationDriver", "estionPATH", "destinatorInfo", "destinatePath", "delinationPoints", "destranceForm", "delinationLog", "destinerSystem", "destinationAt", "delinateLog", "destionPATH", "descinationPath", "destinatedNow", "DestinationLocation", "generinationAt", "destinateHost", "chaininatedDriver", "destinerJar", "chaininatedDisk", "destregationTarget", " destociationPath", "descositoryPort", "termininationJar", "identinationInfo", "destinatepath", "destATIONHost", "generinateSystem", "destigationForm", "destociationPoint", "destinationPoints", "destinationLog", "destinatedPath", "destinationHost", "destinatorPort", "origininationForm", "destinoTime", "termininationpath", "destinatedForm", "destinantPath", "destinoPath", "destinationPATH", "destrancePoints", "estinoName", " destinationDisk", " destociationDisk", "generinationJar", "estinoTime", "destinatedHome", "desticationDir", "DestinationPoint", "destacementKey", "destregationpath", "delinationForm"], "in": ["f", " IN", "ins", "din", "id", "IN", "io", "m", "bin", "c", "file", "reader", "doc", "i", "input", "r", "inner", "l", "t", "o", "d", "info", "w", "In", "n"], "out": ["cn", "f", "ins", "u", "cmd", "output", "go", "OUT", "co", "gr", "v", "b", "p", "dis", "ex", "screen", "ger", "println", "cache", "list", "gen", "s", "con", "e", "ln", "net", "io", "cfg", "print", "sys", "err", "conn", "raw", "outs", "it", "or", "c", "writer", "ou", "inv", "to", "report", "all", "obj", "res", "file", "aos", "nt", "msg", "ch", "nr", "can", "client", "write", "up", "inner", "oe", "conf", "null", "l", "os", "o", "log", "t", "Out", "w", "outer", "n"], "root": ["initial", "context", "scope", "node", "id", "p", "println", "New", "data", "chain", "group", "tree", "m", "table", "de", "_", "dir", "dump", "impl", "Root", "child", "parent", " roots", "name", "def", "graph", "r", "config", "se", "create", "json", "start", "parents", "ok", "roots", "Template"]}}
{"id1": "12454178", "id2": "4056444", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 0, "substitutes": {"alterar": [" scalasar", " ingestar", " scalada", " consequado", " scalar", " ingestada", " ingestasar", " consequar", " alterado", " alterada", " consequada", " scalado", " alterasar", " ingestado", " consequasar"], "t": ["translation", "et", "wt", "ot", "tg", "rt", "tp", "mt", "z", "tip", "b", "p", "ht", "v", "dt", "typ", "tc", "task", "mint", "total", "te", "ent", "e", "q", "tree", "pt", "tu", "m", "st", "it", "c", "ret", "trace", "table", "ti", "qt", "ter", "to", "ts", "j", "a", "x", "nt", " ot", "y", "tr", "det", "T", "out", "txt", "h", "template", "ta", "title", "get", "i", " pt", "g", "tm", "l", "vt", "type", "ct", "o", "temp", "at", "w", "tt", "n"], "stmt": [" superstmt", " stMT", "stMT", " supersttx", " stsm", " sttxt", " superstMT", "Sttm", "StMT", "ttmp", " stmr", "sysm", " stmon", "stmk", "stm", "stmp", "stsm", "ttm", " ststat", " stmp", "sym", "stmon", "irstmk", "sttxt", "stysm", "stytx", " supersttxt", "stytm", " superstmr", " sttx", " stm", "ststat", "stym", "stymt", "Sttx", "Stmp", "sttx", "stmr", "Stmr", "ttmt", "ttstat", "Stmk", "irstmt", "irsttx", "irstMT", "symon", "Sttxt", "stymon", "sttm", " sttm", "styMT", "Stmt", "symt", " stmk", "Stm", "Ststat"], "sql": ["initial", "el", "cmd", "software", "seed", "ls", "dl", "select", "format", "description", "sd", "s", "string", "csv", "ln", "wal", "sys", "q", "pel", "xml", "sq", "scl", "table", "nl", "spec", "sv", "query", "expression", "sol", "lex", "fn", "QL", "name", "lock", "template", "sk", "su", "l", "url", "ql", "SQL", "series", "spr", "n"], "id_disciplina": ["id_disciine", "id_Discomplina", "id_disgrain", "id_disgrine", "id_disciini", "id_Discipline", "id_disciplinate", "id_discomina", "id_disgrini", "id_displine", "id_displinate", "id_disciplINA", "id_displINA", "id_descipline", "id_displina", "id_disciplain", "id_disrigINA", "id_DisciplINA", "id_desciplain", "id_discomplini", "id_discompline", "id_Discompline", "id_Disciplain", "id_disgrina", "id_displini", "id_discomplain", "id_discomain", "id_descomplini", "id_DisciplineINA", "id_disriginate", "id_discomplina", "id_Discomplain", "id_Disciplini", "id_Disciplineinate", "id_discipline", "id_descompline", "id_desciplina", "id_disriginator", "id_Disciplineina", "id_disciplineina", "id_disciina", "id_disciplinator", "id_disciplineINA", "id_disciplineinator", "id_disciplini", "id_descomplina", "id_disciplineinate", "id_discomini", "id_displinator", "id_Disciplinate", "id_descomplain", "id_Disciplina", "id_disciain", "id_Disciplinator", "id_Discomplini", "id_desciplini", "id_Disciplineinator", "id_displain", "id_disrigina", "id_discomine"], "item": ["image", "mi", "object", "tip", "store", "id", "Item", "p", "other", "hit", "match", "ex", "task", "instance", "rec", "items", "e", "me", "iso", "entry", "in", "article", "it", "bar", "link", "key", "obj", "component", "menu", "event", "word", "unit", "element", "team", "i", "iter", "row", "site", "info", "job", "local"]}}
{"id1": "3958807", "id2": "17773263", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"loadBinaryStream": ["loadBixedStream", "loadBbinaryStreamer", "loadEmbinaryInput", "loadBixedStreamer", "loadEmbinaryStreamer", "loadBignedFile", "loadBixedFile", "loadEmbbinaryFile", "loadBignedStreamer", "loadEmbbinaryStreamer", "loadBignedInput", "loadBinaryFile", "loadBbinaryStream", "loadEmbinaryFile", "loadBignedStream", "loadEmbinaryStream", "loadEmbbinaryInput", "loadEmbbinaryStream", "loadBixedInput", "loadBbinaryInput", "loadBbinaryFile", "loadBinaryInput", "loadBinaryStreamer"], "streamName": [" streamPath", " streamType", " streamHandle", "stringType", " streamname", "longPath", "recordNAME", "streamType", "longName", "stringName", "Streamname", "fileNAME", "recordName", "fileName", "StreamName", "recordname", "streamNAME", "filePath", "resourceNAME", "resourceName", "stringNAME", " streamNAME", "longNAME", "streamHandle", "recordHandle", "resourceType", "streamname", "streamPath", "StreamHandle", "StreamNAME"], "streamToLoad": [" stream2Read", "streamtoload", "streamTOload", "streamtoAdd", "stream2Load", "stream2Read", "stringWillLoad", "streamWillload", "streamTORead", "streamTOAdd", "stringToAdd", "stream2load", "stream2Use", "streamToUse", " stream2Use", "streamToload", "streamToAdd", " streamToRead", "streamTOLoad", "streamtoLoad", " streamToUse", "streamTOUse", "stringWillload", "streamToRead", " stream2load", " streamWillLoad", " streamToload", "stringToLoad", "streamWillAdd", " stream2Load", "streamWillLoad", "stringWillAdd", "stringToload", " streamWillload"], "sz": ["sch", " sch", "insze", "rsiz", "siz", "rsld", "Sld", " siz", " sld", "insiz", "sze", "Siz", "insch", "insz", "Sch", "rsze", "rsz", "Sz", " sze", "Sze", "sld"], "req": ["Request", "qq", "cmd", "Requ", "org", "gr", "jp", "usr", "require", "attr", "q", "ctx", "wcs", "sq", "request", "pkg", "http", "qt", "inv", "quick", "comm", "fr", "quest", "urg", "query", "res", "seq", "wx", "rx", "client", "comp", "cur", "dq", "proc", "pas", "qs", "requ"], "resp": ["rel", "fs", "cmd", "output", "exp", "esp", "Resp", "https", "p", " Resp", "serv", "RES", "dis", "gr", "jp", "rec", "content", "sys", "rend", "conn", "ret", "request", "status", "http", "re", "response", "comm", "inv", "vol", "fr", "report", "Res", "obj", "res", "sol", "body", "sp", "soc", "nt", "msg", "pos", "wx", "cmp", "client", "r", "respond", "respons", "proc", "conv", "os", "Response", "cl", "pas", "rep", "html", "compl", "wr", "result"], "out": ["cn", "ins", "ot", "output", "OUT", "co", "bs", "ex", "gt", "us", "net", "io", "sys", "sw", "in", "outs", "gs", "ou", "vol", "ts", "to", " outs", "obj", "res", "aos", "nt", "cos", "client", "oss", "conv", "os", "null", "o", "log", "t", "utt", "ws", "Out", "w", "yout", "n"], "bos": ["oos", "bs", "bits", "mos", "bones", "bes", "ubis", "bo", "banks", "bas", "bles", "bi", "ys", "sys", "nos", "obs", "bin", "bot", "js", "dos", "bat", "bis", "oids", "bh", "ts", "eros", "des", "boards", "aos", "uts", "tes", "fits", "base", "BS", "jas", "oops", "oss", "os", "bytes", "ods", "buff", "los", "ws", "ols", "ios"]}}
{"id1": "11049257", "id2": "7372311", "code1": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"generate": ["validates", " Generates", " obfuscator", "validate", " Generate", " obfuscate", "generator", " obfuscize", "validator", "validize", "generize", " Generator", " Generize", "generates", " obfuscates"], "secure": ["ssl", "encrypted", "server", "domain", "https", "ls", "confirmed", "security", " Secure", "stable", "sync", "secret", "sys", "safe", "debug", "conn", "Secure", "sec", "strong", "status", "active", "control", "query", "protect", "force", "ie", "sp", "client", " securely", "trust", "close", "prime", "sr", "crypt", "quiet", "nice", " insecure"], "sep": ["pepa", "SEps", "aseep", "keps", "asepc", "peps", "asep", " elep", "peq", "kep", " seep", "kepa", "sepc", "asepa", "seps", " sepc", "pep", "seq", " elepc", "SEp", "sepa", " eleep", "SEpa", "SEq", " sepa", "keq", "seep", " elepa"], "messagedigest": ["messagiger", "messagediget", "messributedegment", "messagedager", "messagedegener", "messagedegester", "messagedigoener", "messagedigoest", "messageregment", "messagediffer", "messagingiger", "messagedigoester", "messagingigester", "messagedequener", "messributedigment", "messagedigist", "messagerigener", "messagedequment", "messagedaggest", "messagediggest", "messageriger", "messagedeggest", "messributediget", "messagingegester", "messagediger", "messagingiggest", "messagigener", "messagereger", "messagedeger", "messagedigoment", "messagingigest", "messagedigerest", "messagedegist", "messagediffener", "messagedisset", "messageddigist", "messageregest", "messageregener", "messageddigener", "messagedeget", "messagedagest", "messagedigerester", "messagedissest", "messagingeger", "messageddigest", "messagerigest", "messagedequer", "messagingegest", "messagerigment", "messagediffist", "messagedissment", "messagedigergest", "messageddiger", "messagigist", "messagingeggest", "messagedigerer", "messagedegment", "messagedigoet", "messagedagester", "messagedigoer", "messageger", "messributedegester", "messagegener", "messagedigester", "messributedigester", "messagegest", "messagigest", "messagedegest", "messributedegest", "messagedigment", "messributedigest", "messagedigener", "messagegist", "messagedissester", "messagedequest", "messributedeget", "messagediffest"], "stringbuffer": ["ringbuffer", " stringattribute", "stringpage", "sequenceserver", " stringdatabase", "chainqueue", "chaintemplate", "stringserver", "commentdocument", "chainbuffer", "resourcebuffer", "ringpage", "buffercommand", "stringqueue", "stringtable", "sequencebuffer", " stringserver", "ringtemplate", "stringstyle", "sequencestyle", "stringBuffer", "soundvector", " stringtable", " stringsequence", " stringvector", "ringsequence", "resourcedocument", "Stringbuffer", "stringbuff", "librarytemplate", "stringvector", "bufferattribute", "soundtemplate", "libraryvector", "Stringservice", "joinloader", "ringservice", "sequencedatabase", "resourcebuff", "stringdatabase", "ringappend", "bufferstyle", "bufferbuilder", " stringloader", "resourcetemplate", "soundbuffer", " stringbuff", "bufferloader", "chaincommand", "soundtable", "commentbuffer", "ringBuffer", " stringstyle", "joinbuilder", "bufferbuffer", "Stringsequence", "stringappend", " stringbuilder", "ringattribute", "bufferdatabase", " stringBuffer", "stringloader", " stringdocument", "stringbuilder", " stringappend", "ringqueue", " stringtemplate", "buffertemplate", " stringpage", "stringsequence", "joinpage", "joinattribute", "bufferserver", "joinbuffer", "joinappend", " stringservice", "stringservice", "stringtemplate", "stringdocument", "bufferqueue", "ringcommand", "librarybuffer", "librarytable", "commenttemplate", "commentbuff", "stringcommand", "stringattribute"], "stringbuffer2": ["relationbuffer2", "relationbuffer22", "stringcell52", "stringbuffer9", "listbuffer32", "stringcell\t", "stringbuffer02", "stringqueueTwo", "sequencebuffer5", "relationfilter2", "stringmodel32", "stringvector32", "stringcomment32", "relationbuffer3", "stringvector2", "stringbuffer4", "stringbuff14", "listcacheTwo", "stringblock02", "stringBuffer3", "stringBufferTwo", " stringblock2", "statusbuffer102", "stringcache5", "stringdirectory4", "stringBuffer2", " stringbatch14", "sequencebuff5", "stringmodel6", "statusbuffer\t", " stringblock1", "listcache2", " stringbuffer9", "listbuff4", "stringflake5", "listbuff2", "stringdirectory52", " stringbatch2", "storebuffer14", "stringcomment5", "stringbuff4", " stringbuffer182", "stringfilter32", "stringfilter3", " stringbuffer02", "numberqueue2", "stringbutton\t", "numberqueue02", "listbuff52", "stringmodel2", "stringbuffer182", "stringbufTwo", "stringqueue1", "stringBuffer1", "stringbutton102", " stringblock4", "stringbuffer102", "stringconst2", "storebuffer102", "stringbuffer22", "stringbatch14", "stringbuf1", "statusbuffer2", "stringrecord4", "stringBuffer22", "numberqueueTwo", "stringprofile2", "storeference14", "stringfilter22", "stringdocument2", "stringbuff6", "stringconst32", "numberbuffer2", "stringprofile4", "stringference14", "storebuffer52", "storeference2", "stringbufferTwo", "stringcache4", "statusbatch102", "numberbufferTwo", "stringdirectory3", "stringbutton2", "numberqueue1", "stringconst4", "stringbuffer14", "stringference102", "statusbatch2", " stringbatch4", " stringbuffer32", "stringlevel14", "numberbuff32", "listbufferTwo", "statusbatch\t", "stringrecord1", "stringbuff2", "stringdirectory15", "stringbuffer15", "stringprofileTwo", "stringbuffer5", "stringbuffer6", "stringcache6", "stringprofile32", "stringflake2", "stringference52", "statusbuffer52", "listbuffer52", "stringbuffer52", "stringconstTwo", "stringcell2", "stringmodel4", "relationfilter22", " stringbatch6", "sequencebuffer2", " stringwindow9", "stringdirectory2", "stringrecord2", "stringrecord02", "stringrequest102", "storeference52", " stringmodel4", "stringqueue2", "storebuffer2", "stringdocument14", "stringwindow182", " stringwindow182", "stringdocument4", "listbuffer2", "listcache32", "stringference2", "stringflake32", "stringvector182", " stringblock02", "stringbatch5", "stringvector4", "stringbuff32", "relationfilter32", "stringbatch102", "stringcache2", "sequencebuffer4", "stringlevel2", "stringbuffer3", "stringbatch4", "stringwindow9", "stringdirectory22", "listbuff15", "listbuffer4", "stringbatch52", "stringwindow32", "relationfilter3", " stringbuffer4", " stringmodel32", "stringrequest52", "numberbuff5", "storeference102", "stringdirectory182", " stringmodel2", "stringwindow2", "stringrequest2", "stringcache32", "stringbuff52", "listbuffer15", "stringdirectory32", "stringbuff15", "numberbuff2", "statusbatch52", "stringbuf2", "stringlevel102", "stringBuffer4", "stringbuffer32", "stringdirectory9", "stringvector15", " stringbuffer14", "stringcomment2", "sequencebuff4", "numberbuffer1", "stringcacheTwo", "sequencebuff2", "stringBuffer32", "stringlevel52", "stringbuf02", "stringBuffer02", "stringrequest14", "stringfilter2", "relationbuffer32", "stringvector52", " stringbuffer6", " stringwindow32", "numberbuffer02", "stringbatch2", "stringblock1", "stringvector9", "stringblock2", "listcache4", " stringmodel6", "stringdocument6", "stringbatch\t", "stringbatch6", "stringblock4", "stringcell102", " stringwindow2", "numberbuffer32", "stringbuff5", "numberbuffer5", "stringbutton52", "stringqueue02"], "inetaddress": ["jsonaddress", "jsonattribute", "inetattribute", "jsonmedia", "bitcoinmedia", "ixAddress", "inetaddr", "inetchannel", "inetbuffer", "bitcoinbuffer", "etchannel", "etaddress", "ptonaddress", "socketaddress", "ixaddr", "socketaddr", "ptonmedia", "bitcoinattribute", "bitcoinaddress", "ptonattribute", "ixaddress", "inetmedia", "socketchannel", "ptonbuffer", "etAddress", "inetAddress", "socketAddress", "ixchannel", "etaddr", "jsonbuffer"], "l": ["loc", "L", "z", "el", "u", "lang", "b", "p", "ls", "dl", "ln", "le", "local", "m", "ll", "li", "nl", "x", "left", "locking", "lp", "lt", "r", "len", "ld", "g", "lit", "tl", "t", "d", "lc", "n"], "l1": ["fl001", "li0", "l11", "llau", "L1", " LOne", "lock001", "lOne", "L11", "lock01", "li2", "lockasso", "lf01", "L2", " L11", "lang1", "l2", "lfasso", "lau", "lf1", "lasso", "l01", "fl1", "lcau", "li11", " L1", "langOne", "ll1", "lang2", " lau", " l11", "L0", "l001", "fl01", " lOne", " L2", "ll0", "lang11", "li1", "lcav", "lc0", "lav", "llav", " l2", "lf001", "lc1", "flasso", " lav", "l0", " l0", "lock1"], "abyte0": ["there9", "binary0", " bite000", "ano1", "slice0", "ano6", "sliceee", "slice5", "there6", "bone160", "binary5", "byte0", " bite19", "bone0", "byte5", "abyte000", "abyteee", "abyte6", "ano0", "there1", "abyte1", "ano9", "binaryee", "gment000", "gment0", "abyte19", "byte9", "bone000", "there0", "byte6", " bite160", "gment160", " bite0", "abyte5", "abyte160", "byte1", "abyte9", "bone19", "byteee", "gment19"], "stringbuffer1": ["sqlbank2", "stringbuffer8", "stringbuff2", "resourcecache1", " stringbuffer3", "stringbuff3", "StringBuffer01", "stringcache1", "stringbatch1", "stringBuffer01", "stringBuffer1", "stringcache8", "sqlbuffer1", "Stringbuffer2", "sqlbuffer3", "stringbuff01", "stringbuf1", "StringBufferOne", "StringBuffer2", "resourcebuffer3", "stringbuff1", "resourcebuffer1", "Stringbuffer01", "stringbank01", "StringbufferOne", " stringbuffer8", "resourcecache3", "Stringbuffer1", "stringbatchOne", "stringbank3", "sqlbank3", "stringBuffer3", "sqlbank1", " stringcache3", "resourcebuffer01", "stringbatch01", "resourcebuffer2", "sqlbuffer01", "stringbuf3", "sqlbank01", "stringBuffer2", "stringcache01", "stringbank2", "stringbufferOne", "resourcecache01", "stringbankOne", "stringbank1", "stringbatch2", "stringBufferOne", "stringblock1", "stringbuf8", " stringcache1", "StringBuffer1", "stringblock3", "stringbuffer01", "sqlbuffer2", "stringbatch3", "stringcache2", "stringbuffer3", " stringcache8", "stringcache3", "resourcecache2", "stringblock8"], "i": ["cli", "mi", "ami", "u", "iq", "id", "ri", "v", "ix", "ini", "I", "ii", "us", "si", "ai", "io", "chain", "print", "bi", "q", "m", "me", "ki", "in", "it", "ic", "multi", "li", "ti", "ij", "xi", "init", "x", "ji", "ie", "zi", "phi", "y", "ind", "is", "ui", "uri", "PI", "di", "gi", "json", "ci", "ip", "\u0438", "o", "info", "qi", "im", "pi"], "j": ["k", "z", "dj", "b", "v", "p", "ix", "jj", "jp", "nm", "jc", "aj", "bi", "q", "m", "it", "js", "jump", "ja", "J", "ij", "note", "jl", "obj", "kj", "x", "ji", "y", "ind", "bj", "br", "uj", "g", "json", "jit", "o", "job", "oj", "n"], "s": ["f", "fs", "ashes", "ches", "ends", "ats", "b", "bs", "v", "p", "rs", "cs", "ls", "sts", "bits", "stats", "e", "string", "S", "ms", "ns", "sys", "m", "str", "ss", "sq", "js", "c", "gs", "ds", "comm", "sv", "ts", "ims", "sql", "sb", "y", "less", "is", "als", "h", "details", "r", "parts", "ings", "erences", "es", "abs", "hs", "its", "t", "sample", "qs", "ps", "n"]}}
{"id1": "416857", "id2": "21395184", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "label": 0, "substitutes": {"process": ["update", "processor", "output", "exec", "scan", "Process", "work", "task", "walk", "processing", "program", "load", "step", "run", "execute", "check", "display", "loop", "input", " ingest", "proc", "create", "parse", "accept", "filter", "read", "handle"], "dir": ["loc", "rel", "folder", "del", "div", "host", "dr", "dd", "lib", "org", "id", "old", "ir", "dl", "dat", "data", "window", "home", "mk", "disk", "addr", "lim", "tar", "rect", "src", "str", "pkg", "mod", "http", "direction", "vol", "dist", "www", "orig", "prefix", "md", "file", "DIR", "tmp", "directory", "det", "name", "ind", "this", "def", "out", "txt", "doc", "cur", "grad", "filename", "wd", "db", "cd", "start", "desc", "url", "Dir", "root", "log", "direct", "fd", "html", "d", "local", "rot", "deg", "handle"], "list": ["record", "LIST", "old", "dl", "detail", "ln", "listed", "state", "set", "status", "re", "add", "link", "note", "range", "dump", "file", "code", "def", "line", "details", "get", "null", "log", "local", "length", "match", "cache", "select", "dict", "string", "form", "chain", "print", "sort", "tree", "st", "array", "li", "table", "spec", "lists", "left", "batch", "name", "see", "write", "display", "number", "l", "filter", "result", "copy", "v", "other", "ls", "data", "test", "str", "pre", "single", "all", "tmp", "word", "out", "source", "config", "ist", "names", "now", "index", "history", "L", "show", "delete", "queue", "sequence", "block", "collection", "map", "lat", "this", "split", "rm", "stat", "cont"], "n": ["nn", "z", "nu", "num", "p", "pi", "v", "norm", "count", "nc", "nm", "total", "N", "net", "sn", "ne", "ln", "nw", "ns", "un", "nb", "m", "network", "c", "nor", " N", "nl", "j", "nan", "nt", "name", "nr", "no", "w", "number", "len", "g", "l", "na", "ni", "t", "names", "np", "d", "ng"], "bubblesort": ["bubbsist", "bubbleort", "robblessort", "bubblingorts", "bubblingort", "bubblesist", "bubbsORT", "bubbssort", "robblesorter", "bubbledist", "bubblingorter", "robbledist", "bubblerord", "bubblersort", "bubblingsort", "gobbleist", "bubbsort", "bubbledorter", "bubbsorts", "bubblesorts", "bubbledsort", "gobbsord", "bubblingORT", "bubbledord", "robblesorts", "robblesort", "gobbsort", "bubblesord", "bubbledORT", "gobbleserv", "gobblingort", "bubblesorter", "robblesord", "bubbledorts", "gobblesist", "bubblerv", "bubbsorter", "bubbleorts", "bubblerorter", "bubblsort", "robbledord", "bubbsord", "gobblingorter", "gobblesort", "bubblorter", "robblesist", "gobblesord", "robbledorts", "bubblederv", "bubbleist", "gobbsorter", "gobblesorter", "robbledort", "gobblingerv", "bubblingerv", "bubblessort", "robbledsort", "bubblesORT", "bubbleord", "bubbleorter", "bubblingord", "bubbleserv", "gobbleorter", "gobbsORT", "bubbledort", "robbledorter", "gobblesORT", "gobblessort", "gobbleort", "gobblingsort", "bubblerort", "bubblort"], "i": ["cli", "mi", "z", "u", "record", "id", "ri", "q", "err", "set", "ims", "g", "di", "gi", "ci", "point", "I", "pi", "exp", "ix", "us", "e", "io", "chain", "my", "m", "ki", "multi", "ic", "it", "li", "xi", "to", "init", "key", "ji", "batch", "ind", "is", "l", "fire", "qi", "p", "v", "ex", "ity", "s", "si", "eu", "me", "in", "iu", "c", "j", "x", "zi", "parent", "iri", "uri", "go", "index", "ami", "iq", "ini", "ii", "ai", "bi", "sim", "ei", "ti", "ij", "hi", "phi", "y", "this", "ui", "iter", "im", "oi"], "f": ["fs", "b", "cf", "p", "bf", "fw", "v", "lf", "fm", "af", "elf", "fe", "m", "tf", "sf", "c", "fb", "fr", "file", "df", "aff", "fac", "fp", "fi", "h", "fab", "l", "t", "fd", "F", "d", "w", "fc"], "img": ["image", "og", " im", "org", "uf", "fm", "jp", "gif", "window", "tif", "buf", "ref", "inf", "aj", "imag", "picture", "src", "m", "amp", "gm", "raw", "it", "images", "shr", "anim", "jpg", "fb", "j", "medium", "impl", "md", "obj", "aug", "pic", "Image", "orm", "tmp", "mp", "small", "dm", "mb", "gb", "fig", "good", "h", "png", "imgur", "conv", "url", "util", "html", "im", "now"], "whichcase": ["whorule", "whosepath", "whosetest", "whostring", "whatCase", "whatmatch", "wherecase", " whichmatch", " whichstring", " whichtest", "whichspace", "whosematch", "howchar", "howtest", "whatcatch", "whethertest", "whosecase", "whoseCase", "whatstring", "whethercatch", "howspace", "whichtest", "whattest", "whereCase", "whatcase", "whichcatch", "whatspace", "whocase", "whichpath", "howstring", "howrule", "whotest", "wherecatch", "whatrule", "wheretest", "whichstring", "whichmatch", " whichrule", "whethercase", "whichchar", "whoCase", "whererule", "whetherrule", "howmatch", "whatchar", " whichCase", " whichchar", " whichpath", " whichspace", "wherematch", "howCase", "whichrule", "whopath", "howcase", "whichCase"], "lastDigit": [" lastdiget", "firstdigbit", "lastHourbit", "firstDigbit", "firstdigiter", "lastdigiter", " lastDigot", "firstDigiter", "maxDigot", "lastHourita", "lastDbit", "firstdigot", "lastDoublei", "lastDit", "lastDoublebit", "lastdigita", " lastdigiter", "firstdigi", "maxDigbit", "lastdiget", "maxDigiter", "lastPosit", "lastValet", " lastdigit", " lastDiget", "lastDigbit", "firstdigit", "lastPositer", "firstDigit", "lastDigot", "lastDet", "lastValiter", "lastPosot", "lastdigi", "maxdigit", "lastPosuster", "lastDigiter", "lastdigbit", " lastDigita", "firstDiguster", "lastPosi", "lastDiget", "lastPosbit", " lastDigbit", "lastDigita", "lastDiter", "lastDoubleit", "firstDigi", "maxdigiter", " lastDigiter", "firstDigot", "lastDiguster", "lastDoubleuster", "maxdigot", "lastDigi", "lastHourit", "lastdigot", "lastdiguster", " lastdigbit", "lastValbit", "lastdigit", "maxdigbit", "lastValit", "lastHourot", "firstdiguster", "maxDigit"], "sorted": ["unsorted", " sorting", "sorting", "isorted", "unsorter", "unsort", "sorter", "sort", "Sorter", "isorting", "Sort", " sorter", "isorter", " sort", "unsorting", "insorter", "insorted", "insorting", "insort", "Sorted", "Sorting", "isort"], "temp": ["v", " tmp", "level", " temporary", "tim", " temperature", "test", "buffer", "pre", "m", " t", "orig", "emp", " total", "mp", "tmp", "base", "porary", " v", "txt", "w", "Temp", " w", "tem", "fake", "t", "local", "stem"], "tempp": ["typle", "timple", "typl", "timpps", "comple", "timpp", "compps", "compp", "typps", "typp", "timpl", "tempps", "templ", "compl", "temple"]}}
{"id1": "9413074", "id2": "12242903", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 0, "substitutes": {"getLocation": [" getDescription", "GetDescription", " getURL", "getlocation", "getDescription", "GetLocation", "loadURI", " getLoc", " getURI", " getlocation", "GetLoc", "newLoc", "GetURI", "GetURL", "getURL", "getURI", "loadLocation", "getLoc", "newDescription", "loadDescription", "newlocation", "newLocation", "loadURL", "Getlocation"], "clazz": ["klClass", "Claz", "Clos", "Clazz", "CLazz", "scazz", "klclass", "claz", "clclass", "scaz", "clClass", "clamp", "clos", " clamp", "Clclass", "Clamp", "CLclass", "scamp", " clos", "scos", "CLaz", " claz", "klazz", "ClClass", "klaz", "CLClass"], "url": ["f", "loc", "host", "rel", "u", "sl", "ssl", "gl", "org", "https", "ls", "dl", "channel", "char", "hl", "string", "web", "ml", "ref", "user", "lr", "addr", "q", "buffer", "str", "err", "ll", "xml", "conn", "ret", "loader", "resource", "http", "rl", "ul", "nl", "link", "socket", "browser", "ur", "impl", "sql", "URL", "sb", "run", "cert", "build", "base", "address", "this", "mount", "mail", "client", "ob", "get", "r", "uri", "Url", "l", "abs", "row", "path", "log", "util", "remote", "result", "handle"], "location": ["loc", "length", "translation", "update", "scope", "value", "behavior", "position", "displayText", "language", "message", "relation", "where", "feature", "description", "area", "color", "peer", "string", "path", "origin", "resolution", "application", "Location", "region", "resource", "trace", "direction", "availability", "ocation", "nl", "usage", "comment", "range", "expression", "document", "layout", "function", "operation", "address", "directory", "none", "reference", "name", "history", "family", "library", "ion", "display", "title", "filename", "l", "row", "type", "padding", "summary", "media", "selection", "command", "local", "slot", "result"], "file": ["f", "image", "folder", "object", "entity", "pe", "output", "binary", "angle", "port", "channel", "format", "path", "user", "io", "le", "ref", "checked", "files", "ory", "block", "face", "File", "resource", "table", "FILE", "ca", "page", "dir", " File", "run", "library", "parent", "name", "out", "fp", "ile", "full", "filename", "db", "module"]}}
{"id1": "11616716", "id2": "6987642", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultsAsString", "getCMSResultsasStream", "getCMSResultsAsView", "getCMSResultAsSteam", "getCMSResultasView", "getCMSResultasSteam", "getCMSResultsAsStream", "getCMSResultasStream", "getCMSResultasString", "getCMSResultAsView", "getCMSResultsasSteam", "getCMSResultsasString", "getCMSResultsAsSteam", "getCMSResultsasView", "getCMSResultAsString"], "rqlQuery": ["RQLCommand", " rqlStatement", "rqString", "rqlquery", "Rqlquery", "rQLQuery", "rsqlQuery", "rumbleStatement", "RqlCommand", "rumbleQuery", "rqStatement", "rqlStatement", "rviewQuery", "RQLquery", "rQLquery", " rsqlString", " rsqlQuery", "rsqlString", "rviewCommand", "rqQuery", "rqlString", " rsqlStatement", "rQLCommand", "rqCommand", "rqlCommand", "rviewquery", "RQLQuery", "rqquery", "RqlQuery", "rumbleString", "rsqlStatement", " rqlString"], "osr": ["ooscr", "ossq", "oosd", "iosd", "ossrw", "oeser", " osvr", " osmr", "oosr", "ooser", "iosrg", "oesrator", "osesmr", "oesrw", "ossrar", "osrar", "ossh", "posrator", "osscr", "posr", "iosrator", "iossr", "osmr", " osrg", "ossr", "ossvr", "oseser", "or", " ossr", "oesmr", "osrg", "ovr", "osrator", "orar", " osrar", "osssr", "osesrw", "osd", " osq", "osq", "ossmr", "iosr", "ossrg", "iosq", "possr", "iosvr", "osh", "osser", "osrw", "osesr", "ossd", "oessr", "oscr", "iosmr", " osh", "oesr", "iosh", " oscr", "oser", "osvr", "ioser", "ioscr"], "url": ["loc", "rel", "host", "el", "sl", "ssl", "gl", "https", "ls", "dl", "il", "hl", "char", "bel", "web", "net", "str", "ll", "pkg", "ret", "http", "ul", "nl", "link", "ur", "URL", "cert", "build", "mb", "open", "client", "mail", "mount", "ol", "lb", "ld", "uri", "Url", "l", "abs"], "conn": ["cn", "loc", "rel", "cmd", "exec", "org", "jp", "connect", "nc", "enc", "canon", "sync", "con", "nw", "addr", "sys", "ns", "ctx", "resp", "c", "col", "comm", "j", "socket", "link", "req", "init", "pg", "connection", "res", "Conn", "obj", "cert", "nt", "connected", "act", "ch", "cp", "open", "client", "out", "win", "syn", "cur", "close", "conv", "proc", "conf", "l", "os", "pas", "ct", "cb", "cont", "n"]}}
{"id1": "21488868", "id2": "838844", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "8430178", "id2": "823074", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpFiles", " copyLine", " copyFiles", " copyPath", "cpLine", "CopyFiles", "CopyFile", "copyFiles", "cpFile", "CopyLine", "copyPath", "CopyPath", "copyLine", "cpPath"], "source_name": ["source_NAME", "source_case", "sourcePname", "source_format", "source_local", "Source_NAME", "src_case", "sourcePNAME", "src_names", "sourceEName", "sourceptnames", "source_word", "sourceptcheck", "sourceEname", "source09link", "sourceEcase", "sourceptName", "Source_local", "src_format", "src_file", "Source_name", "src_link", "source_Name", "source09name", " source_names", "source_names", "src_check", " source_word", "sourceEnames", "source09file", "source_check", "src_Name", "sourcePlocal", "src_name", "source_link", "source09names", "sourceptname"], "dest_name": ["source_NAME", "destipcreate", "destitycommon", "start_common", "destationadmin", "dest_time", "destaxyname", "dest_no", " dest_no", "dest_Name", "dest_file", "dest9group", " dest_time", "destipid", "dest_key", "dest__key", "Dest_admin", "dest9Name", "destationName", "destationname", "startityadmin", " dest_key", " dest_names", "destaxynam", "src_create", "destaxyName", "dest_common", "destityadmin", "dest9name", "startityname", "source_nam", "src_id", "dest_nam", "destityName", "dest_id", " dest_file", "start_Name", "dest__name", "start_admin", "dest__names", "src_file", "startityName", "Dest_group", "source_Name", "dest_NAME", "destaxynames", "Dest_name", "dest_size", "dest_group", "destityname", "Dest_Name", "source_names", "dest_admin", "destipname", " dest_Name", "destipfile", "dest_min", "start_name", " dest_size", "startitycommon", " dest_min", "dest9admin", "destationcommon", "dest__size", "src_name", "dest_create", "dest_names"], "source_file": ["site___stream", "sourceistname", "source___time", "source_info", " source_link", "site___service", "source1name", "source___file", "source___service", "source1stream", "source_path", "sourcephpstream", "sourceistlink", "site_file", "ource_time", "sourcepyle", "source1path", "source_service", "ource_class", "source2info", "site___le", "sourcephpfile", "source2entry", "ource_file", "source___stream", "site_service", "sourcephple", "source_time", "sourcepyservice", "source2file", "src_file", "ource_File", "source_le", " source_entry", "source_class", "source_id", " source_info", "site_le", "source___le", "sourceistid", "sourcephpservice", " source_id", "src_path", "source_stream", "source_entry", "sourceistfile", "source_File", "sourcepyfile", "source1file", "sourcepystream", "source___class", "site_stream", "src_stream", "src_name", "source_link", "site___file", "source___File"], "destination_file": ["destinant____file", "destinationJfp", "destinant_port", "destination____domain", "destification_port", "destination_path", "destrant_image", "destinant_fp", "destination_dir", "destinant____db", "destrant_file", "destination____file", "destrant_fp", "destinant_File", "destination_port", "destination_domain", "destrant_path", "destinate_file", "destinate_ile", "destinationJfile", "destinationJpath", "destinant_file", "destination_link", "destinant_link", "destrantJfile", "destination_ile", "destination__File", "destification_path", "destination____File", "destinant_domain", "destination_File", "destification_ile", "destrantJpath", "destification_file", "destination_image", "destination_db", "destination____db", "destrantJimage", "destinate_do", "destinationJimage", "destinate_dir", "destrantJfp", "destination_do", "destinant_db", "destination__file", "destinant____domain", "destination__db", "destination__domain", "destination_fp", "destinant____File"], "source": ["image", "object", "scope", "copy", "server", "store", "search", "product", "SOURCE", "script", "class", "feature", "service", "sin", "ources", "content", "dest", "secret", "target", "cause", "origin", "sequence", "ource", "src", "set", "from", "or", "resource", "join", "status", "major", "argument", "volume", "note", "ser", "session", "query", "connection", "file", "ie", "proxy", "directory", "parent", "base", "reader", "system", "unit", "client", "out", "template", "input", "title", "config", "iter", "start", "shadow", "existing", "Source", "tool", "ce", "site", "sample", "use", "local", "master"], "destination": ["restation", " destinated", "methodinate", "gestinator", "destication", "targetinated", "targetination", " destinator", "alterninate", "restinator", "estinated", "restinated", "methodinated", "alterninated", "terminociation", " destinate", "methodination", "Destination", "estinate", "terminination", "targetion", "targetociation", "destociation", "gestociation", "gestination", "Destinated", "estination", "gestinated", "destion", "Destinator", "estication", "Destinations", "origininator", "targetinations", "destinate", "destation", "coordinated", "Destion", "Destation", "originination", "alternination", "restion", " destation", "termininated", "alterninator", "originification", "coordination", "destification", "destinations", "targetification", " destication", "methodinator", "restination", "coordication", "restinate", "coordinate", "targetinator", "restinations", "destinated", " destification", "origininated", "termininator", "destinator"], "buffer": ["length", "context", "stream", "binary", "b", "cache", "transfer", "message", "window", "buf", "sequence", "block", "text", "table", "frame", "comment", "paste", "document", "batch", "base", "append", "iter", "Buffer", "buff", "bb", "command", "read"], "bytes_read": [" bytes_Read", "bytesunleft", "bytesunread", " bytes_written", "bytes2Read", "bytes2read", "bytes2written", "bytesunRead", "bytes_written", " bytes_left", "bytes_left", "bytesunwritten", "bytes2left", "bytes_Read"], "in": [" IN", "ins", "din", "std", "en", "stream", "id", "p", "ini", "sum", "IN", "inn", "con", "user", "io", "inf", "diff", "gin", "cin", "mm", "err", "bin", "from", "ar", "ic", "it", "add", "all", "nin", "file", "mn", "body", "reader", "ind", "is", "client", "out", "rin", "get", "input", "r", "doc", "inner", "conf", "l", "t", "log", "isin", "read", "In", "n"], "response": ["onse", "reply", "output", "value", "question", "data", "message", "relation", "window", "description", "format", "notice", "print", "sequence", "hello", "block", "example", "resp", "entry", "continue", "request", "network", "answer", "zero", "status", "ping", "offer", "page", "bye", "choice", "python", "query", "connection", "res", "application", "remember", "hash", "line", "vector", "respons", "respond", "one", "reset", "Response", "version", "json", "echo", "success", "sample", "exit", "command", "result"], "parentdir": ["parentdirectory", "Parentfolder", " parentDir", "masterfile", " parentdirectory", "Parentdir", "rootfolder", "fatd", "rootdirectory", "Parentdirectory", "masterdirectory", "Parentfile", "rootdir", " parentdirect", "parentDir", "rootd", "rootdirect", "fatdirect", "masterdir", "parentfile", " parentfolder", "parentdirect", "parentfolder", "fatdirectory", " parentfile", "rootDir", "parentd", "ParentDir", " parentd", "fatdir", "masterDir"]}}
{"id1": "21425787", "id2": "812803", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", "transferFile", " copyByte", "CopyByte", "transferByte", " copyFiles", "CopyFiles", "copyByte", "CopyFile", "copyFiles", "Copyfile", " copyfile", "transferFiles", "transferfile"], "in": ["ins", "din", "el", "en", "b", "old", "IN", "inn", "inf", "cin", "gin", "on", "from", "ar", "ic", "it", "vin", "ie", "ind", "is", "inc", "up", "rin", "i", "input", "source", "l", "o", "isin", "In", "n"], "out": ["ot", "output", "OUT", "b", "v", "p", "ex", "gt", "ent", "s", "net", "ne", "io", "str", "err", "outs", "it", "c", "ou", "to", "po", "nt", "i", "source", "oss", "g", "help", "os", "null", "l", "t", "o", "Out", "at", "w", "n"], "sourceChannel": ["startMachine", "sourceManager", "systemMachine", " sourceClass", "inputChan", " sourceCommand", "srcCh", "ourceChan", "seedMachine", "inputCh", "systemPanel", "sourceConnection", " sourceManager", "systemChannel", "sourceCategory", "sourceCommand", "srcManager", "ourceConnection", " sourceConnection", "startPanel", "srcClass", "sourceMachine", "ourceClass", "srcChannel", " sourceCh", "srcCommand", "srcChan", "srcConnection", " sourceChan", "ourceChannel", "sourceClass", "sourceChan", "inputChannel", "seedCategory", "ourceManager", "sourceCh", "startChannel", "startCategory", "seedPanel", "seedChannel", "ourceCommand", "inputConnection", "systemCategory", "sourcePanel"], "destinationChannel": ["destinoChannel", "destinochannel", "Destinationchannel", "destationChan", "DestationChan", "destationChannel", "DestinationChan", "destinationConnection", "destinationContext", "DestinationChannel", "destinationschannel", "destinationchannel", "destensionChannel", "destensionchannel", "destinatorHandler", "DestinationConnection", "destensionChan", "DestationHandler", "DestinationHandler", "destinationHandler", "destationContext", "destinoContext", "restinationChan", "destinatedContext", "destinatedChannel", "destinoChan", "destinatedchannel", "destinatorchannel", "destinatorChan", "destationConnection", "DestensionConnection", "restinationchannel", "destinationsChan", "restinoChan", "destationchannel", "DestensionChan", "destinationsConnection", "DestationChannel", "restinoChannel", "destinationsChannel", "restinationContext", "restinationChannel", "restinoContext", "destinatorChannel", "destationHandler", "DestensionChannel", "destensionConnection", "destinatedChan", "Destensionchannel", "restinochannel", "destinationChan", "Destationchannel"]}}
{"id1": "13414771", "id2": "4458076", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public InputStream getInputStream() throws TGBrowserException {\n        try {\n            if (!this.isFolder()) {\n                URL url = new URL(this.url);\n                InputStream stream = url.openStream();\n                return stream;\n            }\n        } catch (Throwable throwable) {\n            throw new TGBrowserException(throwable);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"encriptPassword": ["EncriptAuth", " descryptPassword", "EnribePassword", "EncriptKey", " desribeKey", "EnribeKey", " desizeAuth", "EncriptField", " descriptField", "EnribeAuth", " descryptField", " descriptAuth", " descryptAuth", " desribePassword", " desribeField", "EnribeField", " descriptPassword", " desizeField", " descriptKey", "EncriptPassword", " descryptKey", " desizeKey", " desizePassword", " desribeAuth"], "passwd": ["psword", "mailword", "passw", "mailphrase", " passsword", "defphrase", "assphrase", "defword", "pword", "passphrase", "pasw", "defw", "pw", "assw", "passsword", "paswd", "pwd", " password", " passw", "defwd", "mailwd", "mailw", "pasword", "password", "asswd", "assword"], "md": ["pdf", "cmd", "dd", "dr", "mt", " MD", "der", "mo", "red", "mg", "dh", "mk", "sd", "hm", "od", "ms", "mm", "m", "pm", "pd", "mod", "ds", "down", "and", "add", "mc", "mn", "ma", "df", "managed", "nt", "dm", "ind", "mb", "mask", "mail", "td", "ld", "rm", "di", "cd", "desc", "bd", "hd", "d", "at", "MD", "sm"], "hash": ["ash", "sh", "sha", "cache", "rh", "sum", "message", "ssh", "Hash", "checked", "proof", "has", "hidden", "sq", "score", "bh", "ah", "oh", "key", "ashed", "hex", "mass", "mask", "check", "h", "trust", "mac", "her", "shadow", "uh", "hed", "filter", "sample", "hd", "password", "kernel"]}}
{"id1": "23215235", "id2": "1235538", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"readFile": [" readfile", "readSourceFile", "readFiles", "parseFile", "ReadSourceFile", " readFiles", "Readfile", "parsefile", "parseSourceFile", "readfile", "ReadFile", "parseFiles", " readSourceFile", "ReadFiles"], "url": ["loc", "rel", "host", "u", "sl", "ssl", "domain", "gl", "b", "id", "p", "location", "ls", "dl", "channel", "pattern", "il", "char", "bel", "string", "path", "web", "ref", "ml", "str", "ll", "http", "rl", "nl", "link", "page", "browser", "ur", "item", "impl", "URL", "document", "file", "base", "address", "name", "mount", "client", "full", "uri", "Url", "db", "l", "cl", "abs", "fl", "log", "html", "job"], "IOException": [" IOError", "BioException", " ioException", "IOError", "BioError", " ioError"], "ParserConfigurationException": ["parserConfigurationException", "ParserConfigException", "ParserizationException", "ParserizationError", "ParserConfigFailure", "parserConfigException", "parserConfigError", "ParserConfError", "ParserConfigError", "ParserConfigurationFailure", "parserConfigurationFailure", "ParserizationFailure", "ParserConfException", "ParserConfFailure", "parserConfigFailure", "ParserConfigurationError", "parserConfigurationError"], "SAXException": ["DAVException", "DAVFailure", "SAXMError", "DAXException", "DAXFailure", "SAXMFailure", "SAVError", "SAIFailure", "SAXFailure", "SAIException", "SAXError", "DAVError", "DAXError", "SAVFailure", "SAVException", "SAXMException", "SAIError"], "zipFileName": ["zipPagePath", "zipfileID", "zipfileId", "zipFolderId", "zipfilePath", "zipPageName", "zipFileID", "zipPageID", "zipFolderName", "zipFileId", "zipfileName", "archiveFileId", "archiveFilePath", "zipFolderID", "zipPageId", "archivefileName", "archivefileID", "archiveFileName", "archiveFileID", "zipFolderPath", "archivefileId", "zipFilePath", "archivefilePath"], "urlConnection": [" urlConnect", "urlConn", "UrlConn", "sslConnect", "urlControl", "inputControl", "urlClient", "UrlClient", "UrlConnect", "urlReader", "inputClient", "UrlReader", "clientConnect", "UrlConnection", "sslClient", "clientReader", " urlReader", "sslControl", " urlConn", "inputConnect", "urlConnect", "clientConn", "inputConnection", "sslConnection", "UrlControl", "clientConnection"], "inputStream": [" inputView", "InputContext", "inputView", "inputContext", "InputSteam", "InputView", " inputSteam", "inContext", " inputContext", "inputScript", "inSteam", " InputStream", "inStream", "inputSteam", " InputFile", " InputScript", "InputScript", " inputFile", "InputStream", " inputScript", "InputFile", " InputSteam", "inView", "inputFile"]}}
{"id1": "9954926", "id2": "14650352", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"simulate": ["modulation", " simulates", "smulate", "smulation", "simure", "smulates", "modure", " simure", "simulates", " simulation", "modulate", "simulation", "modulates", "smure"], "out": ["ins", "cmd", "ger", "gen", "buffer", "state", "err", "set", "pretty", "report", "obj", "res", "nt", "gov", "null", "log", "f", "store", "OUT", "co", "exp", "cache", "ent", "e", "io", "print", "tree", "conn", "it", "error", "OU", "ou", "inv", "to", "init", "gc", "aos", "batch", "put", "name", "can", "write", "conv", "help", "conf", "o", "at", "w", "cn", "copy", "p", "v", "hit", "ex", "screen", "sum", "con", "content", "group", "cfg", "in", "raw", "outs", "c", "all", "base", "up", "os", "flush", "t", "go", "handle", "output", "b", "gr", "list", "net", "sys", "on", "writer", "pool", "nr", "client", "last", "inner", "manager", "Out", "outer", "n"], "file": ["f", "output", "b", "port", "model", "channel", "data", "message", "format", "e", "path", "le", "io", "buffer", "set", "File", "resource", "table", "FILE", "report", "document", "connection", "console", "library", "base", "pool", "name", "lock", "fp", "ile", "template", "source", "input", "filename", "db", "l", "type", "play", "t", "log", "result", "handle"], "obtainUserReputationRequest": ["obtainUserRelutationTask", "obtainUserReplutationRequest", "obtainUserRepresentutationrequest", "obtainUserReputionTarget", "obtainUserRepetitionRequest", "obtainUserRepresentationRequest", "obtainUserRepresentationQuery", "obtainUserReputationsQuery", "obtainUserRepresentationError", "obtainUserRepationQuery", "obtainUserRepationTarget", "obtainUserRepationError", "obtainUserRelutationQuery", "obtainUserRelutationsResponse", "obtainUserRelutationsQuery", "obtainUserReputationError", "obtainUserRepresentationrequest", "obtainUserReputationsResponse", "obtainUserReporationError", "obtainUserReputationsrequest", "obtainUserReplutationResponse", "obtainUserRepositoryRequest", "obtainUserReputionRequest", "obtainUserRepresentutationTarget", "obtainUserReputationsTarget", "obtainUserRelutationRequest", "obtainUserRepositoryResponse", "obtainUserRepresentutationResponse", "obtainUserRepresentutationRequest", "obtainUserRelutationsRequest", "obtainUserReputationrequest", "obtainUserRelutationResponse", "obtainUserRepresentationTarget", "obtainUserReporationRequest", "obtainUserRepresentutationQuery", "obtainUserReputationTarget", "obtainUserReputationsError", "obtainUserReputationTask", "obtainUserRepresentationResponse", "obtainUserRelutationsTask", "obtainUserRepetitionResponse", "obtainUserReporationQuery", "obtainUserRepresentutationError", "obtainUserRepationResponse", "obtainUserReputionQuery", "obtainUserReputationsTask", "obtainUserRepationRequest", "obtainUserRepetitionTarget", "obtainUserReputionResponse", "obtainUserReputionTask", "obtainUserReporationResponse", "obtainUserRepationrequest", "obtainUserReputationsRequest", "obtainUserReputationQuery", "obtainUserRepositoryTask", "obtainUserReputionrequest", "obtainUserRepositoryQuery", "obtainUserReplutationTarget"], "obtainUserReputationResponse": ["obtainUserReportositoryAnswer", "obtainUserRepositoryService", "obtainUserReputationsAnswer", "obtainUserReputationsResponse", "obtainUserReportutationResponse", "obtainUserReportositoryResponse", "obtainUserRepulationService", "obtainUserReputationAnswer", "obtainUserRepositoryResponse", "obtainUserReportositoryResp", "obtainUserReputationResp", "obtainUserReportutationService", "obtainUserRepositoryAnswer", "obtainUserReportositoryService", "obtainUserRepulationResp", "obtainUserRepulationAnswer", "obtainUserReputationService", "obtainUserRepositoryResp", "obtainUserRepulationResponse", "obtainUserReputationsResp", "obtainUserReportutationResp", "obtainUserReportutationAnswer", "obtainUserReputationsService"], "rateUserRequest": ["rateuserQuery", "rateUserJob", "rateProxyQuery", "RateUsersQuery", "rateOwnerResponse", "rateUserRecord", "rateProxyResponse", "rateUserrequest", "rateUserQUEST", "rateDateRequest", "rateTimeResponse", "rateuserrequest", "rateSampleCommand", "rateRowRecord", "rateUserGrant", "rateLineGrant", "rateDateResponse", "RateUserQUEST", "rateLineCommand", "rateSamplerequest", "raceRowRequest", "createUserRequ", "rateProxyRequest", "rateRowrequest", "scaleOwnerAccess", "createuserRequ", "rateLineRequ", "raceRowrequest", "scaleOwnerResponse", "raceUserrequest", "createuserCommand", "rateUserCommand", "rateOwnerAccess", "rateLineResponse", "rateOwnerRecord", " rateUserJob", "rateProxyQUEST", "rateUsersQUEST", "rateUsersChange", "rateUsersQuery", "RateUsersResponse", "RateUsersrequest", "createUserRequest", "rateuserQUEST", "RateClientRequest", "rateJobChange", "rateTimeRequest", "raceUserRequest", "rateRowJob", "RateLineQuery", "rateuserResponse", "rateSampleRequ", "rateDateGrant", "RateLineResponse", "RateLinerequest", "rateJobRequest", "RateClientResponse", "createUserCommand", "rateUserAccess", "RateUserGrant", "rateSampleRequest", "rateClientGrant", "scaleUserResponse", "rateUsersResponse", "rateuserAccess", "scaleUserRequest", "rateClientJob", "rateuserRequ", "rateTimerequest", "rateUserChange", "rateUsersAccess", "rateRowResponse", "rateClientrequest", "rateOwnerrequest", "rateJobResponse", "rateRowRequest", " rateUserQuery", "createUserrequest", "rateUserQuery", "RateUsersRequest", "scaleOwnerRequest", "scaleUserAccess", "RateUserChange", "rateClientResponse", "raceUserRecord", "createuserRequest", "rateLinerequest", "RateUserResponse", "rateClientRequest", "RateUserQuery", "rateuserRequest", "rateOwnerRequest", "RateLineRequest", "RateUsersQUEST", "RateUsersChange", "rateUserRequ", "rateLineQuery", " rateUserrequest", "RateClientGrant", "rateUsersRequest", "RateUserRequest", "createuserrequest", "RateUserrequest", "rateLineRequest", "rateuserCommand", "raceRowRecord", "rateUsersrequest"], "rateUserResponse": ["ratesClientResponse", " rateUserAnswer", "ratesUserResponse", "ratesUserRequest", "ratesClientResp", "rateWordresponse", "rateTimeResponse", "rateDateRequest", "rateMemberReply", "rateMethodResponse", "rateControllerResp", " rateUserStatus", "rateDateResponse", "rateUserStatus", " rateClientRequest", "rateWordRequest", "rateMemberresponse", "rateDateData", "rateManagerResp", "rateClientResp", "rateFileresponse", "rateClientMessage", "rateClientReturn", "ratesClientMessage", "RateUsersReply", "rateControllerResponse", "ratesUserResp", "rateWordResponse", "RateUsersResponse", "rateControllerMessage", "rateFileRequest", "rateMemberRequest", "rateUserReturn", "rateTimeRequest", "rateControllerRequest", "rateFileResponse", "rateUserVersion", "rateuserResponse", "rateDateVersion", "RateUserresponse", "rateUsersResponse", "rateFileReturn", "rateUsersAnswer", "rateUserresponse", " rateClientresponse", "rateUserData", "rateMemberResponse", "RateUsersresponse", "ratesUserMessage", "rateUserMessage", "rateuserReply", "rateMethodVersion", " rateClientReturn", "RateUserData", "rateUsersReply", " rateUserresponse", "rateTimeStatus", "ratesClientRequest", "rateManagerRequest", "rateuserresponse", "rateWordReturn", "RateUsersRequest", "rateUsersresponse", "rateTimeAnswer", "rateClientResponse", "RateUserResponse", "rateClientresponse", "rateClientRequest", "rateuserRequest", "rateManagerResponse", " rateUserReturn", " rateClientResponse", "rateUsersRequest", "RateUserRequest", "RateUserReply", "rateUserReply", "rateManagerMessage", "RateUserVersion", "rateMethodRequest", "rateMethodData", "rateUserAnswer", "rateUsersStatus", "rateUserResp"], "fis": ["FIs", " fi", "fIS", "lIS", "lis", "liss", "sfIs", "flis", "fIs", "Fis", "sfis", "bi", "fiss", "sfiss", "bis", "flisa", "fli", "bisa", "fi", "sfIS", "fisa", " fisa", "lIs", "FIS", "Fiss"], "br": ["hr", "div", "dr", "bm", "bl", "mr", "gr", "bf", "bn", "ger", "BR", "adr", "buf", "bp", "vr", "lr", "bi", "str", "kr", "shr", "bro", "bridge", "fr", "bh", "browser", "Br", "ber", "bt", "tr", "ch", "be", "gb", "nr", "pr", "cr", "ctr", "bd", "sr", "wr"], "call": ["callback", "update", "cal", "Call", "dial", "message", "char", "list", "cin", "cell", "test", "str", "block", "continue", "request", "c", "trace", "status", "called", "bridge", "inv", "frame", "add", "ell", "all", "report", "comment", "label", "query", "draw", "function", "code", "execute", "name", "word", "line", "check", "url", "play", "log", "contact", "action", "use", "command", "info", "send", "result", "n"]}}
{"id1": "14390569", "id2": "18164929", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"title": ["tip", "header", "question", "message", "description", "setup", "content", "string", "Title", "notice", "theme", "subject", "lead", "term", "text", "size", "itle", "password", "metadata", "label", "prefix", "heading", "holiday", "layout", "msg", "name", "hash", "template", "details", "parts", "filename", "help", " Title", "TIT", "type", "start", "padding", "summary", "t", "hd", "html"], "imageURL": ["imageURI", "photoURI", "fileUrl", "mediaID", "fileString", "imageID", " imageUR", "ImageUrl", "photoUR", "imageUR", "ImageID", "fileURI", "imageString", "mediaUrl", " imageURI", "mediaURL", "ImageURL", " imageString", "photoUrl", "photoURL", "fileURL", "ImageURI", "ImageUR", "photoID", "imageUrl", "photoString", "mediaURI", " imageUrl"], "jd": ["jsD", "ajpd", "kd", "simD", "javad", "djd", " jsd", "qD", "Jp", "Jc", "simdt", "ujD", " jdo", "Jmd", "kbd", "jsds", "gbd", "jsdm", "jad", "jds", "zad", "ijd", "gd", "Jdo", "ujmd", "djds", "djad", "jpd", "ajds", "jmd", "zd", "ujd", "simmd", "simd", "Jd", "jjbd", "javadm", "djdo", "gdo", "qds", "qd", "ujdt", "djc", "kds", " jdt", "JD", "jobd", " jD", "jdt", "jc", "qbd", "jjp", "jjD", "ajd", "jbd", "jD", "kdo", "kdt", "ujad", "Jdt", "jjd", "Jad", "jobdo", " jc", "jsd", " jds", "javapd", "jobdt", "qdo", "jdm", "djsd", "ijD", "ajdm", " jad", "gds", "ijds", "jdo", "zsd", "Jds", "jspd", "qp", "javads", "Jbd"], "jl": ["isl", " ol", "bol", "yl", "jac", "kel", "jin", "abl", "dj", "jj", "dl", "il", "igl", " li", "kl", "ln", "lu", "Label", "kn", "js", "ja", "li", "ibl", "J", "ij", "nl", "j", "elle", "ell", "ijk", "jah", "elly", "kj", "ji", "dll", "lp", "bj", "txt", "elt", "syn", "uj", "dyl", "gn", "mil", "lv", "jet", "rl", "jc"], "icon": ["image", "cn", " Icon", "cil", "\u4e2d", " fruit", "ico", "ex", "icol", "iao", "con", "nic", " captcha", "conn", "ic", "pen", "addon", "chron", " ancestor", "Icon", "iban", "ICO", "label", "ocon", " lang", "fa", "gc", "pic", "fn", " intent", "lock", "ion", " tip", " widget", " canvas", "syn", "png", " screen", "conv", "eric", " ion", "font", " conn", "icons", "jc"], "chooser": ["Chooser", "pooder", "poicer", " chooder", "Chooder", "choose", " choerer", "chooder", "boose", "CHOose", "CHOosen", "CHOoser", "boosen", "Choose", "Choosen", " choose", "composen", " choicer", "pooser", "composer", "choosen", "choerer", "boerer", "Choicer", " choosen", "choicer", "comperer", "booser", "poose", "CHOicer", "compicer", "compose"], "jp": [" ip", "JP", " je", "jin", " gp", "p", " mp", "bp", " sp", " ja", "js", "ja", "ij", " ap", "j", " np", "kj", "pic", "sp", " sip", "bj", "btn", " pl", " dj", " pic", "np", " cp", " joint", "jc"], "jb": ["qbd", "qb", "Jcb", "jcb", "kjbd", "qcb", "Jb", " jcb", "kjb", "jbd", " jbd", "kjcb", "Jbd"], "e": ["f", "u", "en", "p", "v", "er", "te", "s", "ev", "ed", "E", "m", "Event", "it", "c", "or", "re", "a", "ie", "event", "g", "es", "o", "t", "d", "ee", "w", "n"], "returnVal": ["responseVol", " returnVAL", "ReturnVal", "retValue", " returnVol", "returnVol", " returnValue", "returnval", "Returnval", " returnValid", "retVal", " returnval", "responseVal", "ReturnValue", "returnValue", "ReturnVAL", "getVAL", "responseValid", "returnValid", "getVol", "retval", "getValid", "returnVAL", "getVal", "retVAL", "responseVAL"], "file": ["f", "image", "core", "drop", "fs", "port", "angle", "work", "model", "channel", "class", "il", "relation", "format", "fe", "path", "user", "le", "io", "foo", "target", "buffer", "real", "valid", "tree", "rule", "or", "File", "resource", "http", "table", "status", "FILE", "link", "to", "page", "report", "dir", "document", "run", "body", "library", "base", "be", "name", "word", "open", "fp", "h", "ile", "get", "source", "place", "filename", "create", "full", "db", "null", "type", "stat", "info", "local", "handle"], "fileName": ["FileExt", "fileExt", "entityPath", "entityNAME", " fileClass", "FileFace", "fileSet", "imageName", "handlename", "FILENAME", "imageFace", "ileName", "taskFace", " fileNames", "FILEExt", "imagePath", "taskName", " fileExt", "FileSet", "handleNAME", "Filename", "entityName", "FileNAME", " filename", "handleName", "FILEPath", "fileNAME", "entitySet", "fileClass", "FilePath", "ileClass", "FILENames", "imageNAME", "FILEName", "ilename", "ileNAME", " filePath", "filePath", "FILESystem", "filename", "imagename", "FILESet", " fileSystem", "fileNames", "FileSystem", "taskname", "handleClass", "FileName", "taskPath", "fileSystem", "FileNames", " fileNAME", "fileFace"], "ext": ["Ext", "cmd", "ord", "exp", "ix", "EXT", "ex", "typ", "ec", "enc", "aux", "external", "pat", "test", "part", "cod", "xp", "sem", "vert", "fr", "req", "dir", "lex", "hex", "ag", "prot", "ind", "word", "def", "txt", "off", "exe", "len", "exc", "xt", "desc", "ct", "t", "end", "eur", "lib", "cont"], "i": ["cli", "mi", "id", "pi", "ini", "ii", "si", "ai", "bi", "print", "m", "iu", "it", "ei", "status", "li", "ti", "j", "xi", "init", "hi", "ori", "phi", "y", "is", "ui", "fi", "di", "gi", "ci", "qi", "info", "index", "I"], "doIt": [" doIs", "waIt", " doIT", "donIt", "odoit", "didIs", "diWhich", "doneIT", "doIs", "doYou", " doHe", "donIT", "doneIt", "waIT", "doIT", " doWhich", "diit", " doit", "diHe", "didYou", "doneit", "odoIT", "odoIt", "didit", "donit", "doit", "diIt", "donYou", "odoWhich", "doWhich", "doHe", "waIs", "donIs", "odoHe", "didIt", " doYou"], "src": ["loc", "rel", "ins", "sl", "rt", "ssl", "sh", "copy", "rc", "rs", "https", "sc", "usr", "ources", "crop", "sys", "ource", "rob", "from", "st", "sq", "sec", "gs", "rl", "http", "inst", "ser", "trans", "init", "impl", "sub", "sb", "ptr", "tmp", "rx", "comp", "source", "lb", "syn", "proc", "inner", "conv", "input", "r", "start", "ctr", "rb", "sr", "url", "rest", "cont"], "dest": ["loc", "rel", "output", "https", "port", "Dest", "dat", "usr", "way", "target", "nw", "sys", "origin", "st", "gest", "slave", "dist", "orig", "trans", "dir", "des", "coord", "nom", "pot", "sp", "est", "tmp", "pipe", "cp", "master", "out", "mem", "comb", "source", "iter", "foreign", "cat", "proc", "decl", "pas", "desc", "rest", "local", "temp", "cont", "can"]}}
{"id1": "8150996", "id2": "7908169", "code1": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"copyFile": [" dupChannel", "CopyChannel", "cpDir", "cpStream", "CopyFile", " dupDir", " copyStream", "CopyStream", " dupFile", "cpFile", " copyDir", "CopyDir", " dupStream", " copyChannel", "cpChannel"], "in": ["ins", "din", "el", "en", "b", "id", "old", "v", " input", "IN", "inn", "s", "con", "inf", "cin", "gin", "on", "from", "it", "ic", "or", "by", "vin", "init", "as", "file", "ch", "ind", "inc", "rin", "doc", "i", "input", "source", "r", "l", "isin", "In", "n"], "out": ["ot", "output", "OUT", "b", "v", "p", "ex", "gt", "s", "net", "io", "ne", "ns", "set", "outs", "it", "ou", "to", "obj", "po", "aos", "nt", "ch", "can", "write", "oss", "one", "null", "l", "o", "t", "Out", "at", "w", "n"], "is": ["fs", "isl", "isa", "sis", "ins", "icks", "isal", "xs", "lis", "iss", "ri", "mos", "ris", "are", "bs", "ir", "dis", "cs", "isi", "nis", "us", "s", "si", "ys", "sys", "ms", "obs", "ns", "iso", "it", "js", "atis", "ains", "bis", "tis", "ics", "ois", "ims", "init", "IS", "iris", "eps", "vis", "ie", "mis", "Is", "ires", "ind", "ans", "isc", "i", "iter", "ils", "abs", "es", "ip", "ais", "its", "isin", "im", "ios"], "os": ["fs", "oos", "css", "osi", "ot", "acs", "bs", "mos", "ows", "cs", "ros", "ens", "ls", "mot", "s", "io", "sys", "ns", "obs", "ms", "nos", "ss", "outs", "js", "gs", "ds", "dos", "oses", "mes", "tis", "ts", "des", "bos", "aos", "eps", "ox", "vs", "cos", "Os", "pos", "less", "oS", "oss", "ops", "es", "ost", "ks", "oes", "o", "los", "OS", "ws", "ols", "ios"], "buffer": ["length", "initial", "binary", "cache", "message", "window", "buf", "print", "sequence", "phrase", "stack", "tree", "block", "view", "button", "table", "frame", "bar", "stroke", "bridge", "reason", "comment", "paste", "document", "batch", "base", "event", "word", "append", "template", "memory", "number", "display", "mem", "iter", "source", "variable", "Buffer", "padding", "buff", "sample", "pad", "command", "temp"], "len": ["length", "rel", "L", "z", "el", "et", "els", "del", "sl", "num", "en", "gl", "fin", "ls", " clen", "lf", "count", "hl", "lan", "e", "ln", "un", "le", "lim", "val", "err", " el", "ll", "wid", " length", "li", "size", "Len", "yn", " le", "all", "cap", "seq", "body", " l", "nt", "pos", "ind", "no", "elt", "full", "ld", "l", "lon", "coll", "fl", "t", "end", "tl", "n"], "ok": ["k", "f", "ot", "u", "og", "cs", "rc", "par", " Ok", "bo", "yes", "dec", "ook", "Ok", "boot", "clean", "ik", "iro", "arc", "ms", "ko", "valid", "state", "ll", "it", "status", "quick", "ready", "req", "oh", "oc", " okay", "ack", "md", "kok", "msg", "y", "ch", "ak", "good", "ku", "check", "up", "OK", " good", "sk", "ol", "full", "comp", "app", "coll", "ck", "ocr"]}}
{"id1": "15510198", "id2": "7044685", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"buildParser": ["Buildparser", "createProxy", "createparser", "newReader", "newProxy", "createParser", "buildparser", "createReader", "buildProxy", "buildReader", "newParser", "BuildProxy", "BuildReader", "BuildParser", "newparser"], "url": ["host", "sl", "ssl", "domain", "b", "location", "ls", "dl", "char", "email", "string", "path", "web", "ref", "str", "ll", "resource", "http", "ul", "link", "page", "URL", "document", "file", "run", "build", "base", "address", "name", "mount", "mail", "pl", "uri", "Url", "l", "log", "util", "job"], "ParserException": ["parserEvent", "ParserError", "ReaderWarning", "parseError", "parserWarning", "ParserEvent", "ParserWarning", "ReaderException", "parseException", "parserException", "ReaderError", "ReaderEvent", "parserError", "parseWarning", "parseEvent"], "parser": ["could", "processor", "payer", "arson", "p", "language", "jp", "message", " scanner", "instance", "consumer", "er", " parsing", "peer", "arser", "php", "pair", "driver", "handler", "format", "program", "Parser", "xml", "bank", "loader", " parsed", "layer", "writer", " soup", "worker", "runner", "builder", "document", " parse", "library", "asser", "pool", "reader", "jack", "lp", "fp", "still", "inner", "policy", "manager", "json", "taker", "parse", "util", " provider", "job", "master"], "connection": ["server", "established", "position", "computer", "channel", "Connection", "connect", "relation", "communication", "message", "instance", "con", "pointer", "handler", "generation", "database", "network", "conn", "application", "entry", "c", "resource", "http", "response", "link", "to", "session", "document", "directory", "pool", "connected", "current", "ion", "client", "open", "currently", "character", "still", "created", "close", "cone", "condition", "creation", "associated", "closed", "remote", "command", "now"]}}
{"id1": "6470716", "id2": "9257487", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"st": ["sth", "ft", "rt", "sh", "std", "store", "stream", "th", "sts", "nd", "service", "stable", "sn", "ust", "str", "sw", "set", "St", "sta", "inst", "step", "sty", "www", "sp", "est", "stri", "se", "ST", "ld", "ste", "start", "ost", "ist", "rest", "t", "ast", "d", "stra", "tt", "sm"], "url": ["f", "loc", "rel", "host", "el", "sl", "ssl", "domain", "gl", "shell", "location", "ls", "dl", "il", "hl", "char", "bel", "github", "string", "web", "ref", "addr", "rect", "str", "ll", "ret", "http", "li", "ul", "nl", "link", "www", "browser", "ur", "impl", "URL", "file", "cert", "build", "base", "address", "ch", "mount", "mail", "client", "pl", "r", "uri", "Url", "l", "cl", "abs", "null", "fl", "rest", "html"], "fis": ["fais", " fi", "feier", "feois", "flis", "xfois", "ef\u00eds", "fisl", "tiss", "Fis", "Fais", " fisl", "xfi", "uf\u00eds", " fiss", "fiss", "f\u00eds", "Fois", "feis", "tos", "efiss", "ufis", "tis", "fei", "tais", "flisl", " fais", "fli", "Fier", "xfis", "Fos", "xfier", "fi", "ufisl", " f\u00eds", "efis", "fier", "ufiss", "Fiss", "fliss", "fois", "efi", "ufi", "Fi"], "zis": ["zeniss", " zris", "zipes", "czIs", "zes", "ozisa", "zipis", "zisa", "ozes", "ziss", "fris", "fiss", " zisa", "zIs", "zipIs", "zenisi", "ozIs", "zos", "zhisin", "zenris", " zisi", " zos", "fisi", " ziss", "zits", "zisi", "zipos", "zhIs", "ozis", "zenis", "fits", "ozisin", " zIs", "zhes", "ozits", "czisa", "zhis", " zits", "czis", "zisin", "czits", "zris", "zipits", "zipisin"], "entry": ["record", "entity", "field", "ry", "office", "match", "pattern", "char", "enter", "list", "ent", "e", "way", "form", "chain", "cell", "member", "valid", "or", "link", "de", "fr", "comment", "attribute", "jar", "key", "item", "card", "obj", "ie", "tmp", "nt", "sp", "be", "existent", "event", "zip", "name", "system", "element", "def", "out", "inter", "line", "word", "se", "source", "null", "row", "log", "ce", "Entry", "zo", "jo", "info", "index", "result"], "count": ["length", "max", "ount", "core", "num", "match", "sum", "total", "char", "cc", "cell", "acc", "nb", "buffer", "err", "c", "size", "add", "page", "comment", "child", "force", "code", "nt", "base", "batch", "ch", "amount", "name", "ind", "depth", "current", "check", "call", "counter", "found", "number", "len", "last", "iter", "start", "ctr", "ct", "Count", "t", "end", "index", "read", "cont", "n"], "data": ["image", "DATA", "length", "output", "value", "ata", "cache", "dat", "message", "format", "area", "buf", "string", "chain", "buffer", "bin", "block", "raw", "zero", "text", "part", "size", "table", " DATA", "step", "reason", "all", "batch", "name", "good", "def", "out", "mem", "number", "done", "source", "json", "mu", "bytes", "next", "sample", "d", "result", "n"], "fos": ["fiops", "fooss", "wos", "foss", "hos", "fioss", "wis", "his", "Foss", "fol", "woss", " foss", "foops", "wOS", "foos", "fOS", "fool", "fiol", "Fol", "Fos", "fops", "hOS", "hoss", " fOS", "Fops", "fios"], "dest": ["loc", "crit", "output", "std", "exp", "Dest", "nd", "dat", "sum", "transfer", "usr", "way", "target", "origin", "test", "member", "src", "bin", "gest", "writer", "dist", "dc", "them", "trans", "gate", "coord", "des", "nom", "ptr", "result", "send", "nt", "est", "parent", "det", "pipe", "master", "out", "comp", "mem", "comb", "source", "done", "cat", "foreign", "decl", "desc", "pas", "rest", "temp", "cont"]}}
{"id1": "6379126", "id2": "5138455", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": [" crearToyServer", " crearTeutorialPage", " crearTiblScreen", " crearTeoyPage", " crearTiaryServer", " crearToyScreen", " crearTiaryScreen", " crearTutorialPage", " crearTeoyPages", " crearTiaryPage", " crearTiblPages", " crearTutorialScreen", " crearTeutorialPages", " crearTeutorialServer", " crearTeoyServer", " crearTiblServer", " crearTutorialServer", " crearToyPages", " crearTiaryPages", " crearTeoyScreen", " crearTutorialPages", " crearToyPage", " crearTeutorialScreen", " crearTiblPage"], "indexDir": ["htmlDIR", "scriptDir", "htmlPath", "indexFolder", "indexDIR", "htmlDir", "appFolder", "appPath", "appDir", "scriptFolder", "appDIR", "indexPath", "scriptDIR", "scriptPath", "htmlFolder"], "cssDir": ["icsDir", "csRect", "icsRect", "ssDb", "cssdir", "stylesDirectory", "stylesDIR", "icsdir", "cssUrl", "statsDb", "csDir", "ssUrl", "stylesDb", "stylesdir", "statsDir", "cssDIR", "csdir", "csDirectory", "statsUrl", "csUrl", "stylesUrl", "ssDir", "ssDirectory", "cmsDir", "ssdir", "stylesDir", "cssRect", "ssDIR", "cmsdir", "cmsDIR", "cssDirectory", "cmsDirectory", "ssRect", "cssDb", "icsDirectory"], "capDir": ["cmpDir", "configDir", "configDb", "configFile", "configTier", "CapTier", "cmpDb", "capTier", "CapDir", "cmpFile", "CapDb", "cmpTier", "capDb", "capFile", "CapFile"], "licDir": ["licDs", "vidDs", "liaDs", "licRot", "libRot", "libDs", "licDb", "liaDir", "libDir", "libDb", "vidDir", "liaDb", "vidRot", "vidDb", "liaRot"], "midDir": ["manRot", "mnDir", "midDirectory", "mnCat", "pidCat", "midCat", "mnDirectory", "manDirectory", "midRot", "pidDirectory", "pidRot", "mnRot", "manDir", "pidDir", "manCat"], "filesDir": ["framesIter", "videosRel", "tagsRect", "imagesFix", "imagesFolder", "filesFolder", "sectionsDir", "tagsDir", "filesRect", "framesDIR", "framesDir", "framesdir", "filesDIR", "framesRel", "framesFolder", "sectionsJar", "pagesRel", "filesIter", "tagsJar", "pagesFolder", "filesFix", "filesdir", "pagesDir", "framesJar", "imagesDIR", "framesFix", "framesRect", "filesRel", "tagsIter", "sectionsIter", "filesJar", "videosFix", "sectionsRect", "videosdir", "videosFolder", "imagesDir", "videosDIR", "pagesdir"], "videosDir": ["videodir", "imagesFolder", " videosdir", "videoDir", "videoFolder", " videosFolder", "imagesFile", "versionsFolder", "versionsDir", "imagesdir", "versionsFile", "videosFolder", "videosFile", "imagesDir", "videosdir", " videosFile"], "imagensDir": [" imagensIn", "imgensDIR", "imagensesDb", "imagetsDb", "imgensDir", "imagotsDirectory", "imagensFolder", "imagetsDIR", "imgetsDir", " imagensFolder", "imagensDIR", "imagensesDir", "imagetsIn", "imagetsFolder", "imagetsDirectory", "imagensDirectory", "imagmesDir", "imagensesIn", "imgensDirectory", " imagetsFolder", "imagearsIn", " imagetsDir", "imgetsDIR", " imagensDb", "imagmesDirectory", "imagmesDIR", "imagotsDIR", " imagetsIn", "imagetsDir", "imagensIn", "imagensDb", "imagensesFolder", "imagmesFolder", " imagetsDb", "imagearsFolder", "imagotsFolder", "imgetsDirectory", "imagearsDb", "imgetsFolder", "imgensFolder", "imagearsDir", "imagotsDir"], "local": ["loc", "initial", "server", "hid", "lib", "present", "location", "alpha", "upper", "simple", "self", "standard", "where", "home", "localhost", "list", "back", "test", "state", "valid", "central", "land", "val", "part", "single", "http", "south", "install", "personal", "pal", "dir", "shared", "al", "managed", "tmp", "base", "parent", "pid", "lock", "current", "installed", "client", "mail", "system", "serial", "full", "internal", "western", "l", "global", "Local", "root", "util", "remote", "temp"], "srcCss1": ["srcCxx10", "srcLass10", "srcSCss1", "srcSCass3", "srcSCss3", "srcSCss0", "srcSCss2", "srcCcss0", "srcLass1", "srcLss1", "srcCfg1", "srcCcssOnce", "srcCxx0", "srcCson10", "srcCSS2", "srcCSS0", "srcSCass0", "srcSss2", "srcCassOnce", "srcCass10", "srcSssOnce", "srcCass0", "srcSCass1", "srcLssOnce", "srcCcss3", "srcCxx1", "srcChessasso", "srcCass1", "srcSss1", "srcScss1", "srcLassOnce", "srcSCass2", "srcChess10", "srcCss10", "srcCssasso", "srcChess1", "srcCassasso", "srcCxxasso", "srcLass2", "srcScss3", "srcCsonOnce", "srcLss2", "srcCfg2", "srcCfg3", "srcSss3", "srcCcss1", "srcLss10", "srcCson1", "srcScssOnce", "srcChess0", "srcCSS3", "srcCSS1", "srcCcss10", "srcCcss2", "srcCass2", "srcCss0", "srcCson2", "srcCass3", "srcCssOnce", "srcScss2", "srcCfgOnce"], "destCss1": ["destCass2", "destSass2", "destChess1", "destScss2", "destCcss2", "destCcss100", "destCassPre", "destSass100", "destScss5", "destScss0", "destCcssPre", "destChess0", "destSss5", "destSss2", "destSass1", "destCxx0", "destCass0", "destCss0", "destCass100", "destSss0", "destCssPre", "destCrss5", "destScss1", "destCrss2", "destSssPre", "destCxxPre", "destCcss5", "destCcss0", "destCass1", "destChess2", "destCass5", "destChess100", "destSss100", "destCcss1", "destCrss1", "destSassPre", "destCxx1", "destCss100", "destSass0", "destCrss0", "destSss1", "destCxx2"], "srcCss2": ["srcCcss48", "srcSCss1", "srcCfg4", "srcSCss2", "srcCfg1", "srcSCss4", "srcCtx4", "srcCsv1", "srcSCass1", "srcSCass4", "srcCcss3", "srcCson4", "srcCass1", "srcCtxTwo", "srcCffee2", "srcSCassTwo", "srcSCass2", "srcCcss4", "srcCson8", "srcCss48", "srcCsv2", "srcCcss52", "srcCffee1", "srcCsv52", "srcCfg2", "srcCtx1", "srcCassTwo", "srcCcss8", "srcCffee3", "srcCffee52", "srcCcss1", "srcCass4", "srcSCssTwo", "srcCson1", "srcCsv3", "srcCcss2", "srcCass2", "srcCss8", "srcCson2", "srcCfg8", "srcCsv48", "srcCtx2", "srcCssTwo", "srcCcssTwo", "srcCss52"], "destCss2": ["destCass2", "destSass2", "destSss56", "destChess1", "destCcss2", "destCSS42", "destCSS2", "destCcss3", "destChess3", "destCss02", "destCcs2", "destCcs42", "destSss2", "destSass1", "destCass56", "destCass4", "destCrosse4", "destCcss42", "destCcs3", "destCass3", "destCSS3", "destCSS02", "destCrosse2", "destChess56", "destCcss56", "destCass1", "destCcss4", "destChess2", "destCcss1", "destCss42", "destSass56", "destCss56", "destCcss02", "destCrosse1", "destSass3", "destSss3", "destCcs02", "destSss1"], "srcCss3": ["srcCcssThree", "srcCSS2", "srcCssThree", "srcCxx3", "srcCrss2", "srcSss43", "srcCoss6", "srcCass4", "srcCrss3", "srcCcss03", "srcCcssthree", "srcCcssThird", "srcCcss4", "srcScss03", "srcCess3", "srcCsv3", "srcCcss43", "srcCassThree", "srcCoss3", "srcCess4", "srcSss03", "srcCss03", "srcCrss1", "srcCossthree", "srcCss43", "srcCcss6", "srcCxx43", "srcSss3", "srcCSS1", "srcCxx03", "srcCass3", "srcCessthree", "srcCass03", "srcCssThird", "srcCsv1", "srcCess6", "srcCcss3", "srcScss43", "srcCssthree", "srcCessThird", "srcCass43", "srcCsv2", "srcScss3", "srcCassThird", "srcCSS3", "srcCessThree"], "destCss3": ["destCass2", "destCfg03", "destCfg3", "destCcss2", "destCSS2", "destCls83", "destCcss3", "destCls3", "destCss83", "destCcss23", "destCess53", "destCess3", "destCess83", "destCcss03", "destCcss30", "destCass3", "destCSS3", "destCfg23", "destCss03", "destCcss53", "destCass1", "destCass03", "destCss23", "destCcss1", "destCSS30", "destCls53", "destCass30", "destCSS1", "destCss53", "destCass23", "destCcss83", "destCss30"], "srcCss4": ["srcCSSFour", "srcScss4", "srcCcss5", "srcCSS2", "srcSss2", "srcCSS5", "srcCsv4", "srcCsvFour", "srcCcss4", "srcCssFour", "srcSssFour", "srcCcssFour", "srcCsv2", "srcScssFour", "srcSss5", "srcCsv5", "srcCcss2", "srcSss4", "srcScss5", "srcCSS4", "srcScss2"]}}
{"id1": "5951610", "id2": "471804", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"testNetworkHTTP": ["testNetHTML", "testNetworkURL", "TestNetHTTP", "TestNetworkHTTP", "TestNetHTML", "testApplicationHTML", "testNetworkHTML", "TestNetworkURL", "testApplicationURL", "testNetURL", "TestNetURL", "testNetHTTP", "testApplicationHTTP", "TestNetworkHTML"], "url": ["loc", "rel", "host", "el", "u", "sl", "ssl", "bl", "gl", "org", "b", "https", "location", "ls", "norm", "dl", "channel", "il", "hl", "email", "back", "pull", "github", "path", "web", "ref", "ml", "lr", "print", "blog", "m", "acl", "ll", "str", "term", "conn", "ret", "resource", "rl", "http", "ul", "nl", "link", "www", "all", "ur", "impl", "URL", "obj", "console", "cert", "base", "address", "mount", "mail", "lt", "pl", "get", "r", "lb", "uri", "Url", "l", "cl", "fl", "t", "log", "util", "html", "ocl"], "urlConnection": ["urlCon", "dbConn", "methodConnector", "urlPosition", "utilConnect", "emailConnection", "consoleConnection", "methodConn", "urlService", "lsConnection", "mlCon", " urlDiscussion", " urlService", "resourceConnection", "emailConnector", " urlHandler", "urlSet", "urlDiscussion", "fileConnection", "httpHandler", "emailConnect", "managerInfo", "utilConnection", "sslConnection", " urlResponse", "consoleConn", "httpConnector", "urlResponse", "sslPosition", "consoleMachine", " urlConnect", " urlListener", "urlMachine", "resourceConnector", "dbPosition", "emailConn", " urlSet", "httpListener", "nameConnector", "httpSet", "methodConnection", "managerConnect", "dbConnect", "dbConnection", "railHandler", "lrConnection", "nameConnect", "httpService", "lrResponse", "managerConnector", " urlConn", "lsConnector", "utilService", "sslDiscussion", "utilConnector", "urlConnect", "httpConnection", "mlConnection", "fileDiscussion", "urlConn", "implConnect", "lsConnect", "consoleCon", "urlConnector", "httpConn", "mlConn", "browserConn", " urlInfo", "methodConnect", "urlListener", " urlCon", "fileConn", "managerConnection", "railConnect", "urlHandler", "railListener", "fileConnect", " urlConnector", "lrConnector", "railConnection", "browserConnector", "implConnection", "lrConn", "sslConnect", "sslConn", "nameConnection", "utilSet", "httpConnect", "urlInfo", "resourceConn", "resourceResponse", "utilListener", " urlPosition", "sslConnector", " urlMachine", "browserConnection", "implConnector", "httpInfo", "lsConn", "nameConn", "browserConnect", "utilConn", "implConn", "mlMachine"], "rd": ["hr", "din", "dr", "rt", "dd", "mr", "std", "ord", "ck", "ri", "rc", "rs", "red", "nd", "dra", "rh", "rg", "RD", "adr", "usr", "rand", "ded", "repl", "lr", "drm", "rid", "art", "rob", "rend", "rez", "rl", "rn", "rown", "rax", "fr", "dir", "rw", "ptr", "rr", "ered", "ind", "rx", "dig", "r", "ld", "grad", "rm", "ined", "rer", "ird", "rb", "rod", "erd", "ra", "bd", "nder", "fd", "ped", "rus", "d", "gd", "wr", "xd"], "line": ["length", "column", "record", "ine", "node", "liner", "port", "online", "channel", "eline", "zone", "message", "where", "email", "string", "ice", "ln", "lo", "le", "side", "buffer", "cell", "block", "lin", "entry", "continue", "set", "error", "part", "status", "load", "frame", "nl", "Line", "inline", "link", "page", "LIN", "comment", "stay", "range", "file", "pipe", "none", "lock", "check", "loop", "number", " LINE", "len", "iter", "l", "cl", "row", "lines", "time", "next", "log", "LINE", "edge", "point"]}}
{"id1": "6871529", "id2": "13981689", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"readUrlFile": ["readURLPage", " readURLPage", "readURLfile", "readurlStream", "readURLStream", "readUrlfile", "readPathStream", " readUrlfile", "readPathFile", " readURLStream", "readurlfile", "readUrlPage", " readURLfile", " readUrlPage", "readPathfile", "readUrlStream", "readURLFile", "readurlPage", "readurlFile", "readPathPage", " readURLFile", " readUrlStream"], "fullUrl": [" fullName", "fullName", "fullurl", "fulRoute", "partialPath", "fulURL", "fullUr", "completePath", "pathUr", " fullUr", "completeURL", "partialURL", " fullurl", "FullUrl", "fullRoute", "completeUrl", "FullUr", "FullName", " fullURL", "completeurl", " fullPath", "pathName", "fulUrl", "Fullurl", "partialUrl", "FullRoute", "fulurl", "fullPath", "pathUrl", "partialurl", "fullURL", "pathURL", "FullURL", "partialRoute"], "out": ["output", "OUT", "b", "p", "screen", "us", "s", "net", "io", "print", "outs", "c", "it", "writer", "table", "ou", "pretty", "to", "report", "file", "res", "aos", "nt", "msg", "ch", "client", "txt", "write", "os", "json", "flush", "t", "log", "o", "ws", "Out", "w", "n"], "url": ["rel", "f", "sl", "ssl", "b", "git", "ls", "dl", "char", "service", "bel", "google", "path", "web", "ref", "str", "oul", "ll", "conn", "resource", "http", "ul", "nl", "link", "browser", "ur", "URL", "sb", "file", "build", "base", "open", "client", "mount", "mail", "r", "config", "Url", "uri", "l", "job"], "encoding": ["ENCoded", "ENCapping", "Encapping", "coding", "ENCoding", "rcoded", "cryption", "coder", "Encoder", "Encryption", "rcryption", "encoded", "rcoding", "Encoded", "encoder", "encaching", "caching", "coded", "Encoding", "encryption", "capping", "rcaching", "ENCoder", "encapping", "Encaching"], "in": ["f", "ins", "din", "inside", "el", "stream", "id", "sum", "data", "IN", "er", "inn", "user", "io", "inf", "cin", "gin", "m", "bin", "from", "sql", "file", "body", "reader", "ind", "rin", "i", "input", "r", "source", "inner", "conf", "l", "and", "info", " din", "In"]}}
{"id1": "6742637", "id2": "6260216", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public InputStream send(String s, String s1) throws IOException {\n        HttpURLConnection httpurlconnection = null;\n        DataInputStream datainputstream = null;\n        System.setProperty(\"java.protocol.handler.pkgs\", \"com.sun.net.ssl.internal.www.protocol\");\n        URL url = new URL(s1);\n        httpurlconnection = (HttpURLConnection) url.openConnection();\n        configureURLConnection(httpurlconnection);\n        DataOutputStream dataoutputstream = new DataOutputStream(httpurlconnection.getOutputStream());\n        dataoutputstream.write(s.getBytes());\n        httpurlconnection.connect();\n        datainputstream = new DataInputStream(httpurlconnection.getInputStream());\n        if (httpurlconnection.getResponseCode() != 200) {\n            System.out.println(\"Invalid Response Code! Code Returned = \" + Integer.toString(httpurlconnection.getResponseCode()));\n            return null;\n        }\n        if (!httpurlconnection.getContentType().equalsIgnoreCase(\"Text/xml\")) {\n            System.out.println(\"Invalid Content-Type! Content type of response received = \" + httpurlconnection.getContentType());\n            return null;\n        } else {\n            return datainputstream;\n        }\n    }\n", "label": 0, "substitutes": {"findExtensions": [" findExtions", "findEXTensions", "findextras", "findextensions", " findExtras", "findEXTension", " findEXTensions", "findExtras", " findEXTension", "findEXTions", " findExtension", "findExtension", "findExtions", " findEXTras", "findextions", "findAppions", "findAppensions", " findEXTions", "findEXTras", "findAppension", "findAppras", "findextension"], "url": ["loc", "rel", "host", "el", "sl", "ssl", "server", "domain", "gl", "https", "location", "ls", "norm", "dl", "hl", "email", "char", "string", "path", "lr", "ref", "web", "addr", "lim", "str", "val", "xml", "ll", "loader", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "req", "key", "URL", "sb", "file", "cert", "address", "ch", "name", "mount", "mail", "pl", "filename", "uri", "Url", "config", "l", "abs", "row", "cl", "parse", "util"], "extensions": ["Extension", "dimended", "xtensions", "xtended", "dimensions", "exensions", "exends", "appendensions", "extension", " extences", "extances", "expends", "xtends", "dimends", "expences", "expension", "extperties", "extences", "extended", "Extensions", "Extends", "expperties", "expended", "expensions", "appendperties", "dimances", "xtances", "exances", "appendends", " extension", "appendended", "Extences", "xtperties", "exended"], "res": ["rel", "ins", "rt", "pres", "mr", "ry", "gr", "rs", "RES", "er", "reg", "us", "pers", "ers", "ref", "ms", "resolution", "sys", "ress", "vers", "rez", "rys", "re", "vol", "ser", "ro", "mer", "req", "ver", "range", "Res", "ber", "rex", "ch", "rem", "r", "proc", "es", "reset", "abs", "cons", "rest", "ps"], "prop": ["rel", "feat", "cmd", "pred", "exp", "p", "plot", "rop", "bug", "jp", "buf", "properties", "cfg", "attr", "pt", "val", "term", "pkg", "etc", "col", "add", "cap", "priv", "key", "pic", "op", "mp", "tmp", "prot", "po", "cp", "pos", "pid", "def", "Prop", "pro", "kw", "comp", "property", "pr", "proc", "conf", "tab", "desc", "ext", "np", "att", "ps", "pb"], "msg": ["mess", "Msg", "cmd", "mt", "ug", "og", "message", "char", "med", "string", "cfg", "print", "ms", "notice", "str", "err", "m", "gm", "text", "pkg", "gs", "reason", "Message", "bg", "urg", "md", "nom", "mn", "kg", "mun", "body", "good", "gov", "cmp", "txt", "uint", "hog", "g", "desc", "log", "sg", "utt", "sm"]}}
{"id1": "8000624", "id2": "4982745", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "label": 0, "substitutes": {"CopyTo": ["CopyInt", " copyInt", " copyTo", "CopyFrom", " copyFrom", " copiesTo", " CopyInt", " copiesInt", " CopyFrom", " copiesFrom"], "dest": ["image", "loc", "copy", "output", "th", "p", "v", "Dest", "cont", "usr", "path", "target", "origin", "src", "st", "it", "them", "orig", "dir", "img", "nom", "tmp", "sp", "fn", "pipe", "est", "name", "opt", "txt", "mem", "source", "filename", "cat", "null", "rest", "d", "w", "temp", "result"], "in": ["image", "mi", "ins", "din", "inside", "en", "ir", "ini", " input", "IN", "sin", "inn", "con", "ai", "net", "inf", "cin", "gin", "local", "on", "ac", "bin", "m", "from", "ar", "it", "by", "re", "ire", "login", "init", "thin", "nin", "file", "al", "ain", "per", "reader", "ind", "is", "inc", "client", "up", "rin", "i", "input", "source", "iter", "inner", "r", "win", "l", "internal", "one", "o", "t", "isin", " din", "min", "read", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "v", "other", "dis", "ex", "list", "gt", "boot", "con", "e", "loss", "net", "io", "ne", "user", "ln", "ns", "outs", "it", "by", "writer", "ou", "note", "to", "all", "obj", "res", "op", "aos", "batch", "nt", "cos", "fn", "can", "client", "write", "up", "full", "oss", "one", "oe", "inner", "os", "null", "conv", "na", "flush", "not", "t", "o", "end", "Out", "at", "w", "outer", "n"], "c": ["f", "k", "z", "u", "rc", "cs", "v", "cf", "cut", "count", "ec", "sc", "nc", "char", "unc", "cc", "con", "e", "arc", "ac", "C", "cod", "ca", "cap", "gc", "code", "ch", "uc", "cp", "current", "i", "cr", "character", "bc", "cat", "g", "conf", "l", "cd", "cl", "ct", "t", "ce", "cm", "d", "cb", "lc", "cont", "n"]}}
{"id1": "1769771", "id2": "16388708", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " CopyFiles", " copyLine", " copyFiles", " CopyStream", "CopyFiles", " CopyLine", "CopyFile", "copyFiles", " copyStream", "CopyStream", " CopyFile", "CopyLine", "copyLine"], "in": ["ins", "din", "el", "en", "b", "old", "ini", " input", "IN", "inn", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ic", "init", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "l", "isin", "In"], "out": ["update", "ot", "output", "OUT", "b", "v", "p", "serv", "ex", "gt", "s", "net", "io", "err", "outs", "it", "c", "ou", "to", "file", "res", "po", "op", "nt", "msg", "up", "help", "os", "l", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["insideClient", "intChan", "innCase", " inChan", "cinCommand", "inConnection", "inChan", "intCommand", "cinRoom", "inClient", "Inchannel", "inScope", "sinButton", "outConnection", "outchannel", " inCommand", "inCategory", "innButton", "sinRoom", "insideCategory", " inCase", "ainChannel", "insideChannel", "sinCommand", "InChannel", "cinChannel", "dinchannel", "ainClient", "dinChan", "intChannel", "sinChannel", "ainScope", " inConnection", " inchannel", "dinConnection", "inCase", "sinCase", "inchannel", " inClient", " inButton", "outChan", "inCommand", "dinChannel", " inScope", " inCategory", "intchannel", "InChan", " inRoom", "sinClient", "inRoom", "innChannel", "innClient", "InCommand", "ainCategory", "insideScope", "inButton"], "outChannel": ["outputCh", "aosChannel", "blockChannel", "neSection", "inChan", "blockChan", " outCh", "outSection", " outManager", "outputChan", " outchannel", "inSection", "aosMember", "cnManager", "outchannel", "outputchannel", "inCh", "outputManager", "aosSection", "cnChan", "cnChannel", "parentChan", "outMany", "blockMany", "neMember", "inMember", "outCh", "parentGate", "outputChannel", "parentMany", "inchannel", " outGate", "outChan", "outMember", "outGate", "parentChannel", " outChan", "outManager", " outMany", "neChannel", "blockGate", "aosChan", "neChan"]}}
{"id1": "804637", "id2": "16719805", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndRewWrite", "readAndResend", "readAndRepWrite", "readAndrewrites", "readAndrewrite", "readAndRewend", "readAndRepend", "readAndResWrite", "readAndResrites", "readAndRewrites", "readAndReprites", "readAndrewend", "readAndrewWrite", "readAndReprite"], "inFile": ["initFile", " infile", "inputPlace", "inFILE", "inPlace", "inFace", "iTime", "docFilename", "iFilename", "INFILE", "INFilename", "iFILE", "INFace", "inputFace", "inTime", "initFace", "INFile", "outfile", "initFilename", "INPlace", "INTime", "infile", "docFILE", "InFilename", "docTime", "outFilename", "inFilename", "initPlace", "inputFilename", " inFilename", "InFile", "docFile", "Infile", "iFile", "inputFile"], "outFile": ["reportFILE", " outFilename", "inFILE", "reportfile", "reportFile", " outfile", "checkfile", "checkFilename", "namefile", "toFILE", "nameFilename", "checkFILE", "toFilename", "outfile", "toFile", "reportFilename", "infile", "nameFILE", "outFILE", " outFILE", "checkFile", "outFilename", "nameFile", "inFilename", "tofile"], "iis": ["Iis", " iiss", "liisc", " iris", " ii", "iiris", "iiisc", "Iiss", "iIs", "eIs", "Ii", "diis", "ii", "iiis", "iiss", " iisc", "liIs", "aiis", "iisc", "liris", "liis", "eIS", "diiss", " iIS", "iris", "aiIs", "dii", "diIs", "iiIs", " iIs", "eis", "aiIS", "iIS", "IIs"], "dcmParser": ["dgrPar", "dcmAdapter", "dfmReader", "deromReader", "dpmPrivate", "dromReader", "dmoduleAssistant", "drumPar", "dgrStatement", "dcrBuilder", "DpmPar", " dcmPar", "dpmParser", "dcfReader", "dpmLoader", "DcmAdapter", "dromAssistant", "dpmBuilder", " dpmListener", "drumParser", "dpmarser", "dmmmParser", "dmParser", "dpmPar", "dromListener", "dmmparser", "dpcAssistant", "dcrReader", "dromparser", "dcomLoader", "DpmAdapter", "dpmListener", " dcmListener", "dpmStatement", " dcmparser", "dpcReader", "dcmPar", " dpmparser", "dromParser", "decmParser", "dfmBuilder", "deromparser", "dcommParser", "dcfStatement", "dcrParser", "dpcPrivate", " dpmReader", "dcfParser", "deromParser", " dcmPrivate", "dmparser", "dmReader", "dcmReader", "dmodulePrivate", "dpmAdapter", "dmmmAdapter", "dcommListener", "dcfPar", "dcmListener", "dmarser", "dcmPrivate", "dcommAssistant", " dpmPrivate", "dmmAdapter", "dmmmReader", "DpmReader", "dmmReader", "dcmLoader", " dpmBuilder", " dcmAssistant", "dcmStatement", "dfmParser", " dpmParser", "decmReader", "dcomParser", "dmmarser", "dcmAssistant", " dcmReader", "decmarser", "DcmParser", "dfmLoader", "dmmmparser", "DpmParser", " dpmAssistant", "DpmBuilder", "DcmPar", " dcmarser", "DcmBuilder", "dcmarser", "deromarser", " dpmLoader", " dpmPar", " dcmBuilder", " dcmLoader", "dmoduleParser", " dpmStatement", "dmoduleReader", "dpcParser", "DcmReader", "dcomReader", "dromarser", "dpmReader", " dpmarser", "Dpmparser", " dcmStatement", "dpmparser", "drumBuilder", "dcmBuilder", "dmmParser", "dpmAssistant", "dgrParser", "dcrparser", "dcmparser", "decmparser", "dcommReader", "dgrReader", "dcomBuilder", "Dcmparser", "drumReader"], "ds": ["fs", "ins", "dd", "xs", "cs", "rs", "dds", " des", "dx", "ls", "dt", "der", "dl", "bs", "sets", "data", "qs", "dat", "dh", "sd", "s", "pers", "drivers", "ys", "sys", "ns", "obs", "ss", "in", "pd", "outs", "js", "gs", "da", "dos", "DS", "sv", "ads", "ims", "des", "as", " DS", "df", "eps", "vs", "tes", "eds", "aos", "services", "uds", "details", "dq", "db", "os", "es", "ils", "Ds", "bd", "hs", "ks", "its", "ods", "hd", "ws", "d", "gd", "ps"], "pdReader": ["xdHelper", "vdWriter", "ddHelper", "pdParser", "pdRead", "pedReader", "pedLoader", "dpLoader", "xdReader", "vdReader", "pdHelper", "ddParser", "hdRead", "vdHelper", "xdWriter", "pdRunner", "tdRead", "ddRead", "ddCar", "xdLoader", "pedRunner", "dpCar", "tdWriter", "ddRunner", "pdLoader", "dpRunner", "hdReader", "hdWriter", "vdLoader", "dpReader", "tdParser", "pedCar", "ddReader", "ddLoader", "ddWriter", "pdCar", "hdParser", "tdReader"], "out": ["ins", "cmd", "id", "serv", "gt", "gen", "err", "js", "status", "obj", "res", "nt", "pos", "inter", "oss", "null", "log", "OUT", "co", "cache", "ent", "io", "conn", "it", "ou", "inv", "to", "auto", "aos", "ch", " err", "name", "conv", "o", "end", "cb", "at", "w", "cn", "en", "p", "v", "ex", "screen", "data", "sum", "s", "con", "cfg", "str", "in", "raw", "outs", "c", "all", "tmp", "msg", "opt", "up", "full", "one", "os", "desc", "flush", "t", "go", "output", "gr", "we", "list", "over", "net", "sys", "on", "sw", "writer", "pool", "nr", "client", "txt", "inner", "Out", "outer", "n"], "dcmEncParam": ["dcmDecNum", "dcmEscNum", "dmmEnPar", "dcmencCmd", "dmmencParam", "dcmEncVal", "dcmEncCmd", "dmmEncMsg", "dmmEncParam", "dcmencNum", "dcmDecMsg", "dmmEncVal", "dmmEnNum", "dmmEnParam", "dmmEncNum", "dcmEnVal", "dcmEscPar", "dcmEscParam", "dcmEscVal", "dcmencPar", "dmmEncCmd", "dcmDecCmd", "dmmencMsg", "dcmEnNum", "dmmencNum", "dcmEnPar", "dmmencCmd", "dcmEncMsg", "dcmencMsg", "dcmEncPar", "dmmEncPar", "dcmencParam", "dcmEncNum", "dcmDecParam", "dcmEnParam"], "pdWriter": ["tdWrite", "PDWriter", "pidWriting", "pdWriting", "pdWrite", "pcWriting", "tdwriter", "pcWriter", "PDEditor", "pidwriter", "dpWrite", "pidWriter", "pdEditor", "pcwriter", "pcWrite", "tdWriter", "PDReader", "dpEditor", "tdEditor", "dpReader", "tdWriting", "pidWrite", "PDWrite", "pdwriter", "dpWriter", "tdReader"]}}
{"id1": "17161805", "id2": "22879400", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"encode": ["enode", "uncode", "ensforce", "ensode", "ensprocess", "encprocess", "unode", "unprocess", "enccode", "encforce", "enprocess", "Encode", "enforce", "Enode", "unforce", "enscode", "Enforce"], "plaintext": ["formmessage", "pronth", "plainText", " plainText", "ainmessage", " plaindata", "formtext", "mainText", "mainth", "aintext", "aindata", "mainlat", "pronlat", " plainth", "formText", "pronText", "formdata", "maintext", "plainth", "prontext", " plainlat", "plainmessage", "plainlat", " plainmessage", "plaindata", "ainText"], "md": ["del", "pdf", "cmd", "dd", "dr", "mt", " MD", "amd", "der", "mo", "red", "sha", "mg", "dh", "mk", "sd", "med", "od", "ms", "m", "mm", "pm", "pd", "mod", "add", "mc", "mn", " Md", "df", "managed", "mp", "nt", "msg", "dm", "mand", "det", "ind", "mb", "grad", "ld", "cd", "bd", "hd", "d", "ng", "MD", "sm"], "raw": ["cmd", "value", "sh", "strip", "wrap", "message", "derived", "stable", "buf", "bare", "clean", "modified", "valid", "rendered", "pack", "custom", "map", "cooked", " Raw", "orig", "des", "hex", "RAW", "def", "serial", "full", "mem", "input", "Raw", "unsigned", "inner", "json", "row", "unknown", "aw", "bytes", "bound", " RAW", "read", "n"]}}
{"id1": "3994258", "id2": "4168534", "code1": "    public boolean connectServer(String server, String user, String password) {\n        boolean result = true;\n        try {\n            if (user.equals(\"\")) {\n                user = \"anonymous\";\n                password = \"anonymous\";\n            }\n            this.server = server;\n            this.user = user;\n            this.password = password;\n            ftpClient = new FTPClient();\n            ftpClient.setControlEncoding(encode);\n            ftpClient.connect(server);\n            ftpClient.setSoTimeout(1000 * 30);\n            ftpClient.setDefaultTimeout(1000 * 30);\n            ftpClient.setConnectTimeout(1000 * 30);\n            ftpClient.enterLocalPassiveMode();\n            ftpClient.login(user, password);\n            if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                ftpClient.disconnect();\n                return false;\n            }\n            queFilePath = \"data\\\\\" + this.server + \".que\";\n            bufFilePath = \"data\\\\\" + this.server + \".buf\";\n            startGetList();\n        } catch (java.net.SocketTimeoutException e1) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e1, \"\u8fde\u63a5\u8d85\u65f6\");\n        } catch (Exception e) {\n            errMsg = ftpClient.getReplyString();\n            errCode = ftpClient.getReplyCode();\n            result = false;\n            setArrToFile(dirQueue, queFilePath);\n            setArrToFile(fileList, bufFilePath);\n            cn.imgdpu.util.CatException.getMethod().catException(e, \"\u672a\u77e5\u5f02\u5e38\");\n        } finally {\n            if (ftpClient.isConnected()) {\n                try {\n                    ftpClient.disconnect();\n                } catch (IOException ioe) {\n                    cn.imgdpu.util.CatException.getMethod().catException(ioe, \"IO\u5f02\u5e38\");\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"connectServer": ["connectionSer", "openServer", "selectServer", "connectDatabase", "connectionDatabase", "connectionSite", "connectionServer", "selectDatabase", "openSite", "selectSite", "selectSer", "openSer", "connectSite", "openDatabase", "connectSer"], "server": ["host", "folder", "column", "domain", "search", "engine", "node", "seed", "store", "port", "value", "serv", "computer", "model", "scale", "total", "email", "enter", "service", "localhost", "peer", "description", "er", "cookie", "ve", "device", "instance", "test", "database", "entry", "mobile", "Server", "slave", "http", "table", "ter", "erver", "ser", "page", "socket", "ver", "browser", "query", "connection", "console", "code", "base", "address", "directory", "parent", "controller", "name", "system", "client", "template", "source", "uri", "manager", "center", "version", "row", "url", "ip", "site", "free", "remote", "sample", "hello", "master", "project"], "user": ["host", "you", "u", "store", "uid", "field", "person", "port", "profile", "data", "consumer", "char", "student", "er", "issue", "usr", "admin", "string", "token", "owner", "path", "USER", "device", "form", "any", "basic", "order", "database", "me", "rule", "term", "from", "error", "by", "author", "or", "post", "use", "ername", "note", "usage", "login", "attribute", "creator", "key", "ver", "query", "file", "per", "name", "word", "used", "client", "nick", "usa", "username", "account", "auth", "manager", "type", "human", "root", "util", "User", "command", "info"], "password": ["words", "Password", "p", "port", "security", "pattern", "data", "sword", "profile", "language", "pty", "description", "secret", "token", "device", "chain", "sudo", "phrase", "picture", "database", "parser", "application", "worker", "login", "paste", "session", "command", "comment", "attribute", "prefix", "power", "wp", "remember", "code", "directory", "pool", "PASS", "hash", "word", "mask", "client", "number", "username", "pass", "account", "wd", "auth", "policy", "shadow", "crypt", "padding", "wordpress", "hello"], "ftpClient": ["ftpControl", "fftCan", "ftfConnection", "aftpMethod", "ftpDo", "fftpClient", "ftcContent", "ftfClient", "ftpBuilder", "ftcpBody", "ftppclient", "ftcpClient", "ffpCan", "aftpClient", "ftpatNode", "aftpControl", "ftPDo", "factpNode", "aftcpClient", "ftphpContent", "fttpClient", "ftcClient", "fftclient", "ftlpContent", "ftpMethod", "aftcControl", "ftfclient", "ftpContent", "aftPClient", "aftpDo", "ftcpConnection", "fttpStore", " fttClient", "ftcpStore", " ftPclient", "ftcclient", "ctpContent", " ftcpContent", "ftcpclient", "ftcControl", "ctcpClient", "ftcpHandler", "ffpConnection", "ftppClient", "fttclient", "aftPDo", "fttpControl", " fttStore", "fftpConnection", "ctcpContent", "ftpatClient", " fttclient", "fftpclient", "ftPStore", "ftcHandler", "aftPConnection", " ftcpClient", "ctpClient", "ftPBuilder", "aftpHandler", "aftPBuilder", " ftPStore", "fftClient", "ctpclient", "ftpatDo", "ftpHandler", " ftpclient", "fttHandler", "ftcAdmin", "ftphpClient", " ftpBody", "fttAdmin", "aftcHandler", "ftcStore", "ftwpClient", "ftpiClient", " ftPClient", "ftcpContent", "aftcClient", "ctcpclient", "factpatClient", "aftcclient", "fttStore", " fttConnection", "fttMethod", "fftControl", " ftpConnection", "fttpConnection", "ftcpMethod", " ftPConnection", "ftlpClient", "factpClient", "fttpclient", "aftpConnection", "ftPConnection", "ftphpclient", "factpatNode", "fttpBuilder", "factpatDo", "fftAdmin", "aftcpConnection", " ftpStore", "ftcDo", "ftpatAdmin", "ftpclient", "ftcpControl", "ftpatControl", " ftcpBody", "ffpclient", "ffpControl", "ftwpNode", "aftcpMethod", " ftpContent", "ftpBody", "ftcNode", "ftpatclient", "factpclient", "ftpConnection", "fttClient", "fttCan", "ftpaClient", "ftpNode", "ftpCan", "ftpaMethod", "aftpclient", "ftppCan", "aftcpclient", "fttpDo", "ftcBuilder", "ftwpDo", "ftpaclient", "ftpiBody", "ffpAdmin", "ftwpclient", "aftpBuilder", "ftpStore", "ftpAdmin", "ftppControl", "ftlpDo", "ftcCan", "factpatclient", "ftPclient", "ftPClient", "aftcpControl", "ffpClient", "fttConnection", "ftcConnection", "ftpiContent", "factpDo", "ftlpBody", "fttControl", "ftfControl"], "queFilePath": ["queFileId", "queFpath", "queDirPath", "bufFileFormat", "queFPath", "queTableName", "quItemPath", "queItemStep", "queTableId", "queTableDir", "queItemInfo", "quefileId", "queFileInfo", "queTimeInfo", " queTableDir", "quFileStep", "bufFilePos", "queLinePos", "queFPos", "quFilePart", "quItemStep", "queStoreStep", "quefileDir", "quefileName", "quefilePath", "queDirId", "quFilePath", "queStorePart", "quFileInfo", "queFileName", " queTablePath", "quItemInfo", "queLinePath", " queFileId", "queFilePos", "queFileFormat", "queStoreInfo", " queFileName", "queTimeStep", "queFilepath", "queDirName", "queFileDir", "quItemPart", "queFFormat", "queDirDir", " queTableId", "queItemPart", "queFileStep", "queLinepath", " queFileDir", "bufFilepath", "queTimePart", "queFilePart", "queStorePath", "queItemPath", "queTablePath", "queLineFormat", " queTableName", "queTimePath"], "bufFilePath": ["bufferFileName", "buffileLocation", "bufRelTime", "bufFileData", "bufferFilePath", "bufTablePath", "bufQueuePath", "vecQueueName", "bufQueueName", "bufferFileTime", "bufFilenameDef", "bufByteName", "bufByteLocation", "bufFilenamePath", " bufByteName", " bufFileName", "buffileTime", "vecFileStr", "bufRelpath", "bufQueueStr", "bufFileTime", "vecQueueStr", "bufLinepath", "bufFilenameStr", "bufFileDef", "buffileName", "bufFilenameName", "bufLinePath", " bufFileLocation", "bufLineTime", "bufTableName", " bufFileData", " bufBytePath", "vecFileName", "bufLineName", "bufByteData", "bufFileStr", " bufByteLocation", "bufFileName", "bufferfilePath", "bufFilepath", "bufRelPath", "bufFileLocation", "bufferFilepath", "buffileDef", "bufferfilepath", "buffileData", "buffilePath", "vecFileDef", " bufByteData", "bufTableData", "bufRelName", "buffilepath", "bufferfileTime", "vecQueueDef", "bufferfileName", "buffileStr", "vecFilePath", "bufTableLocation", "vecQueuePath", "bufQueueDef", "bufBytePath"], "errMsg": ["cfgLog", "erMess", "failMsg", "sprSm", " errSm", "errLog", " errStr", "sprMsg", "cfgMsg", "sprStr", "errStr", "cfgMess", "failMess", "errMessage", "errMess", " errMessage", " errLog", "sprMess", "failSm", "erMsg", " errMess", "errSm", "erLog", "failStr", "cfgMessage", "erMessage"], "errCode": ["urgNo", "sprCount", "errDef", "rrNo", "errCon", "urgCheck", "eorDef", "urgCon", "urgCode", "errNo", "eorCount", " errNo", "errCheck", "rrCon", "eorCode", "errCount", " errSc", "rrCheck", "sprCode", " errCount", "errSc", " errCon", "eorSc", "sprDef", "rrCode", " errCheck", "sprSc", " errDef"], "result": [" Result", "know", "value", "flag", "perm", "match", "cache", "show", "data", "relation", "profile", "feature", "description", "goal", "Result", "process", "chain", "sequence", "duration", "valid", "continue", "ret", "answer", "status", "table", "report", "res", "draw", "run", "cert", "msg", "were", "event", "fac", "mask", "out", "false", "details", "su", "r", "results", "global", "success", "make", "journal", " res", "date"]}}
{"id1": "17199913", "id2": "19235551", "code1": "    protected static InputStream loadResource(String resource) throws MissingResourceException {\n        Thread thread = Thread.currentThread();\n        ClassLoader cLoader = thread.getContextClassLoader();\n        URL url = cLoader.getResource(resource);\n        if (url == null) {\n            throw new MissingResourceException(\"Unable to find resource '\" + resource + \"'.\", resource, resource);\n        }\n        try {\n            InputStream is = url.openStream();\n            return is;\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Unable to load resource '\" + resource + \"' (IOException).\", resource, resource);\n        }\n    }\n", "code2": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"loadResource": ["loadStream", "loadresource", "parseFile", "parseResource", "getresource", "getFile", "loadFile", "openResource", "getResource", "getStream", "openStream", "parseStream", "openFile", "openresource", "parseresource"], "resource": ["core", "record", "id", "node", "description", "issue", "path", "buffer", "state", "application", "status", "re", "method", "reason", "comment", "attribute", "prefix", "expression", "file", "res", "address", "controller", "template", "property", "get", "title", "null", "use", "module", "context", "scope", "value", "server", "pattern", "relation", "instance", "color", "string", "web", "print", "space", "entry", "term", "OURCE", "document", "name", "element", "resources", "problem", "filename", "common", "version", "Resource", "remote", "project", "message", "service", "resolution", "subject", "rule", "request", "response", "query", "base", "library", "reference", "hash", "source", "create", "uri", "password", "release", "component", "action", "image", "field", "location", "model", "pointer", "sequence", "phrase", "ource", "from", "collection", "connection", "function", "operation", "directory", "event", "role", "system", "client", "ce", "date"], "thread": ["context", "object", "cmd", "engine", "th", "tc", "task", "window", "service", "process", "user", "Thread", "buffer", " Thread", "subject", "loader", "worker", "method", "session", "connection", "nt", "parent", "event", "name", "this", "system", "current", "inter", "template", "tem", "type", "ct", "time", "t", "job", "tt", "TH"], "cLoader": ["ccReader", "ccLoad", "lcJar", "dcBuilder", "lcLoader", "cReader", " cJar", "cBuilder", " cBuilder", "lcBuilder", "ccJar", "dcLoader", "lcLoad", "cUrl", "ccLoader", "cJar", " cLoad", "lcReader", " cUrl", "dcReader", "cLoad", "lcUrl", "dcUrl", " cReader"], "url": ["loc", "f", "rel", "cloud", "el", "sl", "ssl", "gl", "org", "ls", "norm", "dl", "char", "bel", "kl", "lr", "ml", "ref", "path", "user", "web", "str", "oul", "ll", "loader", "http", "rl", "nl", "link", "browser", "ur", "impl", "URL", "file", "build", "name", "mb", "mount", "mail", "pl", "lb", "uri", "Url", "l", "abs", "fl", "log", "util", "bb", "job"], "is": ["isa", "isl", "mi", "lis", "iss", "ri", "ris", "dis", "isi", "instance", "nis", "si", "ai", "ms", "iso", "ism", "has", "imp", "bis", "cms", "ims", "as", "IS", "mis", "Is", "isc", "ui", "get", "i", "isf", "os", "ais", "its", "ist", "isin", "im", "ios"]}}
{"id1": "19378010", "id2": "7458833", "code1": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"getProteins": ["getProteIns", "getPteelines", "getPtein", "getProroteins", "getProteelines", "getProteinins", "getPestein", "getPesteelines", "getProroteIns", "getProroteelines", "getProteinelines", "getPteIns", "getProteinin", "getProrotein", "getPesteins", "getProtein", "getProteinIns", "getPesteIns", "getPteins"], "queries": ["quests", "requeries", "aquues", "quues", "aquions", "requions", " quests", "qeries", "qiries", "requests", "qests", "questues", " quues", "requues", "quiries", " quiries", "aquests", "aqueries", "quions", "questiries", "ques", "questions", "questeries", "questests"], "taxon": [" taxen", "Taxon", "Taxid", "taxen", " taxonomy", "axid", "taxid", "axen", "Taxiton", " taxid", "taxiton", "axon", "axonomy", "axiton", "Taxen", " taxON", "taxonomy", " taxiton", "Taxonomy", "axON", "TaxON", "taxON"], "parser": ["pdf", "processor", "p", "instance", "php", "er", "peer", "arser", "process", "token", "handler", "basic", "Parser", "bank", "xml", "maker", "pp", "pd", "loader", "ucker", "walker", "writer", "http", "creator", "browser", "document", "builder", "auto", "reader", "Reader", "lp", "system", "jack", "book", "ner", "proc", "apache", "parse", "command"], "xpe": ["xpl", "xpes", "zpes", "xspl", " xpse", "zte", "xpse", " xpes", "xte", "axte", "pxte", "pxpes", "zpse", "zpe", "xste", "axpe", "xspe", "xme", "axpl", "pxpse", " xpl", "pxpe", "xsme", "axme", " xte", " xme"], "proteins": ["pegeins", "proteans", "propeIns", "proroteals", "pegeans", "Proteins", "Proroteains", "proceins", "procein", "proroteins", "Proteals", "Proroteins", "progegins", "progeins", "prosteains", "pegegins", "proteIns", "promein", "proceals", "Proteains", "promeains", "proteains", "petegins", "propein", "Prorotein", "protein", "promeals", "Protein", "peteins", "propeins", "proroteIns", "protegins", "propeans", "ProteIns", "propegins", "peteans", "prostein", "propeals", "prosteins", "pegein", "proteals", "proroteans", "proceIns", "ProroteIns", "promeins", "prosteals", "prorotein", "petein", "proroteains", "prorotegins", "progeans", "Proroteals", "progein"], "query": ["column", "quote", "search", "question", "Query", "select", "description", "string", "content", "path", "chain", "test", "q", "subject", "entry", "term", "sq", "request", "text", "continue", "resource", "alias", "comment", "quest", "tag", "key", "sql", "expression", "prefix", "execute", "name", "eries", "word", "qu", "check", "title", "qa", "uri", "statement", "condition", "row", "json", "parse", "ql", "filter", "series", "password", "command"], "connection": ["context", "server", "established", "position", "location", "cache", "channel", "bo", "Connection", "relation", "connect", "nc", "communication", "description", "language", "external", "con", "driver", "pointer", "handler", "generation", "database", "network", "conn", "application", "entry", "wrapper", "c", "collection", "resource", "writer", "response", "internet", "link", "socket", "creator", "session", "document", "console", "function", "library", "connected", "directory", "reference", "pool", "open", "current", "client", "ion", "no", "number", "ticket", "character", "still", "uri", "statement", "cone", "reset", "created", "condition", "creation", "close", "remote", "command"], "encoded": [" encoding", "decoded", "unicoding", " encached", "enccoded", "encured", "decoder", "Encoder", "encoding", " enccoded", "encached", "enoding", "unicoded", "decured", "Encoded", "encoder", "deccoded", "enoded", "enured", "Encoding", "enoder", "uniccoded", "unicached", "decached", "decoding", "Encured"], "url": ["loc", "el", "sl", "ssl", "https", "location", "ls", "dl", "char", "email", "external", "bel", "con", "web", "net", "str", "ll", "conn", "http", "rl", "ul", "nl", "link", "socket", "browser", "ur", "URL", "sb", "address", "name", "open", "mail", "r", "uri", "Url", "l", "log"], "stream": ["context", "Stream", "output", "engine", "store", "present", "channel", "screen", "data", "message", "window", "content", "iterator", "ream", "chain", "stack", "buffer", "sequence", "sw", "network", "in", "view", "collection", "resource", "response", "trans", "document", "file", "console", "body", "pool", "reader", "current", "out", "source", "feed", "input", "row", "sample", "pod", "read"], "doc": ["div", "dr", "Doc", "data", "sum", "window", "dict", "content", "city", "tree", "m", "xml", "str", "text", "js", "DOC", "dc", "page", "oc", "cam", "dir", "Document", "document", "file", "md", "body", "nt", "msg", "word", "def", "out", "graph", "g", "db", "json", "tx", "t", "html", "d", "date"], "nodes": ["enodes", " Namps", " nubs", "nsons", "nons", "lodes", " Noms", "nsods", "neaves", "lums", "nsodes", "nubs", "nums", "nones", "neumbers", "numbers", "neubes", "noms", "nsums", "jords", " namps", "nords", "enubs", "namps", " numbers", " Nords", "ntones", " nubes", "snods", " nones", " Nodes", "enones", "nubes", "snodes", "ntodes", "nods", "snums", "lons", " naves", " noms", "ntords", "joms", "enords", "enubes", "jamps", "lods", "neodes", "enumbers", " nords", "enaves", "naves", "ntubs", "jodes", "snons"], "n": ["cn", "k", "nn", "nu", "num", "ot", "en", "v", "nc", "nm", "N", "ln", "sn", "nw", "net", "ne", "ns", "an", "nb", "m", "un", "ll", "nl", "j", "nan", "mn", "nt", "no", "number", "len", "g", "l", "na", "ni", "o", "np", "d"], "i": ["cli", "mi", "wi", "u", "pi", "ix", "ini", "ii", "us", "si", "e", "ai", "eu", "bi", "print", "ms", "m", "sim", "me", "ki", "iu", "multi", "ic", "ei", "it", "li", "a", "j", "ti", "xi", "init", "x", "hi", "ori", "ji", "zi", "phi", "y", "is", "ui", "di", "gi", "ci", "ip", "\u0438", "o", "qi", "info", "index", "I"], "node": ["image", "nn", "object", "entity", "field", "holder", "ye", "e", "token", "device", "ne", "cell", "normal", "tree", "entry", "ode", "slave", "resource", "stroke", "note", "key", "card", "obj", "document", "brain", "child", "tmp", "name", "word", "good", "element", "line", "source", "Node", "row", "t", "edge", "remote", "job", "local"]}}
{"id1": "11183087", "id2": "1235538", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"doPost": [" dopost", "DoAdd", " doPOST", "Dopost", "handlepost", "DoPost", "DoPOST", "handlePOST", " doAdd", "doPOST", "handleAdd", "dopost", "doAdd", "handlePost"], "request": ["object", "record", "question", "setup", "complete", "application", "http", "re", "report", "quest", "run", "address", "controller", "get", "url", "context", "Request", "server", "search", "select", "enter", "web", "print", "browser", "register", "document", "current", "call", "start", "version", "remote", "command", "project", "result", "initial", "forward", "message", "connect", "begin", "user", "require", "hello", "subject", "raw", "post", "argument", "query", "law", "parent", "reference", "input", "create", "handle", "position", "work", "model", "the", "list", "order", "xml", "collection", "QUEST", "frame", "req", "connection", "event", "open", "system", "client", "reset", "first", "requ"], "response": ["image", "context", "onse", "reply", "output", "server", "message", "service", "content", "e", "ve", "environment", "print", "application", "resp", "entry", "view", "collection", "status", "re", "frame", "to", "page", "report", "connection", "document", "res", "out", "write", "respond", "one", "Response", "default", "success", "next", "ce", "exit", "send", "result"], "senha": ["tinhi", " senhi", " senhas", "tinha", "senwa", "Senho", "ensenHA", "SenHa", " senHA", " senho", "tenHa", "senhi", "senho", "Senhi", "tenwa", "tenja", "renwa", "Senwa", "Senca", "tenha", "Senja", "renHa", "senca", "ensenha", "senja", "Senhas", "senigma", "tinigma", "tinhas", "renja", "Senigma", "Senha", " senigma", "renha", "ensenca", "SenHA", "senhas", "senHA", " senca", "ensenho", "senHa"], "email": ["image", "Email", "el", "quote", "license", "domain", "office", "message", "detail", "external", "enter", "secret", "string", "e", "path", "ne", "le", "addr", "IL", "example", "Mail", "alias", "ilo", "login", "label", "elly", "file", "gmail", "address", "ails", "name", "zip", "lock", "line", "mail", "username", "oe", "ip", "url", "echo", "ql", "live", "sample", "password", "hello"], "messageDigest": [" messageDiger", "messagemdEST", "messageIGEST", "messagemd5", "messageDer", "messageDse", "MessageDig5", " messagedigester", "Messagedigse", "messageDigester", "messageDiger", "messagedigest", "Messagedig5", "messagedigse", "messageDig5", "messagedigester", " messageDigester", "Messagedigester", " messageDigse", "messagemdest", "MessagedigEST", "messageMDest", "messagediger", "messagemdester", "messageDigEST", "messageIGester", "messageIGest", "MessageDigest", "messageDigse", "messageMDEST", " messagedigse", "messagedigEST", "messageDest", "messageIGse", "MessageDigester", "Messagedigest", "messageMDse", "MessageDigEST", " messagedigest", "messagedig5", "messageDester", "messageMDester", "MessageDigse", " messagediger"], "usuario": ["ussurio", " usuarius", "cussuino", "usruarios", "usnuarius", "uscuino", "cussuarial", " usuarial", "usruino", "uscuario", "usuiario", "uscuarial", "cussuarios", "usurio", "ususarial", "cusuarial", "ussuario", "ususrio", "ususarius", "uscu\u00e9r", " usurio", "ussuarios", "usruarial", "ussuino", "usuino", "usuarial", " ussuarius", " ussuarial", "usnurio", "uscuarios", "cusuarios", " ussurio", "usnuario", "cusuario", "usuarios", "cussu\u00e9r", "cusu\u00e9r", "cusuino", "usui\u00e9r", "usuiarial", "ususario", "usruario", "usu\u00e9r", "usuiarios", "cussuario", "ussu\u00e9r", "ussuarius", "ussuarial", "usnuarial", "usuarius", " ussuario"], "redirect": ["indirection", "reddigate", "inderer", "rightRECT", "rightigate", "redrict", "edurl", "predirect", "reddRECT", "redurl", "predurl", "edirection", "redigate", "redRECT", "indirect", "edirect", "redir", "redirection", " redir", "Reddraw", " redirection", "rightirection", "REDir", "predirection", "reddirect", "Redigate", "edir", " redurl", "reddraw", "REDirect", "edrict", " reddraw", "preddraw", "Redurl", "reddirection", "RedRECT", "Rederer", "REDurl", "REDirection", "rightirect", "rederer", "Redrict", "ederer", "Redirection", "Redirect", "indrict"], "session": ["context", "container", "store", "server", "person", "cache", "data", "task", "relation", "instance", "window", "cookie", "s", "user", "group", "environment", "state", "application", "trip", "Session", "metadata", "browser", "sql", "connection", "sid", "layout", "shared", "ess", "params", "current", "system", "client", "activity", "ession", "input", "still", "json", "condition", "save", "use", "local", "ESSION"]}}
{"id1": "3024970", "id2": "4118412", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToInputstream", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamtoInputSteam", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamTooutputFile"], "in": ["mi", "ins", "din", "inside", "el", "copy", "en", "scan", "p", "ini", "IN", "sin", "inn", "con", "ai", "io", "inf", "cin", "gin", "q", "mm", "ac", "bin", "xml", "from", "on", "it", "c", "ic", "inv", "init", "sql", "nin", "mc", "al", "ain", "ind", "this", "is", "h", "rin", "up", "i", "input", "source", "r", "inner", "iter", "doc", "l", "log", "isin", "im", " din", "read", "In", "n"], "baout": ["caio", "BAin", "boout", " balog", "cain", "baouts", "Baouts", "caouts", " baot", "caout", "kaend", "baend", "oaout", "caend", "BAot", "oaio", "abaot", " bain", "balog", "baio", "calog", "kaout", "bain", "BaOut", "oain", "caOut", "boio", " baend", "BAout", "Baout", "abaout", "oaOut", "boOut", "BAOut", "abaOut", " baouts", " baOut", "abain", "boin", "kain", "baOut", "kaOut", "Balog", "baot"], "out": ["ot", "cmd", "copy", "output", "OUT", "b", "gr", "co", "serv", "ex", "sum", " Out", "list", "gt", "con", "net", "io", "sys", "set", "it", "outs", "OU", "ou", "to", "all", "obj", "res", "aos", "client", "check", "up", "oss", "g", "conv", "null", "o", "t", "log", "Out", "at", "n"], "count": ["length", "ount", "z", "num", "id", "sum", "total", "N", "nb", "resp", "c", "size", "skip", "code", "nt", "amount", "current", "found", "counter", "number", "start", "ctr", "ct", "Count", "index", "read"]}}
{"id1": "9796161", "id2": "5836744", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD7", "getMD4", "getmd4", "toMD2", "getSHA7", "getSHA2", "toSHA7", "toSHA5", "getSHA4", "toMD4", "toSHA2", "toSHA4", "getmd2", "getmd5", "getMD2", "toMD5", "toMD7", "getSHA5", "getmd7"], "s": ["f", "fs", "ins", "ends", "ats", "xs", "b", "bs", "p", "v", "rs", "sts", "ls", " gets", "data", "aws", "string", "gets", "S", "ns", "ms", "str", "space", "ss", "strings", "src", "sq", "text", "js", "gs", "c", "sv", "ts", "sql", "sb", "ses", "y", "ies", "is", "h", "source", "i", "g", "es", "l", "os", "abs", "its", "bytes", "t", "ws", "ps", "n"], "m": ["mi", "bm", "mr", "mt", "M", "v", "perm", "mo", "fm", "nm", "hm", "mk", "e", "ms", "mm", "me", "gm", "om", "pm", "man", "mod", "made", "em", "md", "mut", "mc", "managed", "y", "dm", "am", "mask", "rem", "h", "vm", "rm", "tm", "g", "manager", "l", "mac", "mu", "cm", "sm"]}}
{"id1": "1156851", "id2": "23452437", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 0, "substitutes": {"runWeb": ["runHttp", " runHttp", "processSite", "initSite", "processHttp", "initHttp", "initWeb", "processWeb", "runSite", " runSite", " runweb", "runweb", "processweb", "initweb"], "beginURL": ["endURL", "beginHTML", "useUrl", " beginALL", "createUrl", "wardUR", "endUrl", "useHTML", "BeginALL", "startURI", "BeginUR", "beginURI", "createURL", "useURI", "BeginUrl", " beginLocation", "useURL", " beginURI", "beginUrl", "createURI", "wardURL", "startURL", "createHTML", "startLocation", "BeginURI", "wardUrl", "beginLocation", "beginALL", "endUR", "startALL", "BeginURL", "BeginLocation", "beginUR", "BeginHTML"], "contextRoot": ["Contextroot", "resourcePath", "ctxParent", "ContextRoot", "ContextParent", "resourceRoot", "resourceURL", " contextBase", "resourceData", "resourceBase", " contextBox", " contextHome", "contextData", "ContextHome", "contextParent", "contextPath", "ContextBox", "ctxBase", " contextroot", "ctxHome", "contextHome", "ContextBase", "ctxBox", "contextroot", "contextURL", "ContextPath", " contextURL", "ContextURL", "contextBox", "ctxRoot", " contextPath", " contextData", "resourceroot", "ContextData", "ctxPath", "contextBase", " contextParent"], "pageURI": ["pageUR", "puri", "PagePath", "requestFile", "Pageuri", "pageName", " pageName", "pagePath", "requestUR", "pName", "PageURI", "requestPath", "pageURL", "requestURI", "PageFile", " pageUR", "pageuri", "pURI", "PageURL", " pageURL", " pageuri", "pageFile", "PageName", "pURL", " pageFile", "PageUR", " pagePath"], "vtURLs": ["VTURLS", "vtHTTPS", "vtSRls", "vtURers", "VTURLses", "vtTLList", "vtHTTPs", "VTURers", "VTURLls", "vtURLList", "voltTLList", "vtURLS", "vtURS", "vtURa", "VTURls", "vtURses", "voltURLls", "vtURLers", "vtSRList", "vturls", "vtOLls", "vtHTTPa", "vtHTTPls", "vtURls", "vturlS", "vturlls", "voltURLs", "VTURLs", "vturla", "VTURS", "vtURs", "vtTLs", "vtURList", "voltURLList", "vtULS", "vtURLses", "voltTLs", "vtGETs", "vtGETers", "vtSRs", "vtULs", "vtOLers", "VTURa", "vtURLa", "vtGETses", "VTURLers", "VTURLa", "vtGETls", "vtURLls", "vtOLs", "vtOLses", "VTURses", "VTURs", "vtTLls", "voltTLls", "vtULls"], "vtRobots": ["vtHuborts", "vsRobots", "vtHubugs", "virtReplots", "vetRobots", "vtPlugots", "vetRubows", "vsHubotos", "vetRobows", "vtUbugs", "vtPlugugs", "virtRoborts", "vtCapotos", "virtRobots", "vtUbotos", "vtReplops", "vsRobotos", "vsRobbs", "vtRobugs", "vtRoboles", "vtCapot", "vtReplots", "vtTabots", "virtReploles", "vtHubbs", "vtHubotos", "vtLegot", "vtLegotos", "vtCapots", "vtRobops", "vtHubops", "vtTabops", "vetRobot", "vtHubots", "vtTaborts", "vtPlugbs", "virtRobops", "vetRubotos", "vtPlugotos", "vtCapows", "vetRobotos", "vtReploles", "vetRubot", "vtUbbs", "vtTaboles", "vtRobotos", "vsHubots", "vtRobot", "vsRobugs", "vtRubows", "vetRubots", "vtUbots", "virtReplops", "vtHuboles", "virtRoboles", "vtRobbs", "vtRobows", "vtReplorts", "vtRubots", "virtReplorts", "vsHubbs", "vtRoborts", "vtRubot", "vsHubugs", "vtLegots", "vtRubotos", "vtLegows"], "indexer": ["IndexReader", "documente", "Indexe", "Indexator", "indexe", "indexor", " indexener", " indexe", "documenter", "indexator", "documentReader", "indexner", "Indexener", "Indexner", "documentener", "Indexor", "mixator", "mixner", "mixor", "searchner", "searchor", " indexReader", "Indexer", "searcher", "indexener", "mixer", "indexReader", "searchator"], "indexDoc": [" indexDocument", "indexDocument", " IndexPage", " Indexdoc", "IndexDoc", " IndexDocument", "Indexdoc", " indexdoc", "indexdoc", " IndexDoc", "indexPage", "IndexDocument", "IndexPage", " indexPage"], "sxURL": ["SxeURI", "spxUR", "sxeURL", "sxyUR", "sxUrl", " sxeUR", "sxIL", "sixBL", "sfxBL", "desxUrl", " sfxELF", "sfxURI", "sxeBL", "sxeIL", " sxEL", "sxxURL", " sXUrl", "sXEL", " sxeIL", "sxELF", "desXUR", "sxUSER", "SxUrl", "sfxID", "SxeBL", "sXALL", " sXUR", " sxUrl", "sfxEL", "desxALL", "sxfEL", "sxfALL", "sxyURL", "sixID", "desxURL", " sxUR", "SxeURL", "SxID", "sfxPORT", "spxUrl", "sxfURI", "sxeID", "desxUR", "SxeID", "SxURI", "sfxUR", "sXELF", " sxIL", "SxUR", "sxxIL", "sfxUSER", "sxALL", " sfxURL", " sXURL", "sxsURL", "sixURL", "sfxIL", "sXUR", "sxBL", "SXUrl", "sXURI", "desXUrl", " sxeUrl", "sxeURI", " sfxUR", "sxfUrl", "SxBL", "sxPORT", "sxsUSER", "sxePORT", "desXALL", "sxUR", "sxyUrl", "sfxURL", "desXURL", "sxsUR", "spxURL", "sXURL", "sxxALL", "sxxUR", "sxfUR", " sxELF", " sXEL", "sfxUrl", "sxxUrl", "SXURL", " sfxUrl", " sxeURL", "spxELF", "sxID", "sxsUrl", "SXURI", "sfxELF", "sxfURL", "sxEL", "sixURI", "SxURL", "SXUR", "sxeUrl", "sXUSER", "sXUrl", "sxURI", "sxyPORT", "sxeUR"], "sxRobotURL": ["sxRoboteURL", "sxRobotSTR", "sxRobOTURL", "sxRoboSTR", "sxRoboteSTR", "sxRoboteUR", "sxLegoURL", "sxRoboUrl", "sxroboteURL", "sxLegotUR", "sxRobosSTR", "sxLegoteSTR", "sxrobotURI", "sxRobosUrl", "sxRobottSP", "sxRoboteUrl", "sxRoboySP", "sxroboteUR", "sxRobotUrl", "sxRoboURL", "sxRobotePATH", "sxLegoteUR", "sxrobotUrl", "sxroboteUrl", "sxRoboURI", "sxRobOTUR", "sxroboteURI", "sxNobosURL", "sxRoboteURI", "sxRobotSP", "sxRobosUR", "sxRoboyURL", "sxNobotUrl", "sxRobrotUrl", "sxLegotURL", "sxLegoteUrl", "sxrobotURL", "sxRobottUrl", "sxRoboPATH", "sxLegoPATH", "sxRobOTUrl", "sxRobotURI", "sxRobrotURL", "sxNobosHTTP", "sxRobosHTTP", "sxNobotSP", "sxRobottHTTP", "sxRobosURL", "sxRobrotUR", "sxRoboUR", "sxRobotHTTP", "sxrobotUR", "sxLegotUrl", "sxRobotPATH", "sxLegoUrl", "sxLegotPATH", "sxNobotURL", "sxRobrotPATH", "sxRobotUR", "sxLegoteURL", "sxRobosSP", "sxRobottURL", "sxRoboyHTTP", "sxLegoUR", "sxLegotSTR", "sxRobOTURI", "sxRoboyUrl", "sxNobosUrl", "sxNobotHTTP", "sxNobosSP"], "pd": ["dd", "PF", "p", "bf", "ht", "dt", " md", "dl", "dh", " dd", "vd", "Parser", "pm", "parser", "pps", "dp", "pp", " cd", "ds", " prod", "px", "pg", "pard", "wp", "po", "df", "cp", "rpm", "lp", "PD", " PD", "pl", "td", "cd", "bd", "fd", "hd", "d", "tp", "pb", "xd"], "cb": ["cn", "callback", "ck", "abb", "cf", "bf", "tc", "cc", "bp", "CB", " CB", "obb", "cgi", "nb", "fb", "Callback", "dc", "cv", "wb", "xb", "sb", "eb", "bt", "cp", "erb", "gb", "cr", "lb", "ctrl", "bc", "cor", "kb", "proc", "cd", "rb", "bb", "pb"], "bIndexPage": ["bSearchDocument", "bLabelPath", "bFoundLine", "bConnectPage", "bFoundFile", "blFoundLine", "bSearchpage", "bCheckPages", "blFoundFile", "bSearchFile", "bLinkPage", "bindexLine", "blIndexPage", "boolCheckPage", "bAddpage", "bIndexFile", "bConnectFile", "bindexFile", " bLinkPath", "bCheckPage", " bIndexpage", "bLinkPages", "boolIndexPages", "bFindPage", "boolIndexpage", "boolCheckpage", " bIndexDocument", "bFindpage", "bConnectpage", "bProcessLine", "bAddSite", "blIndexLine", "bIndexPath", "bFoundPage", "bLinkFile", " bIndexUrl", "bProcessPage", "bAddPages", " bLinkPage", "bIndexLine", "bLinkPath", "bLinkUrl", "bindexPage", "bSearchPage", "blIndexFile", "bFindUrl", " bIndexPath", "bFoundpage", "bIndexPages", "bCheckpage", "bAddDocument", "boolIndexSite", "bCheckSite", "boolCheckSite", " bLinkUrl", "bIndexSite", " bLinkDocument", "bIndexpage", " bLinkFile", "bFindPath", "blFoundPage", " bIndexFile", "bIndexDocument", "bLinkpage", "bProcessFile", "bLabelPage", "boolIndexPage", "bIndexUrl", "bLinkDocument", "bLinkSite", "bAddFile", "bAddPage", " bLinkpage", "bLabelpage", "boolCheckPages", "bLabelUrl"], "urlConn": [" urlconn", "urlCon", "bbConn", "nlWin", "databaseCon", " urlConnect", "urlCt", "webConnect", "urlCons", "UrlConn", " urlCons", "urlCh", " urlCo", "UrlCo", "httpconn", "bbConnect", "databaseCt", "httpCh", "httpConnect", "UrlConnect", "databaseConn", "nlConn", "urlWin", "urlconn", "URLConn", "urlConnector", "bbconn", "httpConn", "fileCon", "httpWin", "urlCo", " urlCh", "nlConnector", "UrlCons", "nlConnect", "URLCt", "webCo", "fileConn", "webCons", "urlConnect", "webConn", "URLconn", "fileconn", "databaseconn", "bbCh", "URLCon", " urlWin", "fileCt", "httpConnector", " urlConnector"], "modDate": ["modifiedGe", "modTime", "modifiedDay", "modifiedTime", "mtDay", " modGe", " modDay", "mtTime", "mtDate", "modGe", "modDay", " modTime", "modifiedDate", "mtGe"], "bfReader": ["fbReader", "fbWriter", "btReader", "fbParser", "bbParser", "bbWriter", "btParser", "bfWriter", "bbRead", "bfParser", "btRead", "fbRead", "bbReader", "bfRead", "btWriter"]}}
{"id1": "5808579", "id2": "7948308", "code1": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["decryptString", "decryptedPass", "encrollPass", "encryptedPass", "encrollString", "encrollPassword", "encryptedLogin", "decryptPass", "decryptedLogin", "decryptedPassword", "encryptPass", "enccryptLogin", "encryptedString", "enccryptString", "encrollLogin", "encryptedPassword", "decryptedString", "encryptString", "encryptLogin", "enccryptPassword", "decryptPassword", "decryptLogin", "enccryptPass"], "loginName": ["loginN", "usernameName", "cellName", "loginCode", "LoginTime", " loginname", " loginCode", "loginname", "LoginName", "usernameN", "LoginType", "cellTime", "blogTime", "usernameCode", "blogN", "blogCode", " loginType", "loginType", " loginN", "Loginname", "usernameTime", "loginTime", "cellType", "blogName", " loginTime", "cellname"], "password": ["value", "encrypted", "Password", "p", "confirmed", "pattern", "message", "sword", "email", "description", "secret", "string", "token", "user", "content", "path", "phrase", "picture", "database", "hello", "another", "text", "response", "argument", "comment", "attribute", "paste", "prefix", "session", "expression", "address", "PASS", "name", "word", "username", "last", "pass", "reset", "default", "padding", "command", "past", "result"], "md5": ["MD1", "md8", "md6", " md8", "red8", " MD3", " Md53", "sha5", "MD2", "red5", "md53", "red3", "red2", " MD6", " Md2", "md3", "sha2", " md2", "MD5", " md53", "sha7", "MD7", " md1", "MD3", "MD8", " md7", " md3", " Md3", " MD5", "md7", "MD53", " md6", " MD2", " Md5", "MD6", "md1", "sha1", "md2"], "ba": ["aa", "bre", "b", "bo", "ha", "bee", "ga", "aba", "tta", "bas", "xa", "bi", "aka", "abc", "ya", "da", "sta", "ja", "ena", "a", "ka", "ca", "va", "aaa", "cca", "fa", "beta", "bu", "pa", "ta", "bc", "pha", "CA", "ao", "bd", "BA", "ada", "bb", "Ba", "oa", "sa"]}}
{"id1": "20011285", "id2": "17996547", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"copy": ["move", "co", "p", "cut", "transfer", "php", "sync", "delete", "crop", "py", "Cop", "clip", "opy", "c", "link", "to", "export", "paste", "Copy", "gc", "file", "share", "proxy", "cp", "zip", "slice", "write", "split", "clone", "create", "close", "cat", "save", "download", "pixel", "remote", "cop"], "sourceFile": ["SourcePath", "initFile", "aceFile", "SourceUnit", "srcUnit", "sourceUnit", "identFiles", "aceDate", " sourcePath", "sourceFILE", "ourceUser", "srcDirectory", "sourceUser", "SourceLog", "sourceDir", "originDir", "sourcefile", "ourceFILE", "srcUser", "sampleFILE", " sourcePlace", "packageDirectory", "originLine", " sourceLog", "SourceFile", "sourceLocal", "sampleLocal", "initfile", "packageUser", " sourceLine", "originWeb", "packageFILE", "samplefile", "srcfile", "SourceDir", " sourceDir", "identDate", " sourceFiles", "aceFiles", " sourceHeader", "sourceWeb", "initFILE", "identPlace", "SourceWeb", "ourceFile", "ourceLog", "srcLocal", "sourceFiles", "srcFiles", "sourceDirectory", "srcFile", "ourceDirectory", "sourceDate", " sourceWeb", "ourcefile", " sourceLocal", "Sourcefile", "initHeader", " sourceFILE", "srcFILE", "sampleFile", "sourceLog", "originFile", " sourceUnit", "acePlace", "sourcePlace", "sourcePath", "sourceLine", "SourceLine", "packageFile", "SourceFiles", " sourceDate", "sourceHeader", "identFile", "srcHeader", "ourcePath", " sourcefile"], "destinationFile": ["destructionFile", "estinationPath", "identinationLine", "destinationFILE", "destinationPath", "destinationMail", "destinatorPath", "estinatorPath", "destinoKey", "identinatedLine", "destinatorfile", "destinateDir", "destinatorDisk", "identinatedMail", "destinatedfile", "destationfile", "destumentEmail", "destinatefile", "transinationDisk", "transinateDisk", "destumentFile", "destructionLine", "destensionDir", "catinationFile", "destationDir", "catinationfile", "transinateFILE", "destificationFile", "destinationDisk", "transinateFile", "estinationDir", "resultinationfile", "destinatedFile", "destinatorEmail", "resultinationDisk", "parentinateEmail", "resultinateLocation", "destinationKey", "destmentationFile", "destmentationFILE", "destationPath", "destinatorLocation", "catinateKey", "identinatedFile", "estinatorFile", "catinateFile", "resultinateDisk", "destinationfile", "destinationEmail", "destinatorFile", "destinateLocation", "parentinateFile", "parentinateFILE", "destinateEmail", "resultinationFile", "destinatedMail", "identinatedFILE", "destinationDir", "destationFile", "destificationDir", "destinateFile", "destensionDisk", "destentionFile", "estinationFile", "destinationLocation", "resultinationLocation", "destmentationDir", "destentionMail", "destinatorFILE", "estinatorfile", "destentionLine", "transinationFile", "destificationPath", "destationKey", "destinationLine", "destinateDisk", "destructionFILE", "destinatedDisk", "destentionFILE", "estinatorDir", "transinationFILE", "destinatedLine", "destinoFile", "transinationDir", "estinationfile", "catinationKey", "destensionFILE", "destinatorDir", "destinofile", "destensionFile", "destinateKey", "destificationfile", "identinationFile", "parentinationFile", "destinateFILE", "resultinateFile", "destumentFILE", "parentinationEmail", "resultinatefile", "identinationFILE", "transinateDir", "identinationMail", "parentinationFILE", "catinatefile", "destmentationDisk", "destinatedFILE", "destinatedLocation", "destructionMail"], "tmp": ["qq", "xs", "pres", "p", "perm", "xxx", "data", "aux", "yy", "mk", "buf", "ms", "files", "tar", "my", "m", "nb", "obs", "apps", "src", "mm", "tf", "pkg", "multi", "shots", "etc", "emp", "dir", "aaa", "img", "obj", "managed", "mp", "nt", "sp", "msg", "bt", "mb", "cmp", "txt", "split", "cur", "parts", "abs", "tab", "stuff", "buff", "t", "temp", "np", "cb", "tt"], "f": ["fs", "k", "z", "u", "field", "b", "cf", "p", "v", "bf", "fw", "uf", "lf", "fm", "fo", "af", "fe", "e", "ff", "q", "flo", "m", "tf", "sf", "c", "fb", "a", "fr", "fa", "obj", "file", "xf", "df", "fac", "fp", "h", "fi", "fab", "full", "g", "l", "fl", "t", "o", "fd", "F", "d", "w", "fc", "func"], "i": ["k", "mi", "ami", "u", "iq", "id", "ri", "p", "v", "ix", "ini", "I", "us", "ii", "si", "e", "ai", "eu", "bi", "ms", "q", "my", "m", "sim", "me", "in", "iu", "ki", "ic", "multi", "ei", "it", "li", "major", "ti", "ij", "j", "xi", "ims", "init", "key", "x", "hi", "ma", "ji", "ie", "zi", "ori", "phi", "y", "batch", "ind", "is", "ui", "iter", "di", "gi", "ci", "ip", "o", "qi", "point", "im", "index", "pi"], "source": ["image", "scope", "store", "search", "stream", "shell", "seed", "style", "SOURCE", "scan", "show", "archive", "service", "index", "iterator", "owner", "origin", "sequence", "ource", "src", "tree", "subject", "from", "in", "zero", "resource", "size", "score", "spec", "storage", "comment", "session", "init", "query", "file", "console", "missing", "ie", "body", "base", "parent", "none", "zip", "before", "system", "template", "input", "se", "iter", "inner", "start", "Source", "sample", "series", "ce", "site", "use", "info", "local", "result"], "destination": ["destinator", "coordation", " destinated", "declination", "combinate", " destinator", "combation", "combension", "combination", " destinate", " destension", "Destination", "Destension", "declinate", "Destinator", "declaration", "destaration", "declinated", "destinate", "destation", "coordinated", "Destation", "Destaration", " destation", "declinator", "coordination", "declation", "destension", "coordinate", "destinated", " destaration", "Destinate"]}}
{"id1": "937612", "id2": "14038176", "code1": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"new2Password": ["password256Pass", "password1Password", "password1Pass", "new2Pass", "new1Password", "password2Pass", "password5Password", "password2String", "password5Pass", "password256Password", "password2Password", "password1String", "new1Text", "password5Text", "new2Text", "new1Pass", "password1Text", "password256Text", "password2Text", "new2String", "password256String", "new1String", "password5String"], "passwd": ["psword", "passw", "Passwd", "Password", "Passsword", " passsword", "assphrase", "pword", "passphrase", "pasw", "pw", "assw", "pasphrase", "passsword", "paswd", "pwd", "asssword", "Passw", " password", " passw", "Passphrase", "password", "asswd"], "md": ["cmd", "dr", "dd", "sh", "mt", " MD", "der", "mo", "red", "nd", "sha", "mg", "dh", "mk", "sd", "od", "ms", "m", "mm", "me", "pm", "pd", "mod", "and", "metadata", "sam", "mc", "mn", " Md", "df", "managed", "mp", "ad", "dm", "mand", "det", "ind", "mb", "rm", "ld", "di", "cd", "bd", "hd", "cm", "d", "MD", "sm"], "clearPassword": [" clearDescription", "resetString", "resetpassword", " clearWord", "clearDescription", "clearWord", "clearpassword", "cleanDescription", "cleanPassword", "ClearWord", "resetPassword", "clearUser", "resetWord", "cleanpassword", "ClearString", "cleanUser", "ClearUser", " clearUser", "ClearDescription", "ClearPassword", " clearpassword", "Clearpassword", " clearString", "clearString"], "digestedPassword": ["digestToken", "dashedWord", "digifiedPassword", "dashedPassword", "digestedToken", " digestedString", "diguredResponse", "digashedPassword", "digestedpassword", "digestedText", "digestWord", "dashedToken", "digestedResponse", "destedText", " digestedpassword", "digestpassword", "diguredWord", "digashedToken", "destedWord", "diguredString", "digestedWord", "diguredPassword", "digestText", "diguredpassword", "digestResponse", "digifiedString", "diguredText", "diguredToken", "digashedWord", " digestPassword", "digifiedpassword", " digestResponse", "digifiedResponse", " digestedResponse", " digestpassword", "dashedText", "digestPassword", "digashedText", "destedToken", "digestedString", " digestString", "destedPassword", "digestString"]}}
{"id1": "9872346", "id2": "16378239", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["selectRawFile", "readRawFile", "readRawdocument", "readLocalDocument", "readremoteDocument", "selectRawObject", "readRawDocument", "readRemoteFile", "selectRawDocument", "selectRemotedocument", "readLocalObject", "readLocaldocument", "readRemotedocument", "selectRawdocument", "readremoteFile", "selectRemoteObject", "readRawObject", "readremoteObject", "readremotedocument", "readRemoteObject", "readLocalFile", "selectRemoteDocument", "selectRemoteFile"], "url": ["loc", "host", "el", "u", "sl", "ssl", "domain", "org", "b", "p", "location", "ls", "dl", "channel", "github", "web", "path", "ref", "lr", "addr", "q", "str", "ll", "loader", "request", "resource", "http", "rl", "load", "ul", "nl", "link", "browser", "ur", "impl", "key", "URL", "file", "base", "address", "mount", "mail", "client", "r", "uri", "Url", "l", "hub", "cl", "abs", "util", "href", "html"], "validate": [" invalididate", "validates", "Validation", " validateidate", " invalidate", " invalidation", " validateate", "Valididate", " invalidates", "Validate", "Validates", " validateates", "valididate", " validateation", "validation"], "document": ["initial", "context", "object", "record", "entity", "output", "value", "node", "person", "location", "model", "language", "data", "message", "relation", "window", "instance", "dict", "content", "um", "buffer", "program", "duration", "database", "tree", "xml", "application", "entry", "article", "text", "collection", "response", "reason", "ocument", "metadata", "Document", "file", "expression", "event", "word", "doc", "number", "null", "json", "command", "component", "information", "result"], "factory": ["Facter", "bancy", "invacter", "fificate", "hFactory", "facixture", "forFactory", "hixture", "fFactory", "Face", "Fixture", "tactory", "fiber", "foractory", "Factory", "kiber", "Fility", "tacter", "face", "FFactory", "affactory", "inviber", "kactory", "forificate", "fixture", "Fancy", "vancy", "fility", "facFactory", "vactory", "invactory", "bFactory", "kixture", "facility", "tixture", "vacter", "fancy", "bactory", "invixture", "tiber", "Fificate", "facter", "kacter", "affificate", "affFactory", "bacter", "afface", "hility", "facactory", "forace", "hactory", "vFactory"], "connection": ["context", "object", "engine", "server", "position", "location", "channel", "Connection", "connect", "relation", "communication", "description", "service", "con", "driver", "city", "pointer", "handler", "database", "network", "conn", "application", "entry", "wrapper", "resource", "writer", "response", "link", "socket", "to", "session", "query", "builder", "function", "operation", "connected", "directory", "reference", "open", "ion", "client", "current", "character", "create", "uri", "close", "cone", "statement", "created", "condition", "creation", "version", " Connection", "command"], "stream": ["length", "context", "progress", "Stream", "present", "channel", "screen", "data", "message", "window", "instance", "content", "iterator", "ream", "sequence", "buffer", "stack", "sw", "in", "REAM", "resource", "response", "upload", "shape", "file", "sam", "console", "body", "pool", "reader", "zip", "is", "client", "out", "source", "feed", "input", "still", "row", "sample", "read", "cont"]}}
{"id1": "18489832", "id2": "16825994", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" tryLoadXZipImage", " tryLoadXippedImage", " tryLoadXippedFile", " tryLoadZppedImage", " tryLoadXZipDir", " tryLoadXippedfile", " tryLoadZppedDir", " tryLoadZZipfile", " tryLoadZippedFile", " tryLoadZppedfile", " tryLoadZippedfile", " tryLoadZressedFile", " tryLoadZressedDir", " tryLoadZressedImage", " tryLoadZZipImage", " tryLoadZppedFile", " tryLoadXippedDir", " tryLoadXZipFile", " tryLoadZippedImage", " tryLoadZZipFile", " tryLoadZZipDir", " tryLoadZressedfile", " tryLoadXZipfile", " tryLoadZippedDir"], "url": ["sl", "ssl", "b", "https", "location", "dl", "char", "external", "web", "ref", "un", "str", "err", "ll", "xml", "raw", "loader", "ret", "request", "http", "ul", "nl", "link", "browser", "ur", "key", "URL", "file", "build", "base", "address", "name", "open", "call", "mount", "get", "r", "uri", "Url", "l", "row", "parse", "log"], "destDir": ["srcDir", "originDIR", "srcDIR", "destFile", "destDIR", "sourceFolder", "sourceFile", "distDirectory", "distDir", " destDirectory", "destDirectory", " destFolder", "destFolder", "targetDir", "distFolder", " destDIR", "distDIR", "targetDirectory", " destFile", "srcDirectory", "originDirectory", "targetDIR", "sourceDirectory", "srcFile", "originFolder", "sourceDir", "originDir", "targetFolder", "srcFolder"], "urlConnection": ["urlDialog", " urlLink", "URLClient", " urlConnect", "UrlDialog", " urlDialog", "urlClient", "httpConnect", "UrlConnect", "urlCompany", "URLConnection", "streamClient", "URLCompany", "streamCompany", "urlConnector", "UrlConnection", "URLConnector", "httpLink", "streamConnection", "urlConnect", "httpConnection", " urlClient", "streamConnector", " urlCompany", "httpDialog", "UrlLink", "urlLink", " urlConnector"], "tmpFile": ["tempView", " tmpDir", "thisfile", "thisFile", "empView", "thisFilename", "destfile", "cmpFilename", "destFile", "cmpPage", "tmpBe", "tmpTile", "mpfile", "tempFile", "tempfile", "empChain", "tmpChain", "tmpfile", "destBe", "thisChain", "empTile", " tmpfile", "tempBe", "tempChain", "empfile", "tmpPage", "tempFilename", "tmpView", "tmpDir", "tempDir", "cmpfile", "empFilename", " tmpFilename", "empFile", " tmpTile", "tempTile", "empDir", " tmpPage", "mpFile", " tmpView", "tempPage", "cmpFile", "destPage", " tmpBe", "tmpFilename"], "in": ["mi", "ins", "inside", "din", "el", "en", "co", "old", "ini", "IN", "ze", "sin", "inn", "con", "ln", "ai", "inf", "cin", "gin", "on", "bin", "from", "st", "it", "or", "by", "ains", "re", "all", "init", "as", "query", "al", "ma", "ie", "ain", "none", "ind", "is", "inc", "up", "rin", "i", "input", "source", "iter", "inner", "oin", "one", "pass", "win", "l", "info", "isin", "im", "index", "In", "n"], "out": ["cn", "output", "OUT", "co", "v", "ex", "external", "ent", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "or", "writer", "OU", "ou", "col", "note", "to", "all", "obj", "po", "aos", "tmp", "nt", "cos", "ch", "can", "client", "write", "up", "no", "oss", "one", "oe", "conv", "os", "null", "na", "flush", "o", "t", "exit", "Out", "at", "outer", "n"], "localURL": ["LocalID", "LocalLL", "localhostURL", " localURI", " localUL", "LocalUL", "localUrl", "localhostLL", "LocalURL", "localLL", "localUR", "localID", "localUL", " localLL", "LocalUR", "localhostID", "publicURI", "localURI", " localID", "publicUrl", "publicURL", " localUrl", "LocalUrl", "localhostUL", "LocalURI", "publicUR", " localUR"]}}
{"id1": "7396682", "id2": "1954410", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["core", "move", "archive", "transfer", "php", "sync", "delete", "crop", "repeat", "py", "Cop", "clip", "opy", "map", "load", "link", "read", "replace", "upload", "Copy", "gc", "share", "proxy", "cp", "zip", "slice", "write", "split", "clone", "create", "cat", "pixel", "download", "fit", "cross", "cop"], "srcFS": ["sourceFs", "sourcefs", "srcCS", "rcFS", " srcOS", "rcOS", "srcFs", "sysFS", " srcMS", "rcfs", "srcMS", " srcCS", "sourceFS", " srcFs", "sysVS", " srcSF", "srFS", " srcfs", "rcCS", "sourceCS", "sysFs", "srFs", "sourceVS", " srcVS", "rcSF", "sourceOS", "srcOS", "rcFs", "srcVS", "rcVS", "srfs", "srMS", "sourceSF", "rcMS", "srcfs", "srcSF", "sysOS"], "src": ["loc", "rel", "iv", "supp", "th", "node", "rc", "rs", "RC", "SOURCE", "https", "sc", "selected", "usr", "sin", "boot", "sync", "dest", "path", "sn", "secure", "addr", "sys", "target", "obs", "str", "subject", "st", "sq", "from", "via", "sec", "pkg", "resource", "http", "inst", "sit", "spec", "ser", "pri", "req", "dir", "sub", "img", "init", "sb", "obj", "nil", "tmp", "rx", "comp", "txt", "check", "source", "input", "lb", "cur", "filename", "syn", "uri", "proc", "start", "ctr", "sci", "sr", "desc", "url", "Source", "cont"], "dst": [" dest", "deslt", "dnd", " ddest", "ddlt", "Dest", "dhlt", "dslt", "DST", "dhdest", "dDest", "dest", "Dst", "ddnd", "dlt", "Ddest", "dhDest", "dsst", "dddest", "ddst", "lgt", " dST", "degt", "lest", " dlt", "dsest", "dedest", "desst", "dsST", "dST", "desdest", "dsgt", "lst", "dgt", "ddest", " dDest", "dsnd", "desnd", "dsdest", "deest", "DDest", "Dlt", "ldest", "dhst"], "deleteSource": ["delSOURCE", "deleteDest", "deleteSourceFile", "deleteSources", "updateSite", "delSource", "removeSource", "updateSource", "destroyTarget", "removeParent", " deleteResult", "closeSOURCE", " deleteTarget", "delDest", "destroySources", "leteSource", "removeSOURCE", "removeDest", "leteDest", "leteSOURCE", "DeleteSite", "delParent", "leteSources", "updateSOURCE", "deleteSite", "closeSource", "closeSite", "DeleteSourceFile", "destroyResult", "DeleteSource", "deleteParent", "deleteSOURCE", "deleteTarget", "closeSourceFile", "updateSourceFile", "leteResult", "destroySource", "DeleteSOURCE", "leteTarget", " deleteSources", "deleteResult", "leteParent"], "conf": ["fs", "f", "cn", "param", "irm", "Conf", "co", "scan", "cf", "plan", "com", "cache", "cc", "con", "ln", "ref", "cfg", "acc", "q", "m", "ctx", "mm", "conn", "map", "comm", "cms", "ca", "comment", "req", "report", "cb", "params", "ch", "pool", "hash", "ban", "def", "check", "config", "conv", "prop", "log", "info", "css", "cm", "job", "lib"], "contents": ["CONTants", "Contodes", "CONTENT", "CONTent", "Contterms", " contants", "contants", "ContENT", " Content", "Content", " contends", "CONTENTS", "content", "CONTresses", "Contants", "contENTS", " contENT", "contends", " Contresses", "contodes", "contresses", "CONTodes", " contENTS", "constents", " contterms", "constends", " content", "contENT", "CONTterms", "CONTends", " Contents", "constENTS", "CONTaves", "contaves", "contterms", "constaves", " contodes", "Contents", " contresses", " contaves", "CONTents", " ContENTS"], "i": ["cli", "mi", "ami", "u", "docker", "iq", "id", "ix", "ini", "I", "us", "ii", "si", "ai", "chain", "bi", "ms", "n", "q", "my", "m", "sim", "me", "ki", "ic", "multi", "it", "ei", "li", "ij", "ti", "j", "span", "xi", "ims", "init", "key", "x", "hi", "ori", "ji", "ie", "phi", "y", "ind", "is", "client", "ui", "iter", "inner", "di", "gi", "oi", "json", "ci", "ip", "ski", "\u0438", "o", "qi", "im", "index", "pi"], "in": ["ins", "din", "en", "ini", "char", "ze", "IN", "inn", "con", "inf", "cin", "bin", "xml", "from", "raw", "by", "re", "and", "add", "sql", "mc", "body", "reader", "ind", "is", "inc", "out", "check", "doc", "input", "source", "r", "inner", "sample", "isin", " din", "read", "In"]}}
{"id1": "6625074", "id2": "20991673", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "label": 1, "substitutes": {"SHA1": [" SHA512", "HS1", "SHAOne", "SHA512", "shaOne", "HSOne", "SHA2", " SHAOne", "sha2", "sha1", "HS2", " SHA2", "HS512", "sha512"], "text": ["translation", "value", "output", "v", "data", "message", "sum", "content", "string", "path", "form", "print", "test", "buffer", "q", "str", "pt", "it", "comment", "document", "hex", "code", "nt", "msg", "act", "body", "name", "word", "event", "txt", "TEXT", "template", "title", "input", "source", "doc", "url", "tx", "t", "ext", "password", "Text", "read", "cont", "ut"], "sha1hash": ["ha2address", "sha1Hash", "sha3message", "ha1sum", "sha1hex", "sha31Hash", "SHA2Hash", "ha1Hash", "sha2message", "sha1address", "sha0Hash", "SHA1hex", "sha0address", "haoneHash", "SHA2hash", "haonesum", "ha2sum", "sha2sum", "ha2Hash", "ha2hash", "sha3Hash", "sha31sum", "shaonehex", "haonehash", "sha1message", "sha3sum", "SHA1sum", "sha2hash", "sha1sum", "SHA1hash", "ha1hash", "sha2hex", "shaonehash", "sha2Hash", "sha0sum", "sha31hash", "sha2address", "haonemessage", "SHA2hex", "ha1message", "sha0hash", "shaoneHash", "ha1address", "shaonemessage", "SHA1Hash", "SHA2sum", "sha31address", "sha3hash", "shaonesum"], "md": ["pdf", "cmd", "dr", "dd", "mt", " MD", "amd", "der", "sha", "nd", "dh", "mk", "sd", "od", "ms", "m", "mm", "pm", "pd", "mod", "strong", "ds", "and", "obj", "ad", "mn", " Md", "df", "mc", "dm", "mand", "hash", "ind", "det", "ld", "rm", "di", "alg", "cd", "bd", "hd", "d", "MD", "sm"]}}
{"id1": "350482", "id2": "11305840", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionQuery", "doVersionsUpdate", " doVersionTest", "doBuildCheck", "doFeaturecheck", "doFeatureInfo", "doFeatureQuery", " doVersionQuery", "doImageInfo", "doFeatureCheck", " doApplicationQuery", " doVersionsTest", "doVersionsTest", "doApplicationCheck", "doFeatureUpdate", "doApplicationInfo", "doImageQuery", " doVersionUpdate", " doVersionsUpdate", " doVersioncheck", "doBuildUpdate", "doBuildcheck", "doImageCheck", "doVersionscheck", " doVersionInfo", "doVersionsCheck", "doFeatureTest", "doApplicationQuery", " doApplicationCheck", " doApplicationInfo", " doVersionscheck", "doBuildTest", "doVersionInfo", "doVersioncheck", "doImageTest", " doApplicationTest", "doVersionUpdate", "doVersionTest", " doVersionsCheck", "doApplicationTest"], "view": ["image", "update", "iew", "context", "server", "engine", "VIEW", "v", "port", "model", "show", "self", "window", "review", "ml", "form", "box", "print", "buffer", "q", "cell", "tree", "subject", "block", "eye", "http", "page", "cv", "browser", "report", "query", "document", "file", "layout", "tv", "widget", "controller", "pool", "see", "this", "lock", "call", "client", "check", "display", "h", "View", "virtual", "input", "vm", "manager", "version", "row", "html", "project", "component", "index", "views"], "url": ["loc", "rel", "f", "host", "sl", "ssl", "domain", "gl", "b", "v", "dl", "hl", "char", "bel", "ref", "str", "oul", "ll", "rl", "http", "ul", "nl", "link", "browser", "ur", "URL", "file", "build", "address", "mount", "mail", "client", "pl", "get", "lb", "r", "uri", "Url", "l", "log", "html", "job"], "in": ["f", " IN", "ins", "din", "isin", "stream", "IN", "sin", "inn", "ln", "inf", "cin", "gin", "on", "from", "init", "mn", "body", "ain", "reader", "is", "inc", "can", "out", "rin", "i", "input", "source", "inner", "l", "asin", "mat", "vin", "info", " din", "In", "n"], "bin": ["ins", "din", "jin", "bl", " bins", "lib", "binary", "b", "ran", "abin", "bed", "bn", "stock", "cache", "sin", "inn", "con", "ln", "bi", "cin", "gin", "buffer", "nb", "local", "by", "re", "spin", " Bin", "bg", "all", "session", "init", "thin", "sam", "brain", "file", "body", "cos", "reader", "out", "rin", "win", "len", "inner", "db", "conv", "obin", "rb", "bur", "buff", "cb", " din", "ebin", "mon"], "line": ["column", "cmd", "record", "ine", "field", "stream", "style", "liner", "port", "channel", "eline", "zone", "message", "char", " block", "detail", "string", "ice", "ln", "lo", "le", "chain", "print", "sequence", "cell", "section", "block", "lin", "entry", "rule", "err", "part", "status", "trace", "frame", "tile", "Line", "link", "inline", "page", "stay", "comment", "range", "key", "file", "lane", "code", "base", "word", "iter", "cat", "l", "lines", "row", "parse", "next", "log", "LINE", "sample", "point", "job"], "develBuild": ["deffbuild", "DeVELbuild", "deVELLog", "develRelease", "deVELBuilder", "Develbuild", "depoBuilt", "duvelbuild", "devBoot", "desvelbuild", "desvelRelease", "duffbuild", "depobuild", "depoLog", "develLoad", "duVELBuild", "deVELbuild", "desVELbuild", "deVELBuild", "duffBuilt", "deeltaLoad", "devbuild", "DevelLog", "develbuild", "deffBuilder", "deployBuilt", "DevelBuild", "duvelBuilt", "deffBuilt", "duffBuilder", "deployLoad", "desvelLoad", "develBuilder", "duvelBuild", "duvelBuilder", "deVELBoot", "duvelBoot", "DeVELLog", "deVELLoad", "desVELRelease", "deploybuild", "deployBuilder", "DeVELBuilt", "devBuilder", "develLog", "DevelBuilt", "duffBuild", "deployBoot", "duVELBoot", "duVELbuild", "develBuilt", "DeVELBuild", "deVELRelease", "deeltaRelease", "devBuild", "deVELBuilt", "deeltaBuild", "devBuilt", "deployRelease", "depoBuild", "desVELLoad", "devLog", "desvelBuild", "deployBuild", "deffBuild", "duVELBuilder", "deeltabuild", "develBoot", "desVELBuild"], "stableBuild": ["activeMake", " stableCraft", "activeBuild", "stableBind", " unstableLong", " unstableBuild", "stableBoot", " stableBuilder", " stableMake", " unstablebuild", "stableCraft", "confirmedBoot", "secureBuilder", "devbuild", " stablebuild", " stableBoot", " stableBind", "stablebuild", "secureBuild", "activeBuilder", " unstableBuilder", "confirmedbuild", "confirmedBuild", "stableBuilder", "securebuild", " unstableBind", "devBuilder", "secureCraft", "stableLong", "devBind", " unstableCraft", "devBuild", "devMake", "stableMake", " stableLong", "confirmedLong", "activebuild", " unstableBoot"]}}
{"id1": "2736184", "id2": "12586404", "code1": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "code2": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "label": 0, "substitutes": {"getURLContent": ["getHTTPContent", "postURLContent", "geturlContents", "getURLBody", "getURLData", "getUrlBody", "postURLContents", "getURLContents", "getHTTPData", "postURLData", "postHTTPData", "postHTTPContent", "getUrlData", "postHTTPBody", "postURLBody", "getHTTPBody", "geturlBody", "getUrlContents", "postHTTPContents", "geturlData", "getUrlContent", "getHTTPContents", "geturlContent"], "urlPath": [" urlName", "UrlPo", "UrlP", " urlP", "UrlName", "uriCl", " urlPo", "dllPa", "uriName", "urlPa", "UrlPath", "dllName", "uriPa", "uriPath", "fileName", "dllPath", "dllCl", "filePath", "fileP", "urlName", "filePo", "urlPo", "urlCl", " urlCl", "urlP", " urlPa"], "requestData": ["referenceInfo", "referenceDate", "requestInfo", "questInfo", " requestContent", "requestString", "requestContent", "requestDate", "caseData", "caseDATA", "questData", "RequestData", "RequestContent", " requestDATA", "RequestString", " requestString", " requestInfo", "referenceData", "questContent", "questDate", "requestDATA", "caseString", "referenceContent", "RequestDATA", " requestDate", "caseContent"], "charset": ["chamesec", "chamesets", " chapsabet", " chapset", "contarset", "contarsET", "chersect", "chatset", "chamesET", "chablesets", "chablesET", "chARSat", "charsat", "charsets", "cherset", "chinsabet", "chasET", "Charsat", "charsect", "chatsets", "charsET", " chapsET", "chapset", "chapsET", "contarsets", "charspec", "chameset", "chARSpec", "contablesets", "Charspec", "chapsect", "chinsET", "ChARSET", "chARSET", "ChARSat", "chablesec", "chinspec", " charsET", "chatsET", "chinsat", " charsabet", "chatsec", "charsabet", " charsect", "chableset", " chapsect", "contablesET", "chasat", "chersET", "ChARSpec", "contarsec", "chinsect", "ChARSet", "chinset", "CharsET", "chersabet", "contableset", "charsec", "chapsabet", "chaset", "contablesec", "chaspec", "chARSet", "Charset"], "reader": ["readable", "dr", "ssl", "mr", "stream", "rc", "er", "driver", "lr", "iterator", "io", "handler", "print", "parser", "in", "wrapper", "loader", "writer", "resource", "rl", "runner", "ser", "ro", "comment", "query", "builder", "file", "rr", "Reader", "rx", "rar", "client", "source", "r", "ner", "iter", "inner", "rer", "row", "rd", "read"], "conn": ["ann", "cmd", "org", "fin", "enc", "gen", "cc", "ln", "err", "pkg", "ca", "pg", "obj", "res", "Conn", "nt", "cp", "nn", "ssl", "co", "com", "typ", "jp", "addr", "ctx", "yn", "init", "ch", "proc", "conv", "auth", "conf", "close", "pas", "att", "cb", "cn", "exec", "en", "ls", "bo", "connect", "nc", "reg", "con", "apt", "subject", "c", "j", "msg", "rel", "lang", "cs", "cf", "dial", "Connection", "canon", "net", "ns", "on", "ont", "col", "comm", " con", "connection", "cert", "act", "open", "client", "txt", "cur", "syn", "wn", "coll", "ct", "tp", "cont", "n"], "buffer": ["copy", "output", "header", "binary", "cache", "message", "total", "buf", "string", "print", "sequence", "program", "queue", "database", "block", "commit", "trace", "table", "black", "bar", "response", "bridge", "comment", "report", "document", "file", "connection", "batch", "code", "pool", "reference", "this", "line", "template", "memory", "row", "Buffer", "buff", "printf", "command", "temp", "result"], "out": ["cn", "ot", "output", "OUT", "en", "co", "serv", "cache", "external", "ent", "con", "user", "net", "io", "ne", "print", "sys", "on", "in", "outs", "it", "or", "timeout", "writer", "OU", "by", "ou", "note", "to", "all", "obj", "gc", "res", "file", "aos", "op", "auto", "nt", "cos", "ch", "can", "client", "write", "up", "no", "extra", "oss", "source", "one", "g", "conv", "os", "flush", "t", "o", "end", "Out", "at", "w", "outer", "n"], "url": ["loc", "f", "rel", "el", "sl", "ssl", "gl", "org", "b", "ls", "dl", "arl", "il", "hl", "char", "api", "bel", "lr", "net", "ml", "web", "q", "str", "ll", "loader", "rl", "http", "ul", "nl", "link", "ur", "URL", "base", "name", "open", "mail", "pl", "ol", "lb", "r", "Url", "l", "abs", "log"], "repCode": ["regZone", "regCode", "repCount", "respCount", "repCl", " repDay", "servRate", "RepCl", "RepCode", "respZone", "respCl", "servCode", "RepCount", " repCount", "regCount", "regRate", "respCode", "respRate", "servZone", "repZone", "servCount", "respDay", "repDay", "repRate", " repCl", "RepDay"], "count": ["length", "max", "ount", "core", "num", "const", "port", "match", "cache", "sum", "total", "char", "list", "cc", "cell", "acc", "nb", "c", "size", "add", "report", "cycle", "child", "force", "batch", "nt", "amount", "code", "ch", "ind", "depth", "current", "found", "check", "counter", "call", "number", "len", "find", "conf", "start", "ctr", "ct", "Count", "index", "read", "cont", "n"], "chBuffer": ["ichbuffer", "chbuffer", "chLength", "charBuff", "ChBuffer", " chFrame", "charBegin", " chLength", "achBuffer", "ichQueue", "qBuff", "Chbuffer", "ichBuff", "qBuffer", "charBuffer", "echFrame", "chFrame", "achLength", "echbuffer", " chbuffer", "chBuff", "ChQueue", "echBuffer", "achFrame", "qbuffer", "chBegin", "echLength", "ChBuff", "ChBegin", "achQueue", "qBegin", "achBuff", "ichBuffer", "charbuffer", "chQueue", "achbuffer"], "input": ["image", "progress", "inside", "output", "more", "pattern", "data", "char", "Input", "form", "inf", "q", "in", "raw", "text", "view", "it", "add", "active", "query", "file", "ahead", "ch", "before", "current", "open", "client", "inc", "get", "source", "inner", "ip", "background", "local", "history", "read", "cont"]}}
{"id1": "6966398", "id2": "2642914", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"reader": ["dr", "mr", "stream", "ri", "rc", "rs", "er", "cer", "driver", "lr", "io", "handler", "buffer", "parser", "wrapper", "loader", "writer", "rl", "runner", "ro", "query", "redo", "builder", "file", " read", " readers", "rr", "rar", "Reader", "rx", "this", "older", "ner", "r", "input", "iter", "inner", "rer", "row", "roller", "sr", "rot", "read", "ocr"], "ks": ["k", "fs", "checks", "icks", "ars", "akes", "kies", "sky", "uk", "cs", "bs", "ros", "ls", "ols", "ips", "mk", "kes", "nets", "km", "ys", "ms", "obs", "ss", "ki", "kr", "ds", "ke", "KS", "kk", "ses", "vs", "eps", "ups", "eks", "ates", "keys", "uds", "ces", "sk", "oss", "kb", "cks", "agles", "hs", "qs", "ans", "ck", "kens", "kas"], "key": ["k", "core", "object", "tk", "sky", "KEY", "ssh", "char", "er", "service", "mk", "Key", "cer", "pair", "user", "owner", "my", "entry", "by", "ke", "sign", "link", "ey", "ca", "ek", "x", "obj", "power", "file", "ox", "base", "y", "hash", "client", "keys", "sk", "trust", "null", "type", "root", "password", "info"], "chain": ["Chain", "stream", "binary", "cache", "channel", "data", "pair", "list", "chains", "string", "path", "box", "form", "group", "sequence", "stack", "test", "bank", "block", "c", "sche", "trace", "table", "frame", "sign", "ca", "range", "ver", "piece", "file", "batch", "code", "base", "pool", "family", "hash", "check", "number", "type", "root", "ce", "password", "component", "result", "can"], "os": ["fs", "oos", "css", "osi", "ot", "bs", "cs", "ls", "ose", "us", "io", "ys", "sys", "ms", "obs", "js", "ds", "oses", "oids", "ts", "bos", "aos", "uts", "ox", "cos", "Os", "pos", "is", "oS", "out", "oss", "ops", "oes", "o", "oso", "los", "OS", "ols", "ps", "ios"], "stamper": ["important", "stAmper", " strampler", " stcampler", " stimper", " stumter", "stimpler", " stammer", "println", "New", "stimmer", "stramPER", "stumper", " stcammer", " stramPER", "stamter", "stAmPER", " strammer", "valid", "stAmmer", "annot", "stammer", " stimter", " stampler", "The", " stumpler", "stimPER", "stimper", "Print", "stramper", "stumpler", "stAmpler", "read", "_", "stummer", " stcamper", " stamter", "strampler", "strammer", " stumper", " stcamter", "this", "good", "def", "stampler", "stamPER", " stamPER", " stramper", "stumter", " stimpler", "font", " stimmer", " stummer"], "appearance": ["appreciation", "patternearance", "Applies", " appearances", "ascears", "accearances", " appeared", "displayeared", "displayreciation", "patternearances", "apears", "suppeared", "Appeared", "atteared", "appearances", "acreciation", "attearances", "apreciation", "acearances", " appearing", "displaylies", "accearance", "displayearances", "Appearances", "ascearing", "displayendix", "patternendix", "displayearing", "appears", "Appearance", "apearing", "applies", "apearances", "patternearing", "displayears", "attlies", "aceared", "aplies", "acearance", "appeared", "acclies", "appearing", "suppearances", "ascearance", " appendix", "apearance", "ascearances", "suppearance", "attearance", "apeared", "appendix", "accears", "displayearance"]}}
{"id1": "15799935", "id2": "6379126", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveExtachmentPart", "saveAttachedPart", "saveAttachablebody", "saveAttachableFile", "saveAttachablePart", "saveAttachmentFile", "saveAttentionBody", "saveAttachmentPart", "saveExtachmentbody", "saveAttachedbody", "saveAttachableBody", "saveExtachedbody", "saveAttachmentbody", "saveAttentionPart", "saveAttachedBody", "saveAttentionFile", "saveExtachmentBody", "saveAttentionbody", "saveExtachmentFile", "saveExtachedPart", "saveExtachedFile", "saveExtachedBody"], "context": ["host", "translation", "container", "search", "comments", "present", "cf", "cache", "message", "support", "instance", "service", "cc", "content", "environment", "chain", "stack", "state", "ctx", "subject", "network", "application", "request", "view", "frame", "response", "connection", "document", "course", "parent", "java", "system", "current", "client", "template", "config", "foundation", "null", "center", "version", "tx", "background", "ce", "media", "contact", "command", "component", "history", "Context"], "part": ["host", "top", "reply", "PART", "patch", "p", "work", "zone", "data", "task", "message", "instance", "pair", "thread", "partial", "art", "block", "join", "post", "add", "trans", "Part", "session", "piece", "report", "connection", "file", "component", "body", "tmp", "parent", "base", "sp", "name", "word", "se", "parts", "start", "type", "version", "tx", "bound", "sample", "pod", "and", "job", "temp"], "localAttachment": [" localAttail", "localAssail", "localDetachment", " localDetachment", "localDetignment", " localAttached", "localAssached", "localAppachment", "localAssment", " localAttignment", "localAttachached", "localDetail", "localAttachail", "localAppention", " localAttment", "localAttment", "localAttached", "localATTention", " localAttachignment", " localAttachention", "localAppached", "localAttail", " localAssached", " localDetignment", "localAcached", "localAcignment", "localAttention", "localattention", "localAttachignment", "localattachment", "localAssignment", "localAssention", "localAssachment", " localAttention", " localDetached", "localDetached", "localAppail", "localAcachment", "localAttignment", " localAssention", "localATTignment", "localATTment", "localATTachment", "localAttachachment", "localAttachention", " localAttachached", " localAssail", "localDetention", "localattached", " localDetail", " localAttachachment", " localAssachment", "localAcail"], "accountId": ["accountName", "accS", "objectById", "amountId", "containerID", "objectName", "amountDb", "accountDb", "containerId", "accID", "bankId", "accNum", "containerNum", "accountAnd", " accountInt", " accountNum", "AccountName", "objectId", " accountDb", "containerInt", "accId", "accountS", "accAnd", "accDb", "amountInt", "accountInt", "AccountId", "AccountById", " accountAnd", "bankAnd", "accountNum", "AccountID", "amountID", "accountID", "bankID", " accountID", "bankS", "objectID", "accountById", " accountById", " accountS", "accInt", " accountName"], "attachmentId": ["contachmentId", "attacheId", "attociationid", "Attociationid", "attignmentid", "AttachmentId", "attachedById", "attmentID", "attachedSerial", "AttachmentById", "attignmentId", "attignmentID", "assignmentById", "attachmentById", "attacheid", "attionById", "attionid", "contachedId", "contachmentSerial", "assachmentid", "attionSerial", "contachedSerial", "attachmentid", "attmentid", "attociationById", "contachmentById", "attachmentID", "attachedid", "assachmentById", "assignmentID", "contachedid", "attachedID", "attacheID", "attociationId", "attignmentById", "attacheById", "assachmentId", "AttociationId", "attachedId", "AttociationById", "assachmentID", "AttachmentID", "AttociationID", "attmentById", "attociationSerial", "attociationID", "attachmentSerial", "attionId", "contachedById", "Attachmentid", "contachmentid", "assignmentid", "attmentId", "assignmentId"], "in": ["ins", "din", "inside", "en", "id", "p", "ex", "sum", "IN", "inn", "con", "ai", "inf", "cin", "gin", "m", "on", "bin", "mm", "from", "raw", "it", "vin", "all", "init", "as", "file", "mc", "al", "body", "act", "ch", "per", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "iter", "conf", "l", "isin", "info", "read", "In"], "saveIn": ["storeIn", "getIN", "savAs", "saveIN", "savePath", "storeIN", "secureIN", "sendIN", "aveIN", "secureIns", " saveIns", "aveIn", "aveOut", "sendOut", " saveOut", " saveIN", "savIN", "saveIns", "sendPath", " savePath", "getIns", "sendIn", "secureAs", "saveOut", "storePath", "getOut", "getIn", "secureIn", "savIn", "savIns", "storeOut", "aveIns"], "saveAs": [" saveBy", "submitAS", " saveAS", "aveIn", "SaveAs", "aveAs", "submitBy", " saveTo", " saveAn", "aveAS", "aveas", "submitAs", "dumpAn", "aveAn", "Saveas", "saveAS", "submitIn", "dumpTo", "saveas", "dumpAs", "aveTo", "saveTo", "SaveIn", "SaveAS", "submitas", "saveAn", "saveBy", "SaveBy"], "out": ["cn", "copy", "output", "OUT", "co", "v", "serv", "ex", "sum", "ent", "con", "net", "io", "sys", "outs", "it", "OU", "ou", "inv", "to", "all", "obj", "gc", "res", "auto", "aos", "cos", "name", "can", "up", "oss", "i", "one", "inner", "ao", "os", "null", "conv", "o", "t", "log", "Out", "outer", "n"], "copySize": ["copyPercent", "CopyPercent", " copyCount", "likeFontSize", "copyCount", "likeLength", "msgLength", "pushLength", "opySIZE", "msgPercent", "CopyCount", "opySize", "pushSize", "copyLength", "CopySize", "pushFontSize", "CopyLength", "msgSIZE", "CopyFontSize", "copyFontSize", "opyPercent", "likeCount", "likeSize", "msgSize", " copyFontSize", "copySIZE", "opyLength", "CopySIZE", " copyLength", "pushCount"], "contentUriString": ["contentUrisstring", "contentIriString", "contentUuriNumber", "contentUristring", "contentUistring", "contentUniStr", "contentUnuriNumber", "contentUnistring", "contentUriNumber", "contentUnriString", "contentUiStr", "contentIistring", "contentUnriStr", "contentUiString", "contentUriStr", "contentUicStr", "contentUniNumber", "contentUicStatic", "contentUicString", "contentUrisString", "contentUuriStr", "contentUuriStatic", "contentUniString", "contentUrisStr", "contentIiString", "contentUnriNumber", "contentIristring", "contentUiStatic", "contentUuristring", "contentIiStr", "contentIiStatic", "contentUrisNumber", "contentUnuriString", "contentIriStr", "contentIriStatic", "contentUnristring", "contentUicstring", "contentUnuristring", "contentUuriString", "contentUriStatic", "contentUnuriStr"], "mSize": ["lLength", "mPos", "lSize", "mBytes", "moPos", "nSize", "mLength", "moBytes", "moLength", "moSize", "nLength", "lPos", "nBytes", "lBytes", "nPos"], "mContentUri": ["mResourceUri", "mContent_ris", "mContentIuid", "mContent_uid", "mContentUris", "mResourceUuid", "mContent_ri", "mResourceURI", "mContentIri", "mContentUuid", "mContentIRI", "mResourceUris", "mContentURI", "mContentPRI", "mResourceIRI", "mResourceIri", "mResourceIris", "mContentPri", "mContentIris", "mContentPuid", "mResourceIuid", "mContent_RI", "mContentPris"], "cv": ["cn", "const", "av", "vv", "cf", "v", "cu", "rc", "ov", "cont", "tc", "nc", "buf", "ev", "cc", "vr", "csv", "box", "um", "c", "vp", "cod", "qv", "vol", "nv", "sv", "dc", "cap", "GV", "gc", "act", "vc", "uv", "cp", "qu", "cas", "cmp", "mult", "vm", "ctrl", "conv", "CV", "desc", "vt", "ct", "xc", "cm", "lv", "cb", "lc", "fc", "pb"], "uri": ["folder", "u", "uid", "ri", "id", "du", "doi", " Uri", "bid", "origin", "q", "picture", "uni", "URI", "subject", "term", "resource", "link", "report", "ur", "prefix", " URI", "range", "query", "dir", "uu", "address", "phi", "directory", "iri", "unit", "ui", "ue", "i", " ni", "ip", "url", "qi", "component", "result", "handle"]}}
{"id1": "2465747", "id2": "414258", "code1": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"postRequest": ["processQuery", "PostQuery", "processRequest", " postrequest", " postCommand", "PostRequest", " postQuery", "PostCommand", "postCommand", "processCommand", "Postrequest", "processrequest", "postQuery", "postrequest"], "urlString": ["uriStr", "lSource", "lString", "UrlName", " urlRaw", "uriSource", "sslSeries", "sslStr", "urlRaw", "uriName", "sslRaw", " urlStr", "UrlSource", "urlSeries", " urlSeries", "lStr", "lRaw", "urlSource", "uriString", "UrlStr", "lSeries", "urlStr", "urlName", "lName", "UrlString", "sslString"], "data": ["DATA", "update", "record", "value", "store", "p", "ata", "cache", "dat", "message", "format", "description", "dict", "properties", "content", "user", "times", "form", "state", "text", "images", "resource", "post", "table", "response", "map", "to", "metadata", "session", "missing", "batch", "params", "none", "settings", "hash", "name", "def", "extra", "resources", "details", "meta", "done", "results", "json", "default", "filter", "d", "info", "action"], "returnData": ["saveData", "returnString", " returnQuery", "returnLine", "commentLine", "fullLine", "fullData", "saveQuery", "saveDATA", "commentDATA", "ReturnData", "returnQuery", "fullDat", "reportDat", " returnDATA", "getString", "resultData", "returnDat", "returnDATA", " returnString", "getData", "ReturnString", " returnText", "ReturnText", "getDATA", "ReturnQuery", "ReturnDATA", "commentDat", "resultString", "resultText", "getText", "reportDATA", "returnText", "fullDATA", "reportLine", "resultLine", "reportData", "ReturnLine", "commentData", " returnLine", "saveText"], "url": ["f", "u", "sl", "ssl", "gl", "org", "b", "https", "location", "ls", "dl", "bel", "google", "str", "ll", "conn", "loader", "http", "re", "ul", "nl", "link", "ur", "URL", "build", "base", "address", "open", "client", "call", "mail", "mount", "get", "r", "uri", "Url", "l", "log", "job"], "connection": ["container", "online", "established", "position", "general", "https", "channel", "Connection", "connect", "nc", "relation", "communication", "service", "description", "message", "con", "city", "pointer", "io", "database", "subject", "network", "conn", "entry", "application", "wrapper", "c", "resource", "response", "link", "socket", "to", "creator", "session", "document", "function", "cert", "operation", "connected", "directory", "open", "ion", "client", "no", "number", "character", "uri", "statement", "cone", "manager", "l", "condition", "creation", "using", "use", "command", "n"], "out": ["output", "OUT", "co", "b", "v", "p", "ex", "screen", "list", "con", "user", "net", "io", "print", "buffer", "conn", "outs", "writer", "OU", "ou", "pretty", "to", "all", "obj", "console", "auto", "aos", "ch", "ion", "client", "write", "up", "can", "i", "r", "inner", "g", "os", "null", "l", "conv", "flush", "o", "t", "log", "cm", "Out", "at", "w", "outer", "n"], "keySet": ["numList", "keysName", " keyName", "KeyMap", "rowSpec", "verList", "keysSet", " keyset", "rowSet", "verMap", "numSet", "keyList", "KEYList", "keysList", "keySpec", "KEYSpec", "verSet", "KEYMap", " keySpec", "keyset", " keyMap", "keyMap", "Keyset", "KEYSet", "numName", " keyList", "keyName", "KeyName", "KeySet", "KeyList", "verset", "KEYName", "numset", "keysMap", "rowList"], "values": ["fs", "verts", "views", "Values", "rows", "terms", "pins", "value", "bs", "ves", "sets", "maps", "bes", "events", "vals", "fields", "items", "properties", "types", "times", "windows", "gets", "files", "actions", "obs", "flows", "strings", "issues", "options", "users", "codes", "lists", "forms", "vs", "params", "settings", "changes", "objects", "services", "members", "modules", "keys", "UES", "points", "pes", "als", "results", "ports", "versions", "its", "names", "groups", "rules", "roots", "blocks", "tags", "tests"], "count": ["ount", "num", "cmd", "id", "currency", "empty", "repeat", "state", "first", "err", "add", "code", "nt", "consider", "counter", "check", "title", "length", "cloud", "table", "size", "child", "batch", "name", "ind", "current", "mount", "call", "loop", "number", "unique", "find", "account", "conf", "cd", "const", "frequency", "sum", "con", "group", "test", "valid", "continue", "c", "hold", "all", "base", "amount", "found", "create", "make", "contact", "now", "index", "handle", "ask", "country", "flag", "total", "\u00e7", "list", "sequence", "cell", "month", "cycle", "force", "OUNT", "client", "last", "ctr", "coll", "ct", "Count", "next", "and", "cont", "n"], "in": ["mi", "ins", "din", "inside", "en", "ini", "IN", "inn", "form", "inf", "io", "cin", "gin", "buffer", "on", "bin", "from", "raw", "ic", "it", "or", "re", "and", "mn", "ma", "al", "body", "reader", "ind", "is", "inc", "check", "rin", "i", "input", "source", "r", "inner", "conf", "l", "isin", " din", "read", "In", "pi"], "inputLine": ["outputLINE", " inputSet", "evalData", "outputline", "viewData", "contextLINE", " inputRow", " inputline", "textFile", "textLine", "contextline", "evalFile", "viewRow", "inputData", "evalLine", "outputRow", "contextLine", "textData", "inputRow", " inputData", "outputLine", "InputData", "inputLINE", "InputLine", "Inputline", " inputFile", "InputRow", "contextRow", "viewline", "viewLine", "inputline", "inputSet", " inputLINE", "evalSet", "textSet", "inputFile"]}}
{"id1": "5414088", "id2": "21999120", "code1": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 0, "substitutes": {"saveFileData": ["storeAssetData", "saveAssetdata", "saveAssetData", "storeAssetdata", "savefileResource", "saveStreamdata", "storeFileContent", "saveStreamContent", "saveAssetResource", "storeFileData", "storeFiledata", "saveFileContent", "saveStreamResource", "saveAssetContent", "storeFileResource", "savefileData", "storeAssetContent", "saveFiledata", "savefileContent", "saveFileResource", "savefiledata", "saveStreamData", "storeAssetResource"], "file": ["image", "f", "object", "entity", "field", "node", "style", "id", "port", "work", "job", "model", "cache", "class", "language", "data", "task", "message", "feature", "format", "issue", "disk", "path", "e", "io", "form", "print", "foo", "picture", "block", "rule", "entry", "error", "File", "resource", "http", "table", "FILE", "link", "page", "report", "attribute", "comment", "key", "document", "run", "base", "parent", "address", "change", "name", "mail", "ile", "get", "source", "input", "filename", "create", "place", "db", "policy", "null", "type", "url", "play", "info", "local", "module", "handle"], "destination": ["destinator", "domacement", "declination", "targetination", " destinator", "Destification", "transino", "combination", "transinator", "destino", "Destination", "transination", "destining", "Destinated", "Destinations", "declinate", "Destinator", "Destino", "destinate", "combino", "transinated", "coordification", "dominator", "dominate", "Destining", "declinator", "coordination", "domination", "domining", "coordinator", "combinator", "combinated", "destification", "destinations", "declacement", " destinations", "destacement", "targetinate", "Destacement", "coordinations", "targetinator", "targetining", " destification", "destinated", "Destinate"], "newDataFile": ["uniqueDatafile", "newImageStream", "newdataFiles", " newVersionTable", "uniqueDataFILE", "uniqueDataChannel", "newVersionNode", "newImagefile", "newDatafile", "uniqueDataFile", "newContentFILE", "newVersionFILE", "newDataChannel", "newVersionChannel", "newDataNode", "newVersionfile", "newContentFile", "newImageTable", " newDataTable", "uniqueContentFILE", "newDateTable", "newsImageTable", "newImageFiles", "newVersionFiles", " newVersionNode", " newVersionFiles", "newDATAFile", "newsDataTable", "newDatefile", "newVersionTable", "newContentChannel", "newDATAFILE", "newDATAChannel", "newImageNode", "newDataStream", " newDataFiles", "newDataFiles", "newdataFile", "newImageFile", "newDATAfile", "newsImageStream", "uniqueContentfile", "newdataNode", " newDataNode", "newsImageFile", "newDateFile", "newContentfile", "newsDatafile", "newsDataFile", "uniqueContentFile", "newVersionStream", "newDataFILE", "newdataTable", "uniqueContentChannel", "newsDataStream", "newDateStream", "newDataTable", "newsImagefile"], "fileName": ["imageSource", "applicationName", "imageOrder", "linkType", "imageName", "FILENAME", "fileAgent", "wordAgent", "FileType", "wordSource", "imageAgent", "linkname", "Filename", "FileNAME", "fileSource", "FILEType", "fileNAME", "fileOrder", "wordName", "applicationSource", "FILEName", "filename", "wordOrder", "linkNAME", "FileName", "fileType", "FILEname", "applicationOrder", "linkName", "applicationAgent"], "assetsPath": ["filespath", " assetsRoot", "assetsTh", "scriptsDir", "assetsRoot", " assetsTh", "packagesDir", "filesRoot", "packagesRoot", "filesPath", "assetspath", "scriptsRoot", " assetsDir", "packagesTh", " assetspath", "filesTh", "scriptsPath", "packagesPath", "filesDir", "scriptspath", "assetsDir"], "workingFile": [" workingSet", "WorkingPath", "startingSet", "movingFile", "workingFolder", "runningfile", "workingfile", "workingSourceFile", " workingLine", "WorkingSourceFile", "workFiles", "WorkingSet", "workingPage", "WorkingModel", "workingModel", "workingUnit", "workStore", "workingFILE", "workingStore", "WorkingFILE", "WorkingPage", " workingModel", "workingSet", "WorkingStore", " workingUnit", "runningLine", "workingFiles", "writingfile", "workFolder", "runningFile", "workfile", " workingPage", "playingfile", "WorkingFolder", "movingFolder", "writingFile", " workingSourceFile", "workPage", "writingLine", "startingfile", " workingPath", " workingfile", "movingPage", "workLine", "playingModel", " workingFiles", "startingFile", "playingUnit", "workSourceFile", "runningFILE", " workingStore", "WorkingLine", "workFile", "WorkingUnit", "WorkingFiles", "workingPath", "startingPage", "writingFILE", "workPath", "WorkingFile", "Workingfile", "workingLine", "movingfile", "playingFile"], "vc": ["WC", "rt", "vv", "cf", "cu", "v", "rc", "cs", "ht", "cache", "ec", "tc", "nc", "vd", "cc", "vr", "cin", "ic", "c", "vp", "etc", "nv", "sv", "dc", "cv", "mc", "bt", "lp", "hw", "vm", "bc", "conv", "vt", "CV", "VC", "xc", "cm", "lv", "lc", "fc"], "is": ["isa", "isl", "sis", "ins", "are", "ri", "iss", "lis", "ris", "ir", "ls", "ib", "isi", "nis", "ii", "gets", "ys", "sys", "ms", "iso", "has", "in", "ic", "bis", "IS", "iris", "Is", "isc", "isd", "does", "i", "still", "isf", "os", "abs", "\u00eds", "its", "isin", "im", "ios"], "channelFrom": ["entityFrom", "pixelfrom", "entityTo", "pixelTo", "pixelBefore", "channelIn", "entityOf", "categoryIn", "buttonTo", "Channelfrom", " channelFor", " channelfrom", "channelBefore", "buttonFrom", "memberFrom", "memberOf", " channelIn", "ChannelBy", "ChannelFor", "channelfrom", "memberBefore", " channelOf", "channelOf", "ChannelTo", "categoryTo", "memberFor", "ChannelFrom", "entityBefore", "buttonfrom", "memberTo", " channelBy", " channelBefore", "categoryBy", "buttonBefore", "pixelFrom", "ChannelIn", "channelBy", "channelFor", "memberfrom", "categoryFrom"], "newVersionFile": ["nextVersionFile", "newVERSIONImage", "nextVersionTable", "newVERSIONFile", "newVERSIONTable", "newVClass", "nextversionImage", "newVersionsClass", "nextversionFile", "newversionImage", "nextversionFiles", "newServerFiles", "newVersionClass", "newVersionfile", "newversionFile", "newVersionFiles", "newServerTable", "newVersionTable", "newVersionsfile", "newServerImage", "oldVersionfile", "nextVersionFiles", "newServerFile", "newVersionImage", "nextVersionImage", "oldVersionClass", "nextversionTable", "oldVersionFile", "newVersionsFile", "newVFile", "newversionTable", "newversionFiles", "newVfile", "newVERSIONFiles"], "channelTo": [" channelTO", "Channelto", "memberTO", "clientFrom", " channelto", "connectionTo", "consoleTarget", "channelTO", "consoleTo", "commandTo", "connectionFrom", "channelTarget", "clientto", "memberto", "commandFrom", "ChannelTarget", "clientTO", "memberFrom", " channelTarget", "clientTo", "channelto", "ChannelTo", "commandTO", "ChannelFrom", "connectionto", "memberTo", "consoleto", "ChannelTO", "consoleTO", "connectionTO", "commandto"], "writeCurrentChannel": ["writecurrentButton", " writecurrentButton", "writeRecentCategory", "writeRecentchannel", " writeCurrentlyConnection", "writeURRENTButton", "readcurrentchannel", "writeCurrentlyChan", "writecurrentRoom", "writecurrentChannel", "writeCurrentPassword", "writeByConnection", " writeCurrentHandler", "writeCurrentChan", " writeCurrentlyChan", " writecurrentChannel", "writeCurrentlyButton", "writeURRENTConnection", " writeCurrentPassword", "writeURRENTHandler", "writecurrentCategory", " writeCurrentButton", "writeRecentButton", "readCurrentChannel", " writeCurrentlyChannel", "writeCurrentHandler", " writeCurrentSlot", "writecurrentSlot", "writeCurrentButton", " writecurrentConnection", "writeNowConnection", "writeURRENTCategory", "writeNowSlot", "writeByChan", "writeNowChannel", "writecurrentPassword", "writeRecentSlot", " writeCurrentchannel", "writecurrentConnection", "writeByChannel", " writeCurrentCategory", "writecurrentchannel", "writecurrentChan", " writeCurrentConnection", "writeBychannel", " writeCurrentChan", "writeCurrentlychannel", "readCurrentButton", "writeCurrentlyRoom", "writeCurrentConnection", "writeRecentChannel", " writecurrentHandler", "readCurrentRoom", "writeCurrentSlot", "writeURRENTchannel", "writeRecentRoom", "readcurrentChannel", " writecurrentSlot", " writecurrentPassword", "writeCurrentCategory", "writeCurrentlyConnection", "writeRecentPassword", "writeRecentConnection", " writecurrentCategory", "readcurrentButton", "readcurrentRoom", "writeNowchannel", " writeCurrentlychannel", "writecurrentHandler", "writeURRENTPassword", " writecurrentchannel", "writeCurrentlyHandler", "readCurrentchannel", "writeCurrentchannel", "writeURRENTChannel", "writeCurrentlyChannel", "writeCurrentRoom"], "fromChannel": ["formByte", "fromConnection", "toChan", "toCh", "fromCan", "fromByte", "innerButton", "boundChannel", "withByte", "fromCh", "toConnection", " fromConnection", "withchannel", " fromCan", "FromConnection", "boundCh", "FromChannel", "fromchannel", " fromButton", "innerCan", "toChannel", " fromChan", "FromChan", "formChannel", "fromButton", "withChan", " fromByte", "boundchannel", "FromCh", "FromCan", "formChan", "withChannel", "boundChan", "innerChannel", "innerConnection", "Fromchannel", "formchannel", "fromChan", " fromchannel", "tochannel", "FromButton"], "img": ["image", "ami", "big", "iam", "uf", "data", "gif", "buf", "io", "um", "imag", "picture", "src", "m", "gm", "it", "images", "shr", "anim", "jpg", "medium", "bg", "pg", "obj", "aug", "pic", "Image", "mp", "tmp", "im", "md", "mb", "fig", "png", "imgur", "ext", "pixel", "info", "html", "gd", "lib"], "height": ["length", "max", "rows", "acity", "density", "ty", "style", "ows", "angle", "hang", "alpha", "ure", "capacity", "window", "gravity", "grow", "Height", "resolution", "huge", "icity", "view", "rank", "volume", "size", "bottom", "stroke", "medium", "heads", "build", "hash", "depth", "def", "kw", "h", "png", "gh", "html", "gy", "w", "history", "itude"], "width": ["length", "max", "top", "port", "position", "message", "Width", "format", "description", "window", "area", "margin", "blue", "crop", "resolution", "duration", "idth", "weight", "term", "wid", "size", "frame", "span", "page", "render", "x", "layout", "console", "left", "widget", "body", "amount", "only", "west", "lat", "depth", "write", "radius", "title", "rail", "version", "padding", "w", "min"], "folderPath": ["browserName", "FolderDir", "foldDir", "folderName", "browserPath", "Folderpath", " folderName", "FolderName", "browserUrl", "foldName", "foldPath", "FolderUrl", " folderpath", "folderDir", "browserpath", "folderpath", " folderDir", "foldpath", " folderUrl", "folderUrl", "FolderPath"], "directory": [" residing", "folder", "context", "container", " Directory", " future", "archive", " database", "Director", " temporary", "Folder", "path", " director", "buffer", "database", "ory", "tree", "application", "secondary", " repository", " rectangle", "volume", " located", "collection", "dir", "document", "connection", " manager", " directly", " document", "library", " previous", "parent", "reference", " library", " directories", " dictionary", "ORY", "filename", "Directory", "manager", "direct", "division", "root", "module"], "files": ["assets", "fs", " Files", "values", "classes", "data", "fields", "items", "types", "links", "Files", "images", "users", "thumbnails", "workers", "objects", "members", "modules", "keys", "resources", "results", "children", "uploads", "versions", "names", "iles", "photos"]}}
{"id1": "19520541", "id2": "18631594", "code1": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 0, "substitutes": {"getDirectoryListing": ["getDirectorylistging", "getDirectorylistning", "getFileListning", "getDirectoryProcessing", "getDirectoryListList", "getDirectorylistings", "getDirectoryLing", "getFileListING", "getFilelistList", "getDirectorylisting", "getDirectorylistList", "getFilelistging", "getDirectoryListING", "getDirectoryProcessning", "getFileListings", "getDirectoryListning", "getFileListging", "getDirectorylistING", "getFilelistning", "getFileListing", "getDirectoryListings", "getFileListList", "getDirectoryLging", "getDirectoryProcessList", "getFilelistING", "getDirectoryLings", "getDirectoryListging", "getDirectoryProcessING", "getFilelisting", "getDirectoryLning", "getFilelistings"], "url": ["loc", "host", "f", "rel", "el", "u", "sl", "ssl", "server", "domain", "gl", "b", "id", "https", "github", "location", "ls", "dl", "il", "hl", "bel", "back", "string", "kl", "path", "web", "ref", "ml", "print", "addr", "q", "un", "str", "err", "ll", "xml", "ret", "request", "it", "http", "rl", "ul", "nl", "link", "all", "ur", "key", "sql", "URL", "cert", "build", "base", "address", "name", "this", "call", "mail", "mount", "ob", "pl", "get", "r", "uri", "Url", "l", "cl", "null", "fl", "log", "util", "html", "job"], "CancelledOperationException": ["CancelledRuntime ", "CancelledRequestError", "CancelledAction ", "CanceuledRequestException", "CancelledOperationError", "CancelledRuntimeError", "CancelledOperationWarning", "CanceuledOperation ", "CanceuledRequestError", "CanceuledOperationWarning", "CancelledRequestException", "CancelledRequestWarning", "CancelledActionError", "CanceuledRequest ", "CanceuledRequestWarning", "CanceuledOperationError", "CancelledRuntimeWarning", "CancelledActionException", "CancelledRequest ", "CancelledOperation ", "CanceuledOperationException", "CancelledRuntimeException", "CancelledActionWarning"], "file": ["f", "image", "folder", "length", "id", "class", "data", "task", "message", "format", "string", "path", "web", "print", "buffer", "File", "resource", "part", "table", "size", "FILE", "page", "comment", "dir", "key", "body", "base", "address", "name", "family", "fp", "ile", "template", "source", "title", "full", "uri", "filename", "db", "null", "use", "info", "local", "module", "project", "handle"], "userInfo": ["usersINFO", "usernameStatus", "verData", "authorInf", " userInf", "userINFO", "Userinfo", "USERInfo", "usersInfo", "UserData", "usernameInfo", "authorData", "usersData", "USERINFO", "userData", "userinfo", "userStatus", " userStatus", "verInfo", "usernameINFO", "USERStatus", "verINFO", "usersInf", " userINFO", "userInf", "UserInf", "UserINFO", "authorInfo", "authorinfo", " userData", " userinfo", "UserInfo", "verInf"], "urlConnection": ["implLine", "userConnector", "implconnection", "cmdConnection", "dbLine", " urlConnect", "xmlConnect", "jsonConnection", "urlConn", "dbConnector", "implConnection", "xmlConnection", "fileConnector", " urlAction", "userConnection", "cmdConnect", "urlCurrent", " urlconnection", "httpConnect", "httpAction", "httpCurrent", "cmdConn", "dbConnection", "urlLine", "urlConnector", "fileConfiguration", "cmdConnector", "urlconnection", "httpConn", "userConfiguration", "jsonconnection", "urlAction", "fileConnection", "fileCurrent", " urlLine", "httpconnection", "jsonAction", "xmlCurrent", "httpConfiguration", "fileConn", "implConnector", "xmlconnection", " urlCurrent", "dbconnection", "httpConnection", "urlConnect", "userCurrent", "urlConfiguration", "jsonConnect", "fileConnect", "httpConnector", " urlConnector"], "encode": ["enode", " enpack", "enableify", "enify", "EnCode", "enize", "encCode", "enablecode", "enCode", "encpack", "encize", "enableode", " enode", "enpack", " enCode", " enify", "enccode", "Encode", "Enode", "enableize", "encify", " enize", "Enpack"], "urlStream": ["fileWindow", "httpStream", "xmlSteam", "xmlstream", "xmlStream", "UrlSteam", "httpStreamer", " urlWindow", "logSteam", "inputStreamer", "urlSteam", " urlSteam", "UrlStream", "fileStream", " urlStreamer", "inputstream", "inputSteam", "httpSteam", "rowConnection", "inputStream", "logstream", "fileSteam", "urlstream", "fileConnection", "Urlstream", "UrlStreamer", "httpstream", "logStreamer", "urlStreamer", " urlstream", "logStream", "xmlStreamer", "rowStream", "rowSteam", "rowWindow", "urlWindow"]}}
{"id1": "18374598", "id2": "2398448", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"download": ["update", " downloaded", "poll", "dial", "GET", "data", " Download", "connect", "pull", "delete", "loader", "load", "link", "Download", "upload", "install", " downloads", "file", "open", "check", "get", "create", "submit", "filename", "url", "save", "sample", "read"], "a": ["ia", "eta", "el", "u", "aa", "go", "b", "v", "ata", "apa", "alpha", "data", "ga", "area", "ae", "s", "ai", "path", "an", "any", "ac", "from", "au", "ar", "c", "ab", "part", "array", "sta", "ca", "va", "all", "attribute", "aaa", "as", "la", "ma", "aos", "al", "base", "address", "era", "arg", "name", "pa", "ap", "h", "ta", "i", "r", "title", "ao", "l", "app", "na", "url", "aw", "t", "o", "html", "att", "d", "at", "oa", "A", "sa", "am"], "p": ["pe", "b", "perm", "par", "jp", "pat", "bp", "pers", " pe", "P", "q", "pre", "pt", "m", "pp", "pkg", "c", "part", "ping", "vp", "j", "pg", "x", "power", "pard", "wp", "op", "pc", "pos", "cp", "pid", "lp", "pa", "pr", "pro", "ap", "h", "pl", "i", "g", "l", "ip", "prop", "rep", "t", "pad", "np", "d", "tp", "ps", "pb", "pi"], "td": ["div", "cot", "ot", "dd", "th", " TD", "dt", "dial", "dl", "nd", "lf", "tc", "dh", "tif", "sd", "od", "pt", "pd", "tf", "ds", "dc", "ts", "md", "ad", "ptr", "df", "tmp", "nt", "pc", "det", "tr", "TD", "cz", "d", "ld", "db", "deb", "cd", "tap", "bd", "ct", "t", "fd", "hd", " sd", "tp", "fc", "pb"], "f": ["fs", "ft", "b", "cf", "v", "fw", "bf", "fin", "uf", "lf", "fm", "alf", "fo", "af", "fe", "e", "form", "ff", "tf", "sf", "c", "fb", "j", "fr", "fx", "fa", "xf", "file", "df", "fn", "fp", "fi", "h", "i", "g", "l", "fl", "t", "o", "fd", "rf", "F", "d", "w", "fc", "func"], "total": ["max", "initial", "eta", "length", "num", "Total", "equal", "count", "scale", "sum", "stable", "net", "le", "complete", "sequence", "sys", "percent", "valid", "buffer", "normal", "table", "active", "otal", "to", "note", "available", "all", "trans", "nt", "base", "none", "current", "open", "ta", "template", "done", "meta", "full", "unique", "len", "number", "last", "start", "t", "info"], "progress": ["length", "update", "distance", "pdf", "portion", "important", "poll", "grade", "scale", "count", "speed", "process", "print", "percent", "complete", "state", "offset", "Progress", "finished", "debug", "scroll", "continue", "status", "resource", "priority", "step", "dist", "bar", "performance", "usage", "payment", "report", "ptr", "address", "depth", "current", "pro", "display", "done", "memory", "age", "success", "summary", "t", "wait", "history", "result"], "in": ["ins", "inside", "din", "en", "ini", "ze", "IN", "inn", "con", "ai", "io", "inf", "cin", "on", "mm", "bin", "from", "ar", "it", "ic", "by", "to", "init", "ind", "is", "inc", "rin", "get", "i", "input", "win", "iter", "inner", "oin", "l", "o", "and", "im", "In"], "out": ["cn", "ins", "output", "OUT", "b", "co", "v", "ex", "cache", "list", "con", "s", "net", "io", "ne", "sys", "on", "err", "conn", "outs", "it", "c", "by", "writer", "OU", "ou", "vol", "to", "obj", "res", "aos", "auto", "nt", "at", "pool", "ch", "pos", "put", "lock", "client", "write", "oss", "g", "os", "l", "null", "o", "t", "end", "log", "Out", "cb", "w", "outer", "can"], "buf": ["arr", "cmd", "bl", "b", "vec", "bed", "uf", "norm", "data", "window", "box", "buffer", "obs", "aka", "bin", "block", "pkg", "bar", "cv", "cap", "orig", "img", "wb", "bag", "seq", "Buff", "batch", "msg", "cp", "br", "ob", "cat", "conv", "db", "tab", "row", "rb", "Buffer", "mu", "buff", "bytes", "next", "cb", "pb"], "n": ["max", "cn", "z", "num", "nn", "en", "b", "v", "norm", "count", "ng", "dn", "nc", "nm", "N", "ln", "ne", "sn", "nw", "an", "ns", "nb", "m", "on", "c", "nor", "nl", "j", "nan", "note", "yn", "x", "nt", "fn", "y", "none", "ren", "nr", "no", "number", "len", "i", "g", "l", "na", "gn", "wn", "t", "o", "names", "np", "d", "w", "min"], "percentage": ["quantance", "percentension", "CENTategy", "scaleage", "centity", "percentility", "quantension", "percentant", "scaleager", "Percentume", "taxension", "quantage", "Percentant", "scaleility", "parility", "propity", "centade", "parager", "CENTage", "scaleAGE", "parage", "percentager", "percentade", "percentile", "Percentity", "parension", "quantility", "Percentile", "oppage", "propade", "centage", "propage", "centile", "Percentategy", "percentance", "oppant", "Percentage", "taxage", "percentume", "percentAGE", "parAGE", "propile", "centAGE", "CENTume", "Percentility", "oppility", "parance", "taxility", "percentategy", "oppade", "centume", "CENTade", "percentity", "taxance", "centategy", "centility", "Percentade", "centager"], "tmpPercentage": ["tmpIntage", "tmpPropage", "tmppercenture", "tmpPercentency", "tmpIntade", "tmpPercentate", "tmppercentate", "tmppercentane", "tmpPropency", "tmppercentade", "tmpPropade", "tmpPercentade", " tmpIntage", " tmpIntency", " tmppercentate", " tmpIntade", "tmpPlusure", "tmpPlusane", "tmpPercentane", "tmpIntance", " tmpPercentane", "tmpPercenture", " tmpPercentency", "tmpMagnages", "tmppercentages", "tmpPlusage", " tmpPercenture", " tmppercentane", "tmpMagnage", " tmpPercentate", " tmppercentages", " tmppercentage", "tmppercentage", " tmpPercentages", " tmpPercentance", " tmppercentade", "tmpMagnate", "tmpPercentages", "tmpPropance", " tmpIntance", "tmpIntency", "tmpPercentance", " tmppercenture", "tmpMagnade", " tmpPercentade", "tmpPlusade"], "size": ["length", "max", "loc", "num", "Size", "position", "scale", "count", "sum", "SIZE", "ose", "ize", "capacity", "ze", "sd", "area", "s", "empty", "e", "loss", "sn", "notice", "space", "set", "sw", "c", "storage", "small", "body", "sp", "code", "name", "see", "used", "len", "g", "needed", "l", "bytes", "now", "send"], "checksum": ["hsul", "hascan", "cksave", "timesave", "hasam", "readsave", "ksum", "checksam", "checkssum", "hsumm", "actionsumm", "ksam", "checksumm", "kscan", "checksave", " checkssum", "actionssum", "hasum", "actionsul", "checksul", "hassum", "readsum", "actionsum", "timessum", " checksumm", "timesum", "ckssum", "hssum", "hsum", "timesul", "cksul", "readsul", "cksam", "readssum", "cksum", "kssum", " checksul", "checkscan", "ckscan"]}}
{"id1": "20751378", "id2": "17161805", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["updateText", "HashText", "Hashpassword", "updatePrivate", " hashPrivate", "HashPrivate", "hashText", " hashText", "updatePassword", " hashpassword", "HashPassword", "hashpassword", "updatepassword", "hashPrivate"], "password": ["column", "value", "encrypted", "Password", "p", " Password", "security", "pattern", "language", "message", "sword", "email", "description", "secret", "string", "token", "user", "device", "print", "phrase", "database", "application", "request", "argument", "login", "command", "prefix", "attribute", "key", "query", "connection", "expression", "comment", "address", "directory", "PASS", "word", "name", "client", "property", "username", "input", "pass", "wd", "auth", "reset", "shadow", "crypt", "default", "padding", "wordpress", "hello", "w"], "hash": ["ash", "object", "rh", "ashing", "token", "has", "method", "reading", "bh", "ah", "report", "oh", "tag", "address", "mass", "check", "h", "username", "title", "alg", "her", "log", "locking", "sh", "value", "search", "cache", "string", "print", "proof", "hing", "zero", "array", "ping", " Hash", "replace", "key", "tr", "put", "number", "version", "shadow", "crypt", "filter", "result", "copy", "here", "other", "class", "sum", "message", "Hash", "user", "test", "str", "response", "build", "shift", "mask", "uh", "index", "handle", "dig", "sha", "ha", "total", "where", "checking", "block", "cloth", " hashing", "alert", "ho", "hex", "height", "trust", "also", "hed", "html", "hello"], "md": ["del", "dr", "dd", "cmd", "mt", "der", "red", "sha", "nd", "dh", "mk", "sd", "od", "ms", "mm", "m", "pm", "man", "pd", "mod", "js", "ds", "and", "add", "dir", "sam", "obj", "mn", "ad", "df", "managed", "mp", "mc", "dm", "det", "mand", "ind", "grad", "ld", "di", "cd", "bd", "hd", "d", "MD", "sm"]}}
{"id1": "6457199", "id2": "16378239", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 1, "substitutes": {"doRequest": ["processResponse", "processQuery", " doResponse", "processRequest", "doQuery", "doResponse", "handleRequest", "handleResponse", " doQuery", "handlerequest", "processrequest", "handleQuery", " dorequest", "dorequest"], "request": ["initial", "context", "Request", "search", "forward", "position", "question", "message", "select", "each", "setup", "user", "complete", "first", "hello", "xml", "application", "view", "re", "http", "frame", "QUEST", "report", "quest", "req", "transform", "query", "document", "address", "reference", "seek", "open", "call", "get", "input", "create", "reset", "command", "project"], "response": ["image", "context", "onse", "reply", "output", "server", "header", "position", "channel", "message", "relation", "format", "service", "content", "e", "print", "xml", "block", "resp", "application", "continue", "view", "status", "http", "re", "frame", "writer", "socket", "page", "report", "render", "document", "res", "connection", "console", "out", "write", "display", "feed", "respons", "respond", "reset", "Response", "json", "fire", "next", "exit", "release", "send", "result"], "path": ["length", "host", "context", "qualified", "core", "physical", "patch", "near", "p", "port", "location", "ex", "pattern", "message", "select", "api", "format", "where", "string", "clean", "partial", "chain", "pointer", "test", "local", "print", "raw", "PATH", "text", "pkg", "error", "trace", "method", "alias", "prefix", "dir", "transform", "key", "base", "relative", "parent", "name", "right", "binding", "mount", "template", "full", "input", "filename", "uri", "parts", "policy", "route", "json", "type", "url", "prop", "Path", "root", "log", "primary", "href", "kind", "index", "ath"], "internal": ["initial", "context", "rel", "original", "inside", "invoke", "regular", "uid", "binary", "id", "intern", " external", "standard", "api", "external", "back", "index", "origin", "normal", "real", "valid", "central", "bin", "in", "entry", "generic", "ret", "ident", "san", "inline", "alias", "orig", "init", "impl", "console", "managed", "relative", "name", "this", "inter", "virtual", "template", "skin", "Internal", "common", "inner", "identified", "url", "primary", "local"], "resource": ["image", "core", "context", "object", "record", "store", "stream", "binary", "model", "channel", "exclusive", "instance", "service", "process", "pointer", "print", "buffer", "resolution", "network", "entry", "region", "re", "socket", "range", "connection", "file", "res", "console", "library", "address", "reference", "controller", "directory", "system", "resources", "source", "create", "uri", "url", "media", "Resource", "remote", "release", "component", "local", "result", "handle"], "mimeType": [" mimesType", " mimesTypes", "maxStyle", "mIMEType", "metyName", "mimeName", "meshType", "mtimeType", "mIMEStyle", "miscTypes", "meshtype", " meshStyle", " meshName", "mtimeStyle", "Metytype", "MetyName", "metytype", " mimeStyle", "mimePolicy", "MetyTypes", " mimePolicy", "miscName", " mimetype", " meshtype", "misctype", "mimeStyle", "mimesType", "maxPolicy", "mimesStyle", "mimeTypes", "MimeTypes", "MimeType", "MetyType", "Mimetype", " mimesPolicy", "MimeName", " mimeName", "meshStyle", " mimeTypes", "maxType", "mtimetype", "meshName", "metyTypes", "mIMETypes", "mimetype", "mtimeName", " mimesStyle", "mIMEtype", "miscType", "mIMEName", "metyType", "mimesPolicy", " meshType", "mimesTypes", "metyPolicy", "maxTypes", "metyStyle"], "is": ["fs", "sis", "isl", "isa", "icks", "ins", "are", "iss", "ri", "rs", "ris", "cs", "ls", "isi", "nis", "s", "si", "gets", "ys", "obs", "iso", "has", "ism", "in", "ic", "ains", "bis", "ics", "as", "IS", "res", "iris", "Is", "mus", "isc", "i", "isf", "es", "ais", "its", "isin", "ios"], "os": ["fs", "oos", "et", "ot", "osi", "bs", "cs", "ros", "ls", "er", "us", "s", "ys", "sys", "ms", "obs", "nos", " Os", "ss", "ds", "oses", "ts", "oz", "des", "as", "bos", "res", "aos", "ox", "Os", "oS", "oss", "OS", "es", "ks", "oes", "o", "los", "css", "ols", "ps", "ios"]}}
{"id1": "19050432", "id2": "9687813", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openNamedStream", "openNestedRes", "opennamingStream", "opennamingRes", "opennamedClass", "opennamingResource", "openNamingResource", "opennamingClass", "openNamingRes", "openNamedRes", "openNestedResource", "opennamedStream", "openNamedClass", "openNumberedClass", "opennamedResource", "opennamedRes", "openNestedClass", "openNumberedRes", "openNumberedResource", "openNumberedStream", "openNamingClass", "openNamingStream", "openNestedStream"], "name": ["initial", "value", "search", "id", "p", "message", "nm", "description", "string", "path", "ref", "str", "Name", "part", "resource", "size", "link", "alias", "NAME", "prefix", "key", "file", "missing", "address", "word", "ame", "template", "full", "title", "filename", "uri", "null", "type", "url", "named", "names", "password", "use", "local", "n"], "in": ["f", "mi", "ins", "din", "isin", "en", "stream", "pin", "serv", "ini", "IN", "inn", "con", "inf", "gin", "cin", "on", "m", "bin", "from", "conn", "tin", "to", "login", " out", "impl", "as", "mc", "body", "ain", "reader", "pid", "ind", "is", "out", "up", "rin", "i", "input", "inner", "oin", "conf", "asin", "o", "vin", " din", "In", "n"], "propsURL": ["PropsUrl", "proPSUR", "PropsCL", "proprurl", "proppsCH", "propertiesUR", "probsurl", "projsUR", "protsurl", "propertiesCH", "projsURL", "ProPSurl", "proprsURL", "protsURL", "ProPSURI", "Propsurl", "PropsSSL", "ProrsUrl", "proprURL", "proprsUR", "protsUrl", "probsURI", "probsURL", "PropsUR", "projsEL", "propsURI", "progsUR", "prorsEL", "ProPSSSL", "prorsCL", "ProPSUrl", "progsEL", "protsNR", "PropsEL", "propertiesURL", "propertiesCL", "propsEL", "propertiesURI", "propsCL", "proPSSSL", "propsNR", "progsUrl", "PropsURI", "proprUrl", "proPSUrl", "propsurl", "proprNR", "propsSSL", "proPSCL", "propertiesUrl", "prorsUrl", "ProPSNR", "ProPSCH", "proppsCL", "prorsURL", "proprsUrl", "progsURI", "ProPSCL", "ProrsUR", "proprsCL", "propertiesurl", "proppsUR", "progsurl", "propertiesSSL", "propsCH", "prorsUR", "protsURI", "ProrsEL", "proPSURL", "progsURL", "propsUR", "PropsCH", "proPSCH", "ProrsURL", "progsCL", "PropsURL", "proppsSSL", "ProPSURL", "proPSURI", "propsUrl", "proPSurl", "proPSNR", "ProPSUR", "PropsNR", "projsUrl", "probsUrl", "proppsURL", "proppsUrl"], "urlConn": [" urlconn", "urlCon", "slCons", " urlConnect", "urlMem", "webConnect", "urlCons", "lsInit", "handleConn", "urlInit", "httpObj", "UrlConn", "handleConnect", "httpCons", "URLConnect", "lsConnect", "UrlConnect", "slMem", "slConn", "fileCons", "URLConnection", "webInit", "urlconn", "URLConn", "handleCon", "UrlConnection", "httpConn", " urlInit", "httpMem", "fileObj", "handleConnection", "urlObj", "fileConn", "slObj", "urlConnection", "urlConnect", "webconn", "webConn", "lsConn", "fileMem", "URLCon", "lsconn", "UrlCon"], "httpURL": ["ttpURL", "httpUrl", "HTTPDB", "healthurl", "httpsUrl", "hoverURL", "HttpUrl", "HTTPUrl", " httpURI", "httpUR", "httpDB", "httpsUR", "healthUR", "ttpurl", "hoverurl", "healthUrl", "ttpDB", " httpUrl", " httpDB", "httpsURL", "Httpurl", "hoverUR", "httpSSL", "httpURI", " httpurl", "healthURL", "hoverUrl", "HttpURL", "HttpSSL", "httpurl", " httpSSL", "ttpSSL", "httpsurl", "HTTPURL", "HTTPURI", "ttpUrl", "ttpURI"], "hdrVal": [" hdrLen", "hdrEl", "hDRVal", "hlrVal", "hstrValue", "ohdrEl", "hlrval", "hheaderEl", "httpVal", " hheaderValue", "hDRval", "HheaderVal", "hdrval", " hdrval", "ohDRValue", "hDREl", "ohdrVal", "hheaderval", "ohDREl", "HheaderVAL", "ohdrValue", "httpEl", "HdrVAL", "httpValue", "HdrValue", "hDRVAL", "hdrLen", "hdrValue", "HdrEl", " hheaderLen", "ohDRVal", "hdrVAL", "hstrEl", "HheaderEl", "HheaderValue", "hDRLen", "hheaderLen", " hheaderval", "hstrVal", "hheaderVAL", " hdrValue", "hheaderValue", "hheaderVal", "hDRValue", "hlrLen", "httpVAL", "hlrValue", " hheaderVal", "HdrVal"], "code": ["length", "ck", "Code", "value", "header", "id", "rc", "country", "currency", "mode", "xxx", "count", "cont", "message", "level", "description", "color", "cc", "content", "string", "city", "xx", "state", "coe", "magic", "zero", "ode", "text", "c", "error", "sec", "cod", "status", "size", "response", "reason", "comment", "key", "codes", "ack", "cycle", "body", "msg", "ch", "coded", "event", "zip", "no", "ace", "cue", "check", "number", "se", "one", "close", "age", "type", "desc", "ct", "url", "ce", "go", "component", "index", "result"]}}
{"id1": "15737836", "id2": "22625683", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["update", "del", "drop", "move", "select", "clean", "touch", "destroy", "database", "set", "insert", "load", "remove", "add", "link", "de", "dump", "execute", "clear", "write", "quit", "lete", "get", "disable", "Delete", "create", "save", "download"], "site": ["server", "store", "domain", "node", "software", "scan", "data", "ze", "service", "localhost", "e", "path", "group", "environment", "test", "sys", "chain", "theme", "set", "network", "rule", "http", "station", "sit", "link", "page", "ite", "session", "item", "file", "course", "isite", "base", "settings", "Site", "name", "unit", "template", "pse", "se", "source", "config", "ste", "sites", "sample", "info", "remote", "at", "index"], "dbo": ["delbo", "ddpo", "delmu", "Dmu", "delpo", "pbo", "gBO", "drabon", "dbon", "delbu", "ddBO", "odbu", "DBo", "lBo", "draBo", "ddBo", "sdBO", "dambo", "dBO", "Dpo", "Dbon", "dpo", "drabo", "lpo", "DBO", "dBo", "ddbo", "sdbo", "Dbu", "odpo", " dpo", "dmu", "drapo", "debugBo", "debugambo", "odBo", "pmu", "Dado", "lambo", "ddbu", " dbu", " dBO", "pbu", "Dbo", "dbu", " dbon", "odbo", "debugbo", " dambo", "lbo", "sdbu", "debugpo", "dado", " dado", " dBo", "gbo", "gbu", "ddado", "ppo"], "connection": ["context", "container", "engine", "output", "server", "office", "operation", "established", "position", "location", "computer", "bo", "Connection", "relation", "connect", "communication", "con", "net", "pointer", "city", "handler", "generation", "chain", "database", "subject", "network", "conn", "application", "closure", "c", "government", "collection", "resource", "writer", "table", "response", "link", "socket", "usage", "creator", "session", "document", "po", "auto", "function", "console", "library", "connected", "intention", "directory", "settings", "reference", "pool", "controller", "current", "ion", "client", "system", "open", "binding", "character", "config", "statement", "cone", "db", "created", "condition", "manager", "associated", " Connection", "management", "command", "information"], "preparedStatement": ["preachedStat", "preppedstatement", "preppedQuery", "preculatedStatement", "preformedGrant", "preppedStat", "premittedStyle", "prepparedSQL", " prefixedQuery", "preachedStatement", "PreppedStatement", "premittedAdapter", "perparedAdapter", "premedStatement", "pparedStat", "preachedCall", " preparedGrant", "previsedStatement", "Preparedstatement", "preculatedQuery", "prepletedGrant", "preformedCall", "PrearedDevice", "PreparedQuery", "prearedStatus", "premittedComment", "preachedComment", "prearedComment", "preppedStatus", "prelatedStatement", "postparedstatement", "preparedListener", "pretparableStatus", "premedListener", "prepletedStatement", "prefixedCall", "preparedStyle", "paredStatement", "preparedComment", "preferredCall", "preinitializedStatement", "prearedDevice", "previsedQuery", " prefixedCopy", "prepferredQuery", "prefixedstatement", "prejectedstatement", "premedStatus", "perachedStyle", "preformedStat", "premittedStatement", "pretparableListener", "preparedStat", "preparableStatus", "Prearedstatement", "preparedSQL", "preparedCopy", "perachedComment", "preparableListener", " preparedStat", "prearedSQL", "PreparedStatement", "postppedStatement", "prearedStatement", "postppedstatement", "preppedCall", "prearedStat", "prepletedCall", "prepparedstatement", " preparedCopy", "prepletedstatement", "prearedCopy", "PrearedStatement", "PrearedComment", "preinitializedStyle", "prearedQuery", "preferredStatement", "preferredSQL", "preparableStatement", "perachedStatement", "preparedGrant", " preachedCall", "perachedAdapter", "preachedGrant", "preinitializedAdapter", "paredStat", "preachedstatement", "prejectedQuery", "preferredQuery", "preparedAdapter", "preinitializedComment", "perparedComment", "preparedQuery", "pretparableStatement", " preachedStatement", "prearedCall", "prefixedCopy", "prearedListener", "prepparedQuery", "prelatedstatement", " preachedStat", "perparedStatement", "paredStatus", "prepparedStatement", "perparedStyle", " preparedQuery", "preferredstatement", "paredQuery", "prefixedStatement", "prepletedComment", " preparedCall", "preparedStatus", "preppedStatement", "prelatedComment", "prelatedDevice", "previsedStatus", "prepferredstatement", "postparedStatement", "preparedCall", "PreparedDevice", "prepferredStatement", "PreppedQuery", "prepferredSQL", " preachedGrant", "preachedAdapter", "preendedstatement", "preachedStyle", "prepletedDevice", "preendedStatement", "preparedstatement", "prejectedCopy", "prearedstatement", "pretparedStatement", "prefixedQuery", "preparedDevice", "pparedStatement", "postparedCall", "prepletedStat", "pretparedStatus", "preendedQuery", "pretparedListener", "prepparedCall", "preformedStatement", "preculatedstatement", "previsedStat", "pparedStatus", " prefixedStatement", " preparedstatement", "postppedCall", "pparedQuery", "Preppedstatement", "preculatedSQL", " prefixedstatement", "prejectedStatement", "PreparedComment"], "resultSet": ["ResultStream", "rowSource", "resultSum", "resultsUn", "rowHandle", "resultsPath", "resultPath", "rowSet", " resultSource", "resultSession", "characterStream", " resultSession", "ResultTime", "resultUn", "ResultSource", "resultsSet", "resultStream", "ResultList", "ResultUn", "dataStream", "resultTime", "rowSession", "characterSet", " resultStream", "ResultPath", " resultSum", " resultTime", "ResultSet", "dataSet", "dataTime", "ResultSum", "resultSource", "resultList", "responseStream", "responseSet", "resultsStream", " resultPath", "ResultSession", "responseUn", "characterSum", "resultHandle", " resultList", " resultHandle", "ResultHandle", "resultsList"], "chkSql": ["chKDql", "chkStrql", "chkDql", "chkDk", "chkRSk", "chKSyl", "chkSyl", "chKSql", "chkSk", "chKInsq", "chkSQL", "chkStrq", "chkInsQL", "chkRSQL", "chkInsql", "chKSq", "chkInsq", "chKSQL", "chkDQL", "chkDq", "chKDyl", "chKInsql", "chkStrQL", "chKInsQL", "chKDk", "chkDyl", "chkRSql", "chkRSyl", "chKSk", "chKDQL", "chkSq"], "selfDefinePath": ["selfDefineDir", "selfDelinePath", "selfDefidePattern", "selfDefinePattern", "selfDelinepath", "selfDefideDir", "selfDefinesDir", "selfdefineDir", "selfDefINEKey", "selfDefiningpath", "selfDefineSet", "selfDefinesPath", "selfDefinedSet", "selfDefINEPath", "selfdefinePattern", "selfDefinedpath", "selfDefinespath", "selfDefiningPath", "selfdefinesPath", "selfDeliningPath", "selfdefinepath", "selfDefinedPath", "selfDeliningKey", "selfDefiningKey", "selfDefinedKey", "selfDefinesPattern", "selfDefiningDir", "selfDefiningSet", "selfdefinespath", "selfDefineKey", "selfDelineKey", "selfDeliningSet", "selfDefINEpath", "selfDefidepath", "selfdefinesDir", "selfdefinePath", "selfdefinesPattern", "selfDefiningPattern", "selfDefidePath", "selfDeliningpath", "selfDefINESet", "selfDelineSet", "selfDefinepath"], "sqlStr": ["qlString", "qlStr", "SQLStr", " sqlstr", "sqSt", " sqlString", "qlName", "SQLWr", "sqlName", " sqlSt", "sqlSt", "sqlString", "SQLstr", "qlstr", "sqStr", "sqstr", "sqlWr", "SQLSt", "sqString", "sqName", " sqlName", "sqlstr", "sqWr", " sqlWr"]}}
{"id1": "8119563", "id2": "3187685", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"checkLink": [" checkLinks", "checkLinks", "processlink", "openlink", "openLinks", "processLink", "openUrl", " checklink", "checkUrl", "openLink", "processLinks", " checkUrl", "checklink", "processUrl"], "url": ["f", "host", "sl", "ssl", "server", "b", "location", "dl", "char", "email", "string", "path", "ref", "print", "str", "ll", "xml", "resource", "http", "rl", "nl", "link", "all", "browser", "ur", "URL", "file", "cert", "build", "base", "address", "name", "uri", "Url", "l", "job", "n"], "connection": ["position", "channel", "Connection", "connect", "nc", "communication", "relation", "description", "service", "message", "city", "pointer", "net", "way", "generation", "database", "network", "conn", "entry", "application", "c", "resource", "response", "link", "category", "session", "function", "operation", "connected", "reference", "directory", "open", "system", "client", "ion", "number", "character", "statement", "condition", "version", "management", "command"]}}
{"id1": "17724879", "id2": "22338097", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"getDigest": [" getDigested", "getdigest", "getDigEST", " getMDse", "getdigEST", "getdigse", " getDigEST", "getHashested", "getMDested", "getDigested", " getMDest", "getMDEST", "getDigse", "getMDse", "getHashest", " getMDEST", "getMDest", "getHashEST", " getDigse", " getMDested", "getdigested", "getHashse"], "attribute": ["qualified", "object", "value", "operator", "Attribute", "position", "data", "message", "relation", "communication", "description", "each", "pair", "attr", "member", "subject", "space", "application", "entry", "definition", "ident", "article", "request", "option", "argument", "a", "add", "metadata", "report", "command", "item", "expression", "document", "management", "al", "missing", "operation", "address", "directory", "reference", "name", "ribute", "word", "event", "element", "property", "input", "character", "policy", "variable", "type", "associated", "password", "att", "and", "at", "information"], "digestAlgorithm": ["digesteralgebra", "digestalgebra", "digesteralgorithm", "digestALgo", "digestPalgorithm", "digestALgorith", "digestsAlgebra", "digesterAlgebra", "digesterAlgorithm", "digestAlgorith", "digestsAlgorithm", "digestalgo", "digestPalgorith", "digestsalgorithm", "digestPalgebra", "digestsalgebra", "digestsAlgo", "digestAlgebra", "digestSchegebra", "digestALgebra", "digestAlgo", "digesterAlgo", "digestALgorithm", "digestSchego", "digestSchegorithm", "digesterAlgorith", "digesteralgorith", "digestsalgo", "digesteralgo", "digestalgorith", "digestPalgo", "digestalgorithm"], "digest": ["digtest", " digested", " digtest", " digist", "mdse", "digist", "Digested", "hashEST", "designest", "equEST", "Digist", "mdested", "mditude", "digested", "DigEST", "digend", "digests", "designEST", "mdtest", "designist", " digEST", "Digend", "digse", " digse", "diagnested", "Digest", "hashend", "equested", "hashest", "Digse", "equend", "mdest", "designests", "Digests", "hashested", "digEST", "diagnest", "digitude", " digitude", "diagnse", "Digtest", "diagnitude", " digests", "equest"], "md": ["pdf", "cmd", "dd", "dr", "mt", "amd", "der", "red", "nd", "mg", "dh", "mk", "sd", "ms", "mm", "m", "pm", "pt", "esm", "pd", "mod", "js", "strong", "ds", "metadata", "mc", "mn", "ma", "df", "managed", "nt", "ud", "dm", "det", "rpm", "ind", "mb", "good", "cond", "met", "mind", "grad", "ld", "rm", "wd", "di", "cd", "mac", "bd", "ct", "fd", "hd", "d", "MD", "sm"]}}
{"id1": "14819747", "id2": "17202158", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "label": 0, "substitutes": {"debug": ["progress", "DEBUG", "dd", "binary", "javascript", "shell", "bug", "mode", "hide", "cache", "show", "data", "ose", "color", " debugging", "google", "develop", "web", "secure", "enable", "print", "test", "valid", "development", "hidden", "mod", "error", " DEBUG", "trace", "step", "enabled", "browser", "comment", "tag", "dump", "related", "dir", "dev", "file", "Debug", "console", "change", " debugger", "depth", "write", "display", "hack", "production", "config", "close", "db", "play", "default", "log", "d", "date", "module", "stats"], "prologFile": ["prolexBody", "proplotFile", "proLogPath", "prologBody", "profileLine", "proplexFilename", "propelFILE", "rologFiles", "prologFilename", "propelFile", "rologfile", "prologDo", "ProLogFilename", "rologFile", "problogFilename", "proplexFile", "probadfile", "problogPlace", "profilePath", "ProLogPlace", "proLogfile", "proLogDo", "proLogPlace", "propelFilename", "prosystemfile", "problogDo", "proconfigFilename", "ProLogFiles", "proconfigPlace", "PrologMessage", "ProLogPath", "proLogFilename", "prozipParser", "prologLine", "prozipFile", "proplexFILE", "prologFiles", "PrologPlace", "proLogFiles", "procellPath", "proconfigFiles", "prologParser", "probadFile", "proplogFile", "proplotFilename", "prolexFile", "ProLogParser", "PrologFiles", "proLogFILE", "PrologPath", "ProLogFILE", "prolexFilename", "profilefile", "problogFile", "ProLogLine", "proplogFilename", "PrologLine", "prosystemMessage", "prologPath", "Prologfile", "prologFILE", "proLogMessage", "rologDo", "problogFiles", "procellLine", "prozipFILE", "proplotBody", "proconfigFile", "proLogFile", "profileFile", "ProLogMessage", "prologfile", "procellFile", "proplotFILE", "probadParser", "PrologParser", "PrologFILE", "propelBody", "prosystemFile", "proplogBody", "prozipfile", "PrologFile", "problogfile", "ProLogFile", "procellfile", "prolexFILE", "PrologFilename", "prologMessage", "probadFILE", "proplogFILE", "ProLogfile", "proplexBody", "prologPlace", "prosystemFiles", "proLogParser", "proLogLine"], "targetFile": ["destFilename", "TargetFile", "baseDir", "baseFile", "TargetDirectory", "topFile", "topDisk", "destFile", "secondaryDisk", "sourceFile", "destDir", "targetDir", "targetDisk", "secondaryPath", "TargetDisk", "destPath", "secondaryFile", "sourcePath", "targetDirectory", "basePath", "targetFilename", "topDirectory", "secondaryDirectory", "TargetPath", "baseFilename", "sourceDir", "targetPath", "sourceFilename", "topPath"], "source": ["scope", "store", "shell", "style", "SOURCE", "position", "show", "language", "message", "format", "description", "secret", "string", "content", "target", "sequence", "buffer", "ource", "state", "src", "str", "from", "raw", "text", "resource", "join", "status", "response", "note", "ser", "comment", "sql", "expression", "file", "layout", "body", "base", "code", "sp", "unit", "display", "template", "input", "title", "se", "html", "start", "Source", "sample", "site", "password", "result"], "myParser": [" myBuilder", "myPlayer", "miParser", "myparser", "MyParser", "multiReader", "myPlugin", "someReader", "MyBuilder", "multiparser", "someBuilder", "someParser", "miPlugin", "multiParser", "multiPlugin", " myparser", "myReader", "somePlayer", "MyPlayer", "miparser", " myPlayer", "MyReader", "myBuilder", " myReader", " myPlugin", "miReader"], "myProgram": ["userProgram", "Myprogram", "miProgram", "anotherParser", "miLog", "userWar", "MyProgram", "thisProgram", "myProcess", "yourParser", "myWar", "yourProgram", "myPlatform", "anotherProgram", "miProcess", "thisPlatform", " myProcess", "MyLog", "userProcess", "myLog", " myPlatform", "myprogram", "yourprogram", "MyProcess", "userPlatform", "miprogram", "anotherProcess", " myprogram", "thisProcess", "yourProcess", "thisWar", "anotherprogram", " myWar", " myLog"], "myVisitor": ["yourJanator", "myVistor", "miAuditor", "yourVisator", "myActivier", "myvisistor", " myvisitor", "myVisualifier", "yourJanitor", "myVisualator", "yourVisistor", "miAudactor", "myAuditor", "miAudier", "myJanitation", "myVisitation", "yourJanistor", "myJanistor", "miVisiter", "myVisistor", "myJanier", "miVisitor", "myJanactor", " myVisitation", "myActivitor", " myVisistor", "myJanifier", "myCreatifier", "myvisitation", "myVisator", "myVisualitor", "myAuditer", "myJanator", "myViter", "yourJanifier", "myVitor", "myCreatitor", "miAuditer", "myJaniter", "myAudier", " myvisistor", " myVisiter", "myVisifier", "myCreatator", " myvisitation", "myActivactor", "miVisier", "myVisiter", "miVisactor", "yourVisifier", "myAudactor", "myVisualistor", "myVisier", "myActiviter", "myVisactor", " myvisiter", "yourVisitor", "myvisitor", "myvisiter", "myVitation", "myCreatistor", "myJanitor"], "adapterLayer": ["anapterMap", "adviceHeader", "adaptersMap", "agclerLayout", "adaptersStack", "anviceMap", "anviceLayer", "adurationStack", "agapterListener", "adaptersLayer", "adurationLayer", "adclerHeader", "adapterStack", "adapterListener", "adclerListener", "adviceListener", "adapterMap", "adaptersHeader", "adaptersListener", "adviceStack", "agclerLayer", "anviceStack", "adviceLayout", "adclerLayer", "anapterLayer", "agclerHeader", "adaptersLayout", "adviceMap", "agclerListener", "agapterHeader", "adurationMap", "anapterStack", "agapterLayout", "adviceLayer", "adapterHeader", "adapterLayout", "agapterLayer", "adclerLayout"], "classLoader": ["classloader", "ClassReader", "resourcePath", " classPath", " classReader", "classReader", "ClassLoader", "resourceloader", "Classloader", " classloader", "ClassPath", "resourceReader", "classPath", "resourceLoader"], "adapterWriter": ["adabilityWriter", "adabilityWrite", "adaptersWrite", "audapterMaker", "audaptersReader", "adapterWrite", "audaptersWriter", "adaptersWriter", "adaptersMaker", "adapterReader", "audaptersMaker", "adabilityMaker", "audapterReader", "audapterWriter", "adAdapterReader", "adabilityReader", "adAdapterWriter", "audapterWrite", "adapterMaker", "adAdapterMaker", "adAdapterWrite", "audaptersWrite", "adaptersReader"], "annotationGenerator": ["annotationValidators", "annotationGenation", "annotationValidater", "annotationGenerators", "annationGenerater", "annationgenerators", "annotationGenators", "annotationgeneration", "annationGenerator", "annationgeneration", "annationGeneration", "annationgenerator", "annotationgenerators", "annotationGenater", "annationgenerater", "annotationValidation", "annotationGenator", "annotationgenerator", "annotationgenerater", "annotationValidator", "annotationGeneration", "annotationGenerater", "annationGenerators"], "out": ["ins", "crit", "cmd", "output", "store", "OUT", "gr", "ex", "dt", "screen", "sum", "list", "con", "content", "net", "io", "cfg", "print", "sys", "inf", "group", "tree", "err", "str", "set", "conn", "in", "term", "outs", "writer", "ou", "inv", "pretty", "init", "session", "obj", "res", "aos", "nt", "msg", "pool", "base", "nr", "client", "inter", "up", "txt", "last", "conv", "inner", "manager", "null", "json", "desc", "log", "Out", "w", "outer", "n"]}}
{"id1": "4938100", "id2": "23402240", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"sha1": ["md2", "a1", "a256", "SHA3", "md3", "a2", "SHA2", "sha2", "sha256", "md1", "SHA256", "SHA1", "md256", "a3", "sha3"], "text": ["translation", "context", "value", "output", "pattern", "data", "message", "select", "content", "string", "path", "form", "print", "test", "buffer", "q", "str", "pt", "subject", "term", "aut", "comment", "prefix", "x", "document", "code", "nt", "msg", "act", "body", "name", "word", "event", "out", "txt", "TEXT", "template", "title", "input", "source", "url", "ct", "tx", "t", "ext", "now", "password", "command", "w", "Text", "read", "cont"], "UnsupportedEncodingException": ["UnsupportedEncgorithmEx", "UnsupportedChoderEx", "UnsupportedEncoderEx", "UnsupportedEncoderElement", "UnsupportedChodingEx", "UnsupportedChoderElement", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedChoderError", "UnsupportedEncodingElement", "UnsupportedChoderException", "UnsupportedChodingElement", "UnsupportedEncgorithmElement", "UnsupportedEncgorithmError", "UnsupportedEncgorithmException", "UnsupportedChodingError", "UnsupportedEncodingEx", "UnsupportedEncoderException", "UnsupportedChodingException"], "md": ["cmd", "dd", "mt", " ms", "bf", "der", "red", " cmd", " mc", "nd", "sha", " rm", "dh", "mk", "sd", " dd", "od", " sd", "ms", "m", "mm", "pd", "pkg", " cd", "mod", " df", "add", "dir", "ad", "mc", "mond", " Md", " mm", " mo", "df", "mp", "mn", "dm", "mand", "det", "ind", "mb", "h", "grad", "ld", " man", "td", "rm", "di", "cd", "ctr", "bd", "t", "hd", "d", "MD", "mg"], "sha1hash": ["sha1href", "sha1Hash", "ha1result", "haonesha", "ha1sum", "a1sha", "shaonesha", "sha1hex", "sha5result", "a1hash", "sha5hex", "sha1result", "sha5sha", "sha81hex", "sha5Hash", "a1Hash", "aonesum", "sha5href", "haonesum", "sha2sum", "sha5hash", "sha3Hash", "sha81href", " SHA1Hash", " SHA81hash", "sha3result", "haonehash", "sha2sha", "sha3sum", "sha1sha", "sha81hash", "haoneresult", " SHA81Hash", " SHA1href", "sha1sum", "sha2hash", "ha1hash", " SHA1hex", "sha5sum", "a1sum", "shaonehash", "sha3hash", "sha2Hash", "shaoneresult", " SHA81href", "sha81Hash", "ha1sha", "sha3href", "sha3sha", "shaoneHash", "sha3hex", " SHA81hex", "aonehash", "aoneHash", " SHA1hash", "aonesha", "shaonesum"]}}
{"id1": "16590954", "id2": "8135072", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"createJAR": ["createGAR", "saveJAR", "saveIJAR", "createGART", "createPHAR", "createIJAR", "saveIJART", "saveIJARS", "createGARS", "createGAP", "createJAP", "createJARS", "createPHART", "createIJAP", "saveJART", "createPHAP", "saveIJAP", "createJART", "createIJART", "saveJAP", "createPHARS", "saveJARS", "createIJARS"], "fileString": ["fileStr", "messageString", " fileRest", "FileStr", "FileString", "ilestring", "FileRest", "pathstring", "pathStr", "ileName", "FileText", "fileRest", "pathString", "ileRest", "Filestring", "messageStr", "messageText", " fileStr", "ileString", "fileName", " filestring", "messageName", "ileStr", " fileName", "fileText", "filestring", "FileName", " fileText"], "ext": ["Ext", "cmd", "exp", "ix", "EXT", "ex", "typ", "enc", "char", "format", "external", "pat", "e", "path", "except", "str", "gz", "text", "ime", "js", "xp", "tex", "fr", "req", "ort", "prot", "suff", "name", "ind", "append", "txt", "exe", "off", "xt", "type", "desc", "end", "t", "rest", "cont"], "file": ["f", "image", "store", "output", "port", "work", "model", "class", "channel", "cache", "data", "message", "format", "list", "module", "disk", "path", "foo", "le", "io", "user", "buffer", "tree", "from", "File", "resource", "http", "table", "FILE", "link", "to", "page", "report", " File", "document", "run", "force", "base", "parent", "pool", "name", "lock", "this", "open", "line", "fp", "h", "ile", "get", "source", "input", "doc", "memory", "mail", "db", "null", "type", "url", "default", "time", "t", "log", "info", "local", "handle"], "i": ["f", " j", "mi", "ami", "ri", "id", "p", "pi", "v", "ir", "ini", "ii", "s", "si", "ai", "bi", "n", "m", "c", "li", "j", "xi", "x", "phi", "ind", "is", "ui", "di", "gi", "ci", "ip", "ati", "o", "t", "index", "I"], "dir": ["div", "loc", "folder", " Dir", "del", "rel", "dd", "dy", "org", "id", " d", "ir", "home", "disk", "path", "addr", " directory", " folder", "pkg", "mod", "part", "direction", "vol", "dist", "DIR", "star", "tmp", "directory", "ind", "done", "uri", "wd", "db", "url", "Dir", "root", "direct", "d", "lib", "project"], "jarFile": ["jarField", "jFile", "jarfile", "jarName", "pkgFile", "jarEmail", "jfile", "javaFilename", "javaFile", " jarField", " jarFILE", "tarfile", "tarFilename", "jName", "JarFilename", "tarEmail", "pkgField", "JarFILE", " jarEmail", " jarFilename", "jFilename", "tarFile", "JarFile", "JarField", "JarEmail", "jarFILE", "Jarfile", "javafile", "javaName", "jarFilename", "pkgFILE", " jarfile", " jarName"], "fstrm": [" fdrum", "fslcm", "fcrdm", "ftrmed", "fstrmed", "ftrdm", " fstrcm", " fdrmed", "fstrp", " fstrum", "fsprm", "fbstrm", "fcrm", "fsprms", "ftrms", " fdrcm", " fdrm", "fcrp", "fstrms", "fbstrdm", "fstrum", "fsprdm", "fcrms", "ftrum", "fdrcm", "fdrmed", "fslm", "fstrdm", "fbsprdm", "fbstrp", "fbstrms", "fstrcm", "fsprp", "ftrcm", "ftrp", " fstrmed", "fslum", "fslmed", "fdrum", "fdrm", "fbsprms", "fbsprm", "ftrm", "fbsprp"], "in": ["f", " IN", "ins", "din", "inside", "en", "pin", "IN", "sin", "inn", "ai", "io", "inf", "gin", "cin", "m", "mm", "bin", "from", "it", "ic", "re", "add", "init", "ind", "is", "inc", "up", "rin", "input", "r", "iter", "inner", "oin", "o", "isin", "im", " din", "read", "In", "pi"], "out": ["cn", "output", "OUT", "co", "v", "p", "serv", "ex", "channel", "s", "net", "io", "outer", "m", "conn", "outs", "c", "it", "OU", "writer", "ou", "inv", "to", "obj", "gc", "aos", "cos", "ch", "client", "conv", "inner", "os", "null", "t", "o", "cm", "Out", "at", "w", "cont", "n"], "temp": ["mt", "output", "copy", "tt", "p", "wrap", "cache", "cont", "tc", " tmp", "mint", "mk", "thread", " temporary", "path", "dest", "EMP", "buffer", "tar", "mm", "pt", "m", "tree", "term", "mod", "to", "orig", " Temp", "emp", "document", "res", "Tem", "mp", "tmp", "directory", "porary", "pool", "cp", "name", "parent", "zip", "current", "template", "Temp", "memory", "full", "mem", "tm", "tem", "fake", "null", "tx", "t", "util", "TM", "local", "stem"], "fstrm2": ["fstrp1", "fstrp7", "fstrM7", "fstrm1", "fStrm7", "fStrm2", "fstrcm2", "fstrmm1", "fstrM1", "fstrtm2", "fstrm7", "fStrtm1", "fstrmm2", "fstrcm1", "fStrp7", "fStrtm2", "fstrM2", "fStrp1", "fstrcm7", "fStrp2", "fstrtm1", "fStrm1", "fstrp2"], "ostrm": [" ostrem", "astRM", "istnm", "ostrom", "ortlamm", "astm", "istmr", "astrem", "osrem", " ostm", "ostnm", "ostrem", "ortrom", "ostlamm", "istRM", "astlamm", "osmr", "istrem", "astrom", "osRM", "astrm", "osm", "osrm", "ostm", "ortrm", " ostrom", "istrm", "ostRM", " ostnm", "oslamm", "astmr", "osnm", "istm", " ostRM", "ortRM", "ostmr", " ostlamm"], "docFile": ["Docfile", "docFiles", "documentLine", "DocFiles", "manDir", "docLine", " docPath", "manfile", "DocLine", " docfile", "docfile", "documentDir", " docDir", "docPath", " docLine", "manFile", " docFiles", "manPath", "documentFiles", "docDir", "documentFile", "DocFile", "DocDir", "DocPath"]}}
{"id1": "3731077", "id2": "3024992", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["downloadfile", "copyfile", "downloadFile", " cpFile", " cpFiles", " cpfile", "downloadDirectory", "CopyFiles", " cpDirectory", "CopyFile", "copyFiles", "copyDirectory", "CopyDirectory", "Copyfile", "downloadFiles"], "from": ["f", "original", "org", "old", "with", "bean", "From", "data", "s", "string", "path", "un", "por", "without", "form", "origin", "str", "st", "term", "view", "or", "by", "part", "add", "vol", "a", "link", "fr", "what", "orig", "range", "rom", "as", "query", "star", "file", "so", "base", "of", "name", "before", "pro", "ol", "source", "input", "se", "config", "db", "reset", "start", "url", "info", "html", "at", "local"], "to": ["eto", "f", "top", "output", "th", "org", "co", "too", "bo", "total", "te", "token", "dest", "target", "on", "tu", "pt", "tree", "st", "into", "it", "or", "tom", "by", "toc", "size", "etc", "table", "pretty", "must", "that", "To", "oto", "file", "po", "auto", "TO", "nt", "parent", "phi", "base", "none", "name", "this", "two", "no", "ta", "full", "template", "html", "one", "null", "t", "o", "temp", "tt"], "parentDir": [" parentDirectory", "ParentDirectory", "parentFolder", "parentFile", "rootFolder", "Parentdir", "parentDirectory", "parentdir", "ParentFolder", "ParentFile", "netdir", "netFolder", "netFile", "masterDirectory", " parentFolder", "rootdir", "netDir", "rootDir", " parentFile", "rootFile", "ParentDir", " parentdir", "masterFolder", "masterFile", "masterDir"], "in": ["update", " IN", "mi", "ins", "din", "inside", "en", "ri", "id", "irc", "ir", "ini", "IN", "sin", "inn", "con", "net", "form", "inf", "print", "gin", "cin", "on", "mm", "bin", "xml", "raw", "it", "vin", "re", "all", "init", "mc", "ma", "al", "ain", "ind", "is", "inc", "up", "rin", "doc", "i", "input", "win", "source", "inner", "get", "one", "conf", "config", "o", "isin", "local", "min", "In"], "out": ["cn", "ot", "cmd", "output", "OUT", "co", "Out", "b", "v", "again", "ex", "list", "gt", "con", "ln", "net", "io", "ne", "sys", "ns", "on", "err", "it", "c", "or", "outs", "ou", "vol", "ro", "all", "nin", "obj", "file", "res", "gc", "op", "aos", "auto", "nt", "cos", "can", "ion", "write", "client", "no", "oss", "i", "one", "g", "conv", "os", "null", "na", "o", "t", "css", "go", "at", "outer", "n"], "ic": ["ins", "ot", "icc", "co", "rc", "ico", "irc", "cu", "sic", "ix", "tc", "aic", "cc", "wic", "ik", "tic", "arc", "cin", "nic", "icon", "ac", "iu", "c", "it", "ican", "ics", "icy", "mic", "pic", "pc", "vc", "IC", "inc", "isc", "i", "bc", "iac", "ci", "ip", "eric", "ric", "cus", "fc"], "oc": ["cot", "ot", "alloc", "voc", "og", "co", "ucc", "ico", "irc", "ict", "cu", "mot", "ec", "tc", "nc", "aic", "oco", "unc", "osc", "oca", "arc", "nic", "ac", "anc", "c", "toc", "OC", "oci", "roc", "ocon", "mic", "gc", "pic", "ox", "soc", "cos", "pc", "vc", "aco", "oe", "ci", "oct", "ric", "o", "oly", "cus", "yo", "ocr"]}}
{"id1": "22114133", "id2": "22264586", "code1": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"actionPerformed": [" actionPeruted", "actionperressed", "actionperformed", " actionExecressed", "actionperuted", "actionOccformed", "actionOccuted", "actionperplaced", "actionPerressed", "actionExecressed", "actionPerplaced", "actionOccressed", "actionExecuted", " actionExecformed", " actionExecplaced", " actionPerressed", "actionPeruted", "actionExecplaced", " actionPerplaced", "actionOccplaced", " actionExecuted", "actionExecformed"], "e": ["el", "u", "en", "b", "v", "p", "ea", "ze", "er", "te", "ent", "ev", "ae", "ate", "ge", "ed", "q", "E", "m", "Event", "c", "a", "de", "x", "ie", "event", "h", "se", "r", "es", "o", "t", "eeee", "d", "ee", "w", "n"], "cmd": ["cli", "crit", "ck", "fun", "cf", "bug", "job", "Cmd", "mk", "path", "foo", "cfg", "tar", "term", "text", "pkg", "kick", "col", "comm", "qt", "inv", "method", "Command", "what", "req", "dir", "md", "nt", "msg", "act", "vc", "cp", "name", "ch", "cmp", "def", "txt", "quit", "cur", "config", "ctrl", "dq", "conf", "cd", "cl", "ctr", "desc", "prop", "ct", "tx", "command", "cb", "action"], "chooser": ["promicer", "dialoder", "Choerer", " chooder", "choose", "CHOower", "choitcher", "lookoser", "lookoder", "CHOoser", "challressor", "looser", " choressor", "promoser", "chooner", "quicker", " choicer", "challoser", "goressor", "choosen", "Chooner", "gooder", "serialasser", "CHOerer", "loosen", " choose", "loose", "Choester", "Chooser", "promose", "roosen", "Chooder", "booner", "gooser", "Choose", "serialerer", "challicer", " choower", "queose", "boerer", "scheoser", "roose", "queosen", "Choicker", "CHOoder", " choester", "lookosen", "serialicer", "choester", "choressor", "goosen", "boose", "choicker", "CHOosen", "loicer", "boer", "boicer", "Choitcher", "dialester", "dialicer", "quicer", "Choicer", " choosen", "booser", "promer", "CHOicer", "choer", " choitcher", "queoner", "booder", "boasser", "scheower", "roicer", "queoser", "Choasser", "scheicer", " choerer", "chooder", "quoser", "scheerer", "rooser", "boosen", "quressor", "Choosen", "lookitcher", "serialoser", "choerer", "choower", "choicer", "Choressor", "choasser", " choer", "challicker", "dialoser"], "f": ["fs", "el", "b", "cf", "fw", "bf", "v", "exp", "p", "uf", "fm", "alf", "fo", "er", "elf", "fe", "fax", "ln", "form", "buffer", "tf", "sf", "c", "part", "fb", "j", "fle", "fr", "orig", "fx", "fa", "file", "fn", "of", "fal", "fac", "found", "fp", "fi", "h", "fab", "full", "conv", "l", "fl", "t", "o", "fd", "rf", "F", "d", "w", "fc", "func"], "filename": ["folder", "nu", "description", "unc", "path", "csv", "ln", "src", "nl", "that", "prefix", "file", "FN", "lime", "fp", "username", "title", "png", "til", "fd", "there", "bf", "displayText", "println", "sword", "nm", "string", "ename", "FILE", "fle", "family", "name", "json", "sbm", "result", "original", "p", "format", "s", "fil", "lua", "sf", "Filename", "loader", "ername", "fn", "river", "word", "latest", "ren", "source", "foreign", "pdf", "b", "fw", "xxx", "list", "whatever", "text", "jl", "kj", "nil", "directory", "txt", "ame", "mpeg", "html", "n"], "askRestart": ["askStarts", "askStart", "askRebart", "isRebart", "askRestore", "askStore", "askStStart", "isRebStart", "askLoadarts", "isRebore", "isRebarts", "isRestarts", "isRestart", "isRestore", "isRestStart", "askLoadStart", "askLoadore", "askRebore", "askLoadart", "askRestStart", "askRebarts", "askRestarts", "askRebStart"]}}
{"id1": "1769771", "id2": "659316", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " CopyFiles", " copyLine", " copyFiles", " CopyStream", "CopyFiles", " CopyLine", "CopyFile", "copyFiles", " copyStream", "CopyStream", " CopyFile", "CopyLine", "copyLine"], "in": ["ins", "din", "el", "en", "b", "old", "ini", " input", "IN", "inn", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ic", "init", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "l", "isin", "In"], "out": ["update", "ot", "output", "OUT", "b", "v", "p", "serv", "ex", "gt", "s", "net", "io", "err", "outs", "it", "c", "ou", "to", "file", "res", "po", "op", "nt", "msg", "up", "help", "os", "l", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["insideClient", "intChan", "innCase", " inChan", "cinCommand", "inConnection", "inChan", "intCommand", "cinRoom", "inClient", "Inchannel", "inScope", "sinButton", "outConnection", "outchannel", " inCommand", "inCategory", "innButton", "sinRoom", "insideCategory", " inCase", "ainChannel", "insideChannel", "sinCommand", "InChannel", "cinChannel", "dinchannel", "ainClient", "dinChan", "intChannel", "sinChannel", "ainScope", " inConnection", " inchannel", "dinConnection", "inCase", "sinCase", "inchannel", " inClient", " inButton", "outChan", "inCommand", "dinChannel", " inScope", " inCategory", "intchannel", "InChan", " inRoom", "sinClient", "inRoom", "innChannel", "innClient", "InCommand", "ainCategory", "insideScope", "inButton"], "outChannel": ["outputCh", "aosChannel", "blockChannel", "neSection", "inChan", "blockChan", " outCh", "outSection", " outManager", "outputChan", " outchannel", "inSection", "aosMember", "cnManager", "outchannel", "outputchannel", "inCh", "outputManager", "aosSection", "cnChan", "cnChannel", "parentChan", "outMany", "blockMany", "neMember", "inMember", "outCh", "parentGate", "outputChannel", "parentMany", "inchannel", " outGate", "outChan", "outMember", "outGate", "parentChannel", " outChan", "outManager", " outMany", "neChannel", "blockGate", "aosChan", "neChan"]}}
{"id1": "19739421", "id2": "18696387", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": ["UnknownCommandException", "UnknownFormatError", " UnknownOptionError", "UnknownParameterException", " UnknownCommandClass", "UnknownCommandHandler", "UnknownCommandClass", "UnknownOptionHandler", " UnknownCommandException", "UnknownFormatHandler", "UnknownParameterHandler", "UnknownOptionError", " UnknownOptionClass", "UnknownCommandError", "UnknownParameterError", "UnknownOptionClass", " UnknownCommandError", " UnknownOptionHandler", "UnknownFormatException", " UnknownCommandHandler", "UnknownParameterClass", "UnknownFormatClass"], "cmdLineParser": ["cmdlineReader", "cmdLParser", "CmdlineProvider", "mdlinearser", "mdLineparser", "commandLineReader", "commandlineParser", "mdLineReader", "commandlinePers", "cmdFramePers", "cmdNetParser", "cmdlineBuilder", "mdLineLoader", "commandLineParser", "commandLineBuilder", "cmdFrameRunner", "cmdLineOptions", "CmdLineReader", " cmdLineReader", "cmdListparser", "cmdSetParser", " cmdPageBuilder", "cmdBlockHandler", "cmdSetparser", "cmdlineHandler", "mdlineHandler", "cmdlineOptions", "cmdNetStreamer", "cmdLineRunner", "mdLineHandler", "CmdlineBuilder", "commandlineRunner", "mdlineBuilder", "mdLineOptions", "cmdListReader", "mdLineParser", "cmdLinePers", "cmdLineReader", "cmdLineparser", "cmdlinearser", " cmdPageParser", "cmdLinearser", "cmdlineProvider", "cmdPageBuilder", "commandlineProvider", "cmdLOptions", "cmdlinePers", "cmdChainarser", "cmdChainLoader", "cmdPageReader", "cmdSetReader", "CmdlineReader", "cmdNetReader", "cmdlineLoader", "cmdLineLoader", "cmdLineBuilder", "CmdLineBuilder", "mdlineStreamer", "cmdlineRunner", "cmdChainReader", "commandlineBuilder", "cmdLineHandler", "cmdBlockReader", "cmdLineProvider", "cmdBlockProvider", "CmdLineProvider", "cmdlineParser", "cmdLineStreamer", "cmdBlockBuilder", "CmdLineParser", "mdlineParser", "commandLineProvider", "cmdFrameParser", "commandLineRunner", "cmdlineStreamer", "cmdLBuilder", "cmdPageParser", "commandLinePers", "cmdFrameReader", "mdlineOptions", "commandlineReader", "cmdChainParser", "mdLinearser", " cmdLineBuilder", "cmdListParser", "mdlineparser", "mdlineLoader", " cmdPageReader", "cmdBlockParser", "cmdPageProvider", "cmdNetHandler", "mdlineReader", "CmdlineParser", "cmdLHandler", "mdLineStreamer", "mdLineBuilder", "cmdlineparser", "cmdSetBuilder", "cmdListBuilder", "cmdBlockOptions"], "formatOption": [" formatEntry", " formatOptions", "transformEntry", "filterEntry", " formatOperation", "FormatOperation", "formatEntry", "transformOption", "FormatOptions", "transformOperation", "FormatOption", "filterOption", "transformOptions", "formatOperation", "formatOptions"], "outputEncodingOption": ["outputencodingOptional", "outputencappingoption", "outputEncgingOption", "outputEncodingoption", "outputEncodingOptional", "outputEncamingOptional", "outputencappingOption", "outputencachingOptions", "outputEncachingOptional", "outputEncappingoption", "outputEncachingOptions", "outputEncamingoption", "outputencodingoption", "outputEncappingOptional", "outputEncamingOptions", "outputencodingOptions", "outputEncodingOptions", "outputEncgingOptional", "outputEncamingOption", "outputEncgingoption", "outputencodingOption", "outputEncappingOption", "outputEncachingOption", "outputencachingOption", "outputEncappingOptions", "outputencappingOptional", "outputencachingOptional"], "inputEncodingOption": ["inputEncendingOption", "inputenclingAttribute", "inputencodingOptions", "inputCodingOption", "inputCodingOptions", "inputencodingAttribute", "inputEncordingAttribute", "inputEncodingOptions", "inputEncodingoption", "inputencodingoption", "inputEncordingOptions", "inputenclingOptions", "inputCachingOption", "inputEncappingOptions", "inputEncachingOption", "inputEncachingOptional", "inputEncappingOption", "inputEncappingoption", "inputEnclingAttribute", "inputEncappingAttribute", "inputEncendingOptional", "inputEncachingOptions", "inputEncendingOptions", "inputenclingOption", "inputCachingOptions", "inputCodingOptional", "inputencodingOption", "inputCachingOptional", "inputEncodingOptional", "inputEncodingAttribute", "inputEnclingOption", "inputEncappingOptional", "inputenclingoption", "inputEnclingoption", "inputEnclingOptions", "inputEncordingOption", "inputEncordingoption"], "format": ["f", "output", "license", "style", "with", "scale", "language", "pattern", "api", "tif", "string", "form", "print", "sort", "set", "term", "it", "error", "status", "join", "option", "table", "method", "pretty", "note", "what", "export", "prefix", "transform", "file", "layout", "force", "name", "unit", "fix", "display", "template", "get", "title", "source", "filename", "config", "policy", "version", "type", "parse", "accept", "filter", "Format", "printf", "use", "command", "at", "module", "pi"], "outputEncoding": ["currentEncling", "outputEngging", "outputCompryption", "outputEnryption", "responseEncryption", "outputEncoder", "currentEnoding", "outputEngacing", " outputEncacing", " outputEncaming", "responseEncling", "outputEnoder", "outputencaching", "outputDecaming", "outputEngoding", "outputEngaching", "outputencling", "outputDecryption", "publicEncling", " outputDecaming", "outputEnaching", " outputEngoding", "outputMessining", "outputMessaming", "outputEncacing", " outputDecryption", "outputEnacing", "outputEnaging", " outputEngoder", "outputEnalling", "responseEncoding", "outputEngaling", " outputEncoder", "outputDecoding", "outputEnling", "outputEncalling", "outputCompining", "outputEncaching", "outputEncaling", "outputEnording", "outputencaging", "outputencording", "outputEncaging", "currentEnaching", " outputDecoding", "outputDecalling", " outputEncryption", "currentEnging", " outputDecining", "outputencging", "outputMessryption", "outputMessoding", "publicEncaging", "currentEncging", "outputCompaming", "outputEncording", "publicEncording", "responseEncalling", "outputEncryption", "outputEnoding", "outputEngoder", "outputDecining", "outputencoding", "outputDecling", "currentEncaching", "outputEngling", " outputEngacing", " outputEncining", "outputEncging", "publicEncoding", "outputEnaling", "currentEncoding", "currentEnling", "outputEnging", " outputEngaling", "outputEncining", "outputCompoding", "outputEncling", "outputEncaming", " outputEncaling"], "inputEncoding": ["inputEnacing", "inputEncale", "inputEngoding", "inputPackale", "inputEnale", "contextEnacing", "inputEncacing", "outputEncoder", "outputEncging", "sourceEncacing", "inputencale", "contextEncacing", "outputEncale", "contextEncoder", "inputencoding", "inputEning", "inputEncing", "inputPackoder", "contextEncoding", "inputChacing", "sourceEnoding", "outputEnoder", "outputEnging", "inputChoding", "sourceEnacing", "inputCodling", "inputEncling", "inputCododing", "inputEngale", "sourceEncoding", "inputencling", "inputPackging", "inputEnging", "inputEncoder", "inputencacing", "sourceEncing", "inputEngging", "inputEnoder", "sourceEning", "inputCoding", "sourceEnling", "inputEngoder", "outputEnale", "inputCodacing", "contextEnale", "inputChale", "inputChoder", "outputEnoding", "inputPackoding", "sourceEncling", "inputEnoding", "contextEncale", "inputencing", "contextEnoder", "contextEnoding", "inputEncging", "inputencoder", "inputEnling"], "remainingArgs": ["mainingGS", "remgoingGS", "resainingParameters", "remendingItems", "resainedArgs", "remainedArgs", "trainingArgs", "mainedParts", "remainingParts", "trainFrames", "remainingLinks", "remainingItems", "remainArgs", "remistingGS", "resainingargs", "remgoingJs", "remainedBlocks", "resainingGS", "trainingFrames", "resainedLinks", "trainingGS", "remainedParameters", "mainedJs", "resainedBlocks", "mainedArgs", "remainedFrames", "trainItems", "remgoingArgs", "remainBlocks", "trainingItems", "remainFrames", "remainedargs", "remainedItems", "removalBlocks", "remainedLinks", "removalParameters", "resainedargs", "resainedItems", "remainedGS", "trainGS", "remendingArgs", "mainingJs", "remainedJs", "mainedGS", "remainingJs", "remgoingParts", "remgoingItems", "remainedParts", "remainsBlocks", "mainingParts", "remainJs", "resainingLinks", "resainingArgs", "remainGS", "remendingGS", "trainArgs", "remainsParameters", "remainLinks", "removalGS", "removalArgs", "remainsGS", "remainingBlocks", "remistingLinks", "remainItems", "resainingItems", "remainingFrames", "remistingArgs", "remgoingargs", "resainedGS", "remainsArgs", "remainingargs", "remainingParameters", "remendingFrames", "remistingBlocks", "mainingArgs", "resainedParameters", "resainingBlocks", "remainingGS", "remainParts", "remainargs"], "inputFile": [" inputFILE", "inputLine", "Inputfile", "inputPlace", "requestFile", "outputLike", "inputLike", "outputPath", "InputFILE", "hiddenPath", "InputPlace", "inputfile", "inputPath", "hiddenfile", "acceptPlace", "InputPath", " inputLine", "requestPath", " inputPath", " inputLike", "requestFILE", "hiddenLike", " inputfile", "hiddenFile", " inputPlace", "inputFILE", "acceptLine", "InputLine", "outputfile", "InputFile", "acceptfile", "requestfile", "acceptFile"], "outputFile": ["outputFiles", " outputFiles", " outputDir", " outputfile", "clientDir", "writefile", "coinfile", "inputfile", "OutputDir", "cacheFile", "OutputFile", "outputDir", "OutputDo", "clientFiles", "clientDo", "writeFile", "coinFile", "outputFolder", "cacheFilename", "writeFolder", "Outputfile", "outputfile", "coinFolder", "OutputFiles", "writeDo", "outputFilename", "inputDir", "cacheDir", "outputDo", " outputDo", "OutputFilename", "clientFile", "cachefile", "inputFilename", " outputFolder", "coinDo"], "out": ["ins", "output", "OUT", "gr", "ex", "screen", "list", "gen", "con", "ln", "net", "io", "inf", "print", "cfg", "sys", "user", "on", "err", "in", "conn", "outs", "error", "writer", "ou", "inv", "pretty", "ser", "all", "report", "session", "init", "dir", "obj", "res", "aos", "msg", "inter", "up", "inner", "manager", "null", "log", "Out", "temp", "outer", "n"]}}
{"id1": "5061606", "id2": "9347451", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNacessed", "createSettingsIfNacessesar", "createSettingsIfNecessesar", "createSettingsIfNeccesible", "createSettingsIfNecessesary", "createSettingsIfNeccesed", "createSettingsIfNacessible", "createSettingsIfNeccessary", "createSettingsIfNecessible", "createSettingsIfNacessary", "createSettingsIfNecessar", "createSettingsIfNeccessar", "createSettingsIfNacessesary", "createSettingsIfNeccessible", "createSettingsIfNecessesible", "createSettingsIfNeccessed", "createSettingsIfNeccesary", "createSettingsIfNeccesar", "createSettingsIfNacessesed", "createSettingsIfNecessesed", "createSettingsIfNacessar", "createSettingsIfNecessed", "createSettingsIfNacessesible"], "out": ["cn", "f", "max", "ot", "output", "go", "OUT", "server", "co", "again", "ex", "bo", "yes", "list", "ent", "con", "net", "io", "ne", "print", "sys", "on", "err", "conn", "outs", "it", "or", "timeout", "OU", "writer", "ou", "inv", "note", "to", "that", "report", "comment", "init", "obj", "gc", "file", "res", "aos", "nt", "cos", "ch", "ion", "client", "write", "off", "up", "can", "oss", "one", "oe", "conv", "os", "null", "cho", "flush", "t", "o", "log", "exit", "end", "Out", "w", "outer", "n"], "fSettings": ["fOptions", "sfSetup", "fsettings", " fOptions", "bfSettings", "hSettings", "fSetting", " fsettings", "eSetting", "cfSetup", "finalOptions", "finalSetting", "cfsettings", " fChanges", "finalsettings", "cfSetting", "sfSettings", "fSetup", " fSetup", "cfSettings", "finalSettings", "fChanges", " fSetting", "esettings", "hsettings", "sfOptions", "sfChanges", "bfChanges", "bfSetting", "sfSetting", "hSetting", "sfsettings", "eSettings", "bfsettings"], "src": ["loc", "rel", "rt", "th", "rc", "rs", "ls", "sc", "dest", "sys", "attr", "sq", "sf", "view", "pkg", "resource", "rl", "sit", "upload", "ser", "spec", "ur", "dir", "img", "sb", "tmp", "fn", "rx", "txt", "source", "syn", "filename", "cur", "config", "desc", "url", "sr", "root", "cont"], "in": ["ins", "din", "inside", "en", "id", "IN", "sin", "inn", "ln", "inf", "gin", "cin", "bin", "from", "vin", "and", "init", "ad", "is", "rin", "i", "input", "source", "iter", "inner", "r", "l", "isin", "info", " din", "In", "n"]}}
{"id1": "22441244", "id2": "1986417", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"send": ["sent", "Send", "reply", "security", "transfer", "message", "print", "set", "push", "post", "add", "apply", "export", "report", "init", "build", "msg", "execute", "mail", "write", "get", "submit", "create", "parse", "end", "save"], "hsession": [" HSession", "rssession", "HSessions", "HSess", "hhhip", "hhession", "hsess", "hhsession", "rsess", "hession", "HSpace", " HSess", "hssession", " HSsession", "HSettings", " HSpace", "HShip", "hsessions", "HSsession", "rspace", "hship", "hhip", "hsettings", "hspace", "rsession", "hhessions", "hhettings", "hessions", "HSession", "hettings"], "session": ["context", "object", "store", "cache", "message", "instance", "content", "driver", "state", "set", "view", "Session", "connection", "sid", "document", "parent", "ess", "name", "event", "lock", "client", "ession", "account", "manager", "ip", "password", "job"], "repositoryName": ["repoositoryName", "repositoryData", "repositoryTitle", "repositorTitle", "repoitoryTitle", "reposoryName", "repositorNAME", "reposoryNAME", "reposositoryTitle", "repositoryPath", "repositoryNAME", "reposositoryPath", "repoositoryTitle", "repositableData", "repositionPath", "repositionNAME", "repositoryname", "repoositoryPath", "reposoryname", "repoositoryData", "reposositoryData", "repoositoryname", "repositorPath", "repoitoryname", "repositableName", "repoitoryNAME", "repoositoryNAME", "repositionName", "repositableNAME", "reposoryData", "repoitoryName", "repoitoryData", "reposositoryName", "repositionTitle", "repoitoryPath", "reposositoryname", "reposositoryNAME", "repositablename", "repositorName"], "ideIdint": ["ideIdline", "ideidint", "ideIdentno", "ideThline", "IDEIdint", "ideIDline", "ideInfoint", "IDEIdINT", "IDEidINT", "IDEidint", "ideIdno", "ideThno", "IDEidst", " ideIdline", "ideInfoINT", "ideIdind", "ideIDind", "ideDint", "ideDINT", "ideInfost", " ideThind", "IDEIdst", "ideThind", "ideIdINT", "ideidst", "ideIdentline", "ideIDno", "ideIdentint", "ideIDint", "ideIdentind", " ideThint", "ideDst", "ideIdst", "ideThint", " ideThline", "ideidINT", " ideIdind", " ideIdno", " ideThno"], "to": ["eto", "top", "tp", "co", "too", "tel", "about", "token", "target", "addr", "st", "by", "toc", "range", "phone", "To", "topic", "po", "TO", "auto", "address", "tr", "pos", "no", "client", "pro", "company", "ta", "os", "route", "ato", "o", "t", "site", "contact", "tt"], "cc": ["cn", "cloud", "cmd", "co", "cs", "cf", "rc", "ico", "ec", "sc", "CC", "tc", "cin", "ac", "ic", "toc", "control", "dc", "ca", "cv", "cca", "cb", "cci", "mc", "cp", "cmp", "cy", "company", "cr", "ctrl", "cl", "cd", "ci", "ct", "ce", "cm", "ck", "fc"], "bcc": ["rbce", " bCC", "rbcc", "vcc", "cbcc", " bck", "rbcy", "vce", "rbCC", "vcy", "cbck", "bck", "bce", "bcm", "sbce", "cbcm", "cbCC", "vck", "sbck", "sbcc", "bcy", "bCC", "sbcy", " bcm", "rbck", "rbcm"], "subject": ["host", "header", "id", "security", "message", "description", "content", "form", "face", "text", "author", "note", "metadata", "comment", "prefix", "heading", "topic", "Subject", "name", "mail", "template", "title", "source", "filename", "head", "uri", "html"], "body": ["top", "object", "output", "binary", "b", "shell", "other", "data", "message", "description", "back", "content", "business", "ody", "files", "any", "buffer", "bill", "ODY", "Body", "text", "part", "post", "news", "response", "inline", "note", "bh", "comment", "report", "query", "layout", "hex", "code", "base", "params", "name", "zip", "no", "line", "mail", "h", "template", "title", "source", "parts", "head", "inner", "null", "json", "url", "default", "padding", "summary", "bytes", "background", "html", "handle"], "attachments": ["attachachment", "Attachments", "atttypes", "Attachresses", "Attachtypes", "attachresses", "achmentments", "achmenttypes", "attments", "attresses", "attachtypes", "achmentresses", "Attachachment", "achmentachment"], "isHtml": [" isHHTML", " isWhtml", "ishtml", "isWhtml", "isJap", " isWhhtml", "isVip", "isJtml", "IsHtml", "isVtml", " isHhtml", "isWhHTML", "isWhhtml", "IsHhtml", "isChhtml", "IsHttp", "isChHTML", "isVhtml", "ishhtml", "isHip", "isHHTML", "isWhip", "ishap", "isJhtml", "isJttp", "IsHap", " isWhHTML", " isWhip", "ishttp", " isHip", "isHap", "isChip", "isHttp", "isChtml", "isHhtml", "isVHTML"], "charset": ["Charsetter", "chippetter", "charsets", "chippets", "quatset", "quarset", "charspace", "chARSET", "clerspace", "charsec", "chacterspace", "chARSetter", "CHarsets", "channelsetter", "chARSetic", "ChARSetter", "Charsetic", "chatset", "chersets", "chippET", "cherspace", "CHarset", "quatsale", "chippale", "charsET", "chARSpace", "channelset", "chersetter", "chablesec", "CHippET", "quarsec", "chatsec", "clersets", "chableset", "charsett", "ChARSet", "channelsetic", "CharsET", "charpetter", "charpet", "charsetter", "chablesale", "chactersetter", "clarsetter", "cherset", "CHarsett", "charpET", "CHippets", "charpetic", "chippett", "quarsale", "quatsetter", "CHippett", "charpett", "clerset", "ChARSetic", "channelsET", "quatsec", "clarspace", "chactersets", "clarsets", "chablesetter", "chARSets", "CHippet", "chatsetter", "chippec", "chatsale", "charsetic", "ChARSET", "charsale", "CHarsET", "clarset", "chacterset", "chippet", "charpets", "clersetter", "chARSet", "Charset", "quarsetter"], "headers": ["dr", "header", "comments", "fields", "authors", "types", "ers", " trailers", "files", "ilers", "relations", "users", "limits", "metadata", "codes", "heads", "params", "members", "keys", "ors", "details", "head", " heads", "lines", "names", "ters", "ppers"], "priority": ["context", " urgency", "flags", "comments", "id", " severity", "position", "grade", "security", "profile", "level", "description", "properties", "order", "due", "origin", "state", "status", "phone", "prefix", "pos", "company", "serial", "title", "policy", "primary", "password"], "email": ["initial", "Email", "et", "el", "object", "ssl", "server", "domain", "office", "output", "shell", "search", "liner", "license", "voice", "model", "die", "message", "ome", "instance", "detail", "enter", "il", "er", "external", "description", "e", "fax", "ne", "delete", "print", "test", "database", "xml", "example", "entry", "view", "em", "http", "response", "password", "link", "note", "ell", "ilo", "all", "report", "comment", "label", "document", "gmail", "console", "address", "msg", "event", "element", "line", "mail", "call", "company", "template", "oe", "reset", "echo", "url", "log", "sample", "contact", "html", "ee", "result"], "user": ["entity", "output", "uid", "actor", "id", "person", "match", "student", "profile", "usr", "admin", "owner", "USER", "me", "from", "ident", "author", "by", "use", "users", "usage", "browser", "creator", "login", "connection", "name", "system", "client", "usa", "used", "username", "account", "auth", "manager", "ip", "human", "util", "User", "result"], "identity": ["ententity", "IDENTitate", "personITY", "identicate", "entity", "IDENTiciary", "IDENTator", "presententity", "ethnicentity", "primicate", "equator", "identality", "identitate", "ethnicitate", "personicate", "presentitate", "primity", "identalty", "idententity", "instentity", "IDENTalty", "idality", "personity", "personificate", "identificate", "primificate", "IDENTificate", "equalty", "ethnicularity", "IDENTITY", "IDENTity", "identiciary", "identance", "IDENTularity", "IDENTifier", "solidality", "instifier", "instator", "presentity", "IDENTality", "instularity", "primentity", "recognentity", "solidity", "identularity", "IDENTance", "ethnicity", "personentity", "identITY", "idularity", "primance", "recognicate", "idity", "instalty", "equentity", "idiciary", "presentularity", "entifier", "personiciary", "solidentity", "identator", "entularity", "identifier", "IDENTentity", "idITY", "IDENTicate", "equity", "recognity", "instity", "solidularity", "recognance"], "_returnPath": [" _errorAddress", "_getPath", "_savepath", "_ReturnPath", "_requestName", "_ReturnPoint", "_resultTo", "_getDir", " _returnAddress", "_savePath", "_deleteTo", "_errorTo", " _errorPath", " _returnPoint", "_ReturnName", "_errorAddress", "_errorpath", "_retpath", "setsavepath", "_errorPoint", "_saveTo", "_returnDir", "_returnTo", "_deletePath", "setreturnUrl", "setsaveTo", "setreturnpath", "_returnUrl", "_resultPoint", "_errorName", "_retDir", "_getCode", "_getTo", "setsavePath", "_returnAddress", "_replyCode", "_replyPath", " _errorName", "_returnCode", "_replyDir", "_retPoint", "_deletePoint", "_requestPoint", " _returnName", " _errorPoint", "_retUrl", "_errorPath", "_ReturnAddress", "_errorUrl", "_errorLocation", "_retTo", "_returnpath", "_saveUrl", "_requestAddress", "_deletepath", "_requestPath", "_retLocation", "_retCode", "_retPath", "_resultPath", "_returnLocation", "setreturnPath", "_returnPoint", "_resultLocation", "_returnName", "setsaveUrl", "setreturnTo"], "_from": ["_reset", "longreset", "\tform", "letsource", "_about", " _reset", "\tactor", "longsource", "\tauthor", " _source", "longfrom", "_author", "_source", "_owner", " _actor", "longto", "_actor", "remowner", " _form", " _author", "remaddr", "letabout", "_local", "\tfrom", "_addr", "_form", "letfrom", "letto", "remfrom", " _about", "remlocal"], "_replyTo": ["_responseOf", "_closeTo", "_replyOf", "_backFrom", "_responseTO", "_replyPath", "_replyTO", "_returnFrom", "_ReplyTO", "_ReplyPath", "_commentOf", "_ReplyFrom", "_responseFrom", "_returnTo", "_responseTo", "_backTO", "_respondOnly", "_ReplyTo", "_closeLine", "_closeTO", "_backPath", "_responseLine", "_replyOnly", "_respondFrom", "_commentTO", "_returnOnly", "_commentLine", "_ReplyOnly", "_commentTo", "_returnTO", "_respondTo", "_replyFrom", "_responsePath", "_respondTO", "_closeOf", "_replyLine", "_backTo"], "_to": ["prisite", "successta", "_ta", "successto", "successsite", "successtopic", "prito", "_topic", "prita", "pritopic", "_site"], "_cc": [" _subject", " _cs", "_cs", "_cca", "_subject", " _cca"], "_bcc": ["_bca", "_bacc", "_wacc", "_rbacc", "_rcc", "_racc", "_rbcc", "_rca", "_rbck", "_rck", "_wca", "_wck", "_rbca", "_wcc", "_bck"]}}
{"id1": "3024987", "id2": "21308543", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_encending", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Decoded"], "in": [" IN", "mi", "ins", "din", "inside", "copy", "p", "ini", "cont", "data", "IN", "sin", "inn", "con", "Input", "inf", "gin", "cin", "m", "ac", "bin", "mm", "from", "it", "init", "as", "mc", "act", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "iter", "l", "isin", "info", "local", "read", "In", "n"], "reader": ["dr", "mr", "red", "data", "ocker", "er", "iterator", "driver", "io", "handler", "Larry", "buffer", "phrase", "parser", "loader", "writer", "rl", "reading", "ro", "req", "query", "file", "rr", "rar", "Reader", "rx", "per", "ner", "r", "input", "iter", "inner", "oe", "rise", "row", "rot", "read"], "baout": ["boout", "BAin", "caos", "beanout", "cain", "baouts", "beanin", "caouts", " baot", "oaos", "haouts", "beanouts", "caout", "haout", "yares", "oaout", "hain", "BAot", "yain", "bares", "baos", " bain", "yaot", "bain", "oain", "caOut", "BAout", "boos", "haOut", "oaOut", "boOut", "boin", " bares", "baOut", "BAres", "beanOut", "baot", "yaout"], "out": ["cn", "update", "cmd", "copy", "output", " OUT", "OUT", "b", "ex", " os", "bo", " Out", "stable", "gt", "con", "net", "ne", "io", "sys", "outs", "OU", " bout", "ou", "to", "all", " outs", "res", "auto", "batch", "cos", "client", "oss", "conv", "ao", "os", "null", " output", "o", "t", "Out", "outer", "n"], "bytes": ["pdf", "terms", "words", "comments", "binary", "bs", "bits", "values", "videos", "classes", "data", "cells", "ips", "vals", "gets", "files", "strings", "issues", "Bytes", "outs", "raw", "gs", "bps", "reads", "users", "pieces", "des", "letters", "reports", "ites", "tes", "seconds", "ies", "objects", "services", "latest", "resources", "parts", "ings", "pages", "es", "results", "lines", "les", "versions", "its", "unks", "names", "groups", "faces", "units", "frames", "blocks", "ones"]}}
{"id1": "20685385", "id2": "17083703", "code1": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getNextPkValueForEntityIncreaseBy": ["getNextPkValueForEntityIncreaseby", "getNextPkValueForEntityUpgradeWith", "getNextPkValueForEntityIncreBy", "getNextPkValueForentityIncreaseWith", "getNextPkValueForentityIncreaseBy", "getNextPkValueForEntityIncreby", "getNextPkValueForEntityIncreasesWith", "getNextPkValueForEntityUpgradeby", "getNextPkValueForEntityIncreaseWith", "getNextPkValueForentityIncreaseby", "getNextPkValueForEntityUpgradeBy", "getNextPkValueForEntityIncreWith", "getNextPkValueForEntityIncreasesBy", "getNextPkValueForentityIncreasesWith", "getNextPkValueForentityIncreasesBy", "getNextPkValueForEntityIncreasesby", "getNextPkValueForentityIncreasesby"], "entityName": ["activityType", "activityNAME", "templateType", "entityNames", "entityNAME", "entityPath", "fromNAME", "templateName", "EntityType", "componentType", "entName", " entityNAME", "EntityNAME", " entityType", " entityNames", "EntityPath", "templateNAME", "EntityName", "EntityNames", "fromName", "entityType", "eventType", "componentNames", "fromBase", "componentName", " entityPath", " entityBase", "EntityBase", "activityName", "fromNames", "entPath", "eventNAME", "activityNames", "entityBase", "entType", "entNames", "componentNAME", "eventName"], "count": ["length", "max", "ount", "core", "context", "frequency", "NB", "more", "total", "cc", "nb", "ctx", "continue", "c", "C", "limit", "size", "table", "range", "all", "batch", "force", "nt", "OUNT", "amount", "code", "of", "depth", "current", "call", "counter", "found", "number", "find", "ctr", "ct", "Count", "first", "history", "n"], "increasePkBy": ["increasePnTo", "increasePckBy", "increasePkCount", "increasePksBy", "increasePpBy", "increaseDkById", "increasePnBy", "increaseCkBy", "increasePkStyle", "increasePkkMy", "increasePKeyById", "increaseHkMin", "increaseCnTo", "increasePqFrom", "increaseDkeyBy", "increasePkMin", "increasePpStyle", "increaseDkeyStyle", "increaseDkeyWhen", "increasePpById", "increasePidTo", "increasePkeyStyle", "increaseDkStyle", "increasePkkBy", "increaseHkkMin", "increasePkPretty", "increasePkkPretty", "increaseHkBy", "increaseDkBy", "increaseHkPretty", "increaseHkkMy", "increasePksMin", "increasePkWhen", "increasePkeyValue", "increaseCkTo", "increasePnby", "increaseCnby", "increasePcTo", "increasePckPretty", "increasePpCount", "increasePkeyWhen", "increasePkeyTo", "increasePqBy", "increasePKeyStyle", "increaseHkkPretty", "increasePKeyBy", "increasePnWhen", "increaseDkeyTo", "increasePcBy", "increasePidBy", "increasePKeyCount", "increaseHkkBy", "increasePkby", "increaseCkby", "increasePkeyById", "increasePcby", "increaseDkeyCount", "increasePkById", "increasePckMin", "increasePqValue", "increasePpWhen", "increasePkMy", "increasePkeyFrom", "increasePkeyBy", "increaseDkWhen", "increasePkTo", "increasePkeyCount", "increasePpTo", "increaseDkeyById", "increaseDkTo", "increaseHkMy", "increasePckMy", "increasePidFrom", "increasePkkMin", "increasePkValue", "increasePidby", "increasePidValue", "increasePkFrom", "increasePksMy", "increasePksPretty", "increaseDkCount", "increaseCnBy"], "where": ["Where", "wh", "whe", "here", "search", "holder", "style", "with", "when", "location", "show", "message", "select", "how", "delete", "then", "handler", "test", "way", "q", "set", "which", "eth", "hold", " whe", "join", "WHERE", "what", "sql", "query", "hi", "body", "who", "mail", "template", "place", "find", "uri", "condition", "ql", "sample", "html", "w"], "ec": ["et", "EC", "exec", "peg", "ew", "rc", "cs", "co", "ep", "enc", "tc", "dec", "sc", "cc", "ev", "bec", "eu", "e", "arc", "ctx", "ac", "eg", "conn", "eca", "anc", "eth", "c", "sec", "erc", "eco", "dc", "esc", "ek", "oc", "roc", "ect", "mc", "eb", "gc", "ox", "soc", "pc", "uc", "isc", "ctrl", "bc", "eh", "Ec", "xc", "ce", "ee", "lc", "fc"], "dbc": ["cddc", "dedcache", "sdcache", "bdcache", "adec", "sdci", " dbcache", "debcc", "dedcc", "dbdc", " dbcs", " dbci", "cdc", "libca", "bdC", "libC", "dbcache", "debci", "adecc", "debmc", " dbmc", " dbdc", "debdc", "dbd", "debca", "debd", "debcs", "dbcs", "cdcs", "sdmc", "bdc", "dbca", "dbmc", "dedc", " dbca", "adeC", "debcache", "dbC", " dbcc", "dedC", "debC", "adecache", "debc", "libc", " dbd", "dbcc", "bdcc", "libd", "dbci", "sdc", " dbC", "cdcc"], "entity": ["image", "el", "object", "pe", "node", "model", "eme", "data", "security", "instance", "equ", "email", "ent", "peer", "e", "owner", "ITY", "entry", "ident", "Entity", "resource", "table", "alias", "ell", "oid", "document", "connection", "ee", "name", "event", "existent", "activity", "unique", "oe", "type", "ENT", "ce", "component"], "channel": ["context", "scope", "container", "server", "woman", "annels", "relation", "area", "peer", "Channel", "chain", "group", "queue", "member", "handler", "database", "conn", "entry", "c", "chart", "collection", "resource", "table", "col", "all", "attribute", "connection", "course", "console", "caster", "chan", "controller", "ch", "axis", "event", "name", "system", "client", "row", "type", "component"], "result": ["output", "product", "search", "currency", "match", "cache", "data", "profile", "total", "message", "description", "Result", "diff", "group", "sequence", "buffer", "RESULTS", "closure", "answer", "join", "direction", "response", "res", "cup", "event", "current", "found", "true", "details", "cur", "created", "results", "success", "primary", "successful"], "broker": ["roubro", "burlder", "brobro", "brobo", "Brolder", "brlder", "brolder", "brokers", "rouken", "brbro", "brbo", "burger", "Brobo", "Broker", "brker", "Broken", "rouker", "roukers", "brger", "broken", "brken", "Broger", "burker", "brkers", "broger", "Brokers", "burbo", "Brobro"], "con": ["cn", "cal", "cmd", "exec", "en", "co", "cf", "rc", "ran", "bean", "com", "dial", "enc", "connect", "nc", "cc", "clean", "ln", "un", "conn", "anc", "c", "pen", "re", "col", "Con", "ca", "connection", "mc", "Conn", "po", "res", "ain", "soc", "act", "fn", "cp", "cond", "CON", "open", "client", "cur", "ctrl", "conv", "conf", "cons", "coll", "ct", "cm", "go", "fc", "can"], "tries": ["Tails", "pries", "tsrys", "retries", "reties", "tsried", "itrys", "tsies", "tsries", "ties", "pails", " tried", " trys", "tails", "itries", "itried", "retrys", "retails", "tried", "Ties", "Tries", "tsails", "trys", " tails", "pried", "Trys", "itails", "prys", "Tried"], "resultSet": ["resultRow", "tableset", "rowRow", "tableSet", "rowSet", "valueSet", "ResultTime", "resultset", " resultMap", "resultStream", "valueSpec", "valueMap", "ResultList", " resultRow", "resultTime", "rowTime", "resultSpec", "ResultRow", " resultset", " resultStream", "responseMap", " resultTime", "ResultSet", "valueStream", "ResultMap", "resultList", "responseSet", "responseStream", "resultMap", "tableList", " resultSpec", "responseSpec", "Resultset", " resultList", "tableMap", "rowList"], "hasNext": ["hadNew", "hasPrevious", "hadPrev", " hasPrevious", "hasNew", "HasNew", "HasBottom", " hasNew", " hasBottom", "showsNext", "showsPrevious", "hadNext", "hasBottom", "HasNext", " hasPrev", "hasPrev", "showsBottom", "HasPrevious", "HasPrev"], "pk": ["pkid", "tpj", "npkid", "fpkid", " apak", "jpj", "prki", "jpkt", "jpk", "npk", "pj", "dk", "tpk", "pki", "npek", " pck", "dak", "npak", "prek", "prkid", "dck", "fpki", "pkey", "fpek", "jpkey", " apek", "tpkey", " pek", " pki", " pkid", "pek", " apkid", "pck", " pj", "fpk", " pak", "pkt", "dke", " pkt", "pke", "tpkt", " apk", "npke", "pak", " pke", "prk", " pkey", "npck"]}}
{"id1": "884867", "id2": "14317425", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"zipname": ["archiveout", "polyfilename", "downloadnamed", " zipsize", " zipName", "gzname", "zipfilename", "tarnamed", "zipnamed", "zfilename", "tarname", "zipName", "tarroot", "archivebase", "polyname", "zeName", "downloadfilename", "zipbase", "polyName", "zename", "zname", "zipsize", "tarsize", "downloadName", "znamed", "zebase", "gzsize", "zeout", " zipnamed", "archiveName", "zName", "ziproot", "downloadname", " ziproot", " zipbase", "archivename", "polynamed", "gznamed", "gzroot"], "zipout": ["zOut", "zion", "zipoutput", " zipion", " zipin", "sendout", "gzion", "gzall", "zout", "gzgen", " zipgen", "gzin", "Zipout", "zipion", "zipall", " zipall", "Zipn", "Zipname", " zipclient", "zipclient", "Zipin", "sendin", "gzobj", "Zipoutput", "sendname", "sendclient", "zipgen", "zipin", "gzOut", "zname", " zipoutput", "gzout", "zipobj", "zn", "zall", "sendn", "zipOut", "zgen", "zobj", "sendoutput", " zipOut", "Zipclient", "zipn", " zipobj", "zin"], "out": ["ins", " abort", "cmd", "gt", "gen", "ln", "set", "pretty", "obj", "res", "nt", "gov", "oss", "g", "null", "log", "OUT", "co", "dt", " sys", "ent", "io", "print", "n", "ac", "conn", " bout", "ou", "inv", "to", "init", "auto", "aos", " manager", "cos", "ch", "name", "conf", " output", "o", "at", "w", "cn", " OUT", "en", "p", "ex", "screen", "con", "cfg", "group", "str", "outs", " say", "all", "msg", "opt", "up", "one", "os", "desc", "t", "go", "output", " Out", "list", "net", "inf", "sys", "on", "by", "writer", " outs", " fmt", "client", "inner", "Out", "can"], "buffer": ["output", "binary", "cache", "message", "total", "window", "buf", "queue", "phrase", "stack", "sequence", "tree", "database", "block", "button", "table", "frame", "bar", "available", "page", "paste", "attribute", "comment", "document", "batch", "library", "line", "append", "template", "memory", "mem", "iter", "row", "variable", "Buffer", "buff", "filter", "temp", "pad", "command", "history"], "in": ["ins", "din", "en", "ex", "ini", "IN", "inn", "con", "like", "ai", "form", "inf", "bi", "cin", "gin", "on", "mm", "bin", "ac", "from", "it", "ic", "or", "by", "and", "init", "query", "nin", "mc", "ma", "per", "reader", "ind", "is", "inc", "check", "up", "rin", "get", "i", "input", "iter", "inner", "oin", "info", "isin", "im", "read", "In", "pi"], "length": ["loc", "distance", "maximum", "value", "bow", "present", "frequency", "position", "angle", "match", "integer", "count", "class", "language", "message", "total", "capacity", "string", "sequence", "print", "duration", "database", "space", "collection", "volume", "join", "size", "load", "reading", "available", "impl", "shape", "tail", "ength", "code", "library", "amount", "phi", "family", "depth", "shift", "no", "height", "display", "vector", "number", "len", "character", "full", "needed", "version", "type", "padding", "point", "hello", "component", "Length", "history", "read", "ENGTH"]}}
{"id1": "15797402", "id2": "14317425", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"parse": ["pe", "patch", "p", "scale", "format", "php", "process", "print", "parser", "xml", "resource", "ping", "map", "load", "add", "apply", "render", "dump", "transform", "shape", "tag", "build", "execute", "interpret", "slice", "split", "write", "se", "create", "close", "save", "filter", "use", "read", "handle"], "stream": ["length", "image", "Stream", "output", "channel", "archive", "data", "message", "window", "instance", "sync", "content", "iterator", "ream", "clean", "form", "chain", "sequence", "buffer", "stack", "test", "in", "resource", "http", "response", "upload", "document", "file", "console", "reader", "event", "zip", "open", "source", "input", "url", "sample", "download", "read", "cont", "handle"], "handler": ["callback", "host", "processor", "server", "message", "service", "hander", "ctx", "parser", "wrapper", "application", "loader", "writer", "resource", "worker", "storage", "shape", "management", "connection", "function", "address", "controller", "pool", "reader", "event", "h", "hand", "policy", "Handler", "password", "handle"], "metadata": ["image", "pdf", "dd", "mt", "header", "adata", "general", "data", "message", "detail", "properties", "content", "iterator", "google", "tar", "basic", "ctx", "m", "xml", "definition", "hold", "dirty", "md", "document", "MD", "managed", "java", "still", "met", "material", "template", "property", "meta", "details", "parts", "config", "memory", "policy", "td", "mem", "json", "manager", "common", "unknown", "management", "info", "module", "handle"], "context": ["translation", "location", "sc", "instance", "cc", "dict", "content", "environment", "chain", "sequence", "state", "stack", "ctx", "set", "network", "options", "collection", "resource", "frame", "response", "reason", "usage", "document", "connection", "event", "system", "current", "template", "config", "null", "condition", "ce", "command", "component", "local", "module", "Context"], "name": ["image", "pass", "value", "id", "old", "channel", "data", "nm", "description", "service", "lower", "string", "path", "on", "term", "Name", "part", "resource", "size", "nl", "alias", "reason", "comment", "NAME", "prefix", "key", "all", "label", "file", "body", "base", "none", "family", "system", "no", "client", "current", "ame", "title", "source", "filename", "common", "create", "len", "null", "l", "version", "type", "url", "time", "default", "named", "names", "local", "n"], "out": ["cn", "cmd", "output", "OUT", "co", "lay", "v", "serv", "ex", "sum", "external", "list", "gen", "con", "us", "user", "net", "io", "print", "sys", "in", "outs", "it", "OU", "writer", "table", "ou", "col", "to", "all", "obj", "file", "res", "po", "auto", "aos", "cos", "up", "oss", "one", "conv", "conf", "null", "url", "flush", "o", "Out", "outer", "n"]}}
{"id1": "8330057", "id2": "12766394", "code1": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"getHttpURL": ["getHttpAddress", "gethttpUrl", "printHTTPAddress", "getHTTPURL", "getHTTPurl", "getServiceurl", "getServiceURL", "printHTTPurl", "printHttpURL", "gethttpURL", "printHTTPURL", "gethttpurl", "getServiceAddress", "getHTTPAddress", "getHttpUrl", "printHTTPUrl", "gethttpAddress", "getHTTPUrl", "getHttpurl", "printHttpurl", "printHttpAddress", "printHttpUrl", "getServiceUrl"], "url": ["u", "id", "dl", "path", "buffer", "http", "method", "nl", "link", "page", "impl", "res", "address", "pl", "null", "download", "util", "ocl", "host", "ssl", "server", "domain", "https", "string", "web", "parser", "ll", "term", "ret", "www", "ur", "key", "img", "document", "gc", "name", "mount", "l", "version", "type", "default", "result", "loc", "sl", "channel", "data", "api", "format", "lr", "ref", "str", "resource", "URL", "build", "base", "msg", "full", "source", "uri", "image", "location", "window", "github", "xml", "pp", "ul", "label", "connection", "Url", "hub", "html"], "uc": ["UC", "u", "icc", "uid", "rc", "cu", "ucc", "uf", "ubis", "sc", "nc", "tc", "userc", "unc", "us", "con", "cc", "uph", "eu", "pac", "um", "aus", "universal", "lu", "ac", "ocr", "kt", "anc", "c", "ul", "uma", "asc", "ru", "uci", "auc", "oc", "usc", "roc", "ur", "mc", "gc", "uca", "uu", "soc", "ud", "pc", "uv", "uds", "ui", "cur", "ctrl", "bc", "unsigned", "cl", "ci", "uh", "ct", "ub", "orc", "cus", "ux", "util", "utt", "BC", "lc", "fc", "func", "ut"], "allHeaders": ["allBuffsters", " allHeadheaders", "allSignheaders", "allSignERS", "AllHeaders", "allHolders", "allFootels", "AllHolders", "AllHoldsters", "allheadsters", "AllHeadERS", " allSignels", "allBuffered", "allFootheaders", "allSignels", "allHeadsters", "allSigners", "allFooters", "allheadered", "allBuffers", "allHeadERS", " allSigners", " allSignERS", "allHoldsters", "allHoldels", "allHeadheaders", "allheadERS", "allHeadered", "AllHeadered", "allHoldERS", "AllHoldered", "allHeadels", "AllHeadsters", "allFootERS", "AllHoldERS", "allheaders", "allHoldered", "allHoldheaders", "allBuffERS", " allHeadels", " allSignheaders", " allHeadERS"], "itHeaders": ["itHeaderERS", " itDefers", "itMacers", "itDefERS", "itHeadlers", "ItHeadlers", "itDefles", "itHeads", " itDefERS", "icHostERS", "ItHeads", "itHolders", "itHEADings", "itDefs", " itDefs", "itMaclers", "icHosttons", "itHosters", "itHEADers", "ItHeadings", "itHeadertons", "itHeaderings", "itHEADles", "itHEADlers", "itHeadtons", "itHEADters", "itHeadters", "ItHeaderers", "itHEADs", "icHeadtons", "itHostters", " itHeadERS", "itHoldERS", " itHeadles", "icHeadERS", "icHeadters", "icHeaders", "itHeaderlers", "itHostERS", " itDefles", "itHeadERS", "itHeaderers", "itMacs", "itHEADtons", "itHoldles", "itHeaderters", "itDefers", "ItHeaderings", "itHosttons", "icHostters", "icHosters", " itHeads", "itHEADERS", "itHeadles", "ItHeaders", "ItHeaderlers", "itMacings", "itHeadings", "itHolds"], "e": ["et", "el", "pe", "xe", "ec", "ea", "ze", "er", "ent", "te", "ele", "ae", "eu", "ve", "ge", "le", "ed", "ev", "ne", "owner", "E", "eg", "entry", "ei", "re", "ke", "de", "ie", "be", "element", "ue", "se", "r", "one", "oe", "es", "l", "end", "ce", "eur", "ee"], "itValues": ["ritValues", "ItValues", "ItVersions", "atValues", "ritVs", " itFrames", "iVs", "ItContents", "ITValues", "litVersions", "atVersions", "iKeys", " itVs", "ITvalues", "Itvalues", "litContents", "ITVersions", "itvalues", "iValues", "litvalues", "ItItems", "itKeys", "ritKeys", "iFrames", "atvalues", "itFrames", "atItems", "litValues", "ITItems", " itKeys", "ritFrames", "itItems", "itVs", "ITContents", "itContents", "itVersions"], "in": ["mi", "ins", "din", "en", "stream", "IN", "inn", "io", "inf", "cin", "m", "bin", "from", "it", "ic", "ad", "mc", "ind", "this", "is", "inc", "rin", "i", "input", "r", "inner", "l", "o", "In", "n"], "display": ["PLAY", "store", "field", "style", "position", "hide", "dis", "screen", "show", "description", "color", "Display", "lo", "enable", "print", "embed", "debug", "DIS", "view", "visible", "load", "enabled", "link", "replace", "report", "browser", "render", "register", "label", "layout", "change", "flash", "clear", "details", "relevant", "friendly", "play", "summary", "download", "html", "draw", "read"], "reader": ["readable", "dr", "dd", "stream", "upper", "er", "driver", "iterator", "io", "handler", "editor", "buffer", "parser", "loader", "layer", "writer", "rl", "worker", "runner", "reading", "ser", "ro", "builder", "body", "rr", "rar", "Reader", "rx", "older", "ner", "r", "iter", "inner", "proc", "row", "roller", "parse", "read"], "s": ["fs", "acs", "ins", "ends", "ats", "cs", "rs", "ves", "sts", "p", "ls", "prints", "aws", "string", "gets", "S", "ns", "ms", "str", "ss", "sq", "js", "gs", "fts", "ds", "sv", "ts", "ims", "sb", "tes", "vs", "y", "less", "is", "als", "h", "full", "se", "still", "es", "os", "l", "hs", "its", "sample", "qs", "ws", "ans", "ps", "ges", "stats"], "contentType": ["contentTypes", "ContentType", "filetype", "ContentTypes", "fileTypes", " contentTime", "ContentTime", "contentTime", "fileType", " contenttype", " contentTypes", "Contenttype", "fileTime", "contenttype"], "filename": ["f", "fs", "output", "bf", "nm", "fil", "path", "ename", "face", "Filename", "wrote", "writer", " writer", "ername", " fn", " fil", "fn", "FN", "name", " path", "write", "fp", " name", "ame", "uri"]}}
{"id1": "10759917", "id2": "9647576", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["update", "del", "drop", "move", "select", "touch", "destroy", "set", "insert", "load", "remove", "link", "de", "replace", "dump", "query", "execute", "put", "clear", "write", "lete", "get", "Delete", "create", "reset", "save", "download", "command"], "name": ["value", "search", "id", "old", "data", "message", "nm", "format", "description", "string", "path", "e", "chain", "str", "m", "me", "term", "Name", "c", "error", "part", "resource", "size", "link", "alias", "NAME", "label", "prefix", "key", "item", "comment", "file", "connection", "ma", "code", "base", "parent", "word", "family", "ame", "w", "title", "source", "filename", "create", "common", "l", "null", "lon", "type", "version", "time", "url", "o", "names", "local", "n"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkStatus", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinksWarning", "CannotDeleteSystemLinksError", "CannotDeleteSysLinksException", "CannotDeleteSysLinksError", "CannotDeleteSysLinkException", "CannotDeleteSystemLinksStatus", "CannotDeleteSystemLinkError", "CannotDeleteSysLinksEx", "CannotDeleteSysLinksStatus", "CannotDeleteSystemTypeWarning", "CannotDeleteSystemLinkWarning", "CannotDeleteSystemDataStatus", "CannotDeleteSystemLinksException", "CannotDeleteSystemLinkEx", "CannotDeleteSystemTypeError", "CannotDeleteSystemDataEx", "CannotDeleteSystemTypeEx", "CannotDeleteSysLinkError", "CannotDeleteSystemPageException", "CannotDeleteSystemPageStatus", "CannotDeleteSystemTypeException", "CannotDeleteSystemLinksEx", "CannotDeleteSystemLinkStatus", "CannotDeleteSystemDataException", "CannotDeleteSystemDataError", "CannotDeleteSystemPageEx", "CannotDeleteSystemPageError"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotUsedException", "ClassLinkTypeNotFoundOver", "ClassLinkTypeIsFoundOver", "ClassLinkTypeNotFindEx", "ClassLinkTypeIsFoundException", "ClassLinkTypeIsFindOver", "ClassLinkTypeNotUsed ", "ClassLinkTypeNotFind ", "ClassLinkTypeIsFindException", "ClassLinkTypeIsFind ", "ClassLinkTypeNotFindException", "ClassLinkTypeNotUsedOver", "ClassLinkTypeNotUsedEx", "ClassLinkTypeNotFound ", "ClassLinkTypeIsFindEx", "ClassLinkTypeIsFoundEx", "ClassLinkTypeNotFoundEx", "ClassLinkTypeIsFound ", "ClassLinkTypeNotFindOver"], "conn": ["cmd", "rt", "org", "port", "yes", "ec", "enc", "cc", "err", "pkg", "pen", "socket", "ca", "pg", "obj", "Conn", "nt", "cp", "co", "https", "ens", "jp", "addr", "ctx", "pt", "yn", "oc", "gc", "ch", "close", "conv", "conf", "pas", "ws", "cb", "cn", "loc", "mt", "exec", "en", "bo", "die", "connect", "nc", "con", "resp", "c", "sec", "priv", "mc", "win", "t", "rel", "dn", "iw", "canon", "ang", "sys", "ns", "on", "col", "comm", "gate", "req", "connection", "cert", "act", "pool", "open", "client", "cur", "db", "coll", "ct", "ce"], "stmt": [" stMT", " stpr", "statm", " stmm", "constmb", "Stmb", "constmt", "stMT", "startMT", "snmt", "STm", "STtx", "Sttm", "StMT", "strm", "strmt", "stattm", "Stpt", "stmb", "constm", "stmm", "stpt", "Str", "strMT", "STmb", "str", "stpr", "stm", "snpt", "stmp", "STMT", " stpt", "startmt", "consttm", "strr", "Stmm", "strpr", "STmm", " sttx", " stmb", " stm", "Sttx", "Stpr", "Stmp", "sttx", "STtm", "startmp", "STmt", " str", "statMT", "snm", "startmm", "strmm", "sttm", " sttm", "Stmt", "snMT", "strmp", "Stm", "statmt"], "prepTable": [" preptable", "PrepTree", "ppTab", " prepTier", "prepTree", "preptable", "PrepTab", " prepTree", "pptable", "Preptable", "PrepTable", "summaryTable", "summarytable", " prepTab", "ppTree", "summaryTier", "prepTab", "ppTable", "PrepTier", "prepTier"], "objectLinkTable": ["objectLinkType", "objectlinktable", "objLinkstable", "objectLinkList", "objectLinkTab", "objectLinkstable", " objectLinkType", "objectTypeType", "objectLinkController", "objectlinkTab", "objLinktable", "objLinkList", " objectLinktable", "objectlinkTable", "objLinksList", "objectlinkType", "objectLinksList", "objectTypeTab", " objectLinkTab", "objLinksTable", "objLinkController", "objectLinksController", "objectLinksTable", "objectTypeTable", "objectTypetable", "objectLinktable", "objLinksController", "objLinkTable"], "sql": ["rel", "expr", "sl", "quote", "qs", "dl", "ips", "select", "format", "description", "fields", "sd", "s", "string", "csv", "form", "ns", "q", "str", "xml", "sq", "sf", "js", "join", "scl", "inv", "spec", "sv", "nl", "query", "expression", "sp", "fn", "template", "json", "url", "ql", "SQL", "spr", "html", "result"]}}
{"id1": "10759917", "id2": "804637", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"delete": ["update", "del", "drop", "move", "select", "touch", "destroy", "set", "insert", "load", "remove", "link", "de", "replace", "dump", "query", "execute", "put", "clear", "write", "lete", "get", "Delete", "create", "reset", "save", "download", "command"], "name": ["value", "search", "id", "old", "data", "message", "nm", "format", "description", "string", "path", "e", "chain", "str", "m", "me", "term", "Name", "c", "error", "part", "resource", "size", "link", "alias", "NAME", "label", "prefix", "key", "item", "comment", "file", "connection", "ma", "code", "base", "parent", "word", "family", "ame", "w", "title", "source", "filename", "create", "common", "l", "null", "lon", "type", "version", "time", "url", "o", "names", "local", "n"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkStatus", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinksWarning", "CannotDeleteSystemLinksError", "CannotDeleteSysLinksException", "CannotDeleteSysLinksError", "CannotDeleteSysLinkException", "CannotDeleteSystemLinksStatus", "CannotDeleteSystemLinkError", "CannotDeleteSysLinksEx", "CannotDeleteSysLinksStatus", "CannotDeleteSystemTypeWarning", "CannotDeleteSystemLinkWarning", "CannotDeleteSystemDataStatus", "CannotDeleteSystemLinksException", "CannotDeleteSystemLinkEx", "CannotDeleteSystemTypeError", "CannotDeleteSystemDataEx", "CannotDeleteSystemTypeEx", "CannotDeleteSysLinkError", "CannotDeleteSystemPageException", "CannotDeleteSystemPageStatus", "CannotDeleteSystemTypeException", "CannotDeleteSystemLinksEx", "CannotDeleteSystemLinkStatus", "CannotDeleteSystemDataException", "CannotDeleteSystemDataError", "CannotDeleteSystemPageEx", "CannotDeleteSystemPageError"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotUsedException", "ClassLinkTypeNotFoundOver", "ClassLinkTypeIsFoundOver", "ClassLinkTypeNotFindEx", "ClassLinkTypeIsFoundException", "ClassLinkTypeIsFindOver", "ClassLinkTypeNotUsed ", "ClassLinkTypeNotFind ", "ClassLinkTypeIsFindException", "ClassLinkTypeIsFind ", "ClassLinkTypeNotFindException", "ClassLinkTypeNotUsedOver", "ClassLinkTypeNotUsedEx", "ClassLinkTypeNotFound ", "ClassLinkTypeIsFindEx", "ClassLinkTypeIsFoundEx", "ClassLinkTypeNotFoundEx", "ClassLinkTypeIsFound ", "ClassLinkTypeNotFindOver"], "conn": ["cmd", "rt", "org", "port", "yes", "ec", "enc", "cc", "err", "pkg", "pen", "socket", "ca", "pg", "obj", "Conn", "nt", "cp", "co", "https", "ens", "jp", "addr", "ctx", "pt", "yn", "oc", "gc", "ch", "close", "conv", "conf", "pas", "ws", "cb", "cn", "loc", "mt", "exec", "en", "bo", "die", "connect", "nc", "con", "resp", "c", "sec", "priv", "mc", "win", "t", "rel", "dn", "iw", "canon", "ang", "sys", "ns", "on", "col", "comm", "gate", "req", "connection", "cert", "act", "pool", "open", "client", "cur", "db", "coll", "ct", "ce"], "stmt": [" stMT", " stpr", "statm", " stmm", "constmb", "Stmb", "constmt", "stMT", "startMT", "snmt", "STm", "STtx", "Sttm", "StMT", "strm", "strmt", "stattm", "Stpt", "stmb", "constm", "stmm", "stpt", "Str", "strMT", "STmb", "str", "stpr", "stm", "snpt", "stmp", "STMT", " stpt", "startmt", "consttm", "strr", "Stmm", "strpr", "STmm", " sttx", " stmb", " stm", "Sttx", "Stpr", "Stmp", "sttx", "STtm", "startmp", "STmt", " str", "statMT", "snm", "startmm", "strmm", "sttm", " sttm", "Stmt", "snMT", "strmp", "Stm", "statmt"], "prepTable": [" preptable", "PrepTree", "ppTab", " prepTier", "prepTree", "preptable", "PrepTab", " prepTree", "pptable", "Preptable", "PrepTable", "summaryTable", "summarytable", " prepTab", "ppTree", "summaryTier", "prepTab", "ppTable", "PrepTier", "prepTier"], "objectLinkTable": ["objectLinkType", "objectlinktable", "objLinkstable", "objectLinkList", "objectLinkTab", "objectLinkstable", " objectLinkType", "objectTypeType", "objectLinkController", "objectlinkTab", "objLinktable", "objLinkList", " objectLinktable", "objectlinkTable", "objLinksList", "objectlinkType", "objectLinksList", "objectTypeTab", " objectLinkTab", "objLinksTable", "objLinkController", "objectLinksController", "objectLinksTable", "objectTypeTable", "objectTypetable", "objectLinktable", "objLinksController", "objLinkTable"], "sql": ["rel", "expr", "sl", "quote", "qs", "dl", "ips", "select", "format", "description", "fields", "sd", "s", "string", "csv", "form", "ns", "q", "str", "xml", "sq", "sf", "js", "join", "scl", "inv", "spec", "sv", "nl", "query", "expression", "sp", "fn", "template", "json", "url", "ql", "SQL", "spr", "html", "result"]}}
{"id1": "13886238", "id2": "12306305", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"init": ["update", "go", " initiate", "launch", " initialization", "setup", "Init", "ping", "load", " refresh", "gc", "construct", "base", " Init", "open", "get", "create", "reset", "start", "version", " reset", "rest", "save", "download", "release", "index"], "backupFile": ["backapFILE", "BackipLock", "backupLock", "backipLock", "backopfile", "backupImage", "Backipfile", "backupidLock", "BackupFormat", "backupidLog", "backipFile", " backupfile", "backopImage", "BackupLog", "backupidFile", "backapfile", "backusterFile", "BackupFILE", "backupidFILE", "BackipLog", "backorefile", " backopStream", "Backupfile", "BackapFILE", "backupfile", " backopImage", "backupidFormat", "backupStream", "BackipFile", "BackapFormat", "backusterFormat", "backakLog", "backapFormat", "backusterfile", "backipStream", "backupFILE", "backakLock", "Backapfile", "backipLog", "backoreImage", " backopfile", "backopStream", "BackupLock", "backupidfile", " backopFile", "backupFormat", " backupStream", "backusterFILE", "BackupFile", "backupLog", "backakFile", "backipImage", "backakfile", "backipfile", "backopFile", "backoreStream", "BackapFile", "backapFile", " backupImage", "backoreFile"], "buff": ["max", "butt", "qq", "num", "cmd", "bm", "bl", "b", "bs", "uff", "bf", "binary", "bed", "bits", "uf", "nd", "buf", "prof", "grow", "ref", "ff", "buffer", "lim", "nb", "xx", "bin", "zero", "tf", "hold", "text", "xff", "fb", "black", "bis", "bg", "req", "img", "cb", "Buff", "emb", "batch", "msg", "cond", "ind", "comp", "txt", "ob", "mem", "append", "null", "tab", "wind", "bytes", "printf", "bb", "bound", "end", "font", "pb"], "in": ["mi", "ins", "din", "inside", "en", "ri", "id", "ex", "ini", "IN", "ze", "inn", "con", "ai", "io", "inf", "cin", "gin", "on", "mm", "bin", "it", "ic", "add", "mc", "body", "ain", "ind", "is", "inc", "up", "rin", "get", "i", "input", "r", "iter", "inner", "conf", "l", "o", "isin", "im", " din", "In"], "out": ["cn", "output", "OUT", "co", "again", "v", "ex", "we", "con", "net", "io", "ne", "sys", "on", "conn", "outs", "writer", "OU", "ou", "to", "obj", "res", "auto", "aos", "op", "cos", "can", "ion", "write", "up", "full", "i", "oss", "one", "conv", "inner", "os", "conf", "o", "end", "Out", "at", "w", "outer", "n"], "read": ["length", "max", "update", "readable", " write", "bind", "pop", "need", "copy", "stream", "scan", "old", "count", "show", "print", "Read", "buffer", "give", "have", "raw", "push", "scroll", "hold", "reads", "size", "load", "tell", "add", "remove", "reading", "skip", "ready", "READ", "shape", "query", "run", "take", "build", "pos", "ind", "before", "open", " Read", "check", "write", "seek", "shift", "get", "len", "input", "mem", "find", "close", "iter", "start", "play", "end", "next", "ok", "index", "send", "n"], "reportWriter": ["reportTimer", " reportManager", "reportScope", " reportContent", " reportApplication", "reportMember", "serviceWriter", "reportHandler", "commentContent", "modulewriter", "portPublisher", " reportwriter", "createWriter", "repairManager", "createwriter", "reportWriting", "moduleMember", " reportTimer", "portFile", "repairWriting", "portReader", " reportWriting", "repairPublisher", "portWrite", "repairApplication", "createEntry", "commentWriter", "reportContent", "reportWrite", "reportApplication", " reportEditor", "summaryTimer", "createScope", "repairEntry", " reportScope", "repairPage", "reportwriter", "serviceApplication", "moduleWriter", "repairScope", "detailHandler", " reportEngine", " reportPage", "portwriter", "detailReader", "reportTree", "repairWrite", "repairwriter", "repairWriter", "reportReader", "summaryWriter", "portHandler", "detailFile", "reportEntry", "repairEngine", "xmlWriter", "repairTimer", "summaryEditor", "servicePage", "repairContent", "xmlReader", "reportEngine", " reportHandler", "listPublisher", "repairTree", "summaryHandler", "listWrite", " reportTree", "listWriter", "serviceWriting", "commentEngine", "reportFile", "detailWriter", "summaryTree", "commentWriting", "xmlHandler", "repairHandler", "reportManager", " reportEntry", " reportMember", "portWriter", "reportPage", "repairMember", "reportEditor", "reportPublisher", "summaryWriting", "xmlFile", "moduleManager", "repairEditor", "listwriter"], "restarting": ["restortating", " restorted", " restartating", "restartsbing", "restartating", "restricting", "startedbing", "restrictating", "started", "startedating", "restrupted", "restreatinging", "startbing", "startating", "restricted", "restarteded", "restartedating", "restrupting", "restortinging", "restarteding", "restarted", "restorted", "restreatating", "restartbing", "restruptbing", " restortating", "restruptating", "restartsed", "restorting", "restreated", " restartinging", "starteding", "restrictinging", " restorting", "restartsating", "starteded", "restartinging", " restarted", "restartsing", "restartedbing", "restreating", " restortinging", "starting"]}}
{"id1": "22366505", "id2": "22611968", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"incluir": ["incluiir", "inclUator", "inCLUir", "inclouator", "incluar", "inCLUar", "inCLuier", "inclouir", "inCLUier", "inCLuir", "incluiier", "inclUier", "inCLUator", "incluier", "inclUar", "incluiar", "incluator", "incluiator", "inclouier", "inCLuar", "inclouar", "inCLuator", "inclUir"], "igreja": ["igopenji", "iggrej", " iggreva", "igreji", "iggreja", " iggreji", " iggrej", " igrej", " igreva", " iggreja", "igopenj", " igreji", " iggreje", " igcrej", "iggreje", "igcreJa", " igreJa", "igopenva", " igcreji", "iggreJa", "igarreja", "igarreji", "igvrej", "igarreva", "igarrejas", "igrejas", "igopenja", "iggreva", "igrej", "igcreji", "iggrejas", "igreje", "igcreja", "igreva", " iggrejas", "igarreJa", "igarreje", "igcrej", " igcreja", "igreJa", "igvreje", " igreje", "iggreji", "igarrej", "igvrejas", " igrejas", "igvreja", " igcreJa"], "connection": ["context", "container", "engine", "server", "established", "position", "computer", "language", "Connection", "connect", "relation", "communication", "instance", "description", "message", "setup", "con", "user", "city", "generation", "database", "section", "network", "conn", "application", "which", "c", "collection", "resource", "response", "link", "socket", "to", "creator", "gate", "session", "query", "document", "function", "library", "connected", "pool", "directory", "settings", "reference", "operation", "open", "ion", "client", "system", "current", "config", "created", "db", "close", "manager", "condition", "statement", " Connection", "management", "command", "component", "n"], "sql": ["cmd", "shell", "seed", "plan", "dl", "select", "description", "sd", "string", "csv", "ln", "form", "sys", "normal", "q", "pel", "xml", "sq", "sf", "san", "scl", "table", "inv", "nl", "sv", "spec", "install", "login", "query", "expression", "sol", "zip", "lock", "serial", "template", "sk", "title", "pl", "statement", "url", "ql", "SQL", "log", "spr", "series", "command"], "sql2": ["sql3", "SQL4", "SQL1", "ql02", "sql1", "SQL02", "sd02", " sql3", "sd2", "sd4", " sql02", "ql2", " sql4", " sql1", "sql4", "SQL2", "ql3", "SQL3", "ql1", "sd3", "sql02"], "stmt": [" stMT", " stmm", "statm", "Stmb", "statmn", "stMT", "restm", "tMT", " stmn", "STm", "strmb", "tmm", "StMT", "strm", "strmt", "stmb", "stmm", "tmt", "estmb", "strMT", "statmt", "STmb", "STMT", "stm", " ststat", "Stmm", "restmt", "reststat", "STmm", "estm", "stmn", " stmb", " stm", "ststat", "estmt", "estMT", "tmb", "Stmn", "STmt", "statMT", "Stmt", "STmn", "Stm", "Ststat", "restmm"], "stmt2": ["Stmem3", "sttmTwo", "Stmt3", "stMTTwo", " stmt02", " stmp3", "stMT4", "stmt1", " stmp2", "stmttwo", "stmTwo", "sttx2", "stmem3", " stmt3", " stMT02", "stm3", "stm02", " stmp4", "stmr4", "stmem2", "StmemTwo", "stmt4", " stmttwo", "sttm3", "stmt3", "stMT3", "stmemTwo", "stmem1", "Stmem2", "Stmem1", " stmt4", "StmtTwo", "sttm2", " stMT3", "stmptwo", "stMT1", "stmr1", "stMT02", "stm2", " stMT1", " stMT2", "stm1", "stmtTwo", "stmp4", "stmrtwo", "sttx3", " stmptwo", "stmp2", "stMT2", "Stmt2", " stmp1", "sttm4", " stmt1", " stmpTwo", "sttx02", "stmp3", "stmpTwo", "sttx1", "stmp1", "Stmt1", "stmr2", " stmtTwo", "stmt02", "stMTtwo"], "rs": ["fs", "rows", "ins", "ars", "rt", "ats", "mr", "xs", "rc", "ris", "cs", "bs", "ls", "ros", "sts", "ows", "usr", "s", "pers", "ys", "ms", "ns", "ss", "RS", "Rs", "js", "vers", "gs", "ds", "rys", "rates", "ts", "ims", "res", "eps", "vs", "ras", "r", "results", "rss", "ks", "hs", "sr", "its", "rd", "qs", "ws", "ps"], "retorno": ["montora", "altorno", "retora", "retorne", "gotorno", "eltorn", " retorn", "retrero", "montrero", " retogo", "eltorno", "eltogo", "montorne", "retano", "altorn", " retano", " retrero", "montorno", "gotrero", " retora", "eltano", "retorn", "gotorne", "gotora", "altogo", " retorne", "altano", "retogo"]}}
{"id1": "8093133", "id2": "13122204", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXMLFromFile", "loadXMLFromWeb", "loadXMLFormUrl", "loadXmlFormWeb", "loadXmlAsFile", "loadXmlFormUrl", "loadXMLFormFile", "loadXMLFromURL", "loadXmlAsUrl", "loadXMLFormWeb", "loadXmlWithUrl", "loadXmlWithFile", "loadXmlWithURL", "loadXmlFromFile", "loadXmlWithWeb", "loadXmlFormURL", "loadXmlFormFile", "loadXmlFromURL", "loadXmlAsWeb", "loadXMLFormURL", "loadXmlFromWeb", "loadXmlAsURL", "loadXMLFromUrl"], "url": ["loc", "host", "u", "sl", "ssl", "domain", "b", "id", "location", "char", "bel", "web", "path", "user", "str", "ll", "xml", "in", "request", "http", "nl", "link", "page", "ur", "URL", "document", "file", "res", "build", "base", "address", "name", "open", "get", "input", "uri", "Url", "l", "abs", "log", "html", "job", "n"], "timeout": ["length", "max", "server", "OUT", "frequency", "mode", "monitor", "exclusive", "total", "window", "capacity", "until", "io", "delay", "resolution", "duration", "buffer", "network", "term", "it", "limit", "size", "password", "to", "Timeout", "course", "seconds", "amount", "directory", "latest", "unit", "height", "client", "out", "number", "policy", "blocking", "version", "type", "time", "sleep", "period", "t", "padding", "wait"], "xmlType": ["xmlUnit", " xmlUnit", "complexUnit", " xmlTypes", "imageBlock", "xmltype", "xmlBlock", "mlType", "fileBlock", "complextype", " xmlTyp", "xmlStyle", "complexTyp", "fileStyle", "fileTypes", "mlTyp", "complexType", " xmlStyle", " xmlBlock", "xmlTyp", "imageType", "imageTypes", " xmltype", "mltype", "xmlTypes", "fileType", "mlUnit", "imageStyle"], "connection": ["established", "position", "computer", "channel", "Connection", "connect", "nc", "communication", "relation", "description", "con", "user", "city", "pointer", "io", "generation", "database", "subject", "network", "conn", "entry", "application", "c", "resource", "response", "internet", "link", "socket", "to", "creator", "usage", "session", "builder", "directory", "reference", "connected", "system", "ion", "client", "open", "current", "number", "still", "character", "config", "close", "cone", "statement", "manager", "condition", "creation", "uri", "command", "opening"], "buffInputStream": ["buffEarStream", "buffInputForm", "BuffInputSteam", "BuffInputStream", "buffOutputSteam", "buffOutputStream", "BuffInputField", "buffInputSteam", "buffInputChannel", "buffEntityStream", "buffEarField", "BuffOutputForm", "buffIOSteam", "buffEarSteam", "buffEarForm", "buffEntityChannel", "BuffInputForm", "BuffOutputChannel", "buffInputField", "buffOutputChannel", "buffIOForm", "buffIOField", "BuffInputChannel", "buffOutputForm", "buffIOStream", "buffOutputField", "BuffOutputField", "BuffOutputStream", "BuffOutputSteam", "buffEntityForm"]}}
{"id1": "11477906", "id2": "20939940", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"loadDefaultSettings": ["readDefaultValues", "loadFAULTsettings", "loadFAULTSettings", "loadFAULTValues", "loaddefaultSetting", "readDefaultSettings", "loaddefaultSettings", "readdefaultValues", "readdefaultsettings", "loadDefaultSetting", "readDefaultSetting", "readDefaultsettings", "readdefaultSettings", "loadDefaultValues", "loaddefaultsettings", "loadFAULTSetting", "loadDefaultsettings", "readdefaultSetting", "loaddefaultValues"], "configFileName": ["configFilenameLocation", "configFILELocation", "conffilename", "configPagename", "configFileNames", "conffilePath", "configPagePath", "confFilenamename", "configStreamname", "configPageNames", "configfileName", "configFilePath", "configfileNames", "configfilename", "configFilenamePath", "configFilenameNames", "configFilename", "conffileNames", "configFILEname", "confFileLocation", "confFilename", "configStreamPath", "configFILEPath", "confFileName", "confFilePath", "confFilenameName", "configFILEName", "confFilenameLocation", "configStreamLocation", "configPageName", "configFilenamename", "confFilenamePath", "conffileName", "configFilenameName", "configfilePath", "confFileNames", "configFileLocation", "configStreamName"], "in": ["mi", "ins", "din", "en", "id", "ls", "ini", "IN", "ze", "con", "inn", "e", "ai", "user", "inf", "cin", "gin", "on", "m", "bin", "from", "ar", "it", "or", "re", "ro", "init", "ad", "mc", "run", "al", "ma", "ain", "im", "ind", "is", "check", "up", "rin", "doc", "source", "input", "i", "inner", "l", "t", "o", "isin", "info", " din", "In", "n"], "out": ["ins", "port", "gt", "de", "obj", "file", "res", "nt", "check", "oss", "null", "log", "not", "server", "store", "OUT", "are", "co", "cache", "ent", "ge", "io", "ne", "n", "m", "it", "or", "OU", "ou", "to", "init", "gc", "aos", "auto", "ind", "conv", "o", "at", "w", "cn", "update", "copy", "en", "v", "ex", "con", "user", "raw", "outs", "all", "po", "up", "off", "ing", "os", "une", "t", "handle", "ot", "output", "over", "net", "sys", "writer", "des", "ion", "client", "Out", "read", "can"]}}
{"id1": "10281203", "id2": "10445819", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"makeRead": [" makePrint", " doPrint", "makePrint", " doread", "recordread", "recordPrint", "recordRead", "makeread", " makeread", " doReading", " makeReading", " doRead", "makeReading", "recordReading"], "user": ["host", "server", "uid", "field", "id", "person", "student", "message", "string", "owner", "USER", "database", "rule", "author", "by", "post", "use", "users", "table", "usage", "creator", "connection", "file", "name", "word", "client", "username", "auth", "url", "human", "password", "User", "command", "date", "project"], "databaseID": ["databaseId", "connectionId", " databaseType", " databaseId", " databaseSet", "directoryId", "directoryIDs", "directoryType", "databaseType", "databaseSet", "directorySet", "directoryID", "connectionSet", "connectionID", "connectionIDs", "databaseIDs", "connectionType", " databaseIDs"], "time": ["etime", "runtime", "value", "ty", "id", "frequency", "port", "date", "message", "window", "TIME", "tim", "times", "string", "sequence", "delay", "duration", "m", "ime", "text", "timeout", "year", "clock", " Time", "create", "tm", "age", "version", "type", "start", "Time", "second", "t", "rate", "end", "info", "timer", "now", "tt", "estamp"], "query": ["update", "cmd", "quote", "ask", "search", "question", "script", "task", "message", "select", "Query", "description", "string", "then", "sequence", "q", "term", "entry", "sq", "request", "text", "view", "join", "what", "comment", "quest", "sql", "transform", "body", "menu", "code", "qu", "call", "check", "template", "title", "qa", "create", "condition", "ql", "command"], "statement": ["cmd", "shell", "description", "ment", "le", "sn", "buffer", "state", "application", "article", "status", "pretty", "fr", "ts", "that", "comment", "report", "sql", "expression", "sp", "template", "se", "journal", "ements", "relation", "print", "st", "entry", "commit", "volume", "table", "storage", "usage", "init", "document", "batch", "call", "memory", "number", "policy", "cm", "command", "bind", "quote", "Statement", "mt", "copy", "binary", "frequency", "rule", "continue", "response", "library", "word", "condition", "yahoo", "processor", "position", "confirmed", "language", "communication", "list", "sequence", "phrase", "database", "session", "minute", "connection", "function", "execute", "ct", "stat"], "count": ["length", "loc", "ount", "num", "sum", "message", "total", "list", "complete", "n", "state", "nb", "any", "ctx", "c", "status", "size", "table", "all", "report", "batch", "code", "nt", "amount", "OUNT", "cond", "ind", "current", "found", "counter", "check", "call", "number", "parts", "find", "Count", "now", "contact", "index", "handle"]}}
{"id1": "18489832", "id2": "12783713", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" tryLoadXZipImage", " tryLoadXippedImage", " tryLoadXippedFile", " tryLoadZppedImage", " tryLoadXZipDir", " tryLoadXippedfile", " tryLoadZppedDir", " tryLoadZZipfile", " tryLoadZippedFile", " tryLoadZppedfile", " tryLoadZippedfile", " tryLoadZressedFile", " tryLoadZressedDir", " tryLoadZressedImage", " tryLoadZZipImage", " tryLoadZppedFile", " tryLoadXippedDir", " tryLoadXZipFile", " tryLoadZippedImage", " tryLoadZZipFile", " tryLoadZZipDir", " tryLoadZressedfile", " tryLoadXZipfile", " tryLoadZippedDir"], "url": ["sl", "ssl", "b", "https", "location", "dl", "char", "external", "web", "ref", "un", "str", "err", "ll", "xml", "raw", "loader", "ret", "request", "http", "ul", "nl", "link", "browser", "ur", "key", "URL", "file", "build", "base", "address", "name", "open", "call", "mount", "get", "r", "uri", "Url", "l", "row", "parse", "log"], "destDir": ["srcDir", "originDIR", "srcDIR", "destFile", "destDIR", "sourceFolder", "sourceFile", "distDirectory", "distDir", " destDirectory", "destDirectory", " destFolder", "destFolder", "targetDir", "distFolder", " destDIR", "distDIR", "targetDirectory", " destFile", "srcDirectory", "originDirectory", "targetDIR", "sourceDirectory", "srcFile", "originFolder", "sourceDir", "originDir", "targetFolder", "srcFolder"], "urlConnection": ["urlDialog", " urlLink", "URLClient", " urlConnect", "UrlDialog", " urlDialog", "urlClient", "httpConnect", "UrlConnect", "urlCompany", "URLConnection", "streamClient", "URLCompany", "streamCompany", "urlConnector", "UrlConnection", "URLConnector", "httpLink", "streamConnection", "urlConnect", "httpConnection", " urlClient", "streamConnector", " urlCompany", "httpDialog", "UrlLink", "urlLink", " urlConnector"], "tmpFile": ["tempView", " tmpDir", "thisfile", "thisFile", "empView", "thisFilename", "destfile", "cmpFilename", "destFile", "cmpPage", "tmpBe", "tmpTile", "mpfile", "tempFile", "tempfile", "empChain", "tmpChain", "tmpfile", "destBe", "thisChain", "empTile", " tmpfile", "tempBe", "tempChain", "empfile", "tmpPage", "tempFilename", "tmpView", "tmpDir", "tempDir", "cmpfile", "empFilename", " tmpFilename", "empFile", " tmpTile", "tempTile", "empDir", " tmpPage", "mpFile", " tmpView", "tempPage", "cmpFile", "destPage", " tmpBe", "tmpFilename"], "in": ["mi", "ins", "inside", "din", "el", "en", "co", "old", "ini", "IN", "ze", "sin", "inn", "con", "ln", "ai", "inf", "cin", "gin", "on", "bin", "from", "st", "it", "or", "by", "ains", "re", "all", "init", "as", "query", "al", "ma", "ie", "ain", "none", "ind", "is", "inc", "up", "rin", "i", "input", "source", "iter", "inner", "oin", "one", "pass", "win", "l", "info", "isin", "im", "index", "In", "n"], "out": ["cn", "output", "OUT", "co", "v", "ex", "external", "ent", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "or", "writer", "OU", "ou", "col", "note", "to", "all", "obj", "po", "aos", "tmp", "nt", "cos", "ch", "can", "client", "write", "up", "no", "oss", "one", "oe", "conv", "os", "null", "na", "flush", "o", "t", "exit", "Out", "at", "outer", "n"], "localURL": ["LocalID", "LocalLL", "localhostURL", " localURI", " localUL", "LocalUL", "localUrl", "localhostLL", "LocalURL", "localLL", "localUR", "localID", "localUL", " localLL", "LocalUR", "localhostID", "publicURI", "localURI", " localID", "publicUrl", "publicURL", " localUrl", "LocalUrl", "localhostUL", "LocalURI", "publicUR", " localUR"]}}
{"id1": "14819747", "id2": "16820041", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 0, "substitutes": {"debug": ["progress", "DEBUG", "dd", "binary", "javascript", "shell", "bug", "mode", "hide", "cache", "show", "data", "ose", "color", " debugging", "google", "develop", "web", "secure", "enable", "print", "test", "valid", "development", "hidden", "mod", "error", " DEBUG", "trace", "step", "enabled", "browser", "comment", "tag", "dump", "related", "dir", "dev", "file", "Debug", "console", "change", " debugger", "depth", "write", "display", "hack", "production", "config", "close", "db", "play", "default", "log", "d", "date", "module", "stats"], "prologFile": ["prolexBody", "proplotFile", "proLogPath", "prologBody", "profileLine", "proplexFilename", "propelFILE", "rologFiles", "prologFilename", "propelFile", "rologfile", "prologDo", "ProLogFilename", "rologFile", "problogFilename", "proplexFile", "probadfile", "problogPlace", "profilePath", "ProLogPlace", "proLogfile", "proLogDo", "proLogPlace", "propelFilename", "prosystemfile", "problogDo", "proconfigFilename", "ProLogFiles", "proconfigPlace", "PrologMessage", "ProLogPath", "proLogFilename", "prozipParser", "prologLine", "prozipFile", "proplexFILE", "prologFiles", "PrologPlace", "proLogFiles", "procellPath", "proconfigFiles", "prologParser", "probadFile", "proplogFile", "proplotFilename", "prolexFile", "ProLogParser", "PrologFiles", "proLogFILE", "PrologPath", "ProLogFILE", "prolexFilename", "profilefile", "problogFile", "ProLogLine", "proplogFilename", "PrologLine", "prosystemMessage", "prologPath", "Prologfile", "prologFILE", "proLogMessage", "rologDo", "problogFiles", "procellLine", "prozipFILE", "proplotBody", "proconfigFile", "proLogFile", "profileFile", "ProLogMessage", "prologfile", "procellFile", "proplotFILE", "probadParser", "PrologParser", "PrologFILE", "propelBody", "prosystemFile", "proplogBody", "prozipfile", "PrologFile", "problogfile", "ProLogFile", "procellfile", "prolexFILE", "PrologFilename", "prologMessage", "probadFILE", "proplogFILE", "ProLogfile", "proplexBody", "prologPlace", "prosystemFiles", "proLogParser", "proLogLine"], "targetFile": ["destFilename", "TargetFile", "baseDir", "baseFile", "TargetDirectory", "topFile", "topDisk", "destFile", "secondaryDisk", "sourceFile", "destDir", "targetDir", "targetDisk", "secondaryPath", "TargetDisk", "destPath", "secondaryFile", "sourcePath", "targetDirectory", "basePath", "targetFilename", "topDirectory", "secondaryDirectory", "TargetPath", "baseFilename", "sourceDir", "targetPath", "sourceFilename", "topPath"], "source": ["scope", "store", "shell", "style", "SOURCE", "position", "show", "language", "message", "format", "description", "secret", "string", "content", "target", "sequence", "buffer", "ource", "state", "src", "str", "from", "raw", "text", "resource", "join", "status", "response", "note", "ser", "comment", "sql", "expression", "file", "layout", "body", "base", "code", "sp", "unit", "display", "template", "input", "title", "se", "html", "start", "Source", "sample", "site", "password", "result"], "myParser": [" myBuilder", "myPlayer", "miParser", "myparser", "MyParser", "multiReader", "myPlugin", "someReader", "MyBuilder", "multiparser", "someBuilder", "someParser", "miPlugin", "multiParser", "multiPlugin", " myparser", "myReader", "somePlayer", "MyPlayer", "miparser", " myPlayer", "MyReader", "myBuilder", " myReader", " myPlugin", "miReader"], "myProgram": ["userProgram", "Myprogram", "miProgram", "anotherParser", "miLog", "userWar", "MyProgram", "thisProgram", "myProcess", "yourParser", "myWar", "yourProgram", "myPlatform", "anotherProgram", "miProcess", "thisPlatform", " myProcess", "MyLog", "userProcess", "myLog", " myPlatform", "myprogram", "yourprogram", "MyProcess", "userPlatform", "miprogram", "anotherProcess", " myprogram", "thisProcess", "yourProcess", "thisWar", "anotherprogram", " myWar", " myLog"], "myVisitor": ["yourJanator", "myVistor", "miAuditor", "yourVisator", "myActivier", "myvisistor", " myvisitor", "myVisualifier", "yourJanitor", "myVisualator", "yourVisistor", "miAudactor", "myAuditor", "miAudier", "myJanitation", "myVisitation", "yourJanistor", "myJanistor", "miVisiter", "myVisistor", "myJanier", "miVisitor", "myJanactor", " myVisitation", "myActivitor", " myVisistor", "myJanifier", "myCreatifier", "myvisitation", "myVisator", "myVisualitor", "myAuditer", "myJanator", "myViter", "yourJanifier", "myVitor", "myCreatitor", "miAuditer", "myJaniter", "myAudier", " myvisistor", " myVisiter", "myVisifier", "myCreatator", " myvisitation", "myActivactor", "miVisier", "myVisiter", "miVisactor", "yourVisifier", "myAudactor", "myVisualistor", "myVisier", "myActiviter", "myVisactor", " myvisiter", "yourVisitor", "myvisitor", "myvisiter", "myVitation", "myCreatistor", "myJanitor"], "adapterLayer": ["anapterMap", "adviceHeader", "adaptersMap", "agclerLayout", "adaptersStack", "anviceMap", "anviceLayer", "adurationStack", "agapterListener", "adaptersLayer", "adurationLayer", "adclerHeader", "adapterStack", "adapterListener", "adclerListener", "adviceListener", "adapterMap", "adaptersHeader", "adaptersListener", "adviceStack", "agclerLayer", "anviceStack", "adviceLayout", "adclerLayer", "anapterLayer", "agclerHeader", "adaptersLayout", "adviceMap", "agclerListener", "agapterHeader", "adurationMap", "anapterStack", "agapterLayout", "adviceLayer", "adapterHeader", "adapterLayout", "agapterLayer", "adclerLayout"], "classLoader": ["classloader", "ClassReader", "resourcePath", " classPath", " classReader", "classReader", "ClassLoader", "resourceloader", "Classloader", " classloader", "ClassPath", "resourceReader", "classPath", "resourceLoader"], "adapterWriter": ["adabilityWriter", "adabilityWrite", "adaptersWrite", "audapterMaker", "audaptersReader", "adapterWrite", "audaptersWriter", "adaptersWriter", "adaptersMaker", "adapterReader", "audaptersMaker", "adabilityMaker", "audapterReader", "audapterWriter", "adAdapterReader", "adabilityReader", "adAdapterWriter", "audapterWrite", "adapterMaker", "adAdapterMaker", "adAdapterWrite", "audaptersWrite", "adaptersReader"], "annotationGenerator": ["annotationValidators", "annotationGenation", "annotationValidater", "annotationGenerators", "annationGenerater", "annationgenerators", "annotationGenators", "annotationgeneration", "annationGenerator", "annationgeneration", "annationGeneration", "annationgenerator", "annotationgenerators", "annotationGenater", "annationgenerater", "annotationValidation", "annotationGenator", "annotationgenerator", "annotationgenerater", "annotationValidator", "annotationGeneration", "annotationGenerater", "annationGenerators"], "out": ["ins", "crit", "cmd", "output", "store", "OUT", "gr", "ex", "dt", "screen", "sum", "list", "con", "content", "net", "io", "cfg", "print", "sys", "inf", "group", "tree", "err", "str", "set", "conn", "in", "term", "outs", "writer", "ou", "inv", "pretty", "init", "session", "obj", "res", "aos", "nt", "msg", "pool", "base", "nr", "client", "inter", "up", "txt", "last", "conv", "inner", "manager", "null", "json", "desc", "log", "Out", "w", "outer", "n"]}}
{"id1": "771802", "id2": "494226", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createInputstream", " createOutSteam", " createInputstream", "createInputStream", "createOutputFile", " createFilestream", " createFileFile", " createInputFile", " createOutputFile", " createInputStream", " createFileSteam", " createOutputstream", " createOutstream", " createOutputSteam", "createInputFile", " createFileStream", " createOutStream", "createInputSteam", " createInputSteam", "createOutputSteam", " createOutFile", "createOutputstream"], "inFile": [" infile", "dinPath", "ninFilename", "dinPort", "inputPath", " inPort", " inDir", "outPath", "outfile", "inputPort", "infile", "inPort", "inPath", "inDir", " inPath", "outFilename", "dinDir", "inputDir", "inFilename", "dinFile", " inFilename", "ninfile", "ninFile", "ninPath", "inputFile"], "outFile": ["outPort", "OutFile", "exFilename", "newPlace", "newFile", "OutFilename", "toPort", "outputPlace", "toFilename", "outfile", "toFile", "newfile", "exfile", "infile", "outputFile", "inPort", "outPlace", "outFilename", "outputfile", "outputFilename", "inFilename", "newFilename", "tofile", "exPlace", "Outfile", "exFile", "OutPort"], "k_blockSize": ["k4BlockName", "k4BlockCount", "k_batchCount", "k_byteName", "k_BlockLength", "k4BlockSize", "k_BlockSize", "k_BlockCount", "k4blockCount", "k_batchSize", "k_blockCount", "k_byteCount", "k_BlockTime", "k_byteStyle", "k_batchTime", "k2blockCount", "k_byteTime", "k2byteCount", "k_BlockName", "k4blockName", "k_byteSize", "k2blockSize", "k_blockStyle", "k2blockLength", "k2byteTime", "k4BlockStyle", "k_blockName", "k_BlockStyle", "k2byteSize", "k_blockLength", "k_blockTime", "k4blockStyle", "k2blockTime", "k_batchLength", "k4blockSize", "k2byteLength", "k_byteLength"], "byteCount": ["bitCode", "blockCheck", "byteCounter", "charCount", "charLength", " bytePtr", "bitLength", "bytePtr", "wordSize", "byteLength", " byteCounter", "byteCode", " bytecount", "byteN", "blockLength", "byteSize", "bbCount", "blockCounter", "wordCount", "charcount", "bitCounter", "wordN", "bitCount", "bitN", "linecount", "lineLength", "bytecount", "wordCode", "bbSize", "bbCode", "bitCheck", "byteCheck", "linePtr", "bitSize", " byteCheck", "charPtr", "bbN", "lineCount", " byteLength", "blockCount"], "buf": ["arr", "cmd", "bl", "b", "exp", "vec", "bn", "uf", "alph", "queue", "buffer", "str", "ctx", "block", "raw", "pkg", "cv", "bg", "cap", "img", "bag", "fg", "seq", "Buff", "batch", "cast", "msg", "txt", "mem", "doc", "cur", "bc", "conv", "db", "proc", "cat", "ctr", "Buffer", "rb", "tx", "buff", "bytes", "cb", "pb"], "ofp": ["Ofd", "Ofp", "ofd", "owlp", "ofpa", " ofpa", " ofl", "Ofpa", "ofl", "OFP", "Ofl", " ofP", "OFp", "OfP", "owld", "owlP", "OFl", "ofP", " ofd", "owlpa", "OFd"], "zos": ["zy", "sis", "z", "osi", "zh", "zes", "hz", "sbm", "zag", "sch", "bs", "std", "enos", "bes", "jp", "ze", "ws", "hess", "LOS", "zona", "zen", "webkit", "gs", "rez", "js", "zers", "south", "zik", "tis", "socket", "eros", "init", "zzle", "python", "amia", "zi", "cos", "ez", "zer", "zip", "cz", "jas", "settings", "esa", "rose", "oss", "zon", "psy", "es", "os", "zb", "zu", "nz", "rss", "ossus", "los", "zo", "css", "zl", "ps", "za", "zin"], "osw": ["sysW", "osswx", " osW", "ossrw", "ossW", "oswx", "opace", " osd", "isw", "osssw", "osew", "cosw", "owa", "osiwa", "sysrw", "oswd", "osswd", "iswx", "osiw", "ossw", "osws", "osiW", "aoswd", "aosew", "aosd", "ospace", "osd", "isW", " oswx", "aoswa", "sysw", "cosew", "osipace", "syswd", "issw", "aosws", "cosd", "cosws", "osrw", "aosrw", "aosw", "oswa", " ossw", "ow", "aospace", " osws", "oW", " osew", "aosW", "osW"], "bw": ["abew", " bx", "obwt", "nbew", " bwl", "abw", "rbw", "wbw", "pbz", "pbwy", "wbz", "sbz", "pbw", "wbwp", "bz", " bex", "pbwb", "pbwt", "wbem", "bwt", "bsw", " bsw", "abwe", "rbws", "bbem", "bbws", "wbwt", "bbz", "obz", "bwy", "wbx", " bwp", " bz", "bbex", "bbx", "bewl", "bew", "bbwp", " bem", "pbew", "nbwy", "bewk", "obwb", "nbw", "obw", "bbend", "bwk", "nbwe", "bwp", " bend", "bwl", "obsw", "bem", "bwb", "sbwt", " bwt", "bwe", "wbend", "bws", "bbwt", "obwk", " bwk", "rbz", "bend", "pbwe", "abwy", "bex", "bbw", "bx", "rbex", "sbw", "besw", " bws", "obwl", "sbwb"], "zot": ["zipot", "zipiat", "Zit", "Zott", "ziat", "ziot", "Zot", "zipiot", "zerot", "zott", "ziphot", " zor", "zero", "zerhot", "zote", "zerote", " zote", " zhot", " ziat", " zonet", "zeror", "zoonet", "zonet", " ziot", "zeriat", "zeronet", "zor", "Zote", "zerit", "zoor", "zoot", "zeriot", " zo", "zerott", "zhot", " zott", "zo", "zoo"], "ifp": [" ifth", " ifP", "ifP", "Ifth", "isP", " ifr", "iwr", "ihd", "isth", "iwd", "ihtp", "isjp", "ihp", "ifr", " ifjp", "Ifjp", " ifd", "ifth", " iftp", "isp", "iwp", "IfP", "Ifp", "ihr", "ifjp", "iftp", "iwtp", "ifd"], "zis": ["izis", "ziinit", " zi", "zic", "zois", "zipis", "zisa", "izisa", " zisc", "zoisa", "zipIS", "ziss", "zeris", "izisc", "zinit", "zisc", "zoiss", "ezisc", "ezis", " ziss", "iziss", " zIS", "zi", " zic", "zIS", "zeric", "ziis", "izinit", "ezi", "eziss", "zoinit", "zerIS", "zipic", "izi", "ziiss", "ziisa"], "isr": ["iosstr", "sisrc", " isrc", "isalpr", "issrc", " isrs", "isscr", "iossr", "siscr", "isstr", "sisrs", "isrs", "ispr", "itsr", "issrs", "sisr", "itspr", "iscr", "isalstr", "isrc", "issr", "itsstr", "isalsr", "iospr", " iscr", "isalr", "iosr", "itssr"], "br": ["hr", "rel", "yr", "ba", "dr", "bm", "mr", "bl", "b", "gr", "bf", "bn", "Fr", "BR", "bp", "vr", "lr", " Br", "bi", "str", "kr", "js", "shr", "bro", "fr", "bh", "obl", "Br", "ber", "ptr", "bt", "tr", "bj", "pr", "cr", "r", "ctr", "rb", "bd", "sr", "wr"], "zit": ["zlit", " zite", "zipist", "cziti", "oziti", "ziIt", "czunit", "zipite", " zip", "zipIT", "ziti", " zIT", "lexIt", "zeop", "zeot", "czip", "ezite", " zop", "ozunit", "ozip", "ezlit", "lexit", "czop", "zIT", "ziIT", "zop", "czot", "czit", "izip", "zite", "zeit", "zeip", "ziplit", "lexist", "zIt", "ozit", "zipIt", "zip", "ezit", "zist", "zipit", "ezIT", "ziist", "lexIT", "izit", "zunit", "ziit", "iziti", "izunit", " zlit"]}}
{"id1": "397240", "id2": "841724", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndRewWrite", "readAndResend", "readAndRepWrite", "readAndrewrites", "readAndrewrite", "readAndRewend", "readAndRepend", "readAndResWrite", "readAndResrites", "readAndRewrites", "readAndReprites", "readAndrewend", "readAndrewWrite", "readAndReprite"], "inFile": ["initFile", " infile", "inputPlace", "inFILE", "inPlace", "inFace", "iTime", "docFilename", "iFilename", "INFILE", "INFilename", "iFILE", "INFace", "inputFace", "inTime", "initFace", "INFile", "outfile", "initFilename", "INPlace", "INTime", "infile", "docFILE", "InFilename", "docTime", "outFilename", "inFilename", "initPlace", "inputFilename", " inFilename", "InFile", "docFile", "Infile", "iFile", "inputFile"], "outFile": ["reportFILE", " outFilename", "inFILE", "reportfile", "reportFile", " outfile", "checkfile", "checkFilename", "namefile", "toFILE", "nameFilename", "checkFILE", "toFilename", "outfile", "toFile", "reportFilename", "infile", "nameFILE", "outFILE", " outFILE", "checkFile", "outFilename", "nameFile", "inFilename", "tofile"], "iis": ["Iis", " iiss", "liisc", " iris", " ii", "iiris", "iiisc", "Iiss", "iIs", "eIs", "Ii", "diis", "ii", "iiis", "iiss", " iisc", "liIs", "aiis", "iisc", "liris", "liis", "eIS", "diiss", " iIS", "iris", "aiIs", "dii", "diIs", "iiIs", " iIs", "eis", "aiIS", "iIS", "IIs"], "dcmParser": ["dgrPar", "dcmAdapter", "dfmReader", "deromReader", "dpmPrivate", "dromReader", "dmoduleAssistant", "drumPar", "dgrStatement", "dcrBuilder", "DpmPar", " dcmPar", "dpmParser", "dcfReader", "dpmLoader", "DcmAdapter", "dromAssistant", "dpmBuilder", " dpmListener", "drumParser", "dpmarser", "dmmmParser", "dmParser", "dpmPar", "dromListener", "dmmparser", "dpcAssistant", "dcrReader", "dromparser", "dcomLoader", "DpmAdapter", "dpmListener", " dcmListener", "dpmStatement", " dcmparser", "dpcReader", "dcmPar", " dpmparser", "dromParser", "decmParser", "dfmBuilder", "deromparser", "dcommParser", "dcfStatement", "dcrParser", "dpcPrivate", " dpmReader", "dcfParser", "deromParser", " dcmPrivate", "dmparser", "dmReader", "dcmReader", "dmodulePrivate", "dpmAdapter", "dmmmAdapter", "dcommListener", "dcfPar", "dcmListener", "dmarser", "dcmPrivate", "dcommAssistant", " dpmPrivate", "dmmAdapter", "dmmmReader", "DpmReader", "dmmReader", "dcmLoader", " dpmBuilder", " dcmAssistant", "dcmStatement", "dfmParser", " dpmParser", "decmReader", "dcomParser", "dmmarser", "dcmAssistant", " dcmReader", "decmarser", "DcmParser", "dfmLoader", "dmmmparser", "DpmParser", " dpmAssistant", "DpmBuilder", "DcmPar", " dcmarser", "DcmBuilder", "dcmarser", "deromarser", " dpmLoader", " dpmPar", " dcmBuilder", " dcmLoader", "dmoduleParser", " dpmStatement", "dmoduleReader", "dpcParser", "DcmReader", "dcomReader", "dromarser", "dpmReader", " dpmarser", "Dpmparser", " dcmStatement", "dpmparser", "drumBuilder", "dcmBuilder", "dmmParser", "dpmAssistant", "dgrParser", "dcrparser", "dcmparser", "decmparser", "dcommReader", "dgrReader", "dcomBuilder", "Dcmparser", "drumReader"], "ds": ["fs", "ins", "dd", "xs", "cs", "rs", "dds", " des", "dx", "ls", "dt", "der", "dl", "bs", "sets", "data", "qs", "dat", "dh", "sd", "s", "pers", "drivers", "ys", "sys", "ns", "obs", "ss", "in", "pd", "outs", "js", "gs", "da", "dos", "DS", "sv", "ads", "ims", "des", "as", " DS", "df", "eps", "vs", "tes", "eds", "aos", "services", "uds", "details", "dq", "db", "os", "es", "ils", "Ds", "bd", "hs", "ks", "its", "ods", "hd", "ws", "d", "gd", "ps"], "pdReader": ["xdHelper", "vdWriter", "ddHelper", "pdParser", "pdRead", "pedReader", "pedLoader", "dpLoader", "xdReader", "vdReader", "pdHelper", "ddParser", "hdRead", "vdHelper", "xdWriter", "pdRunner", "tdRead", "ddRead", "ddCar", "xdLoader", "pedRunner", "dpCar", "tdWriter", "ddRunner", "pdLoader", "dpRunner", "hdReader", "hdWriter", "vdLoader", "dpReader", "tdParser", "pedCar", "ddReader", "ddLoader", "ddWriter", "pdCar", "hdParser", "tdReader"], "out": ["ins", "cmd", "id", "serv", "gt", "gen", "err", "js", "status", "obj", "res", "nt", "pos", "inter", "oss", "null", "log", "OUT", "co", "cache", "ent", "io", "conn", "it", "ou", "inv", "to", "auto", "aos", "ch", " err", "name", "conv", "o", "end", "cb", "at", "w", "cn", "en", "p", "v", "ex", "screen", "data", "sum", "s", "con", "cfg", "str", "in", "raw", "outs", "c", "all", "tmp", "msg", "opt", "up", "full", "one", "os", "desc", "flush", "t", "go", "output", "gr", "we", "list", "over", "net", "sys", "on", "sw", "writer", "pool", "nr", "client", "txt", "inner", "Out", "outer", "n"], "dcmEncParam": ["dcmDecNum", "dcmEscNum", "dmmEnPar", "dcmencCmd", "dmmencParam", "dcmEncVal", "dcmEncCmd", "dmmEncMsg", "dmmEncParam", "dcmencNum", "dcmDecMsg", "dmmEncVal", "dmmEnNum", "dmmEnParam", "dmmEncNum", "dcmEnVal", "dcmEscPar", "dcmEscParam", "dcmEscVal", "dcmencPar", "dmmEncCmd", "dcmDecCmd", "dmmencMsg", "dcmEnNum", "dmmencNum", "dcmEnPar", "dmmencCmd", "dcmEncMsg", "dcmencMsg", "dcmEncPar", "dmmEncPar", "dcmencParam", "dcmEncNum", "dcmDecParam", "dcmEnParam"], "pdWriter": ["tdWrite", "PDWriter", "pidWriting", "pdWriting", "pdWrite", "pcWriting", "tdwriter", "pcWriter", "PDEditor", "pidwriter", "dpWrite", "pidWriter", "pdEditor", "pcwriter", "pcWrite", "tdWriter", "PDReader", "dpEditor", "tdEditor", "dpReader", "tdWriting", "pidWrite", "PDWrite", "pdwriter", "dpWriter", "tdReader"]}}
{"id1": "11556231", "id2": "2676365", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "label": 0, "substitutes": {"ByURL": ["ByHTTP", "byHTTP", "byURL", "createURL", "byUrl", " byURL", "createUrl", " byString", " byHTTP", "ByString", "ByUrl", " byUrl", "createHTTP", "createString", "byString"], "urlstr": ["uriStr", "Urlobj", "lobj", "uriobj", "ulStr", "urlobj", "uristr", "Urlstring", "uristring", "lSTR", "lstring", "ulstring", "ulstr", "lStr", "Urlstr", "UrlStr", "urlStr", "urlstring", "ulSTR", "UrlSTR", "urlSTR", "lstr"], "uri": ["context", "u", "uid", "ri", "id", "https", "du", "doi", "description", "string", "path", "io", "origin", "q", "database", "URI", "subject", "term", "resource", "http", "link", "range", "ur", "prefix", " URI", "init", "query", "URL", "file", "uu", "address", "directory", "reference", "phi", "iri", "system", "ui", "i", "filename", "Url", "href", "html", "pi"], "url": ["loc", "f", "host", "sl", "ssl", "location", "ls", "char", "str", "parser", "ll", "conn", "resource", "http", "li", "ul", "nl", "link", "socket", "browser", "ur", "impl", "URL", "file", "sb", "build", "base", "address", "open", "client", "mail", "mount", "r", "Url", "l", "hub", "parse", "job"], "connection": ["context", "engine", "established", "position", "channel", "Connection", "connect", "relation", "service", "con", "io", "handler", "database", "network", "conn", "application", "c", "resource", "http", "response", "link", "socket", "session", "console", "connected", "directory", "open", "ion", "client", "number", "i", "condition", "using", "command", "opening"], "in": ["f", "ins", "din", "en", "stream", "id", "IN", "sin", "us", "inn", "inf", "cin", "mm", "bin", "from", "mc", "file", "ma", "body", "ind", "client", "out", "rin", "get", "i", "input", "r", "inner", "l", "mat", "isin", "info", " din", "In"], "reader": ["context", "dr", "stream", "ri", "er", "iterator", "io", "handler", "buffer", "parser", "loader", "writer", "resource", "runner", "ator", "reading", "ro", "builder", "body", "Reader", "rar", "rx", "input", "r", "iter", "inner", "ner", "row", "read", "handle"], "is": ["isa", "fs", "sis", "ins", "lis", "ri", "iss", "rs", "ris", "are", "serv", "isi", "nis", "s", "sys", "ms", "sim", "has", "ism", "bis", "as", "IS", "res", "sam", "iris", "mis", "Is", "isc", "i", "input", "se", "es", "os", "ais", "its", "info", "isin", "im", "ios"], "document": ["context", "object", "record", "output", "node", "message", "content", "tree", "m", "xml", "application", "collection", "response", "ocument", "page", "Document", "file", "dom", "library", "element", "template", "doc", " Document", "media", "information", "result"], "source": ["context", "object", "node", "SOURCE", "location", "instance", "select", "content", "dest", "sn", "handler", "ource", "src", "tree", "set", "or", "resource", " src", "event", "element", "out", "number", "input", "se", "Source", "site", "result"], "name": ["param", "object", "value", "id", "node", "location", "class", "format", "description", "string", "path", "attr", "Name", "comment", "attribute", "prefix", "key", "NAME", "tag", "label", "file", "code", "event", "property", "title", "version", "type", "variable", "default", "named", "names"], "namespaceURI": ["nspaceID", "namesplaceID", "namespaceRI", "nsplaceURL", "namesenterRI", "workspaceuri", "namesetURI", "namesetID", "namesenterURI", "namespaceIX", "namespaceuri", "worksystemuri", "nameseturi", "nspaceURI", "namesplaceURL", "namesificationuri", "workspaceRI", "namespaceURL", "namesaceURI", "namesystemRI", "resourcespaceUI", "namesetURL", "resourcespaceIX", "worksystemURI", "namesificationRI", "nspaceuri", "namesystemUID", "workspaceUID", "worksystemRI", "nsplaceuri", "namesificationUID", "nsplaceID", "resourcesacementIX", "namesenterUID", "workspaceURI", "namespaceID", "resourcesacementURI", "resourcespaceURI", "namesacementURI", "namesificationURI", "worksystemUID", "namespaceUID", "resourcesacementUI", "namesenteruri", "namesystemuri", "namesystemURI", "namesaceUI", "namespaceUI", "namesaceIX", "nspaceURL", "namesacementIX", "namesacementUI", "namesplaceuri", "nsplaceURI", "namesplaceURI"], "qualifiedName": ["localname", "fullName", "fullNames", "fullValue", "commonType", "commonname", "relativeName", "friendlyNames", "friendlyname", "relativeValue", "localValue", "fullname", "friendlyName", "relativeNames", "qualifiedname", "commonNames", "friendlyType", "localNames", "qualifiedValue", "localType", "commonName", "qualifiedNames", "qualifiedType", "relativename"], "data": ["image", "DATA", "object", "value", "output", "mode", "ata", "dat", "message", "pattern", "format", "description", "content", "string", "buffer", "str", "xml", "text", "definition", "error", "resource", "response", "comment", "key", "expression", "body", "address", "event", "element", "def", "input", "version", "type", "media", "password", "command", "info", "result", "action"], "tagName": ["TagData", "localname", "Tagname", "localData", "qualifiedValue", "TagName", "qualifiedData", "qualifiedname", "tagData", "tagValue", "localValue", "TagValue"], "target": ["context", "object", "node", "location", "class", "language", "instance", "format", "content", "path", "owner", "ref", "handler", "src", "subject", "error", "alias", "link", "prefix", "role", "binding", "property", "title", "ip", "command", "Target", "result", "action"], "elementId": ["documentid", "elementid", "nodeid", "documentID", "objectIndex", "objectid", "documentIndex", "objectId", "nodeId", "elementID", "objectID", "nodeID", "elementIndex", "documentId", "nodeIndex"], "tagname": ["shortname", "localid", "localnum", "localname", "Tagname", "Tagid", "shortnum", "TagName", "Tagnum", "tagid", "shortName", "tagnum", "shortid"], "localName": ["fixedname", "fixedNAME", "localNAME", "localname", "supportedname", "fixedName", "componentNames", "supportedName", "componentName", "localNames", "fixedNames", "supportedNames", "componentname", "supportedNAME", "componentNAME"]}}
{"id1": "20310134", "id2": "11032546", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"copyFile": [" duplicateFile", " cpFile", " copyDirectory", " duplicateDirectory", " cpfile", " CopyStream", " duplicateStream", " cpDirectory", " duplicatefile", " CopyDirectory", " copyStream", " CopyFile", " cpStream", " copyfile", " Copyfile"], "in": ["ins", "din", "el", "en", "b", "id", "old", "ini", "IN", "inn", "io", "inf", "cin", "gin", "on", "mm", "from", "ic", "it", "init", "as", "ain", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "l", "isin", "In"], "out": ["ot", "output", "OUT", "b", "v", "p", "serv", "ex", "gt", "s", "net", "io", "ne", "err", "it", "outs", "c", "ou", "to", "po", "op", "nt", "msg", "help", "g", "os", "null", "l", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["intChan", " inChan", "dinCommand", "insidePanel", "inConnection", "sinListener", "inChan", "intCommand", "cinRoom", "inClient", "cinClient", "oinChannel", "sinButton", "insideCommand", "outConnection", "outchannel", " inCommand", "cinButton", "sinRoom", " inCase", "insideChannel", "cinCase", " inApplication", "cinChannel", "dinButton", "inApplication", "dinChan", "intChannel", "sinChannel", "oinConnection", " inConnection", " inchannel", "inputChannel", "inCase", "sinCase", "dinChannel", " inClient", " inButton", "inchannel", "inCommand", "oinchannel", "inputCommand", " inListener", "inListener", "cinListener", "intButton", " inRoom", "inPanel", "sinClient", "inRoom", "oinApplication", " inPanel", "inputPanel", "outApplication", "inButton"], "outChannel": ["outputCh", "noteChan", "inChan", "fullChannel", " outCh", "noteChannel", "outputChan", " outchannel", "inCategory", "outchannel", "outConnection", "OUTCan", "outCategory", "inCh", "outputchannel", "outerUser", "outputUser", "outerChan", "cosCategory", "fullCategory", "outCan", "OUTCategory", "outUser", " outConnection", "noteMember", "inMember", "outerConnection", "fullChan", "outCh", "OUTChan", "outputChannel", "cosChan", " outCategory", "outerChannel", "inchannel", "outChan", " outCan", "OUTChannel", " outUser", "cosChannel", "noteCategory", "fullCan", "outMember", " outChan", "outputConnection", "cosMember"]}}
{"id1": "21092340", "id2": "4118412", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addInArchZip", "addToArchFile", "addToArchiver", "addToArchZip", "addInHarFile", "addToZipive", "addToHarZip", "addToZipZip", "addToExZip", "addToZipiver", "addInArchive", "addInArchiver", "addInHarive", "addToZipFile", "addToHarFile", "addToHariver", "addToExFile", "addToHarive", "addInHariver", "addInArchFile", "addToExive", "addInHarZip", "addToExiver"], "pod": ["top", "poll", "p", "job", "archive", "zone", "task", "message", "disk", "od", "device", "pack", "pkg", "volume", "post", "table", "spec", "Pod", "report", "ad", "pick", "ack", "wp", "op", "body", "pc", "cp", "check", "proc", "policy", "start", "ods", "pad", "point", "component", "module", "project"], "podArchiveOutputStream": ["podArchiveMainStream", "podArchiveOUStream", "podArchiveOutputSync", "podArchiveResourceSteam", "podArchiveOUForm", "podArchiverOutputMap", "podArchiverInputstream", "podArchiverOutputSteam", "podArchiverInputSync", "podArchiveInputContext", "podArchiveInputPoint", "podArchiveOutputMap", "podArchiverOutputSync", "podArchiverInputPoint", "podArchiveOUMap", "podArchiverOutputStream", "podArchiveInputSteam", "podArchiveStreamStream", "podArchiveInputstream", "podArchiveResourcestream", "podArchiveEntryPoint", "podArchiveOutputPoint", "podArchiveMainStreamer", "podArchiveOutStream", "podArchiveOUSync", "podArchiveOutPoint", "podArchiveResourceStream", "podArchiveoutputStreamer", "podArchiveOutputSteam", "podArchiverOutputForm", "podArchiveOutstream", "podArchiveInputMap", "podArchiveOutputstream", "podArchiveMainSteam", "podArchiveInputForm", "podArchiverOutputStreamer", "podArchiveStreamSync", "podArchiveEntryStream", "podArchiveInputStreamer", "podArchiveoutputStream", "podArchiverInputContext", "podArchiverInputStreamer", "podArchiverInputSteam", "podArchiveResourceContext", "podArchiveInputStream", "podArchiverOutputContext", "podArchiverOutputPoint", "podArchiverOutputstream", "podArchiverInputStream", "podArchiveStreamMap", "podArchiveMainForm", "podArchiveInputSync", "podArchiveoutputSteam", "podArchiveOutSteam", "podArchiveEntrySteam", "podArchiveoutputForm", "podArchiveOutputStreamer", "podArchiveStreamForm", "podArchiverInputMap", "podArchiverInputForm", "podArchiveOutputContext", "podArchiveOutContext", "podArchiveOutputForm"], "filename": ["folder", "original", "output", "binary", "p", "location", "archive", "println", "message", "nm", "description", "string", "fil", "path", "kl", "ename", "subject", "Filename", "resource", "jpg", "FILE", "upload", "NAME", "prefix", "key", "file", "nil", "fn", "directory", "FN", "name", "family", "latest", "ame", "txt", "fp", "title", "username", "uri", "png", "version", "url", "names", "release", "stem"], "source": ["image", "context", "copy", "store", "supp", "stream", "shell", "seed", "style", "SOURCE", "select", "service", "iterator", "sequence", "ource", "src", "from", "loader", "view", "resource", "spec", "ser", "sql", "file", "force", "body", "address", "template", "get", "input", "proc", "inner", "start", "Source", "sample", "series", "info", "password", "use", "component"], "entry": ["record", "ry", "job", "channel", "archive", "data", "task", "char", "enter", "ent", "ment", "cell", "set", "or", "resource", "quick", "link", "comment", "attribute", "key", "card", "sheet", "obj", "connection", "file", "query", "ie", "tmp", "nt", "zip", "word", "good", "element", "system", "line", "cue", "ace", "book", "se", "row", "log", "ce", "Entry", "component"]}}
{"id1": "3024992", "id2": "949327", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_NullOut"], "baout": ["BAin", "baouts", "cain", "abait", "BAoul", "dbin", "dbout", "caout", "baouth", "dboul", "buouts", "BAit", "bait", " bain", "gaoul", "buin", "gain", "bain", "baoul", "gaouth", "caOut", "BAout", "buout", "cait", "abaout", "BAOut", " baouts", "abaOut", " baOut", "abain", "baOut", "gaout", "BAouth", "buOut", "dbouth", "BAouts"], "out": [" OUT", "output", "OUT", "gr", "serv", "ex", "er", "gen", "net", "io", "sys", "err", "in", "outs", "it", "ser", "res", "tmp", "pool", "write", "null", "o", "Out", "result", "n"], "writer": ["riter", "processor", "output", "woman", "channel", "println", "data", "window", "er", "service", "NULL", "driver", "target", "nw", "handler", "print", "buffer", "player", "maker", "wrote", "worker", "builder", "rw", "wright", "usher", "file", "document", "widget", "writ", "killer", "reader", "this", "client", "write", "inner", "null", "Writer", "w", "outer"]}}
{"id1": "16931472", "id2": "13207437", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 1, "substitutes": {"handler": ["callback", "update", "processor", "output", "forward", "Handle", "hook", "adapt", "processing", "received", "request", "handle", "render", "init", "transform", "controller", "execute", "done", "proc", "handled", "Handler", "success", "accept", "end", "index", "read", "action"], "result": ["output", "product", "mate", "cache", "data", "profile", "total", "list", "Result", "complete", "sequence", "buffer", "valid", "RESULTS", "ret", "status", "map", "table", "response", "page", "report", "all", "res", "hash", "current", "met", "found", "out", "full", "done", "source", "memory", "details", "created", "results", "success", "make", "successful", "master"], "target": ["object", "cmd", "node", "style", "detail", "gt", "dest", "complete", "buffer", "pkg", "http", "link", "alias", "page", "that", "report", "controller", "template", "info", "local", "arget", "translation", "scope", "match", "jp", "external", "goal", "e", "tree", "term", "it", "view", "trace", "table", "to", "layout", "name", "internal", "version", "type", "remote", "project", "task", "self", "format", "service", "test", "valid", "subject", "closure", "expected", "prototype", "base", "parent", "arg", "source", "tool", "t", "component", "history", "Target", "master", "handle", "top", "output", "window", "tif", "thread", "peer", "bolt", "transform", "proxy", "this", "iter", "manager", "next", "primary", "trigger"], "url": ["loc", "rel", "f", "el", "sl", "ssl", "git", "ls", "dl", "hl", "char", "service", "bel", "lr", "web", "ll", "loader", "rl", "http", "ul", "nl", "link", "browser", "ur", "impl", "URL", "connection", "file", "cert", "build", "base", "address", "mount", "client", "mail", "uri", "Url", "l", "hub", "html"], "reader": ["context", "readable", "operator", "stream", "liner", "upper", "er", "review", "iterator", "driver", "buffer", "parser", "loader", "layer", "writer", "rl", "resource", "runner", "reading", "ro", "linger", "redo", "file", "builder", "rr", "rar", "Reader", "older", "ner", "cur", "iter", "inner", "uri", "row", "and", "rot", "read"], "line": ["entity", "ine", "store", "node", "style", "liner", "online", "port", "eline", "zone", "message", "level", "email", "detail", "string", "ln", "lo", "le", "chain", "queue", "sequence", "cell", "buffer", "state", "print", "section", "block", "lin", "continue", "network", "text", "rule", "trace", "limit", "status", "frame", "inline", "Line", "nl", "stay", "link", "page", "range", "comment", "file", "body", "base", "code", "lock", "word", "no", "out", "loop", "source", "user", "iter", "l", "row", "ip", "lines", "next", "log", "LINE", "sample", "point", "date", "now"], "entry": ["object", "record", "search", "ry", "field", "office", "match", "ex", "deep", "instance", "char", "pair", "list", "ent", "enter", "e", "ary", "cell", "member", "term", "it", "or", "part", "add", "quick", "comment", "key", "ie", "element", "ace", "def", "check", "se", "inner", "row", "pixel", "Entry", "exit", "job", "escape"], "fromIndex": ["leftInd", "FromInd", "fromPosition", "fromindex", " fromPosition", " fromInt", "leftindex", "fromInt", "FromLink", "normalIndex", " fromAlpha", "fromInd", "oldIndex", " fromInd", "oldAlpha", "oldInd", "normalindex", "oldLink", " fromindex", "forIndex", "fromLink", "FromAlpha", "minIndex", "minInd", "normalInd", "minindex", "FromIndex", "leftIndex", "forPosition", "leftPosition", "normalInt", "minInt", "forindex", "fromAlpha", "forInd", " fromLink"], "r": ["u", "dr", "rt", "mr", "b", "rc", "rs", "v", "p", "rg", "er", "e", "vr", "q", "rect", "m", "R", "err", "str", "ar", "kr", "re", "fr", "range", "render", "res", "rr", "rar", "nr", "cr", "g", "l", "rb", "sr", "rate", "rd", "w", "n"]}}
{"id1": "7396682", "id2": "9236363", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["core", "move", "archive", "transfer", "php", "sync", "delete", "crop", "repeat", "py", "Cop", "clip", "opy", "map", "load", "link", "read", "replace", "upload", "Copy", "gc", "share", "proxy", "cp", "zip", "slice", "write", "split", "clone", "create", "cat", "pixel", "download", "fit", "cross", "cop"], "srcFS": ["sourceFs", "sourcefs", "srcCS", "rcFS", " srcOS", "rcOS", "srcFs", "sysFS", " srcMS", "rcfs", "srcMS", " srcCS", "sourceFS", " srcFs", "sysVS", " srcSF", "srFS", " srcfs", "rcCS", "sourceCS", "sysFs", "srFs", "sourceVS", " srcVS", "rcSF", "sourceOS", "srcOS", "rcFs", "srcVS", "rcVS", "srfs", "srMS", "sourceSF", "rcMS", "srcfs", "srcSF", "sysOS"], "src": ["loc", "rel", "iv", "supp", "th", "node", "rc", "rs", "RC", "SOURCE", "https", "sc", "selected", "usr", "sin", "boot", "sync", "dest", "path", "sn", "secure", "addr", "sys", "target", "obs", "str", "subject", "st", "sq", "from", "via", "sec", "pkg", "resource", "http", "inst", "sit", "spec", "ser", "pri", "req", "dir", "sub", "img", "init", "sb", "obj", "nil", "tmp", "rx", "comp", "txt", "check", "source", "input", "lb", "cur", "filename", "syn", "uri", "proc", "start", "ctr", "sci", "sr", "desc", "url", "Source", "cont"], "dst": [" dest", "deslt", "dnd", " ddest", "ddlt", "Dest", "dhlt", "dslt", "DST", "dhdest", "dDest", "dest", "Dst", "ddnd", "dlt", "Ddest", "dhDest", "dsst", "dddest", "ddst", "lgt", " dST", "degt", "lest", " dlt", "dsest", "dedest", "desst", "dsST", "dST", "desdest", "dsgt", "lst", "dgt", "ddest", " dDest", "dsnd", "desnd", "dsdest", "deest", "DDest", "Dlt", "ldest", "dhst"], "deleteSource": ["delSOURCE", "deleteDest", "deleteSourceFile", "deleteSources", "updateSite", "delSource", "removeSource", "updateSource", "destroyTarget", "removeParent", " deleteResult", "closeSOURCE", " deleteTarget", "delDest", "destroySources", "leteSource", "removeSOURCE", "removeDest", "leteDest", "leteSOURCE", "DeleteSite", "delParent", "leteSources", "updateSOURCE", "deleteSite", "closeSource", "closeSite", "DeleteSourceFile", "destroyResult", "DeleteSource", "deleteParent", "deleteSOURCE", "deleteTarget", "closeSourceFile", "updateSourceFile", "leteResult", "destroySource", "DeleteSOURCE", "leteTarget", " deleteSources", "deleteResult", "leteParent"], "conf": ["fs", "f", "cn", "param", "irm", "Conf", "co", "scan", "cf", "plan", "com", "cache", "cc", "con", "ln", "ref", "cfg", "acc", "q", "m", "ctx", "mm", "conn", "map", "comm", "cms", "ca", "comment", "req", "report", "cb", "params", "ch", "pool", "hash", "ban", "def", "check", "config", "conv", "prop", "log", "info", "css", "cm", "job", "lib"], "contents": ["CONTants", "Contodes", "CONTENT", "CONTent", "Contterms", " contants", "contants", "ContENT", " Content", "Content", " contends", "CONTENTS", "content", "CONTresses", "Contants", "contENTS", " contENT", "contends", " Contresses", "contodes", "contresses", "CONTodes", " contENTS", "constents", " contterms", "constends", " content", "contENT", "CONTterms", "CONTends", " Contents", "constENTS", "CONTaves", "contaves", "contterms", "constaves", " contodes", "Contents", " contresses", " contaves", "CONTents", " ContENTS"], "i": ["cli", "mi", "ami", "u", "docker", "iq", "id", "ix", "ini", "I", "us", "ii", "si", "ai", "chain", "bi", "ms", "n", "q", "my", "m", "sim", "me", "ki", "ic", "multi", "it", "ei", "li", "ij", "ti", "j", "span", "xi", "ims", "init", "key", "x", "hi", "ori", "ji", "ie", "phi", "y", "ind", "is", "client", "ui", "iter", "inner", "di", "gi", "oi", "json", "ci", "ip", "ski", "\u0438", "o", "qi", "im", "index", "pi"], "in": ["ins", "din", "en", "ini", "char", "ze", "IN", "inn", "con", "inf", "cin", "bin", "xml", "from", "raw", "by", "re", "and", "add", "sql", "mc", "body", "reader", "ind", "is", "inc", "out", "check", "doc", "input", "source", "r", "inner", "sample", "isin", " din", "read", "In"]}}
{"id1": "442381", "id2": "8166767", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionQuery", "doVersionsUpdate", " doVersionTest", "doBuildCheck", "doFeaturecheck", "doFeatureInfo", "doFeatureQuery", " doVersionQuery", "doImageInfo", "doFeatureCheck", " doApplicationQuery", " doVersionsTest", "doVersionsTest", "doApplicationCheck", "doFeatureUpdate", "doApplicationInfo", "doImageQuery", " doVersionUpdate", " doVersionsUpdate", " doVersioncheck", "doBuildUpdate", "doBuildcheck", "doImageCheck", "doVersionscheck", " doVersionInfo", "doVersionsCheck", "doFeatureTest", "doApplicationQuery", " doApplicationCheck", " doApplicationInfo", " doVersionscheck", "doBuildTest", "doVersionInfo", "doVersioncheck", "doImageTest", " doApplicationTest", "doVersionUpdate", "doVersionTest", " doVersionsCheck", "doApplicationTest"], "view": ["image", "update", "iew", "context", "server", "engine", "VIEW", "v", "port", "model", "show", "self", "window", "review", "ml", "form", "box", "print", "buffer", "q", "cell", "tree", "subject", "block", "eye", "http", "page", "cv", "browser", "report", "query", "document", "file", "layout", "tv", "widget", "controller", "pool", "see", "this", "lock", "call", "client", "check", "display", "h", "View", "virtual", "input", "vm", "manager", "version", "row", "html", "project", "component", "index", "views"], "url": ["loc", "rel", "f", "host", "sl", "ssl", "domain", "gl", "b", "v", "dl", "hl", "char", "bel", "ref", "str", "oul", "ll", "rl", "http", "ul", "nl", "link", "browser", "ur", "URL", "file", "build", "address", "mount", "mail", "client", "pl", "get", "lb", "r", "uri", "Url", "l", "log", "html", "job"], "in": ["f", " IN", "ins", "din", "isin", "stream", "IN", "sin", "inn", "ln", "inf", "cin", "gin", "on", "from", "init", "mn", "body", "ain", "reader", "is", "inc", "can", "out", "rin", "i", "input", "source", "inner", "l", "asin", "mat", "vin", "info", " din", "In", "n"], "bin": ["ins", "din", "jin", "bl", " bins", "lib", "binary", "b", "ran", "abin", "bed", "bn", "stock", "cache", "sin", "inn", "con", "ln", "bi", "cin", "gin", "buffer", "nb", "local", "by", "re", "spin", " Bin", "bg", "all", "session", "init", "thin", "sam", "brain", "file", "body", "cos", "reader", "out", "rin", "win", "len", "inner", "db", "conv", "obin", "rb", "bur", "buff", "cb", " din", "ebin", "mon"], "line": ["column", "cmd", "record", "ine", "field", "stream", "style", "liner", "port", "channel", "eline", "zone", "message", "char", " block", "detail", "string", "ice", "ln", "lo", "le", "chain", "print", "sequence", "cell", "section", "block", "lin", "entry", "rule", "err", "part", "status", "trace", "frame", "tile", "Line", "link", "inline", "page", "stay", "comment", "range", "key", "file", "lane", "code", "base", "word", "iter", "cat", "l", "lines", "row", "parse", "next", "log", "LINE", "sample", "point", "job"], "develBuild": ["deffbuild", "DeVELbuild", "deVELLog", "develRelease", "deVELBuilder", "Develbuild", "depoBuilt", "duvelbuild", "devBoot", "desvelbuild", "desvelRelease", "duffbuild", "depobuild", "depoLog", "develLoad", "duVELBuild", "deVELbuild", "desVELbuild", "deVELBuild", "duffBuilt", "deeltaLoad", "devbuild", "DevelLog", "develbuild", "deffBuilder", "deployBuilt", "DevelBuild", "duvelBuilt", "deffBuilt", "duffBuilder", "deployLoad", "desvelLoad", "develBuilder", "duvelBuild", "duvelBuilder", "deVELBoot", "duvelBoot", "DeVELLog", "deVELLoad", "desVELRelease", "deploybuild", "deployBuilder", "DeVELBuilt", "devBuilder", "develLog", "DevelBuilt", "duffBuild", "deployBoot", "duVELBoot", "duVELbuild", "develBuilt", "DeVELBuild", "deVELRelease", "deeltaRelease", "devBuild", "deVELBuilt", "deeltaBuild", "devBuilt", "deployRelease", "depoBuild", "desVELLoad", "devLog", "desvelBuild", "deployBuild", "deffBuild", "duVELBuilder", "deeltabuild", "develBoot", "desVELBuild"], "stableBuild": ["activeMake", " stableCraft", "activeBuild", "stableBind", " unstableLong", " unstableBuild", "stableBoot", " stableBuilder", " stableMake", " unstablebuild", "stableCraft", "confirmedBoot", "secureBuilder", "devbuild", " stablebuild", " stableBoot", " stableBind", "stablebuild", "secureBuild", "activeBuilder", " unstableBuilder", "confirmedbuild", "confirmedBuild", "stableBuilder", "securebuild", " unstableBind", "devBuilder", "secureCraft", "stableLong", "devBind", " unstableCraft", "devBuild", "devMake", "stableMake", " stableLong", "confirmedLong", "activebuild", " unstableBoot"]}}
{"id1": "8665649", "id2": "18433984", "code1": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"_getImage": [" _getFile", "_getFile", "_buildImage", "_downloadFile", "_getimage", " _downloadImage", " _getimage", "_downloadimage", " _downloadimage", " _getImages", "_getImages", "_buildImages", " _downloadFile", "_buildimage", " _downloadImages", "_buildFile", "_downloadImage", "_downloadImages"], "urlStr": ["mountString", "uriStr", "imageStr", "urlSt", "lString", "uristr", "mountStr", "uriSTR", "lSTR", "imageSTR", " urlString", "mountstr", "mountSTR", "imageSt", " urlSt", "urlString", "urlstr", "lStr", "Urlstr", "imageString", " urlSTR", "uriString", "UrlStr", "UrlString", "UrlSTR", "urlSTR", "lSt"], "url": ["loc", "host", "f", "el", "sl", "ssl", "gl", "org", "https", "atl", "ls", "dl", "api", "char", "bel", "google", "web", "q", "str", "ll", "http", "re", "rl", "ul", "nl", "link", "ur", "URL", "sb", "cert", "build", "base", "client", "pl", "lb", "r", "uri", "Url", "l", "abs", "sur", "parse"], "conn": ["cn", "loc", "rel", "nn", "ann", "cmd", "ssl", "org", "cs", "serv", "jp", "connect", "nc", "enc", "canon", "con", "net", "ctx", "c", "comm", "yn", "gate", "init", "pg", "connection", "res", "Conn", "cert", "nt", "ch", "cp", "open", "client", "cur", "syn", "ctrl", "conv", "db", "conf", "l", "coll", "ct", "pas", "cb", "cont"], "in": ["ins", "din", "en", "stream", "again", "serv", "sum", "IN", "inn", "con", "s", "ai", "user", "io", "gin", "cin", "on", "m", "bin", "xml", "from", "it", "or", "and", "req", "all", "init", "as", "file", "mc", "ma", "body", "act", "reader", "ind", "pid", "is", "inc", "out", "txt", "rin", "doc", "i", "input", "source", "qa", "inner", "oin", "proc", "l", "include", "o", "mat", "t", "ill", "isin", "im", " din", "In"]}}
{"id1": "7981642", "id2": "4895903", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "label": 0, "substitutes": {"update": ["reply", "store", "escape", "move", "data", "delete", "touch", "test", "set", "pack", "mod", "text", "commit", "insert", "post", "load", "remove", "add", "upload", "replace", "apply", "login", "register", "init", "edit", "UPDATE", "change", "updated", "put", "check", "write", "up", "Update", "append", "username", "place", "alter", "config", "create", "auth", "feed", "input", "save", "printf", "sample", "read", "handle"], "mail": ["host", "Email", "del", "el", "cmd", "server", "domain", "id", "old", "port", "com", "dial", "dl", "dn", "grid", "alt", "message", "enter", "ln", "net", "addr", "test", "print", "m", "mm", "imp", "pkg", "Mail", "hold", "eth", "mobile", "http", "link", "mill", "label", "dir", "md", "gmail", "file", "mun", "cert", "address", "msg", "dm", "name", "zip", "mount", "virtual", "pl", "username", "mem", "iter", "mails", "ip", "url", "log", "im", "local", "tp", "n"], "email": ["cn", "host", "Email", "del", "el", "image", "object", "entity", "et", "server", "domain", "dn", "message", "il", "nm", "enter", "external", "atom", "detail", "e", "ln", "addr", "test", "ns", "IL", "m", "xml", "example", "text", "nl", "link", "note", "ilo", "label", "phone", "sql", "file", "address", "name", "zip", "line", "template", "number", "username", "html", "uri", "virtual", "ip", "url", "echo", "log", "sample", "password", "cdn", "date", "n"], "pwd": ["Pfx", " pgen", "pressws", "Pwd", "dpw", "pswd", " pword", " pfx", "pword", "ppriv", "dpwd", "pressw", "pgen", "dpword", "pws", "Ppriv", "pw", "Pw", " pow", "pow", "presspriv", "psfx", "Pgen", " pw", "presswd", "psw", " ppriv", "pfx", "dpgen", "Pow", "Pws", "Pword", " pws", "psow"], "firstname": [" firstrun", " firstnames", "firstNAME", "Firstparent", "firstrun", "smallname", " firstNAME", "firstnames", "lastparent", " firstName", "smallName", "firstparent", " firstparent", "smallNAME", "lastnames", "lastNAME", "Firstnames", "Firstname", "FirstNAME", "smallrun", "FirstName", "firstName", "lastrun", "lastName"], "lastname": ["longame", "firstnum", "fullName", "lastnum", "givenname", "givennum", "longname", "longName", "firstame", " lasttype", "lastame", "givenName", "lasttype", " lastame", "fullname", " lastnum", " lastName", "firsttype", "giventype", "fullame", "longnum", "firstName", "lastName"], "connection": ["context", "engine", "Connection", "connect", "nc", "communication", "relation", "description", "con", "onet", "city", "handler", "database", "network", "conn", "application", "entry", "c", "collection", "resource", "response", "link", "creator", "session", "document", "directory", "connected", "pool", "event", "system", "ion", "client", "cone", "condition", "management", "command"], "attrs": ["actributes", "atries", "atrd", " attrd", " attras", "atributes", "attries", "atrs", "attsrs", "atds", "latters", "latributes", "atras", "atps", "adras", "attachras", "attrys", "addras", "attras", "avrs", " attns", "attsries", "addRs", "attns", "attRs", " attRs", "attachrs", "atRs", "avras", " attps", " attributes", "attsributes", "attrics", "attsras", "addrd", "actrys", "attachRs", "addrs", "attributes", "attds", " attds", "addributes", "attachributes", "adrs", "avrics", "attsrics", "actters", "attsps", "latrs", "attsds", "atrics", "actrs", "atters", "attps", "avributes", "attrd", "atns", "adributes", "latrys", "attters", "atrys", " attries", "adns"], "sha": ["sh", "shell", "git", "alpha", "sum", "ha", "ssh", "total", "lambda", "HA", "tar", "acl", "ya", "has", "func", "iso", "sq", "sche", "ppa", "da", "a", "ka", "ca", " SHA", "hi", "sam", "md", "shared", "ma", "auto", "wa", "cos", "asha", "mb", "pa", "no", "comp", "h", "mem", "mac", "ksh", "SHA", "go", "shi", "sa", "sm"], "digest": ["divest", "mdhest", " digested", "mdse", "Digested", "dests", "divhest", "dest", "Dighest", "redests", "mdests", "divEST", "Digge", "mdested", "dge", "mdEST", "dighest", "digested", "DigEST", "digests", "redest", "redge", " digEST", "digse", "redested", "digge", "divse", "Digest", "Digse", "dested", "mdest", "Digests", "digEST", " digests"], "hash": ["ashes", "ash", "sh", "search", "ASH", "cache", "rh", "sum", "message", "ha", "total", "format", "each", "Hash", "print", "proof", "has", "score", "password", "bh", "tag", "dump", "key", "md", "hex", "base", "flash", "dig", "check", "h", "input", "trust", "auth", "mac", "shadow", "filter", "html", "result", "handle"], "ctx": ["loc", "context", "tk", "co", "cf", "cu", " cx", "rc", "jp", "tc", "nc", "sc", "mk", "con", "kl", "gm", "conn", "sq", "pkg", "dc", "ca", "tz", "cv", "pg", "x", "obj", "mc", "Conn", " context", "gc", "cb", "tmp", "nt", "wx", "cp", "cmp", "kw", "txt", "ctrl", "bc", "conv", "ctr", "ct", "tx", "xc", "np", "cm", "ck", "lc", "Context"], "newName": ["oldNames", " newNAME", "NewNAME", "Newname", "newKey", "finalHome", "currentname", "oldHome", "oldname", " newHome", "finalName", "NewName", "newNames", "newname", "currentName", "newNAME", "NewKey", "finalname", "currentKey", " newNames", " newname", "currentNAME", "newHome", " newKey", "finalNames"], "oldName": ["oldAnd", " oldKey", "oldername", "olderKey", "prevName", "recentName", "smallname", "newAnd", "smallOr", "oldOr", "newOr", "recentAnd", "smallName", " oldname", "oldname", "recentOr", " oldPref", "prevPref", "oldKey", "smallAnd", "olderName", "newname", "recentname", "olderPref", "oldPref", "prevname", "prevKey"]}}
{"id1": "12066447", "id2": "7458833", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"truncate": ["trculize", "trunation", "truncation", "trculicate", "truncicate", "extvalidation", "trunate", "extuncicate", "extvalidicate", "trculation", "trvalidicate", "extvalidize", "truncize", "extuncate", "trvalidate", "trunicate", "trunize", "trculate", "trvalidation", "trvalidize", "extvalidate", "extuncation", "extuncize"], "file": ["f", "image", "object", "port", "work", "model", "class", "channel", "data", "message", "format", "path", "foo", "le", "user", "e", "io", "files", "tree", "block", "from", "or", "File", "resource", "table", "size", "frame", "FILE", "link", "spec", "to", "page", "line", "report", "range", "dir", "attribute", "run", "base", "parent", "be", "event", "name", "lock", "this", "word", "current", "out", "fp", "zip", "ile", "full", "get", "source", "filename", "create", "template", "null", "type", "time", "log", "use", "info", "local", "module", "handle"], "backupRoot": ["BackupidRoot", "backupidroot", "backureDir", "BackupFolder", "BackupRoot", "backureroot", "BackupidFolder", "backupsBox", "backupFolder", "backureRoot", "workupDir", "backumpDir", "backdownFolder", "backmpDir", "backupidBox", "workuproot", "backflowFolder", "backupDir", "backupsroot", "backmproot", "workupidBoot", "workupidHome", "backumpRoot", "backuproot", " backupidDir", "workupRoot", "backupBoot", " backupidroot", "backmpRoot", "workupBoot", "backupidFolder", "workupidDir", "backflowRoot", "BackupidDir", "backdownRoot", "backuperroot", "workupidRoot", "backupBox", "BackupDir", " backupBox", "backumpBox", "backupidDir", "backuperHome", " backuproot", "backupHome", "backuperDir", "backupidHome", "backureBoot", " backupidBox", "backureHome", "backmpBoot", " backupDir", "backumproot", "backupsDir", "backdownDir", "workupHome", " backupidRoot", "backupidBoot", "backflowDir", "backuperRoot", "backupsRoot", "backupidRoot", "workupidroot"], "df": ["f", "pdf", "dd", "dr", "fun", "cf", "bf", "du", "dx", "dt", "uf", "dl", "lf", "format", "tif", "sd", "mm", "pd", "tf", "sf", "ds", "dc", "md", "Def", "dm", "NF", "def", "dep", "dim", "DF", "db", "raf", "deb", "di", "cd", "fd", " pdf", "hd", "d", "gd", "dp"], "date": ["update", "cal", "output", "value", "Date", "when", "match", "today", "dt", "grade", "zone", "dat", "data", "message", "standard", "sum", "format", "string", "content", "ate", "due", "future", "month", "duration", "dated", "resource", " Date", "down", "frame", "note", "day", "range", "year", "tag", " day", "daily", "run", "late", "dates", "name", "event", "number", "get", "create", "age", "start", "version", "default", "time", "save", "now", "module", "days"], "zipFile": ["zipfile", "zipPath", "zipFilename", "jsonFile", "ZipFile", "ZipStream", "zipStream", "ZipPath", "zipStore", "jsonFilename", "pdffile", "zStore", "pdfPath", "Zipfile", "jsonStore", "zFilename", "logStore", "zFile", "pdfStream", "logFile", "logfile", "logPath", "zfile", "jsonfile", "logStream", "logFilename", "pdfFile"], "zos": ["sis", "z", "zan", "css", "hz", "zes", "sch", "zag", "bs", "ros", "enos", "bes", "ze", "hess", "estro", "esm", "zona", "ozo", "ss", "js", "webkit", "asar", "rez", "zen", "zers", "oses", "zik", "south", "tz", "asio", "eros", "zar", "zzle", "sol", " sands", "ses", "zi", "cos", "ez", "zer", "cz", "jas", "enz", "stice", "shed", "oss", "zon", "os", "zb", "Sax", "nz", "hs", "los", "zo", "sbm", "ones", "za", "zin"], "fis": ["ifisc", "FIs", "dfis", "foia", "dfIs", "lia", " fib", "fisc", "sfIs", "lis", "sfisc", "cfisc", "ofib", "fiib", "ofits", "cfits", "foIs", "ef\u00eds", "fiiss", "fIs", "if\u00eds", "fia", "Fis", "ofisc", "sfier", "sfis", "F\u00eds", "fiss", " fiss", "f\u00eds", "foi", "ofiss", " fois", "cfis", "sfiss", "cfiss", "li", "fiois", "sfits", "dfier", "ofis", "ifIs", "efisc", "ifis", "fiis", "Fier", "fits", "dfiss", "fi", "ofois", "fib", "Fisc", "efis", "lIs", "fier", "Fia", "Fiss", "Fi", "fois", "efIs"], "entry": ["object", "entity", "record", "office", "ry", "search", "deep", "data", "char", "description", "ent", "rance", "e", "ment", "delete", "ary", "cell", "member", "section", "xml", "set", "or", "resource", "insert", "option", "and", "add", "de", "tex", "comment", "attribute", "key", "sheet", "connection", "obj", "ie", "event", "zip", "word", "element", "ion", "def", "cue", "ace", "se", "internal", "row", "ce", "Entry", "zo", "command", "escape"], "buffer": ["length", "letter", "header", "binary", "cache", "screen", "message", "window", "char", "buf", "queue", "stack", "phrase", "sequence", "block", "zero", "view", "button", "volume", "table", "frame", "bar", "available", "page", "comment", "category", "paste", "attribute", "document", "batch", "code", "library", "base", "word", "append", "template", "memory", "iter", "variable", "Buffer", "padding", "buff", "sample", "command", "temp"], "readed": ["READd", "indexED", "indexed", "readied", "Readared", "Readied", "reded", "READed", "countED", "findED", "readared", "readableED", "counted", "readented", " readED", "indexented", "READer", " readented", "readableed", "Readed", "countd", "readd", "Reader", "reader", "counter", "indexeded", "Readd", "redented", "rededed", "ReadED", " readeded", "redED", "readableied", "findied", "readeded", "READED", "findared", "readED", "readableared", "finded"]}}
{"id1": "21656668", "id2": "732800", "code1": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"copyResourceToFile": ["copyResourcetoPath", "copyResourceFileFiles", "copyResourcetoFile", "copyResourceToFiles", "copyStringtoFILE", "copyStringToFILE", "copyStringtoFile", "copyResourceFromFILE", "copyStringToFile", "copyResourceFileFile", "copyResourceFromFiles", "copyResourcetoFiles", "copyResourceFromPath", "copyResourceToFILE", "copyResourcetoFILE", "copyStringtoPath", "copyResourceFileFILE", "copyResourceFromFile", "copyStringToFiles", "copyResourceToPath", "copyStringToPath", "copyStringtoFiles", "copyResourceFilePath"], "resourceFilename": ["fromSourceFile", "resourceWriter", "sourceTitle", "sourceFile", "fileFile", "sourceWriter", "resourceFile", " resourceSourceFile", "resourceTitle", "fromFile", "fileFilename", "fileTitle", " resourceWriter", "fromName", "fileWriter", "sourceName", " resourceName", "resourceSourceFile", "sourceSourceFile", " resourceFile", " resourceTitle", "resourceName", "fromFilename", "sourceFilename"], "destinationFilename": ["destificationFile", "declificationFILE", "destinationFile", "destificationfilename", "DestificationFile", "destinatedFile", "destinationFILE", "destinedFil", "destificationFILE", "DestinationFile", "destinedSourceFile", "declificationFilename", "declinationfilename", "DestificationFilename", "destinatedSourceFile", "destificationFilename", "declinationSourceFile", "destificationSourceFile", "declinationFilename", "destinedFile", "DestificationSourceFile", "declificationSourceFile", "destinatedFil", "destinationFil", "DestinationSourceFile", "DestificationFil", "destinatedfilename", "destificationFil", "DestinationFilename", "destinalFilename", "destinationSourceFile", "destinalFILE", "declinationFILE", "destinedFilename", "destinalfilename", "destinatedFilename", "destinatedFILE", "declificationfilename", "destinationfilename", "destinalSourceFile", "DestinationFil"], "inStream": ["inSource", "inInterface", "linSteam", "outStreamer", "INStream", "innerSteam", "inputForm", "InStream", "InInterface", "InSteam", "inIterator", "outInterface", " inSource", "inSteam", "linStream", "INStreamer", "innerStream", "inputSteam", "inStreamer", "outSteam", "inputStream", "innerForm", " inSteam", " inInterface", "INSteam", "inForm", "insForm", "outSource", "InForm", "inputSource", " inForm", "insStream", "innerStreamer", " inIterator", "linForm", "insStreamer", "insSteam", "outForm", "linIterator", "INForm", "inputIterator"], "outStream": ["outputStream", "netStreamer", "outStreamer", "exStreamer", "oustream", "netStream", "outputstream", " outStreamer", "inSteam", "netForm", "inStreamer", "outSteam", "ouSteam", "exForm", "instream", "inForm", " outstream", "exSteam", "exStream", "outputForm", "outputSteam", " outSteam", "outForm", "ouStream", "outputStreamer", "netSteam", "ouStreamer", "outstream", " outForm"]}}
{"id1": "6371607", "id2": "23620712", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"removeRealm": ["remRealarm", "removePerM", "remRealM", "removerealarm", "remrealmo", "remrealm", "removerealmo", "removeRealM", "removeScheM", "removeAlms", "remrealarm", "removeRealmo", "removeRealarm", "removerealms", "removeAlarm", "removePermo", "removeSchem", "remRealmo", "remrealms", "removerealm", "removePerms", "removerealM", "remRealm", "removePerm", "remRealms", "removeAlm", "removeRealms", "removeSchemo", "removePerarm", "removeSchems", "remrealM", "removeAlmo"], "realmIds": ["realmsIdNames", "realmPathParts", "realmIDList", "realmsByIds", "realmIDs", "realmsIdParts", "realmsByIdids", "realmsIds", "realmidsls", "realmIdNames", "realmPathls", "realmByIdNames", "realmidsids", "realmsByIdNames", "realmsByIdls", "realmPathids", "realmIDNames", "realmsIdls", "realmByIdls", "realmsIdList", "realmidss", "realmIdParts", "realmByIdParts", "realmByIdList", "realmsIdids", "realmsByIdList", "realmidsList", "realmIDls", "realmIdList", "realmByIdids", "realmIdls", "realmidsParts", "realmIdids", "realmidsNames", "realmPaths", "realmsByIdParts", "realmByIds"], "psImpl": ["PSEl", "epsimpl", "ppsStack", " psInstance", "ppsEl", "ppsExpl", "pseInstance", "psObj", "psStack", "ppsImpl", "epsImpl", "pseEl", "ppsInstance", "pseImpl", " psStack", "epsExpl", "epsObj", "ppsimpl", " psExpl", "PSimpl", "PSImpl", "PSExpl", " psEl", "psimpl", "PSObj", "pseStack", "psInstance", " psObj", "psEl", " psimpl", "psExpl"], "iter": ["loc", "iv", " iterator", "iz", "ipper", "gener", "ir", "ger", "upper", "er", "gen", "cer", "ev", "iterator", "ait", "iller", "oper", "lim", "valid", "fer", "walker", "it", "vers", "li", "inv", "ter", "ator", "ser", "iner", " iv", "ver", "ptr", "ori", "hex", "vis", "per", "ind", "nr", "older", "inter", "liter", "loop", "ner", "i", "former", "her", "ip", "coll", "ider", "its", "Iter", "outer"], "realmId": ["RealmId", "realomReference", "realMPath", "realgmId", "trmID", "trvInd", "palmid", "pallemid", "reallemID", "realvmid", "realmeId", "reallemid", "pallemInt", "realvInd", "trvID", "trmId", "realmPath", "realnPath", "RealmById", "RealmRef", "realmID", "realgmid", "realmIs", "realomInd", "trmInd", "realmanReference", "realmeInt", "realmiInt", "balmid", "realnRef", "realmanId", "realvId", "realvReference", "realvID", "realvmId", "pallemID", "realomID", "realmiid", "realmanID", "realomId", "realmiID", "realmeID", "RealMPath", "reallemId", "realgId", "RealMById", "trmReference", "RealmPath", "RealMRef", "balgmid", "realmiId", "realvmIs", "realmById", "balmID", "palmInt", "pallemId", "trvReference", "realmInt", "realMRef", "realnId", "realgmIs", "balgmID", "realMId", "realvmID", "reallemInt", "realgRef", "balmIs", "realmiIs", "realgById", "realMById", "balgmIs", "palmID", "realmanInd", "realgmID", "palmId", "balmId", "realmRef", "realmInd", "trvId", "realgPath", "realmReference", "realmeid", "RealMId", "realnById", "balgmId", "realmid"]}}
{"id1": "21125261", "id2": "13152325", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"test": ["evaluate", "server", " sample", "show", "launch", "feature", "Test", "example", "debug", "load", "read", " tests", "run", "execute", "testing", "unit", "train", " testing", " evaluate", "t", "sample", "volt", "fit", "hello", "T", "tests"], "is": ["isa", "sis", "fs", "xs", "lis", "ri", "stream", "rs", "ris", "bs", "are", "serv", "ls", "isi", "us", "s", "ai", "sys", "ms", "iso", "xml", "in", "has", "tis", "sit", "as", "IS", "mis", "Is", "out", "isc", "does", "i", "input", "es", "os", "ais", "its", "ws", "ps", "ios"], "byteArrayOutputStream": ["byteArrayOutputString", "byteArrayApplicationSteam", "byteStreamOutputStream", "byteStreamInputStyle", "byteArrayApplicationStyle", "byteStreamOutputForm", "byteArrayoutputForm", "byteArrayByteSteam", "byteArrayInputSteam", "byteStringoutputSteam", "byteArrayOutputForm", "byteStreamOutputStyle", "byteStringOutputForm", "byteArray4Steam", "byteArrayByteString", "byteStringOutputSteam", "byteArray4Stream", "byteArrayInputStyle", "byteStreamInputStream", "byteArrayOutputSteam", "byteStringoutputForm", "byteArrayApplicationStream", "byteStringInputString", "byteArrayoutputSteam", "byteStringoutputString", "byteArrayByteStyle", "byteArrayByteView", "byteArray4String", "byteArray4View", "byteStringOutputStream", "byteStreamInputForm", "byteArrayInputView", "byteArrayApplicationForm", "byteArrayInputString", "byteStreamInputSteam", "byteStringOutputView", "byteStringInputStream", "byteStringOutputString", "byteStreamOutputSteam", "byteArrayByteForm", "byteArrayInputStream", "byteStringoutputStream", "byteArrayoutputString", "byteArrayOutputStyle", "byteArrayByteStream", "byteStringInputView", "byteStringInputSteam", "byteArrayInputForm", "byteArrayOutputView", "byteArrayoutputStream"], "def": ["del", "crit", "dl", "dec", "dal", "dict", "sd", "ded", "Definition", "definition", "sche", "da", "ds", "define", "DEF", "ef", "de", "dem", "des", "md", "dev", "df", "Def", "det", "pro", "DE", "db", "conf", "cd", "json", "defined", "decl", "default", "desc", "hd", "d"], "se": ["sl", "pe", "engine", "ine", "ese", "sea", "we", "ze", "te", "ge", "ae", "e", "spe", "ve", "ne", "le", "sd", "me", "set", "ode", "sec", "sche", "he", "ke", "de", "sem", "ser", "ane", "ade", "ses", "so", "ie", "est", "she", "be", "sp", "sed", "see", "SE", "pse", "su", "ide", "ste", "Se", "es", "sel", "ene", "ase", "ense", "parse", "ce", "ee", "sa"], "linkId": ["lineId", "LinkName", " linkID", "linkedId", "linkid", "Linkid", "chainID", "connectionId", "chainId", "linkedIdent", "connectionIdent", "lineid", "LinkID", " linkid", "lineID", "chainIdent", "linkedID", "lineName", "connectionID", "LinkId", " linkName", "linkID", "linkName", "linkIdent"], "segmentId": ["idegmentId", "semissionName", "idegmentRef", "segmentID", "sementId", "segroupId", "begmentById", "segmentRef", "begmentID", "idegementid", "begroupID", "sementid", "segementId", "segementID", "sementRef", "idegmentid", "sementById", "segmentName", "segementById", "semissionId", "begmentName", "begroupName", "segroupById", "semissionid", "semissionRef", "segmentid", "segroupID", "segementid", "begroupId", "begroupById", "segementName", "idegementId", "segroupName", "segmentById", "sementName", "segementRef", "sementID", "idegmentName", "idegementRef", "idegementName", "begmentId"], "linkSegments": ["linkConnectlements", " linkSegroups", "linkFragment", "linkBuildgments", " linkBuildets", " linkSeggments", " linkGroups", " linkThreadroups", "linkConnectables", "linkFragments", "linkGments", "linkGroups", "linkThreadgments", " linkSeglements", "linkFraggments", "linkBuildets", "linkSeables", "linkBuildment", "linkParments", "linkSegets", " linkSegables", "linkConnectroups", "linkSeets", " linkThreadgments", "linkGment", " linkBuildables", " linkGment", " linkGgments", "linkParroups", "linkSegables", "linkBuildables", "linkBuildments", "linkThreadlements", "linkSeggments", " linkSegets", " linkBuildments", "linkSements", "linkSegment", "linkBuildroups", "linkThreadments", "linkThreadroups", "linkSeglements", "linkSegroups", "linkConnectets", "linkConnectments", " linkGments", "linkParlements", " linkThreadlements", "linkFragroups", " linkBuildgments", " linkThreadments", "linkConnectgments", "linkGgments", "linkPargments", " linkSegment"], "segments": [" Seges", "selements", " Sements", "vegments", " segs", "usegments", "parsegments", "usegs", " sements", " Segments", "segins", "sements", "usements", "bements", "megments", "bevals", " segins", "parselements", "sectors", "megins", "sevals", " sevals", "velements", "megs", "vectors", " sectors", "begments", "beges", " selements", "parsements", "parsectors", "vements", " seges", "mements", "usegins", "segs", "seges", " Sevals"], "frameProperties": ["frameParps", "framePropptions", " framePrps", " frameByperties", " framePrperties", " frameProps", "framePrrics", "frameParptions", "frameByps", "framePropps", "frameProilities", " frameByps", "frameProptions", "frameParrics", "framePrptions", "frameComrics", "frameProfperties", " framePrrics", " frameProrics", "framePrps", "frameByilities", " frameProilities", "frameParperties", "framePropperties", " frameByilities", "framePropilities", "frameByperties", " framePrptions", "frameProfilities", "frameProfps", "frameProrics", "frameComptions", "frameProfptions", "frameComps", "frameProps", "frameByptions", "frameComperties", " frameByptions", "framePrperties", " frameProptions"], "time": ["length", "distance", "context", "etime", "runtime", "value", "frequency", "money", "date", "slow", "count", "message", "task", "window", "speed", "each", "total", "TIME", "tim", "times", "sequence", "delay", "duration", "set", "ime", "timeout", "trace", "size", "step", "ts", "clock", "year", "transform", "x", "event", "before", "depth", "system", "check", "counter", "trust", "think", "start", "version", "Time", "rate", "t", "second", "tx", "point", "timer", "now", "tt", "estamp"], "vehicle": ["vertocity", "Vehicles", "vericle", "vehICLE", "vehic", "survogram", "verticles", "Vehic", "ventic", "survocity", "heroICLE", "yardogram", "vehogram", "vehocity", "heroicle", " vehICLE", "venticle", "vehicles", "heroocity", "vertic", "venticles", "survendor", "heroicles", "verticle", "VehICLE", "verogram", " vehicles", "Vehicle", "survicle", "yardendor", "Vehocity", "yardicle", "ventocity", "yardocity", "verocity", " vehocity", "vehendor", "verendor"]}}
{"id1": "19849797", "id2": "12380475", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", "transferFile", "copyfile", " cpFile", " copyFiles", " cpfile", " cpFiles", "copyFiles", " copyStream", "transferStream", " cpStream", " copyfile", "transferFiles", "transferfile"], "sourceFile": ["sourcePage", " sourceTable", " sourceField", "ourceFile", " sourceLine", " sourcePath", "srcField", "srcLine", "sourcePath", "sourceLine", "srcfile", "ourcePage", "srcTable", " sourcePage", "sourceField", "srcPage", "srcFile", "ourceTable", "srcPath", "sourcefile", "sourceTable", "ourcefile", "ourcePath", "ourceField", " sourcefile", "ourceLine"], "destFile": ["srcDir", "datFiles", "destFilename", "datPlace", "optPath", "restFiles", "DestFilename", "optFilename", "declEntity", "destDir", "optDir", "restFile", "restFilename", "optEntity", "destFolder", "optFolder", "datFile", "restPlace", "destPath", "DestDir", "declDir", "destFiles", "datFilename", "destPlace", "destEntity", "DestFiles", "declFile", " destPlace", "optFile", " destFilename", "DestPath", " destDir", "srcFiles", "srcFile", "srcEntity", "DestFile", "declFolder", " destPath", " destFiles", "srcFolder", "srcPath"], "source": ["image", "update", "scope", "copy", "store", "search", "stream", "shell", "style", "SOURCE", "match", "channel", "scale", "show", "standard", "char", "service", "back", "iterator", "cause", "target", "owner", "origin", "sequence", "ource", "src", "subject", "local", "from", "in", "slave", "resource", "OURCE", "load", "score", "table", "spec", "note", "comment", "attribute", "init", "query", "console", "missing", "ie", "body", "proxy", "parent", "force", "none", "reader", "before", "check", "input", "se", "iter", "inner", "create", "start", "parse", "Source", "sample", "ce", "series", "use", "pose", "component", "index", "send", "result"], "destination": ["destinator", "noninated", "terminined", " destinated", " destinator", "separination", "restinator", "restinated", "noninator", "noninate", " destinate", "descation", "Destination", "terminination", "verinated", "decination", "decined", "verination", "Destinated", "separment", "separinated", "Destinator", "Destment", "destined", " destment", "destinate", "destation", "destificate", "Destation", " destation", "descinate", "decinated", "termininated", "descination", "destment", "nonination", "Destificate", "descinator", "termininate", "restination", "restinate", " destificate", "verificate", "separation", "decinate", "destinated", "veration", " destined", "Destinate"]}}
{"id1": "19687456", "id2": "18696387", "code1": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"testReadPerMemberSixSmall": [" testReadPermemberSixLarge", " testReadPerMembersixsmall", " testReadPerMembersixMember", " testReadPermemberSixsmall", " testReadPerMemberEightSmall", " testReadPerMemberEightMember", " testReadPermemberSixSmall", " testReadPermemberEightLarge", " testReadPermemberEightMember", " testReadPerMembersixLarge", " testReadPerMemberEightsmall", " testReadPermemberEightSmall", " testReadPerMembersixSmall", " testReadPermemberSixMember", " testReadPerMemberSixLarge", " testReadPerMemberEightLarge", " testReadPerMemberSixMember", " testReadPerMemberSixsmall", " testReadPermemberEightsmall"], "gzin": ["cliin", "gifin", "gtIN", "gifcin", "gifIn", "gdin", "gifins", "gtcin", "gzgen", "gdinner", "respin", "gifadd", "cliins", "gzvin", "gilcin", "gilisin", "gdins", "qusisin", "gcIn", "gzcin", "gzinner", "zagins", "gcins", "urgIN", "qusin", "gtnin", "cfgins", "gtgen", "zagin", "zaggen", "ctxin", "zagnin", "znin", "quscin", "gcin", "zipcin", "zagadd", "ctxins", "gzisin", "zipisin", "gifIN", "gzIN", "gzpin", "gcIN", "ctxIN", "gdcin", "zagcin", "gtin", "gtins", "gzins", "zgen", "gzadd", "urgins", "gilpin", "zaginner", "respvin", "cfgin", "gtIn", "gilin", "urgin", "gilvin", "gifinner", "cfgcin", "cfgadd", "zipin", "cliIN", "gzIn", "resppin", "zagvin", "gznin", "zagpin", "zcin", "zin"], "i": [" j", "u", "go", "id", "pi", "p", "ix", "v", "ex", "ini", "wait", "us", "ii", "ai", "chain", "print", "ms", "n", "q", "m", "sim", "me", "ic", "multi", "it", "li", "j", "mill", "init", "x", "batch", "phi", "y", "ind", "is", "client", "ui", "gu", "di", "gi", "ci", "ip", "qi", "im", "index", "I"], "count2": ["found4", "ount5", " count4", "ount2", "count1", "Count1", " countTwo", "count4", "count5", "countTwo", " count1", "found2", "const2", " count5", "constTwo", "found1", "ountTwo", "const5", "Count2", "Count4"], "count3": ["command43", "ountthree", "currency3", "count313", "trustthree", "trust43", "currencyThree", "command3", "ountThree", "count43", " count313", "countThree", "ount313", "currencythree", " countthree", "trust3", " countThree", "ount43", "currency313", "ount3", "countthree", "commandthree"], "countEnd": ["CountBegin", "foundBegin", "foundEnd", "ountEnd", "detailEND", "countBegin", "ountend", "CountEND", " countBegin", " countend", "CountEnd", "countEND", "foundEND", "detailBegin", "ountBegin", "detailEnd", "foundend", "ountEND", "detailend", " countEND", "Countend", "countend"]}}
{"id1": "13152325", "id2": "539195", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"loadExistingAntlibs": ["loadExistingAntlibFiles", "loadExistingantLibz", "loadExistingantlibs", "loadExistingAntLibFiles", "loadExistingantlibz", "loadExistingAntribFiles", "loadExistingAntlibz", "loadExistingAntibz", "loadExistingAntribz", "loadExistingAntribd", "loadExistingAntibd", "loadExistingantlibFiles", "loadExistingAntibs", "loadExistingAntibFiles", "loadExistingAntLibd", "loadExistingAntribs", "loadExistingantLibFiles", "loadExistingantLibd", "loadExistingantlibd", "loadExistingAntlibd", "loadExistingantLibs", "loadExistingAntLibs", "loadExistingAntLibz"], "classLoader": [" classLoad", " classReader", " ClassPath", "classReader", "classLoad", "Classloader", " Classloader", " ClassLoader", " classPath", "ClassPath", "classPath", "classloader", " ClassReader", "ClassReader", "ClassLoader", " classloader", " ClassLoad", "ClassLoad"], "antlibUrl": ["antsliburl", "antLibUr", "antLibStr", "antdbURL", "AntlibURL", "antlabUrl", "antslibUr", "antslibRel", "antdburl", "antsLiburl", "antLibURL", "antsLibUr", "antslibStr", "antappURL", "antLibUrl", "antriburl", "antappUrl", "AntLibUr", "AntLibUrl", "antlibStr", "antliburl", "AntlibUr", "antappUr", "antribUr", "antlibraryURL", "antLibRel", "antsLibUrl", "antlibraryUr", "antsLibURL", "antsLibRel", "antappRel", "antlabStr", "antlaburl", "antlibURL", "antlibraryStr", "antlibUr", "antdbUrl", "AntlibUrl", "antdbUr", "Antliburl", "antlabUr", "antlibraryurl", "antlibraryUrl", "antslibUrl", "antribUrl", "antslibURL", "antribURL", "antLiburl", "antlibraryRel", "antlibRel", "AntLibURL", "AntLiburl", "antsLibStr"], "antlibUri": ["antlibEis", "antLibUtpi", "antlibUtrid", "antLibUtris", "antlibEUris", "antlibraryUne", "antlibIri", "antLibUpi", "antlibEUri", "antlibUtmi", "antlibUsr", "antlibEURI", "antlibEUpi", "antlibUURI", "antlibURris", "antlibIrid", "antlibURRI", "antLibIri", "antLibUtri", "antlibUtRI", "antlibUtris", "antlibUris", "antlibraryUsne", "antlibraryUsmi", "antlibraryUsri", "antlibEri", "antlibraryUmi", "antlibUne", "antlibUr", "antlibUpi", "antLibUis", "antlibURI", "antlibIis", "antlibUsmi", "antLibUris", "antlibUsURI", "antlibURri", "antlibUmi", "antlibUsis", "antlibUtri", "antlibIRI", "antlibraryUsRI", "antlibUsRI", "antlibOr", "antlibOne", "antlibraryUr", "antLibUri", "antlibURmi", "antLibIURI", "antlibIpi", "antlibUis", "antlibUsris", "antlibIURI", "antLibIis", "antlibGerid", "antlibUrid", "antlibIne", "antlibraryUsr", "antlibraryURI", "antlibUsne", "antLibURI", "antLibIrid", "antlibUsri", "antlibraryUris", "antlibOris", "antlibGeris", "antLibUURI", "antlibOri", "antlibraryUri", "antlibUtpi", "antlibGeri", "antLibUrid", "antLibIris", "antlibIr", "antlibEris", "antLibIRI", "antlibraryUsris", "antlibIris", "antlibGeRI"], "resources": ["iers", "checks", "ions", "writers", "models", "values", "rs", "maps", "classes", "events", "Resources", "builders", "ues", "types", "files", "actions", "links", "packages", "issues", "relations", "headers", "ries", "images", "users", "works", "books", "reports", "res", "workers", "seconds", "objects", "dates", "services", "modules", "keys", "archives", "pages", "stores", "states", "ples", "ports", "parents", "bytes", "names", "groups", "roots", "years", "these"], "url": ["loc", "f", "rel", "host", "el", "sl", "ssl", "server", "gl", "location", "ls", "dl", "char", "format", "service", "bel", "github", "string", "path", "web", "ref", "lr", "addr", "str", "ll", "xml", "entry", "request", "resource", "http", "rl", "li", "add", "nl", "link", "browser", "ur", "key", "URL", "file", "base", "address", "name", "mount", "get", "source", "r", "lb", "Url", "l", "abs", "util", "remote", "date"], "stream": ["context", "progress", "Stream", "sl", "store", "channel", "data", "message", "standard", "window", "content", "iterator", "ream", "path", "io", "user", "stack", "buffer", "sw", "loader", "view", "resource", "response", "socket", "file", "console", "body", "pipe", "zip", "open", "system", "client", "out", "source", "feed", "input", "inner", "row", "sample", "history", "read"], "reader": ["length", "readable", "dd", "server", "ri", "liner", "upper", "instance", "er", "review", "iterator", "driver", "handler", "buffer", "parser", "via", "entry", "loader", "layer", "volume", "writer", "rl", "resource", "reads", "runner", "collection", "reading", "socket", "ro", "READ", "range", "query", "file", "console", "reviewed", "per", "Reader", "rr", "rx", "rar", "client", "older", "ner", "r", "input", "iter", "inner", "rer", "row", "roller", "sample", "read"], "line": ["column", "sl", "ine", "pe", "header", "liner", "online", "port", "ls", "lf", "eline", "profile", "message", "string", "ln", "lo", "le", "print", "cell", "n", "buffer", "str", "block", "lin", "entry", "text", "li", "frame", "nl", "Line", "inline", "link", "page", "stay", "comment", "range", "label", "sql", "file", "body", "msg", "pos", "word", "len", "iter", "l", "row", "lines", "next", "log", "sample", "LINE", "point", "handle"], "pkg": ["quote", "patch", "lang", "var", "p", "perm", "port", "dl", "kid", "pair", "Package", "path", "ctx", "packages", "pt", "entry", "pack", "pp", "gp", "imp", "mod", "ppa", "part", "col", "alias", "jar", "req", "dir", "prefix", "fx", "init", "pg", "key", "kg", "msg", "pod", "cp", "rpm", "pid", "zip", "mask", "family", "name", "cmp", "wd", "deb", "ip", "root", "password", "lib", "module", "plugin"], "uri": ["cli", "folder", "mi", "domain", "uid", "ri", "id", "location", "profile", "api", "io", "handler", "URI", "term", "resource", "http", "link", "ur", " URI", "connection", "file", "uu", "proxy", "address", "library", "directory", "reference", "base", "iri", "system", "ui", "i", "source", "ip", "util", "local", "pi"], "resource2antlib": ["resource2AntLib", "resourcetoantconfig", "resource2antloc", "resource2boltlib", "resource2Antli", "resource2ANTloc", "resource2agentib", "resource2Antib", "resource2ntlibrary", "resource2boltib", "resource2agentlibrary", "resource2ANTlib", "resource2antlibrary", "resource2ntli", "resource2antli", "resource1agentlibrary", "resource1agentib", "resource2boltloc", "resource2Antlib", "resource2etlib", "resource2etLib", "resourcetoANTlib", "resource2antsconfig", "resource1antlib", "resourcetoantloc", "resource2ntLib", "resource2ANTib", "resource2ntlib", "resource2agentLib", "resourcetoANTloc", "resource2antsloc", "resource1antib", "resourcetoANTib", "resource2antconfig", "resource2etlibrary", "resource2etli", "resource2Antlibrary", "resource1agentLib", "resource2ANTconfig", "resource1antLib", "resourcetoantlib", "resource2antslib", "resource2agentlib", "resource1agentlib", "resource2antLib", "resource2antib", "resource2ntib", "resource2boltconfig", "resourcetoantib", "resourcetoANTconfig", "resource1antlibrary", "resource2antsib"]}}
{"id1": "4118412", "id2": "11377441", "code1": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"compress": ["compact", " complate", "ompract", "encress", "Compose", "ompact", "suppressed", "suppress", " compose", "suppact", "Complate", "Compression", "encract", "encact", "encrypt", "compressed", " compression", "complate", "omplate", "Comprypt", "Compressed", "suppression", "Compress", "ompress", "ompressed", "compression", "Compact", "omprypt", "ompose", "ompression", "Compract", "compract", "compose", "comprypt"], "outputFile": ["outputFiles", "outputStream", " outputFiles", "outDir", " outputDir", " outputfile", "sourceStream", "outputString", "outputPath", "outFormat", "sourceFile", "connectionFILE", "connectionFile", " outputFilename", " outputPath", "inputPath", "inputfile", "outputPage", "OutputDir", "outputFILE", "publicFILE", "OutputFile", "outputDir", "putStream", "putFile", " outputString", "putPage", "inputString", "outPath", " outputFormat", " outputFILE", "outfile", "inputStream", "putPath", "outFiles", "putFormat", "inputPage", "inputFormat", "Outputfile", "OutputString", "outFilename", "publicFile", "outputfile", "outputFilename", "inputDir", "OutputFiles", " outputStream", "outStream", "OutputFilename", "putfile", "inputFilename", "sourceFormat", "outFile", "sourcefile", "publicPath", "connectionPath", "outputFormat", " outputPage", "OutputPath", "inputFile"], "inputFiles": ["outputFiles", "outputItems", "InputFiles", " incomingfiles", " inputResources", " incomingFiles", " inputTopics", " incomingTopics", " inputItems", "Inputfiles", "currentItems", " inputfiles", " incomingFile", "currentfiles", "inputfiles", "inputTopics", "currentResources", "inputResources", " inputFile", "outputfiles", "InputFile", "inputFile", "outputResources", "InputTopics", "inputItems", "currentFiles"], "log": ["progress", "Log", "el", "cmd", "crit", "cal", "output", "store", "og", "en", "shell", "exp", "low", "ex", "message", "order", "path", "net", "pers", "le", "print", "lo", "cell", "blog", "pel", "err", "xml", "debug", "set", "entry", "ll", "error", "trace", "writer", "bar", "skip", "report", "sql", "console", "lex", "LOG", "msg", "lv", "zip", "lock", "line", "mail", "display", "ob", "write", "pl", "def", "loop", "mem", "db", "conf", "l", "json", "row", "url", "printf", "and", "job", "w"], "absPath": ["abP", " absPort", "httpsPath", "expath", "AbsRoot", "ascUrl", "absoluteLog", "exPath", "abcPal", "AbsUrl", "abisLog", "AbsP", "ascPod", "httpsP", "AbsDir", "abPh", "absChain", "absolutePod", "httpsUrl", "ascLog", "absPal", "httpsDir", "Abspath", " absP", "abUrl", "AbsPatch", "exPort", "AbsPath", "abisPal", "exP", "absPh", "abPatch", "abcLog", "absPod", "acsP", "absoluteRoot", "AbsPod", "abDir", "absRoot", "absoluteUrl", "abcChain", "AbsPort", "absPatch", "abPath", "abLog", "absolutePath", " abspath", "httpsPoint", "acsPoint", "absP", "abspath", "abPal", "acsPath", "abisChain", "abChain", "absPoint", "abcPath", "acsPh", "httpsPh", "absDir", "absPort", "absoluteP", "abPoint", "abisPath", "absUrl", "AbsLog", "httpsPatch", "abRoot", "ascPath", "absLog"], "out": ["copy", "output", "OUT", "en", "co", "gr", "com", "ex", "cache", "we", "sum", "list", "con", "net", "io", "sys", "n", "outs", "it", "by", "writer", "OU", "ou", "to", "all", "obj", "gc", "console", "auto", "op", "cos", "client", "write", "up", "oss", "one", "os", "null", "o", "end", "t", "Out", "at", "outer", "can"], "buffer": ["length", "initial", "column", "output", "value", "header", "binary", "cache", "channel", "message", "window", "char", "buf", "sequence", "stack", "phrase", "block", "limit", "table", "frame", "bar", "paste", "shape", "document", "batch", "library", "base", "word", "append", "template", "memory", "source", "input", "iter", "row", "variable", "Buffer", "parse", "buff", "sample", "password", "command", "index", "history", "read"], "readBytes": ["writeBytes", "readableBytes", "findValues", "readableContents", "findbytes", "readByte", "writeTokens", "countBytes", "readContents", "countValues", "readTokens", " readTokens", " readbytes", "writeValues", "findByte", "readValues", "Readbytes", "writeContents", "findBytes", "readbytes", "ReadBytes", "readableValues", " readByte", " readValues", "countbytes", "ReadByte", " readContents", "countByte", "readableTokens", "ReadValues"], "file": ["f", "image", "entity", "field", "id", "model", "channel", "language", "data", "message", "relation", "format", "string", "path", "e", "le", "print", "files", "block", "rule", "from", "entry", "request", "File", "part", "http", "table", "FILE", "tile", "link", "page", "key", "document", "run", "base", "name", "line", "ile", "source", "input", "filename", "type", "url", "sample", "info", "local"], "in": ["ins", "din", "el", "inside", "en", "IN", "rec", "sin", "inn", "con", "ai", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ic", "it", "and", "init", "mc", "al", "per", "reader", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "isin", "info", "local", "read", "In"], "normalSize": [" normalLength", " normalTime", "standardsize", "commonFontSize", "minTime", "normalName", "commonAge", "commonsize", "normalFontSize", "NormalLength", "NormalName", "normalTime", "normName", "NormalSize", "normalsize", "normTime", "NormalTime", "normLength", "standardFontSize", "examplesize", "minName", "standardSize", "minNumber", "exampleAge", "standardAge", "normalAge", "NormalNumber", "exampleFontSize", "exampleSize", "normNumber", "normSize", "normalNumber", " normalName", "commonSize", "normalLength"], "builder": ["operator", "built", "b", "der", "bean", "bo", "alph", "message", "builders", "driver", "web", "order", "handler", "Build", "parser", "block", "loader", "building", "or", "by", "writer", "bridge", "runner", "bar", "worker", "control", "creator", "browser", "ler", "build", "library", "base", "framework", "BU", "client", "full", "Builder", "manager", "hub", "keeper", "make", "uild", "command", "job", "result"], "process": ["processor", "cmd", "object", "exec", "node", "Process", "position", "job", "script", "class", "count", "task", "connect", "thread", "service", "processing", "program", " Process", "pm", "term", "frame", "and", "session", " program", "run", "function", "code", "execute", "pid", "this", "call", "check", "cess", " processes", "proc", "condition", "parse", "success", "make", "command", "component", "result"], "minSize": ["maxBytes", "minStatus", "MinStatus", "minScreen", "MINBytes", "maxSize", "MinBytes", "minBytes", "MINSize", "MinScreen", "minLength", "maxLength", "MINStatus", "MinLength", " minLength", " minScreen", " minStatus", "maxScreen", "MINLength", " minBytes", "MinSize"], "diff": ["div", "distance", "update", "del", "rel", "mix", "different", "length", "same", "Delta", "equal", "Diff", "dx", "iff", "dis", "dl", "erence", "sd", " Diff", "delete", "delay", "resp", "eff", "size", "add", "dist", " difference", "range", "dev", "missing", "change", "def", "cmp", "split", "comp", "changed", "deb", "exc", "fail", "desc", "dust", "d", "draw", "between"], "percentage": ["repAGE", " percentager", "repages", " percentade", "voltager", " percentAGE", " percentability", "taxager", "taxade", " percentages", "percentages", "taxure", "percentager", "percentade", "repability", "repage", "Percentability", "Percentages", "voltade", "Percentage", "taxage", "percentAGE", " percenture", "PercentAGE", "voltage", "volture", "percentability", "percenture"], "diffSize": ["rangeSize", "rangeLength", "resultSize", " diffFontSize", " diffsize", "resultLength", "DiffLength", "dustSIZE", "DiffFontSize", "diffFontSize", " diffSIZE", "dustPrice", "rangeSIZE", "diffsize", "diffSIZE", "diffPrice", "resultsize", "dustSize", " diffPrice", "resultFontSize", "dustLength", "rangePrice", "Diffsize", "diffLength", "DiffSize", " diffLength"]}}
{"id1": "6966398", "id2": "4750967", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"reader": ["dr", "mr", "stream", "ri", "rc", "rs", "er", "cer", "driver", "lr", "io", "handler", "buffer", "parser", "wrapper", "loader", "writer", "rl", "runner", "ro", "query", "redo", "builder", "file", " read", " readers", "rr", "rar", "Reader", "rx", "this", "older", "ner", "r", "input", "iter", "inner", "rer", "row", "roller", "sr", "rot", "read", "ocr"], "ks": ["k", "fs", "checks", "icks", "ars", "akes", "kies", "sky", "uk", "cs", "bs", "ros", "ls", "ols", "ips", "mk", "kes", "nets", "km", "ys", "ms", "obs", "ss", "ki", "kr", "ds", "ke", "KS", "kk", "ses", "vs", "eps", "ups", "eks", "ates", "keys", "uds", "ces", "sk", "oss", "kb", "cks", "agles", "hs", "qs", "ans", "ck", "kens", "kas"], "key": ["k", "core", "object", "tk", "sky", "KEY", "ssh", "char", "er", "service", "mk", "Key", "cer", "pair", "user", "owner", "my", "entry", "by", "ke", "sign", "link", "ey", "ca", "ek", "x", "obj", "power", "file", "ox", "base", "y", "hash", "client", "keys", "sk", "trust", "null", "type", "root", "password", "info"], "chain": ["Chain", "stream", "binary", "cache", "channel", "data", "pair", "list", "chains", "string", "path", "box", "form", "group", "sequence", "stack", "test", "bank", "block", "c", "sche", "trace", "table", "frame", "sign", "ca", "range", "ver", "piece", "file", "batch", "code", "base", "pool", "family", "hash", "check", "number", "type", "root", "ce", "password", "component", "result", "can"], "os": ["fs", "oos", "css", "osi", "ot", "bs", "cs", "ls", "ose", "us", "io", "ys", "sys", "ms", "obs", "js", "ds", "oses", "oids", "ts", "bos", "aos", "uts", "ox", "cos", "Os", "pos", "is", "oS", "out", "oss", "ops", "oes", "o", "oso", "los", "OS", "ols", "ps", "ios"], "stamper": ["important", "stAmper", " strampler", " stcampler", " stimper", " stumter", "stimpler", " stammer", "println", "New", "stimmer", "stramPER", "stumper", " stcammer", " stramPER", "stamter", "stAmPER", " strammer", "valid", "stAmmer", "annot", "stammer", " stimter", " stampler", "The", " stumpler", "stimPER", "stimper", "Print", "stramper", "stumpler", "stAmpler", "read", "_", "stummer", " stcamper", " stamter", "strampler", "strammer", " stumper", " stcamter", "this", "good", "def", "stampler", "stamPER", " stamPER", " stramper", "stumter", " stimpler", "font", " stimmer", " stummer"], "appearance": ["appreciation", "patternearance", "Applies", " appearances", "ascears", "accearances", " appeared", "displayeared", "displayreciation", "patternearances", "apears", "suppeared", "Appeared", "atteared", "appearances", "acreciation", "attearances", "apreciation", "acearances", " appearing", "displaylies", "accearance", "displayearances", "Appearances", "ascearing", "displayendix", "patternendix", "displayearing", "appears", "Appearance", "apearing", "applies", "apearances", "patternearing", "displayears", "attlies", "aceared", "aplies", "acearance", "appeared", "acclies", "appearing", "suppearances", "ascearance", " appendix", "apearance", "ascearances", "suppearance", "attearance", "apeared", "appendix", "accears", "displayearance"]}}
{"id1": "20920051", "id2": "6188784", "code1": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyTo": ["moveDir", "CopyFiles", "copyFiles", "transferTo", "transferFiles", "copyFrom", "opyPhoto", "CopyTo", " copyFile", "CopyFrom", "moveOver", " copyPhoto", "transferFile", " copyFiles", "copyFile", "moveTo", " copyFrom", "opyDir", "movePhoto", "copyOver", " copyOver", "opyOver", "copyDir", "copyPhoto", "CopyFile", "transferFrom", " copyDir", "opyTo"], "source": ["shell", "style", "old", "id", "empty", "target", "src", "status", "visible", "note", "sql", "file", "missing", "sp", "template", "get", "se", "details", "oss", "null", "use", "local", "scope", "store", "search", "seed", "select", "sort", "entry", "size", "spec", "init", "name", "unit", "start", "Source", "original", "sl", "copy", "service", "sin", "s", "subject", "raw", "sf", "resource", "query", "ie", "base", "parent", "ace", "pse", "input", "config", "site", "component", "image", "scan", "SOURCE", "flat", "secure", "origin", "ource", "from", "part", "none", "iter", "sample"], "dest": ["loc", "del", "folder", "port", "Dest", "dat", "self", "path", "target", "ref", "test", "origin", "src", "st", "it", "tom", "dist", "dc", "to", "orig", "trans", "dir", "des", "nom", "dev", "tmp", "nt", "est", "parent", "name", "master", "this", "good", "opt", "pro", "out", "txt", "doc", "null", "desc", "rest", "end", "d", "w", "deg", "result"], "temp": ["mt", "unt", "p", "dat", "alt", " tmp", "mk", " temporary", "empty", "por", "path", "test", "EMP", "tar", "buffer", "mm", "pt", "mod", "em", "orig", " Temp", "emp", "Tem", "mp", "tmp", "parent", "porary", "cp", "zip", "out", "txt", "w", "template", "Temp", "pl", "rem", "rm", "tm", "tem", "null", "tab", "fake", "make", "t", "local", "stem"], "sel": ["del", "el", "ael", "sl", "kel", "ial", "zh", "ls", "nel", "lf", "rol", "sc", "select", "selected", "ele", "Sel", "elect", "kl", "ml", "le", " sl", "fol", "cell", "nav", "El", "cel", "rl", "sels", "nl", "sv", "ser", "sol", "so", "sil", "pl", "se", "syn", "Se", "cl", "fl", " lic", "selection", "mil", "sen", "lv"], "tempDest": ["poraryTemp", "poraryDec", "ptDest", " tempdest", " temporaryNeg", "destLoc", "poraryDe", "poraryDir", " tempDir", "tempNeg", "tempLoc", "destTemp", "destDec", "temDe", "ptNeg", " tempNeg", "poraryLoc", " tempTemp", "tempDe", "mmLoc", "poraryDest", " temporaryTemp", "destDest", "mmDest", "ptdest", "temdest", "tempDir", " temporarydest", " tempDe", "ptTemp", "mmTemp", "tempTemp", "mmDec", " temporaryDest", "temDest", "tempDec", "porarydest", "temDir", "tempdest"], "sourceCh": ["seedChan", "ourceColl", "seedCh", "statusCol", " sourceCor", "sampleCh", "samplech", "srcCh", "startCol", "ourceChan", "sourcech", "ourceCr", "ourceCH", "sampleCor", "srcCol", "sourceCol", " sourceCH", "srcCor", "srcChan", "startCh", "statusCh", "sourceCH", "statusCr", "sourceChan", "seedColl", " sourceCol", " sourcech", "startComp", "statusCH", "startCH", "srcColl", "sampleComp", "sourceComp", "srcch", "sourceCr", " sourceCr", "seedCol", "ourceCol", "sourceCor", " sourceComp", "srcCH", "sourceColl", "srcComp", "ourceComp", "ourceCh"], "destCh": ["destCol", "destC", "tempChan", " destChan", "estC", " destChar", " destCl", "tempCh", "estDest", " destCol", "targetChar", "tempCl", "usrCh", "usrC", "targetChan", "destChan", "targetC", "restChan", "restC", "destDest", "estCl", "destCl", "usrChar", " destDest", "restCol", " destC", "targetCh", "destChar", "usrChan", "tempCol", "restCh", "estCh", "tempC"]}}
{"id1": "4593011", "id2": "20232250", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadSDLS", "loadPDL", "readPDLS", "loadPDLS", "readDDLS", "loadDSLS", "readDDl", "loadDDl", "loadSDl", "readDDDL", "loadDDDL", "loadDSL", "loadDSDL", "loadDSl", "loadPDDL", "loadSDL", "loadDDLS", "readPDl", "readPDL", "readPDDL", "readDDL", "loadSDDL", "loadPDl"], "stmt": [" Stm", " stMT", " superstmt", " stmm", "stemt", "Stmb", "stMT", "tMT", " superstMT", " stmn", "strmb", "STm", "STtx", "tmm", "StMT", "Stdo", "strmt", "stmb", " Stmt", "stpt", "tmt", "stmm", " StMT", "sttr", "stedo", "steMT", "strMT", "STMT", "stm", "stdo", " stpt", "ttr", "Stmm", " Stpt", "stmn", " sttr", " sttx", " stmb", " stm", "Sttx", " superstpt", " stdo", "sttx", "Stmn", "STmt", "strmn", "Sttr", "Stmt", "Stm", " superstm", "stem"], "qry": ["qury", " qtry", " qrys", "Qrys", "sqries", "qrys", "qtry", " qries", "Qry", "sqtry", "quries", "qries", "sqrys", "quri", " qri", "sqry", "sqri", "qutry", "Qri", "qri", "Qries"], "q": ["k", "f", "z", "qq", "u", "iq", "ry", "v", "p", "e", " sq", "qi", "m", "sq", "pkg", "c", "qv", "qt", "j", "Q", "quest", "query", "y", "qu", "h", "i", "qa", "dq", "g", "l", "ql", "t", "o", "qs", "d", "w", "n"]}}
{"id1": "807346", "id2": "19109981", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"runScript": ["executeCode", " runCode", "callScript", " runProgram", "runCode", "runscript", "callscript", "executescript", "callCode", "executeProgram", "executeScript", "runProgram", " runscript", "callProgram"], "scriptName": ["templateName", "scriptFile", " scriptPath", "criptName", "scriptPath", "criptBody", "ScriptKey", "fileKey", " scriptBody", "scriptname", " scriptname", "criptFile", "fileName", "Scriptname", "templatePath", " scriptFile", "ScriptName", "templateBody", "ScriptPath", "filePath", "filename", "scriptKey", "scriptBody", "templateFile", "criptPath", " scriptKey"], "data": ["image", "DATA", "rel", "div", "output", "value", "comments", "p", "video", "ata", "cache", "dat", "message", "window", "format", "list", "description", "string", "empty", "content", "partial", "chain", "sequence", "buffer", "n", "str", "debug", "raw", "text", "error", "rew", "table", "response", "step", "a", "reason", "to", "what", "report", "alert", "all", "comment", "some", "res", "missing", "name", "this", "extra", "out", "source", "input", "title", "results", "json", "row", "type", "default", "padding", "next", "log", "t", "html", "command", "info", "result", "action"], "url": ["loc", "f", "rel", "sl", "ssl", "gl", "b", "https", "dl", "hl", "char", "bel", "web", "user", "str", "ll", "resource", "http", "ul", "nl", "link", "browser", "ur", "URL", "build", "base", "address", "open", "mount", "out", "mail", "pl", "get", "lb", "r", "uri", "Url", "l", "abs", "log", "job"], "in": ["ins", "din", "en", "stream", "serv", "IN", "inn", "io", "inf", "gin", "cin", "on", "mm", "bin", "val", "it", "all", "mc", "al", "ma", "body", "act", "ind", "is", "inc", "out", "check", "rin", "i", "input", "source", "r", "inner", "l", "mat", "isin", "info", " din", "In", "pi"], "buffIn": ["bufferIn", " BuffIns", "bufferIns", "bufferCon", " buffOut", "BuffCon", " BuffIn", "bufedIn", "BuffIn", "bufOut", "BuffIns", "buffedIn", "buffCon", "buffIns", "bufferOut", "BuffedIn", "BuffOut", " BuffOut", " buffedIn", "bufIn", " BuffCon", "buffOut"], "temp": ["length", "there", "output", "perature", "perm", "dat", "tc", "mint", "thread", "index", "tim", "test", "buffer", "cell", "sequence", "acc", "pt", "term", "mod", "cel", "j", "read", "cap", "emp", "ptr", "result", "cert", "tmp", "relative", "porary", "current", "txt", "template", "Temp", "i", "input", "cur", "character", "tem", "Temperature", "fake", "variable", "t", "wr", "deg", "stem"]}}
{"id1": "884867", "id2": "8182932", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"zipname": ["archiveout", "polyfilename", "downloadnamed", " zipsize", " zipName", "gzname", "zipfilename", "tarnamed", "zipnamed", "zfilename", "tarname", "zipName", "tarroot", "archivebase", "polyname", "zeName", "downloadfilename", "zipbase", "polyName", "zename", "zname", "zipsize", "tarsize", "downloadName", "znamed", "zebase", "gzsize", "zeout", " zipnamed", "archiveName", "zName", "ziproot", "downloadname", " ziproot", " zipbase", "archivename", "polynamed", "gznamed", "gzroot"], "zipout": ["zOut", "zion", "zipoutput", " zipion", " zipin", "sendout", "gzion", "gzall", "zout", "gzgen", " zipgen", "gzin", "Zipout", "zipion", "zipall", " zipall", "Zipn", "Zipname", " zipclient", "zipclient", "Zipin", "sendin", "gzobj", "Zipoutput", "sendname", "sendclient", "zipgen", "zipin", "gzOut", "zname", " zipoutput", "gzout", "zipobj", "zn", "zall", "sendn", "zipOut", "zgen", "zobj", "sendoutput", " zipOut", "Zipclient", "zipn", " zipobj", "zin"], "out": ["ins", " abort", "cmd", "gt", "gen", "ln", "set", "pretty", "obj", "res", "nt", "gov", "oss", "g", "null", "log", "OUT", "co", "dt", " sys", "ent", "io", "print", "n", "ac", "conn", " bout", "ou", "inv", "to", "init", "auto", "aos", " manager", "cos", "ch", "name", "conf", " output", "o", "at", "w", "cn", " OUT", "en", "p", "ex", "screen", "con", "cfg", "group", "str", "outs", " say", "all", "msg", "opt", "up", "one", "os", "desc", "t", "go", "output", " Out", "list", "net", "inf", "sys", "on", "by", "writer", " outs", " fmt", "client", "inner", "Out", "can"], "buffer": ["output", "binary", "cache", "message", "total", "window", "buf", "queue", "phrase", "stack", "sequence", "tree", "database", "block", "button", "table", "frame", "bar", "available", "page", "paste", "attribute", "comment", "document", "batch", "library", "line", "append", "template", "memory", "mem", "iter", "row", "variable", "Buffer", "buff", "filter", "temp", "pad", "command", "history"], "in": ["ins", "din", "en", "ex", "ini", "IN", "inn", "con", "like", "ai", "form", "inf", "bi", "cin", "gin", "on", "mm", "bin", "ac", "from", "it", "ic", "or", "by", "and", "init", "query", "nin", "mc", "ma", "per", "reader", "ind", "is", "inc", "check", "up", "rin", "get", "i", "input", "iter", "inner", "oin", "info", "isin", "im", "read", "In", "pi"], "length": ["loc", "distance", "maximum", "value", "bow", "present", "frequency", "position", "angle", "match", "integer", "count", "class", "language", "message", "total", "capacity", "string", "sequence", "print", "duration", "database", "space", "collection", "volume", "join", "size", "load", "reading", "available", "impl", "shape", "tail", "ength", "code", "library", "amount", "phi", "family", "depth", "shift", "no", "height", "display", "vector", "number", "len", "character", "full", "needed", "version", "type", "padding", "point", "hello", "component", "Length", "history", "read", "ENGTH"]}}
{"id1": "21821404", "id2": "22442270", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"getWebPage": ["downloadWebPages", "getDebugpage", "downloadWebpage", "getwebUrl", "getwebPages", "downloadwebPage", "getWebpage", "getLiveUrl", "getWebPages", "getDebugUrl", "downloadWebPage", "getDebugPages", "getLivePage", "getDebugPage", "getWebUrl", "downloadwebPages", "getLivePages", "getwebpage", "downloadWebUrl", "downloadwebpage", "getwebPage", "downloadwebUrl", "getLivepage"], "urlObj": [" urlOb", "uriCtrl", "urlCtrl", "Urlobj", " urlObject", "UrlCtrl", "httpOb", " urlobj", "httpObj", "uriobj", "urlObject", "urlobj", "urlOb", "logObject", "urlInd", " urlCtrl", "urlInfo", "httpObject", " urlOnce", " urlInd", " urlInfo", "UrlObj", "uriObj", "uriObject", "logInfo", "logOb", "logObj", "UrlObject", "UrlOnce", "httpInfo", "uriOnce", "uriInd", "urlOnce", "UrlInd"], "content": ["core", "context", "object", "ontent", "value", "output", "header", "comments", "data", "message", "Content", "equ", "format", "empty", "string", "clean", "complete", "sequence", "buffer", "str", "section", "continue", "raw", "wrapper", "text", "article", "view", "load", "response", "reason", "page", "comment", "document", "layout", "result", "body", "code", "address", "current", "txt", "write", "template", "display", "source", "title", "ext", "ce", "articles", "html", "cm", "command", "temp", "read", "cont"], "is": ["fs", "ese", "ri", "id", "rs", "ris", "when", "ists", "his", "ms", "err", "has", "ism", "re", "bis", "sit", "IS", "res", "be", "se", "es", "ais", "its", "not", "plays", "lis", "iss", "are", "being", "string", "e", "web", "chain", "iso", "or", "Is", "name", "isa", "isl", "other", "s", "in", "c", "internet", "tis", "iris", "out", "isc", "does", "isf", "os", "\u00eds", "ist", "isin", "was", "ios", "sis", "ot", "ir", "more", "isi", "where", "nis", "net", "sys", "by", "rys", "sels", "a", "ire", "ois", "as", "mis", "were", "ians", "i", "and", "job"], "reader": ["dr", "ipper", "stream", "ri", "liner", "dra", "ader", "ocker", "er", "iterator", "io", "handler", "editor", "buffer", "parser", "in", "loader", "writer", "runner", "reading", "ser", "ro", "file", "per", "Reader", "rar", "rr", "ner", "r", "iter", "inner", "anger", "row", "roller", "iper", "read"], "line": ["el", "column", "record", "ine", "liner", "online", "eline", "zone", "message", "char", "email", "detail", "e", "string", "ln", "le", "lo", "print", "sequence", "cell", "section", "block", "lin", "entry", "text", "part", "frame", "nl", "Line", "stroke", "inline", "page", "link", "comment", "range", "label", "piece", "file", "lane", "lined", "word", "l", "row", "LINE", "sample", "point"]}}
{"id1": "810342", "id2": "20365090", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "label": 0, "substitutes": {"doVersionCheck": ["doLicensecheck", "DoVersioncheck", "doVersionsUpdate", "doDateFix", "DoVersionFix", "doLicenseCheck", "doVersionFix", "DoDateCheck", "DoVersionCheck", "doVersionscheck", "doLicenseUpdate", "doDateCheck", "doVersionsCheck", "doDatecheck", "DoDateFix", "doLicenseFix", "doDateUpdate", "DoDatecheck", "doVersionsFix", "DoDateUpdate", "doVersioncheck", "doVersionUpdate", "DoVersionUpdate"], "view": ["image", "host", "iew", "context", "update", "server", "engine", "VIEW", "v", "model", "show", "self", "window", "hl", "review", "web", "form", "print", "buffer", "q", "cell", "tree", "subject", "block", "wrapper", "eye", "http", "table", "page", "cv", "browser", "report", "query", "document", "file", "layout", "tv", "console", "blade", "widget", "controller", "see", "this", "open", "call", "check", "out", "display", "client", "View", "doc", "input", "get", "help", "manager", "row", "util", "html", "component", "index", "views"], "url": ["loc", "f", "rel", "host", "sl", "ssl", "gl", "org", "b", "id", "v", "location", "ls", "dl", "language", "hl", "char", "bel", "github", "string", "lr", "web", "path", "str", "oul", "ll", "http", "rl", "ul", "nl", "link", "socket", "browser", "ur", "URL", "file", "address", "client", "mount", "pl", "lb", "r", "uri", "Url", "l", "null", "json", "log", "html", "date"], "in": ["f", " IN", "ins", "din", "isin", "stream", "b", "IN", "sin", "inn", "ln", "inf", "cin", "gin", "kin", "init", "file", "mn", "body", "ain", "reader", "is", "inc", "out", "rin", "i", "input", "source", "inner", "l", "asin", "mat", "vin", "info", " din", "In", "n"], "bin": ["din", "bl", " bins", "lib", "binary", "b", "ran", "abin", "bed", "bn", "stock", "cache", "sin", "inn", "con", "ln", "bi", "cin", "gin", "buffer", "nb", "local", "conn", "loader", "by", "spin", " Bin", "bg", "thin", "sam", "file", "cos", "pipe", "reader", "out", "rin", "mem", "win", "len", "inner", "obin", "rb", "bur", "buff", " din", "ebin", "mon"], "line": ["el", "column", "cmd", "record", "ine", "store", "field", "style", "liner", "port", "ls", "channel", "eline", " Line", "level", "char", "string", "ice", "ln", "path", "le", "chain", "print", "lo", "cell", "state", "section", "block", "lin", "entry", "err", "text", "part", "trace", "load", "frame", "col", "inline", "Line", "link", "page", "range", "comment", "file", "lane", "body", "base", "code", "word", "no", "ide", "se", "iter", "cat", "one", "l", "row", "lines", "log", "LINE", "sample", "point", "job"], "version": ["image", "update", "translation", "value", "license", "software", "v", "Version", "position", "match", "video", "scale", "language", "VER", "feature", "format", "description", "string", "form", "test", "sequence", "iso", "vers", "volume", "resource", "status", "major", "spec", "usage", "ver", "vision", "browser", "tag", "python", "key", "hash", "river", "latest", "name", "ion", "client", "serial", "virtual", "number", "title", "release", "type", "versions", "info", "command", "date", "index", "VERSION", "project"], "build": ["update", "built", "th", "bor", "b", "binary", "bug", "work", "other", "match", "style", "round", "old", "boost", "where", "develop", "print", "test", "hold", "building", "arch", "load", "add", "dist", "link", "install", "ver", "tag", "struct", "builder", "dev", "ble", "ship", "be", "hash", "latest", "unit", "ward", "full", "last", "db", "fail", "make", "log", "uild", "util", "use", "release", "date", "lib", "project", "Build"]}}
{"id1": "17716716", "id2": "3252116", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"plainToMD": [" stringFromDM", " convertToMD", " stringTomd", " convertAsDM", " convertAsMC", " stringToDM", " stringToMD", " convertAsMD", " stringFromMC", " stringAsMC", " convertToDM", " stringToMC", " convertToMC", " stringAsMD", " stringAsmd", " convertTomd", " convertAsmd", " stringFromMD", " stringFrommd", " stringAsDM"], "loggerCol": ["logiderCol", "logGERCOL", "loggeColl", "loggerCl", "logiderCOL", "badgerCOL", " logggerCOL", "badinatorCol", "badinatorCOL", "badgerCl", "loginatorCol", "logggerCol", " logggerColumn", " loggerCOL", "loggeCOL", "logggerCOL", "logGERColumn", "loginatorCOL", "badgerCol", "logggerCl", " logggerCol", "badinatorColl", " loggerColumn", "badgerColl", "logiderColumn", "loggerColumn", "logGERCol", "loggeCl", "logggerColl", "loggerCOL", "loggeCol", "badinatorCl", "loggerColl", "logggerColumn", "loginatorColl", "loginatorCl"], "input": ["image", "initial", "context", "output", "value", " inputs", "pattern", "data", "char", "Input", "string", "form", "buffer", "q", "hello", "str", "subject", "example", "in", "raw", "from", "text", "request", "it", "active", "prefix", "document", "file", " Input", "base", "hash", "this", "out", "up", "source", "config", "url", "background", "command", "result"], "byteHash": ["byteHas", "ByteHas", "ueHash", "ByteMap", "byteLength", "bytehash", "ueLength", "uehash", "binaryHash", "ByteTr", " bytehash", "bytesMap", "byteshash", " byteMap", "bytesHash", "Bytehash", "byteTr", " byteHas", "bytesHas", "ByteHash", "ByteLength", " byteTr", "binaryHas", "binaryhash", "ueTr", "byteMap", " byteLength"], "md": ["cmd", "dd", "dr", "mt", " MD", "gr", "der", "mo", "red", " mc", "nd", "mg", "mk", "med", "sd", "ded", "od", "ms", "mm", "m", "pm", "gm", "pd", "mod", "ds", "add", "de", "sam", "mc", "mn", " Md", "df", "mp", "msg", "dm", "det", "dig", "cond", "mb", "ind", "hash", "def", "met", "material", "comp", "doc", "grad", "ld", "rm", "di", "cd", "mac", "bd", "ct", "hd", "d", "ng", "MD", "sm"], "md5result": [" md8proc", "md5proc", "MD5string", "md2response", "MD2string", "md2results", "md65Result", "md8proc", "MD2Result", "md45response", "MD5comment", "md3proc", " md5proc", "md2comment", "md3result", "md3message", "MD5response", "md5comment", "MD2result", "md2result", "md45result", "md7result", "MD2response", "md7Result", "md7results", " md5message", "md64comment", "md5string", "md65proc", " md5Result", "MD2results", "MD2comment", "md2Result", "MD5results", " md8message", " md8result", "md8Result", "md5message", "md8message", "md2string", "md65message", "md64response", "md5Result", "md8result", "MD5Result", "md45results", "md7string", "md64result", "md5response", "MD5result", "md65result", " md8Result", "md3Result", "md3results", "md64results", "md45comment", "md3string", "md5results"], "i": ["cli", "mi", "z", "u", "id", "b", "v", "ix", "I", "ii", "us", "si", "ai", "io", "bi", "n", "q", "my", "m", "me", "sim", "in", "multi", "ic", "it", "c", "ei", "li", "ti", "a", "j", "span", "xi", "ims", "init", "key", "x", "ji", "ie", "phi", "y", "ind", "is", "ui", "fi", "gu", "iter", "uri", "di", "gi", "l", "ci", "ip", "\u0438", "o", "qi", "im", "index", "pi"]}}
{"id1": "9826240", "id2": "21999120", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 1, "substitutes": {"checkHashBack": ["checkClearUp", " checkhashback", "checkhashUp", " checkhashBack", "checkHashback", "checkLockUp", " checkHashDown", "checkhashDown", "checkhashBack", " checkHashback", "checkLockback", "checkHashUp", "checkClearBack", "checkLockDown", "checkClearback", "checkhashback", " checkhashUp", " checkhashDown", "checkHashDown", " checkHashUp", "checkClearDown", "checkLockBack"], "facade": ["servades", "funcage", "Facader", " facaded", "formificate", "glade", "formace", "Facacet", "Facaded", "funcader", "facaded", " facage", "famace", "Faclegate", "latade", "facader", "formacet", "Facace", "funcade", "facificate", "famade", "famacet", "facades", "latlegate", "faclegate", "funcace", "formade", "Facade", "glage", " facades", "latader", "funclegate", "Facage", "Facades", "latace", "servade", "servage", "servaded", "Facificate", "glace", "facace", "facage", "famificate", "facacet", "glader"], "req": ["Request", "qq", "cmd", "Requ", "mr", "org", "forced", "gr", "p", "Resp", "work", "rh", "data", "jp", "aux", "reg", "rec", "e", "require", "queue", "attr", "q", "ctx", "err", "wcs", "resp", "sq", "request", "pkg", "http", "etc", "qt", "quest", "urg", "obj", "res", "body", "wx", "msg", "params", "rpm", "good", "out", "cur", "r", "uj", "proc", "needed", "required", "forge", "desc", "rb", "ctr", "tx", "qs", "compl", "requ"], "txtTransactionID": ["txtTXName", "textTxID", "xtTxId", "txtTxId", "xtTransactionID", "txtTransID", "txtTxID", "txtOrderKey", "txtTransactionKey", "textTransactionID", "textTransactionName", "txtTransName", "textTxId", "txtTXId", "txtTransactionId", "txtTxKey", "textTransactionId", "txtOrderName", "xtTransactionId", "xtTxName", "textTxName", "txtTransId", "xtTxID", "xtTxKey", "txtOrderID", "txtTxName", "txtTransKey", "xtTransactionKey", "txtTXID", "txtOrderId", "txtTransactionName", "xtTransactionName"], "txtOrderTotal": ["txtOrderInfo", "txtJobId", "xtOrdTotal", "txtOrderSum", "xtOrderInfo", "txtJobInfo", "xtOrderTotal", "txtOrdTotal", "txtJobTotal", "txtOrderBase", "txtTradeTotal", "txtOrderComplete", "txtTransactionTotal", "txtOrderId", "txtTradeComplete", "txtJobSum", "strOrderComplete", "txtTradeBase", "strTransactionComplete", "txtArticleInfo", "strTransactionTotal", "xtOrderId", "xtOrderSum", "txtOrdComplete", "txtArticleId", "strOrderTotal", "txtOrdId", "xtOrdSum", "xtOrdId", "txtTransactionComplete", "txtTransactionBase", "txtArticleSum", "txtArticleTotal", "txtOrdSum", "txtOrdBase", "xtOrdInfo", "strOrderBase", "txtOrdInfo", "strTransactionBase"], "txtShopId": ["txtSiteID", "xtSiteID", "txtServerID", "txtStreetById", "txtServerid", "textShopid", "txtSiteAid", "xtShopAid", "textStoreId", "xtSiteId", "txtStreetID", "txtForgeId", "txtShopById", "txtShopAid", "txtForgeAid", "txtForgeid", "txtServerAid", "txtStreetId", "xtShopID", "txtStreetid", "txtSiteid", "textStoreid", "txtStoreID", "txtShopid", "xtShopId", "txtForgeID", "txtSiteById", "xtSiteAid", "textShopById", "textStoreById", "txtStoreid", "txtStoreId", "txtShopID", "txtServerId", "textShopID", "txtStoreById", "txtSiteId", "xtShopid", "textShopId", "xtSiteid", "textStoreID"], "txtArtCurrency": ["txtArtCourrencies", "txtArtCurrencies", "txtArtConategories", "txtArtConcurrency", "txtArtCourrency", "txtArtConulture", "txtArticleCourrency", "txtArticleCurrency", "txtArtCoategories", "txtArtCoulture", "txtArticleCocurrency", "txtArtCategories", "txtArticleCourrencies", "txtArtColurrency", "txtArtCcurrency", "txtArtCulture", "txtArtConurrency", "txtArticleCulture", "txtArticleCategories", "txtArticleConategories", "txtArticleConcurrency", "txtArticleCcurrency", "txtArtColcurrency", "txtArticleCoulture", "txtArticleCurrencies", "txtArtCocurrency", "txtArtConurrencies", "txtArtColategories", "txtArticleConurrency"], "txtHashBack": ["txtLockFront", "textHashBack", "txtHashFront", "xtHashback", "texthashFront", "texthashback", "xtHashFront", "txtStockFront", "txtHelpback", "txthashValue", "txthashFront", "txtFilterBACK", "txtStockBack", "txtHashBACK", "xtStockBack", "xtStockback", "txthashback", "txtFilterFront", "txthashBack", "txtHashValue", "txtClearBack", "xtHashBACK", "txtLockBACK", "txtClearBACK", "txtClearFront", "texthashValue", "txtClearback", "txtRawBACK", "txthashBACK", "txtRawValue", "textHashBACK", "txtLockBack", "textHashValue", "txtLockback", "texthashBACK", "txtStockBACK", "txtStockback", "txtRawback", "txtHelpBack", "textHashFront", "txtFilterBack", "txtFilterback", "texthashBack", "textHashback", "txtRawBack", "txtHelpBACK", "xtStockBACK", "xtStockFront", "txtHelpFront", "xtHashBack", "txtHashback"], "hashSeed": ["hashSep", "hashAsep", "hashAsetter", "hashSlee", "hashSleed", "hashSourceetter", "hoSep", " hashSiper", " hashSeeds", "hashSiper", "hashSourceeed", " hashSeeeds", " hashSeee", "hoAsetter", " hashSeiper", "hashFeed", "hashSetter", "hashSeee", "hashSourceep", " hashSee", "hashSeeeds", "hoAseed", "hashFep", "hashSourceeder", "hashSeeds", "hashAseder", "hoSetter", " hashSeeed", "hashSee", "hashAseed", "hashFeder", "hoSeed", "hoSeder", "hashSeder", "hoAseder", "hashSeiper", "hashSeeed", "hoAsep", "hashSleeds", "hashFetter", "hashSliper"], "securityValue": [" securityVal", "securityData", "secValues", "SecurityVal", " securityValues", "SecurityData", " securityData", "securityVal", "secValue", "secData", "securityValues", "SecurityValues", "secVal", "SecurityValue"], "digest": ["dEST", "dependgest", "contests", "Diger", "der", " diger", " digested", "dependester", "macester", "Digester", " diget", "dester", "Digested", "dest", "equse", "dependested", "diget", "dse", "contse", "digested", "DigEST", "macgest", "equet", "macested", "digests", " digEST", "digse", "diger", " digse", "diggest", " digester", "Digest", "contest", "Digse", "dested", "Diget", "macest", "Diggest", "contested", "Digests", "digEST", "dependest", "digester", "equester", " digests", "equest"], "array": ["length", "max", "arr", "ash", "ashes", "object", "record", "av", "iq", "Array", "binary", "v", "angle", "sha", "archive", "stage", "arrow", "instance", "pair", "list", "area", "audio", "string", "RAY", "buffer", "raw", "ar", "view", "collection", "map", "response", "bar", "a", "range", "export", "attribute", "shape", "rays", "share", "batch", "our", "angular", "vector", "number", " Array", "row", "ray", "now"], "sb": ["ssl", "abb", "bs", "bf", "shell", "ls", "SB", "ib", "sn", "obb", "obs", "nb", "esm", "gob", "rob", "sq", "sf", "bps", "bis", "sv", "bh", "stab", "bg", "wb", "rub", "sam", "gc", "eb", "bt", "soc", "erb", "orb", "lp", "gb", "bj", "ob", "lb", "ctrl", "kb", "abs", "zb", "pb", "bsp", "rb", "sg", "bb", "sbm", "cb", "sa"], "j": ["k", "z", "el", "dj", "gr", "v", "ix", "jj", "jp", "jet", "yy", "jc", "ody", "aj", "q", "state", "bot", "from", "it", "js", "jump", "ja", "J", "ij", "_", "key", "x", "obj", "kj", "jl", "ji", "msg", "ind", "bj", "br", "i", "uj", "g", "json", "jit", "jo", "att", "job", "oj", "n"], "b": ["k", "ba", "bs", "bf", "v", "binary", "ib", "bp", "bi", "nb", "ab", "BB", "fb", "bis", "bar", "bg", "B", "eb", "beta", "base", "bt", "bu", "be", "mb", "gb", "bit", "br", "h", "bc", "db", "bd", "rb", "bound", "bb", "cb"], "hash": ["ashes", "ash", "ssl", "value", "hz", "search", "header", "ASH", "sha", "cache", "rh", "sum", "message", "data", "where", "format", "total", "string", "Hash", "test", "block", "response", "password", "bh", "ah", "report", "oh", "tag", "key", "hex", "address", "flash", "buster", "height", "check", "h", "title", "json", "version", "uh", "url", "crypt", "filter", "sample", "href", "html", "result", "handle"]}}
{"id1": "19235551", "id2": "23677142", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"handleFCLAException": ["handleFCAError", "handleFCMAError", "handleFCARequest", "handleICMARequest", "handleICMAException", "handleFCCLAImage", "handleFCLAImage", "handleICLAError", "handleFCLAError", "handleICLAException", "handleICLAImage", "handleFCAException", "handleFCAImage", "handleFCCLAException", "handleFCCLARequest", "handleFCLARequest", "handleICMAImage", "handleICLARequest", "handleFCMARequest", "handleFCMAException", "handleFCCLAError", "handleFCMAImage", "handleICMAError"], "params": ["rs", "las", "headers", "gs", "pretty", "ims", "shape", "sql", "settings", "pos", "details", "ops", "results", "includes", "ports", "versions", "ids", "param", "models", "features", "items", "files", "ctx", "spec", "requires", "reports", "layout", "vs", "styles", "keys", "conf", "tools", "errors", "lines", "plugins", "tags", "terms", "pres", "papers", "properties", "actions", "cases", "services", "modules", "posts", "parts", "steps", "config", "docs", "parents", "padding", "names", "rules", "ps", "stats", "pins", "comments", "values", "vals", "types", "pps", "packages", "options", "marks", "ams", "codes", "helps", "changes", "fixes", "members", "points", "rison", "units", "photos", "tests"], "uri": ["cli", "folder", "distance", "surface", "uid", "ri", "id", "description", "path", "bid", "http", "report", "range", "prefix", " URI", "file", "menu", "controller", "username", "local", "pi", "length", "server", "domain", "du", "doi", "archive", "io", "then", "form", "term", "volume", "direction", "browser", "init", "ori", "unit", "wiki", "filename", "version", "grab", "loc", "copy", "message", "subject", "request", "resource", "dir", "query", "library", "msg", "slice", "iri", "cue", "source", "route", "ip", "component", "processor", "near", "har", "ini", "umi", "queue", "origin", "handler", "uni", "database", "URI", "duration", "function", "force", "proxy", "directory", "phi", "ui", "i", "href", "html"], "url": ["image", "rel", "sl", "ssl", "b", "https", "location", "ls", "dl", "channel", "window", "char", "string", "web", "m", "str", "ll", "ret", "resource", "http", "rl", "nl", "link", "browser", "ur", "URL", "file", "library", "address", "open", "client", "mail", "r", "Url", "l", "null", "result"], "connection": ["image", "context", "object", "output", "server", "position", "channel", "Connection", "connect", "data", "communication", "relation", "description", "con", "process", "pointer", "generation", "database", "network", "conn", "c", "collection", "resource", "response", "page", "session", "sql", "document", "connected", "reference", "open", "client", "still", "close", "statement", "condition", " Connection", "command", "result"]}}
{"id1": "14231545", "id2": "18974466", "code1": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"createTempFile": ["createTempFilename", " createTemfile", " createTemFiles", " createTemImage", " createTempFilename", "createTempfile", " createTempFiles", "createtempSourceFile", "createNewSourceFile", "createTemfile", "createtempFiles", " createTemFilename", "createNewFile", "createNewImage", "createTempFiles", " createTempfile", "createTemImage", "createTempSourceFile", " createTemFile", "createFakeFilename", "createNewFiles", " createTemSourceFile", "createTemFiles", "createTemFile", " createTempImage", "createNewFilename", "createFakeFile", "createNewfile", "createtempfile", "createFakeFiles", "createTemSourceFile", "createTemFilename", "createTempImage", "createFakeImage", " createTempSourceFile", "createtempFile"], "resourceName": ["requestname", "ResourceName", "resourcePath", "templateName", "referenceSource", "resourceKey", "Resourcename", "requestName", "attributeFamily", " resourceSource", "attributename", " resourcePath", "requestFamily", "templatename", "templateId", "resourceId", "resourcename", " resourceId", "fileSource", " resourceFamily", "referenceName", "attributeKey", "fileName", "referencename", "templateKey", "requestKey", " resourcename", "ResourceId", "attributeName", "filePath", " resourceKey", "filename", "referencePath", "ResourceKey", "resourceFamily", "resourceSource"], "input": ["image", "initial", "inside", "exec", "stream", "rc", "data", "instance", "through", "enter", "service", "list", "Input", "pull", "empty", "iterator", "form", "inf", "in", "raw", "from", "request", "it", "resource", "load", "quick", "add", "upload", "init", "file", "result", " Input", "reader", "before", "this", "open", "up", "get", "source", "feed", "config", "internal", "cur", "create", "null", "iter", "start", "ip", "url", "unknown", "inner", "accept", "sample", "hello", "local", "cont"], "inputFile": ["tempStream", " inputFILE", "Inputfile", "InputFILE", "outputFILE", "inputPath", "inputfile", "InputPath", "importPath", "importfile", "tempFile", " inputPath", "tempfile", "importFILE", "inputStream", " inputfile", "inputFILE", "outputFile", "importFile", "outputfile", " inputStream", "InputStream", "InputFile"], "output": ["image", "you", "column", "online", "monitor", "channel", "screen", "data", "format", "web", "outer", "csv", "print", "generation", "buffer", "icon", "xml", "network", "continue", "hidden", "collection", "OU", "ou", "response", "Output", "four", "to", "that", "ilo", "export", "document", "file", "console", "none", "put", "see", "current", "client", "out", "write", "display", "source", "unsigned", "null", "written", "success", "summary", "next", "log", "exit", "download", "save", "component", "result"]}}
{"id1": "5744493", "id2": "18164929", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"onlyFileCopy": [" synchronizedFullMove", " doPageDownload", " synchronizedFullCopy", " synchronizedFullDownload", " synchronizedFileCopy", " doStreamCopy", " synchronizedFileDownload", " doStreamDownload", " doFullCopy", " doFileDownload", " synchronizedFileMove", " doStreamMove", " doPageMove", " doPageCopy", " doFullMove", " doFileCopy", " doFileMove", " doFullDownload"], "in": ["ins", "din", "el", "en", "b", "old", "ex", " input", "IN", "inn", "inf", "cin", "gin", "mm", "ac", "from", "ic", "it", "or", "init", "as", "file", "ain", "ind", "inc", "up", "rin", "source", "input", "i", "r", "l", "o", "isin", "ck", "In", "n"], "out": ["ot", "output", "OUT", "v", "p", "serv", "ex", "gt", "s", "net", "io", "ne", "outs", "it", "c", "ou", "to", "as", "file", "res", "po", "op", "nt", "ch", "write", "up", "check", "help", "os", "l", "null", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["dinCommand", " inChan", "cinCommand", "inConnection", "innCategory", "isinChannel", "inChan", "isinButton", "isinConnection", "vinChannel", "Inchannel", "InCh", "INStream", "vinCase", "outchannel", " inCommand", "inCategory", "innButton", "inCh", "cinButton", " inCase", "vinConnection", "INchannel", "INChannel", "innerStream", "inStream", "InChannel", "dinCase", "cinChannel", "innerchannel", "innerChan", "dinButton", "innCommand", "dinChan", "isinChan", " inCh", " inConnection", " inchannel", "outCh", "dinConnection", "inCase", "dinChannel", "inchannel", "outChan", "INChan", " inCategory", "inCommand", " inButton", "outStream", "InChan", "innerChannel", "innChannel", "cinCategory", "vinCommand", "inButton"], "outChannel": ["cosMachine", "outputCh", "aosChannel", "onChan", "outputStream", "inChan", " outCh", "outSection", "cosDisk", "newChannel", "onchannel", "outputChan", " outchannel", "outDisk", " outRoom", "outConnection", "outchannel", "OutStream", "onConnection", "aosSection", "OutCh", "OutChannel", "outerChan", "aosDisk", "cosSection", "outRoom", "upSection", "upMachine", "inStream", "onChannel", "upChannel", " outConnection", "newChan", "outCh", "outerStream", "outputChannel", "OutChan", "outerChannel", "outChan", "cosChannel", "outerRoom", "newchannel", "aosMachine", " outStream", "outStream", "outMachine", "upDisk", "inRoom", " outChan", "newConnection"], "maxCount": ["MaxCount", "minSize", "maxSize", " maxLength", " maxFlag", " maxCast", "MAXCount", "MAXFlag", "minCount", "minFlag", "minLength", "MaxLength", "MAXLength", "maxLength", "MaxCast", "minCast", "maxFlag", "MaxSize", " maxSize", "maxCast"], "size": ["length", "readable", "sent", "equal", "Size", "position", "scale", "count", "show", "sum", "message", "SIZE", "ose", "ize", "ze", "capacity", "sd", "area", "speed", "si", "total", "empty", "gets", "notice", "ms", "resolution", "any", "duration", "m", "space", "set", "scroll", "fee", "score", "south", "export", "range", "shape", "small", "body", "name", "seek", "shift", "is", "height", "keys", "write", "len", "close", "start", "bytes", "sample", "send", "read"], "pos": ["loc", "rel", "length", "exp", "p", "port", "position", "Pos", "pi", "Position", "POS", "pointer", "offset", "pt", "zero", "resp", "it", "part", "limit", "spec", "to", "page", "coord", "pg", "x", "seq", "po", "left", "sp", "cos", "pc", "pid", "no", "def", "pro", "pr", "off", "pl", "i", "len", "pass", "doc", "os", "l", "start", "row", "o", "point", "pose", "index", "slot", "ps", "n"]}}
{"id1": "16378239", "id2": "18693224", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["forRef", "ByReference", "forreference", "byreference", "forReference", " byResource", "byRef", "forResource", "Byreference", "byResource", "ByRef", "ByResource", " byreference", " byRef"], "inputStream": ["inputReader", "readableSteam", "InputSteam", "readableReader", " inputstream", " inputSteam", " inputReader", "inFile", "inSteam", "inStream", "inputSteam", "readableStream", "inputstream", "Inputstream", "InputReader", "instream", " inputFile", "InputStream", "InputFile", "readablestream", "inputFile"], "tempFile": ["poraryUrl", "poraryFile", "tmpPlace", " temporaryfile", "TempDirectory", "tempFiles", "TempFiles", " temporaryChain", "poraryDir", " tempDir", "poraryPlace", "tempfile", " tempfile", "poraryName", "empPlace", "TempPath", "tempDirectory", "tmpfile", "tmpDirectory", "TempDir", "TempUrl", " temporaryFile", "Tempfile", "tempChain", " tempUrl", "empfile", "tempName", "empName", "TempChain", " tempFiles", "empDirectory", "tempDir", "poraryfile", " tempChain", "empFile", "tempUrl", " temporaryFiles", "tmpPath", "empPath", "tmpFile", "TempFile", "tempPlace", "tmpName", "tempPath"], "out": ["ins", "output", "OUT", "co", "gr", "v", "lay", "again", "serv", "ex", "dis", "sum", "ent", "us", "con", "s", "user", "net", "io", "sys", "in", "outs", "OU", "writer", "ou", "to", "all", "as", "file", "auto", "aos", "cos", "msg", "up", "oss", "source", "one", "conv", "ao", "os", "l", "null", "o", "t", "Out", "n"]}}
{"id1": "18374598", "id2": "5808579", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 0, "substitutes": {"download": ["update", " downloaded", "poll", "dial", "GET", "data", " Download", "connect", "pull", "delete", "loader", "load", "link", "Download", "upload", "install", " downloads", "file", "open", "check", "get", "create", "submit", "filename", "url", "save", "sample", "read"], "a": ["ia", "eta", "el", "u", "aa", "go", "b", "v", "ata", "apa", "alpha", "data", "ga", "area", "ae", "s", "ai", "path", "an", "any", "ac", "from", "au", "ar", "c", "ab", "part", "array", "sta", "ca", "va", "all", "attribute", "aaa", "as", "la", "ma", "aos", "al", "base", "address", "era", "arg", "name", "pa", "ap", "h", "ta", "i", "r", "title", "ao", "l", "app", "na", "url", "aw", "t", "o", "html", "att", "d", "at", "oa", "A", "sa", "am"], "p": ["pe", "b", "perm", "par", "jp", "pat", "bp", "pers", " pe", "P", "q", "pre", "pt", "m", "pp", "pkg", "c", "part", "ping", "vp", "j", "pg", "x", "power", "pard", "wp", "op", "pc", "pos", "cp", "pid", "lp", "pa", "pr", "pro", "ap", "h", "pl", "i", "g", "l", "ip", "prop", "rep", "t", "pad", "np", "d", "tp", "ps", "pb", "pi"], "td": ["div", "cot", "ot", "dd", "th", " TD", "dt", "dial", "dl", "nd", "lf", "tc", "dh", "tif", "sd", "od", "pt", "pd", "tf", "ds", "dc", "ts", "md", "ad", "ptr", "df", "tmp", "nt", "pc", "det", "tr", "TD", "cz", "d", "ld", "db", "deb", "cd", "tap", "bd", "ct", "t", "fd", "hd", " sd", "tp", "fc", "pb"], "f": ["fs", "ft", "b", "cf", "v", "fw", "bf", "fin", "uf", "lf", "fm", "alf", "fo", "af", "fe", "e", "form", "ff", "tf", "sf", "c", "fb", "j", "fr", "fx", "fa", "xf", "file", "df", "fn", "fp", "fi", "h", "i", "g", "l", "fl", "t", "o", "fd", "rf", "F", "d", "w", "fc", "func"], "total": ["max", "initial", "eta", "length", "num", "Total", "equal", "count", "scale", "sum", "stable", "net", "le", "complete", "sequence", "sys", "percent", "valid", "buffer", "normal", "table", "active", "otal", "to", "note", "available", "all", "trans", "nt", "base", "none", "current", "open", "ta", "template", "done", "meta", "full", "unique", "len", "number", "last", "start", "t", "info"], "progress": ["length", "update", "distance", "pdf", "portion", "important", "poll", "grade", "scale", "count", "speed", "process", "print", "percent", "complete", "state", "offset", "Progress", "finished", "debug", "scroll", "continue", "status", "resource", "priority", "step", "dist", "bar", "performance", "usage", "payment", "report", "ptr", "address", "depth", "current", "pro", "display", "done", "memory", "age", "success", "summary", "t", "wait", "history", "result"], "in": ["ins", "inside", "din", "en", "ini", "ze", "IN", "inn", "con", "ai", "io", "inf", "cin", "on", "mm", "bin", "from", "ar", "it", "ic", "by", "to", "init", "ind", "is", "inc", "rin", "get", "i", "input", "win", "iter", "inner", "oin", "l", "o", "and", "im", "In"], "out": ["cn", "ins", "output", "OUT", "b", "co", "v", "ex", "cache", "list", "con", "s", "net", "io", "ne", "sys", "on", "err", "conn", "outs", "it", "c", "by", "writer", "OU", "ou", "vol", "to", "obj", "res", "aos", "auto", "nt", "at", "pool", "ch", "pos", "put", "lock", "client", "write", "oss", "g", "os", "l", "null", "o", "t", "end", "log", "Out", "cb", "w", "outer", "can"], "buf": ["arr", "cmd", "bl", "b", "vec", "bed", "uf", "norm", "data", "window", "box", "buffer", "obs", "aka", "bin", "block", "pkg", "bar", "cv", "cap", "orig", "img", "wb", "bag", "seq", "Buff", "batch", "msg", "cp", "br", "ob", "cat", "conv", "db", "tab", "row", "rb", "Buffer", "mu", "buff", "bytes", "next", "cb", "pb"], "n": ["max", "cn", "z", "num", "nn", "en", "b", "v", "norm", "count", "ng", "dn", "nc", "nm", "N", "ln", "ne", "sn", "nw", "an", "ns", "nb", "m", "on", "c", "nor", "nl", "j", "nan", "note", "yn", "x", "nt", "fn", "y", "none", "ren", "nr", "no", "number", "len", "i", "g", "l", "na", "gn", "wn", "t", "o", "names", "np", "d", "w", "min"], "percentage": ["quantance", "percentension", "CENTategy", "scaleage", "centity", "percentility", "quantension", "percentant", "scaleager", "Percentume", "taxension", "quantage", "Percentant", "scaleility", "parility", "propity", "centade", "parager", "CENTage", "scaleAGE", "parage", "percentager", "percentade", "percentile", "Percentity", "parension", "quantility", "Percentile", "oppage", "propade", "centage", "propage", "centile", "Percentategy", "percentance", "oppant", "Percentage", "taxage", "percentume", "percentAGE", "parAGE", "propile", "centAGE", "CENTume", "Percentility", "oppility", "parance", "taxility", "percentategy", "oppade", "centume", "CENTade", "percentity", "taxance", "centategy", "centility", "Percentade", "centager"], "tmpPercentage": ["tmpIntage", "tmpPropage", "tmppercenture", "tmpPercentency", "tmpIntade", "tmpPercentate", "tmppercentate", "tmppercentane", "tmpPropency", "tmppercentade", "tmpPropade", "tmpPercentade", " tmpIntage", " tmpIntency", " tmppercentate", " tmpIntade", "tmpPlusure", "tmpPlusane", "tmpPercentane", "tmpIntance", " tmpPercentane", "tmpPercenture", " tmpPercentency", "tmpMagnages", "tmppercentages", "tmpPlusage", " tmpPercenture", " tmppercentane", "tmpMagnage", " tmpPercentate", " tmppercentages", " tmppercentage", "tmppercentage", " tmpPercentages", " tmpPercentance", " tmppercentade", "tmpMagnate", "tmpPercentages", "tmpPropance", " tmpIntance", "tmpIntency", "tmpPercentance", " tmppercenture", "tmpMagnade", " tmpPercentade", "tmpPlusade"], "size": ["length", "max", "loc", "num", "Size", "position", "scale", "count", "sum", "SIZE", "ose", "ize", "capacity", "ze", "sd", "area", "s", "empty", "e", "loss", "sn", "notice", "space", "set", "sw", "c", "storage", "small", "body", "sp", "code", "name", "see", "used", "len", "g", "needed", "l", "bytes", "now", "send"], "checksum": ["hsul", "hascan", "cksave", "timesave", "hasam", "readsave", "ksum", "checksam", "checkssum", "hsumm", "actionsumm", "ksam", "checksumm", "kscan", "checksave", " checkssum", "actionssum", "hasum", "actionsul", "checksul", "hassum", "readsum", "actionsum", "timessum", " checksumm", "timesum", "ckssum", "hssum", "hsum", "timesul", "cksul", "readsul", "cksam", "readssum", "cksum", "kssum", " checksul", "checkscan", "ckscan"]}}
{"id1": "12055086", "id2": "7087108", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeletging", " copyDeeleging", " copyDelingging", " copyDelingving", " copyDeeleting", " copyDeeleing", " copyDeleing", " copyDeletting", " copydeleving", " copydeletting", " copyDeeleving", " copydeletving", " copyDeletging", " copydeleging", " copydeleting", " copydeleing", " copyDelingting", " copyDelinging", " copyDeleging", " copyDeleving", " copyDeletving"], "source": ["image", "original", "scope", "store", "search", "seed", "style", "SOURCE", "service", "back", "target", "form", "origin", "ource", "src", "from", "resource", "spec", "init", "sql", "query", "body", "sp", "parent", "base", "ace", "template", "input", "se", "oss", "start", "Source", "site", "ce", "sample", "local"], "dest": ["loc", "del", "th", "exp", "https", "port", "Dest", "way", "target", "origin", "src", "mm", "bin", "pub", "st", "it", "tom", "dist", "them", "orig", "trans", "dir", "img", "nom", "sp", "est", "cas", "comb", "cat", "lit", "null", "decl", "pas", "rest", "end", "temp", "d", "w", "master"], "buf": ["arr", "cmd", "bl", "b", "cf", "bs", "vec", "uf", "alph", "data", "capt", "box", "ref", "buffer", "str", "aka", "block", "pkg", "fb", "bh", "cv", "cap", "img", "bag", "fg", "seq", "Buff", "eb", "batch", "cast", "cp", "br", "comb", "cur", "bus", "cat", "conv", "db", "bc", "meg", "tab", "rb", "Buffer", "prop", "tx", "buff", "bytes", "pause", "cb"], "in": ["ins", "din", "inside", "el", "en", "ri", "ini", "ze", "IN", "inn", "con", "ai", "user", "un", "inf", "cin", "gin", "mm", "on", "bin", "from", "ic", "it", "or", "by", "init", "al", "per", "ind", "is", "inc", "rin", "input", "i", "iter", "inner", "isin", "info", "read", "In"], "out": ["cn", "output", "OUT", "en", "co", "v", "dis", "sum", "con", "net", "io", "ne", "sys", "n", "on", "conn", "outs", "by", "writer", "ou", "to", "page", "obj", "res", "auto", "aos", "nt", "ion", "client", "write", "up", "oss", "i", "conv", "inner", "os", "flush", "o", "t", "end", "log", "Out", "at", "outer", "can"], "count": ["length", "cloud", "ount", "z", "num", "core", "max", "deep", "sum", "total", "char", "cc", "index", "q", "nb", "acc", "c", "size", "add", "span", "cap", "comment", "batch", "code", "nt", "amount", "ch", "cond", "ind", "current", "counter", "check", "found", "number", "len", "common", "conf", "start", "ctr", "coll", "ct", "Count", "t", "now", "read", "cont", "n"]}}
{"id1": "1798720", "id2": "23370621", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"save": ["update", "folder", "store", " Save", "Save", "archive", "data", "delete", "pack", "pkg", "upload", "install", "export", "register", "init", "dump", "zip", " seal", "saving", "filename", "version", "aw", "accept", "download", "release", "send"], "packageName": ["PackageNames", "packageType", "moduleName", "packageCode", "packagename", " packageId", "moduleCode", " packageKey", "PackageId", "packageKey", "pkgname", "pkgId", "PackageName", "pkgType", " packagename", "pkgNames", "packageId", "moduleId", " packageType", "modulename", "moduleKey", "packageNames", "pkgKey", "pkgName", " packageNames", "moduleNames", " packageCode", "pkgCode", "PackageType"], "fileContents": ["FileContents", "FileItems", "fileIngredients", "pageNames", "byteContent", "FileIngredients", " fileIngredients", "FileBytes", "byteValues", "byteContents", "FileContent", "FileValues", "pageItems", " fileBytes", "fileBytes", "fileValues", " fileItems", " fileValues", "pageContents", "packageContents", " fileContent", "fileContent", "packageNames", "pageBytes", "packageIngredients", "byteNames", "fileItems", "FileNames", "packageContent"], "fileNames": [" fileLeaks", "FileContents", "FileLeaks", "moduleName", "moduleContents", "fieldTypes", " fileVaults", "resourceNames", "fileLeaks", "dirNames", "resourceContents", "FileValues", "issueVaults", " fileNumbers", " fileTypes", "moduleVaults", "dirLeaks", "resourceNumbers", "FileKeys", " fileKeys", "fileValues", "messageKeys", "fileName", "fileTypes", " fileValues", "FileTypes", "fileVaults", "issueName", "messageName", "dirKeys", "resourceValues", " fileName", "fileNumbers", "issueNames", "issueContents", "messageNames", "fileKeys", "moduleNames", "FileName", "dirTypes", "resourceTypes", "FileNames", "fieldNumbers", "fieldNames", "messageValues", "fieldContents"], "dirBase": ["irbase", "DIRBase", "DIRBottom", "directoryBas", "dirBasic", "pkgBas", "irBase", " directoryBottom", "folderbase", "DIRBuilder", "dirbase", "directoryBasic", "folderBase", "pkgbase", "irSet", "pathbase", "DirBase", "dirBuilder", "pkgBase", " directoryBuilder", "dirBas", "directorybase", "dirBottom", "directorySet", "DirBas", "irBas", "DIRBas", "pathBas", "folderBasic", " directoryBas", "folderBas", "pathBasic", "dirSet", "DirBuilder", " directoryBase", "directoryBase", "pkgSet", "pathBase", "DirBottom"], "packageDir": ["packageDef", "pkgPath", "pkgDef", "modulePath", "moduleDef", "moduleFolder", "installDir", " packageFolder", "podDef", "packageD", "podDist", "packagePath", "pkgRel", " packageRel", "moduleDir", " packageDef", " packageDist", "pkgFolder", " packageD", "pkgDir", "packageDist", "podDir", "installDef", "podD", "installDist", " packagePath", "moduleRel", "packageFolder", "packageRel", "installD"], "created": ["raised", "creat", "forced", "present", "arted", "confirmed", "started", "registered", "given", "TED", " generated", "checked", "Created", "made", "generated", "activated", "filled", "produced", "loaded", "called", " started", "founded", "ready", "creator", "provided", "ced", "locked", "recorded", "released", "developed", "joined", "existent", "installed", "create", "allowed", "creation", "printed", "defined", "associated", "successful", "reported", "mounted", "added"], "currentPath": ["recentParent", " currentParent", "CurrentCh", "recentName", "recentPath", "currentlyPath", "currentCh", "CurrentPath", "currentlyFile", "currentFile", "currentlyCh", " currentCh", "CurrentPoint", "currentParent", "currentlyName", "CurrentParent", "currentPoint", "CurrentName", " currentFile", " currentPoint", " currentName", "CurrentFile", "recentPoint", "currentName"], "i": ["cli", "mi", "u", "id", "ri", "q", "status", "them", "g", "di", "gi", "ci", "mu", "ski", "info", "I", "f", "pi", "exp", "ix", "chain", "my", "m", "ki", "multi", "it", "ic", "li", "xi", "init", "key", "ji", "batch", "ind", "o", "qi", "v", "p", "ex", "ity", "si", "me", "iu", "in", "major", "j", "ie", "zi", "iii", "slice", "iy", "uri", "os", "ip", "go", "index", "ami", "iq", "ini", "jj", "ii", "ai", "bi", "cgi", "yi", "sim", "ei", "ij", "ti", "hi", "phi", "y", "this", "ui", "im", "oi"], "file": ["f", "et", "header", "p", "port", "fo", "format", "disk", "path", "le", "io", "handler", "buffer", "set", "rule", "sf", "File", "resource", "table", "FILE", "link", "page", "comment", "dir", "child", "body", "base", "parent", "pool", "name", "h", "ile", "template", "source", "db", "l", "row", "type", "play", "log", "info", "local", "handle"], "fos": ["oos", "ffos", "wos", "foss", "oaos", " faos", "fbo", "fo", "floss", "Foss", "oow", "Faos", "fbow", "foses", "foes", "ffoes", "flo", "woss", " foss", "sfos", "woses", "fbos", "fbaos", "oo", "ffo", "flaos", "FOS", "floses", "flos", "fOS", "faos", "floes", "woes", "sfaos", "Fos", " foses", " fo", "Foes", "fow", "sfOS", " fOS", "Fo", "sfoss", " foes", "ffaos", " fow"], "fileSrc": ["fileDrl", "fileErl", "jobSrc", "fileEri", "fileInrc", "fileNri", "fileNrc", " fileInsRC", "fileSsrc", "fileNci", "jobSri", "fileInsrc", "fileInRC", "fileSci", " fileSsrc", "fileSRC", " fileSRC", "fileDource", "fileErc", "fileSri", "fileDrc", "fileSrl", "fileInsRC", "fileSource", "jobNci", " fileInsrc", "jobSci", " fileSource", "fileDri", "fileDRC", "jobSrl", " fileInsource", "jobNrl", "fileNrl", "jobNrc", "fileEci", "fileInource", "fileInsource", "fileDci", "jobNri", "fileDsrc", "fileInssrc", " fileInssrc"], "fileDst": ["fileSlt", "fileDnd", "FileSst", "fileNst", "FileSpl", "FileSnd", "fileNot", "FileDnd", "FileDot", "FileSlt", "FileDlt", "FileDld", "FileDpl", "fileDot", "fileDld", "FileDcr", "fileSst", "fileDpl", "fileScr", "filedld", "fileNld", "fileNcr", "fileSpl", "fileWot", "fileWpl", "filedcr", "filednd", "fileWst", "fileWlt", "fileSld", "fileSot", "fileDlt", "fileNpl", "fileNnd", "filedst", "fileDcr", "FileSot", "fileNlt", "FileScr", "FileSld", "fileSnd", "FileDst"], "reader": ["context", "readable", "dr", "actor", "stream", "ri", "rc", "upper", "ader", "ocker", "er", "review", "oder", "driver", "iterator", "handler", "Larry", "buffer", "parser", "entry", "loader", "author", "resource", "rl", "runner", "reading", "ro", "ler", "query", "controller", "rr", "rar", "Reader", "rx", "ner", "r", "book", "iter", "inner", "rer", "row", "roller", "rot", "read"], "writer": ["riter", "operator", "writers", "store", "server", "stream", "liner", "println", "window", "format", "later", "service", "driver", "iterator", "user", "order", "player", "editor", "print", "buffer", "handler", "test", "parser", "maker", "wrapper", "walker", "loader", "entry", "table", "worker", "runner", "ter", "storage", "creator", "browser", "report", "query", "document", "wright", "caster", "console", "function", "builder", "Reader", "word", "client", "write", "wire", "writing", "iter", "manager", "variable", "adder", "flush", "Writer", "draw", "w", "read", "outer"], "line": ["column", "record", "ine", "pe", "entity", "ole", "header", "node", "style", "liner", "port", "eline", "message", "detail", "string", "user", "ln", "le", "chain", "print", "sequence", "cell", "valid", "kin", "block", "rule", "entry", "continue", "lin", "text", "frame", "stroke", "Line", "inline", "nl", "page", "link", "range", "comment", "label", "code", "lined", "word", "number", "source", "l", "row", "LINE", "sample", "edge", "point", "date"]}}
{"id1": "1421557", "id2": "8770016", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "19584877", "id2": "21125261", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "15799935", "id2": "11673907", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveExtachmentPart", "saveAttachedPart", "saveAttachablebody", "saveAttachableFile", "saveAttachablePart", "saveAttachmentFile", "saveAttentionBody", "saveAttachmentPart", "saveExtachmentbody", "saveAttachedbody", "saveAttachableBody", "saveExtachedbody", "saveAttachmentbody", "saveAttentionPart", "saveAttachedBody", "saveAttentionFile", "saveExtachmentBody", "saveAttentionbody", "saveExtachmentFile", "saveExtachedPart", "saveExtachedFile", "saveExtachedBody"], "context": ["host", "translation", "container", "search", "comments", "present", "cf", "cache", "message", "support", "instance", "service", "cc", "content", "environment", "chain", "stack", "state", "ctx", "subject", "network", "application", "request", "view", "frame", "response", "connection", "document", "course", "parent", "java", "system", "current", "client", "template", "config", "foundation", "null", "center", "version", "tx", "background", "ce", "media", "contact", "command", "component", "history", "Context"], "part": ["host", "top", "reply", "PART", "patch", "p", "work", "zone", "data", "task", "message", "instance", "pair", "thread", "partial", "art", "block", "join", "post", "add", "trans", "Part", "session", "piece", "report", "connection", "file", "component", "body", "tmp", "parent", "base", "sp", "name", "word", "se", "parts", "start", "type", "version", "tx", "bound", "sample", "pod", "and", "job", "temp"], "localAttachment": [" localAttail", "localAssail", "localDetachment", " localDetachment", "localDetignment", " localAttached", "localAssached", "localAppachment", "localAssment", " localAttignment", "localAttachached", "localDetail", "localAttachail", "localAppention", " localAttment", "localAttment", "localAttached", "localATTention", " localAttachignment", " localAttachention", "localAppached", "localAttail", " localAssached", " localDetignment", "localAcached", "localAcignment", "localAttention", "localattention", "localAttachignment", "localattachment", "localAssignment", "localAssention", "localAssachment", " localAttention", " localDetached", "localDetached", "localAppail", "localAcachment", "localAttignment", " localAssention", "localATTignment", "localATTment", "localATTachment", "localAttachachment", "localAttachention", " localAttachached", " localAssail", "localDetention", "localattached", " localDetail", " localAttachachment", " localAssachment", "localAcail"], "accountId": ["accountName", "accS", "objectById", "amountId", "containerID", "objectName", "amountDb", "accountDb", "containerId", "accID", "bankId", "accNum", "containerNum", "accountAnd", " accountInt", " accountNum", "AccountName", "objectId", " accountDb", "containerInt", "accId", "accountS", "accAnd", "accDb", "amountInt", "accountInt", "AccountId", "AccountById", " accountAnd", "bankAnd", "accountNum", "AccountID", "amountID", "accountID", "bankID", " accountID", "bankS", "objectID", "accountById", " accountById", " accountS", "accInt", " accountName"], "attachmentId": ["contachmentId", "attacheId", "attociationid", "Attociationid", "attignmentid", "AttachmentId", "attachedById", "attmentID", "attachedSerial", "AttachmentById", "attignmentId", "attignmentID", "assignmentById", "attachmentById", "attacheid", "attionById", "attionid", "contachedId", "contachmentSerial", "assachmentid", "attionSerial", "contachedSerial", "attachmentid", "attmentid", "attociationById", "contachmentById", "attachmentID", "attachedid", "assachmentById", "assignmentID", "contachedid", "attachedID", "attacheID", "attociationId", "attignmentById", "attacheById", "assachmentId", "AttociationId", "attachedId", "AttociationById", "assachmentID", "AttachmentID", "AttociationID", "attmentById", "attociationSerial", "attociationID", "attachmentSerial", "attionId", "contachedById", "Attachmentid", "contachmentid", "assignmentid", "attmentId", "assignmentId"], "in": ["ins", "din", "inside", "en", "id", "p", "ex", "sum", "IN", "inn", "con", "ai", "inf", "cin", "gin", "m", "on", "bin", "mm", "from", "raw", "it", "vin", "all", "init", "as", "file", "mc", "al", "body", "act", "ch", "per", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "iter", "conf", "l", "isin", "info", "read", "In"], "saveIn": ["storeIn", "getIN", "savAs", "saveIN", "savePath", "storeIN", "secureIN", "sendIN", "aveIN", "secureIns", " saveIns", "aveIn", "aveOut", "sendOut", " saveOut", " saveIN", "savIN", "saveIns", "sendPath", " savePath", "getIns", "sendIn", "secureAs", "saveOut", "storePath", "getOut", "getIn", "secureIn", "savIn", "savIns", "storeOut", "aveIns"], "saveAs": [" saveBy", "submitAS", " saveAS", "aveIn", "SaveAs", "aveAs", "submitBy", " saveTo", " saveAn", "aveAS", "aveas", "submitAs", "dumpAn", "aveAn", "Saveas", "saveAS", "submitIn", "dumpTo", "saveas", "dumpAs", "aveTo", "saveTo", "SaveIn", "SaveAS", "submitas", "saveAn", "saveBy", "SaveBy"], "out": ["cn", "copy", "output", "OUT", "co", "v", "serv", "ex", "sum", "ent", "con", "net", "io", "sys", "outs", "it", "OU", "ou", "inv", "to", "all", "obj", "gc", "res", "auto", "aos", "cos", "name", "can", "up", "oss", "i", "one", "inner", "ao", "os", "null", "conv", "o", "t", "log", "Out", "outer", "n"], "copySize": ["copyPercent", "CopyPercent", " copyCount", "likeFontSize", "copyCount", "likeLength", "msgLength", "pushLength", "opySIZE", "msgPercent", "CopyCount", "opySize", "pushSize", "copyLength", "CopySize", "pushFontSize", "CopyLength", "msgSIZE", "CopyFontSize", "copyFontSize", "opyPercent", "likeCount", "likeSize", "msgSize", " copyFontSize", "copySIZE", "opyLength", "CopySIZE", " copyLength", "pushCount"], "contentUriString": ["contentUrisstring", "contentIriString", "contentUuriNumber", "contentUristring", "contentUistring", "contentUniStr", "contentUnuriNumber", "contentUnistring", "contentUriNumber", "contentUnriString", "contentUiStr", "contentIistring", "contentUnriStr", "contentUiString", "contentUriStr", "contentUicStr", "contentUniNumber", "contentUicStatic", "contentUicString", "contentUrisString", "contentUuriStr", "contentUuriStatic", "contentUniString", "contentUrisStr", "contentIiString", "contentUnriNumber", "contentIristring", "contentUiStatic", "contentUuristring", "contentIiStr", "contentIiStatic", "contentUrisNumber", "contentUnuriString", "contentIriStr", "contentIriStatic", "contentUnristring", "contentUicstring", "contentUnuristring", "contentUuriString", "contentUriStatic", "contentUnuriStr"], "mSize": ["lLength", "mPos", "lSize", "mBytes", "moPos", "nSize", "mLength", "moBytes", "moLength", "moSize", "nLength", "lPos", "nBytes", "lBytes", "nPos"], "mContentUri": ["mResourceUri", "mContent_ris", "mContentIuid", "mContent_uid", "mContentUris", "mResourceUuid", "mContent_ri", "mResourceURI", "mContentIri", "mContentUuid", "mContentIRI", "mResourceUris", "mContentURI", "mContentPRI", "mResourceIRI", "mResourceIri", "mResourceIris", "mContentPri", "mContentIris", "mContentPuid", "mResourceIuid", "mContent_RI", "mContentPris"], "cv": ["cn", "const", "av", "vv", "cf", "v", "cu", "rc", "ov", "cont", "tc", "nc", "buf", "ev", "cc", "vr", "csv", "box", "um", "c", "vp", "cod", "qv", "vol", "nv", "sv", "dc", "cap", "GV", "gc", "act", "vc", "uv", "cp", "qu", "cas", "cmp", "mult", "vm", "ctrl", "conv", "CV", "desc", "vt", "ct", "xc", "cm", "lv", "cb", "lc", "fc", "pb"], "uri": ["folder", "u", "uid", "ri", "id", "du", "doi", " Uri", "bid", "origin", "q", "picture", "uni", "URI", "subject", "term", "resource", "link", "report", "ur", "prefix", " URI", "range", "query", "dir", "uu", "address", "phi", "directory", "iri", "unit", "ui", "ue", "i", " ni", "ip", "url", "qi", "component", "result", "handle"]}}
{"id1": "9099457", "id2": "932225", "code1": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"hash": ["update", "id", "sum", "message", "format", "string", "Hash", "print", "str", "text", "sign", " hashing", "link", "tag", "dump", "key", "hex", "code", "address", "name", "check", "h", "uri", "shadow", "type", "component", "index"], "value": ["object", "output", "values", "v", "position", "language", "data", "message", "select", "description", "string", "content", "test", "sequence", "tree", "val", "example", "raw", "text", "label", "attribute", "item", "key", "expression", "python", "document", "name", "VALUE", "word", "current", "this", "vector", "source", "input", "title", "null", "json", "version", "type", "variable", "sample", "password", "hello", "Value", "now", "result"], "md": ["cmd", "dd", "amd", "der", "red", " cmd", " mc", "mg", " rm", " sm", "mk", "sd", " dd", "od", " sd", "ms", "m", "mm", "pm", "pt", "gm", "pd", "mod", "strong", "down", "and", "add", "ke", "de", "dir", "sam", "ad", "mn", "df", "nt", "msg", "dm", "mand", "ind", "mb", "det", "met", "h", "grad", "ld", "td", "rm", "di", "bd", "hd", "d", "MD", "sm"], "md5hash": ["md2sum", " md3hash", "md5cache", "md3print", "MD2Hash", "md3hash", "md2Hash", "md3sha", "md5hex", "MD2h", "md2hash", "md4hash", "md5sum", "md3sum", "md7sum", "md50print", " md5sum", "md45hash", " md3print", "md45sum", " md3hex", " md3sum", "md2cache", "md3cache", "MD5hash", "md4h", "md4sum", "MD5sum", "MD2hash", "md50hash", "md4Hash", " md3sha", "MD5h", "md7Hash", "md45sha", "md2h", " md3cache", "md5Hash", " md5sha", "md45hex", "md2sha", "md2hex", " md5cache", " md5hex", "md5print", "md7hash", " md5print", "MD2sum", "MD5Hash", "md50sum", "md3hex", "md5h", "md50cache", "md7h", "md2print", "md5sha"]}}
{"id1": "17996547", "id2": "8069594", "code1": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyfile", "copyDir", " copyFiles", "deleteDir", "deletefile", "CopyFiles", "CopyFile", "copyFiles", "deleteFile", "Copyfile", " copyDir", "deleteFiles", " copyfile", "CopyDir"], "fileToCopy": ["filetoCopy", "fileToApply", "FILEToCop", "fileTomDelete", "FILETOApply", "FILEToSave", "file2Cop", "fileFromRemove", "fileToWrite", "fileToSave", "fileToCop", " filetoCopy", "fileToDelete", "file2Save", "fileTOCop", "fileTomWrite", "fileTomRemove", "file2Apply", "fileTOSave", "fileFromDelete", " fileToDelete", "FILETOCop", "fileTomCopy", "FILETOCopy", "filetoDelete", " fileToRemove", " filetoDelete", "FILEToApply", "file2Copy", "fileFromCopy", "fileTOApply", " filetoWrite", "FILETOSave", "FILEToCopy", "filetoWrite", "fileTOCopy", " filetoRemove", "fileFromWrite", " fileToWrite", "filetoRemove", "fileToRemove"], "copiedFile": ["coponeFILE", "copifiedfile", "copIEDFile", "calledyingFILE", "copicedFilename", "coriedFilename", "partiedLog", " copcedFile", "partiedFile", "copriedPath", "copiedLog", "copanedFile", "copyingFILE", "calledyingFile", "coricedFilename", "copIEDLog", "coricedFile", " copcedFilename", "partriedFilename", "copriedFolder", " copriedDirectory", "coponeFile", "copyingFile", "callediedPlace", "copiatedFolder", "copanedDir", "partriedLog", "copifiedDir", "coponeFilename", "coriedfile", "copiatedDirectory", "copriedDirectory", "calledyingDir", "copiedFilename", " copcedfile", "copiedPath", " copiedPath", "copifiedFilename", "copifiedPlace", "callediedFILE", " copriedFolder", "coricedFILE", "copyingLog", "calledyingPlace", "callediedDir", "copriedFilename", "copicedFile", "copiatedFile", "copriedFile", "copifiedFILE", "copriedLog", "callediedFile", "copriedfile", "copanedFILE", " copiedDirectory", " copiedFolder", "coricedfile", "copyingPlace", "copcedfile", "copiedDirectory", "copicedFILE", " copriedPath", "coriedFile", "copyingFilename", "copicedfile", "copyingDir", "coponefile", "copiedfile", "copifiedFile", "partiedFilename", "copcedFile", "copiatedPath", "copyingFolder", " copiedfile", " copiedFilename", "copiedDir", "copriedFILE", "copIEDFilename", "copyingDirectory", "copcedFilename", "copiedFILE", " copriedFile", "copiedPlace", "copanedPlace", "copiedFolder", "coriedFILE", "partriedFile", "copyingPath"], "in": ["f", "ins", "din", "inside", "irm", "en", "ini", "IN", "inn", "con", "ai", "io", "inf", "form", "cin", "gin", "on", "bin", "from", "ar", "it", "vin", "ains", "re", "inv", "init", "file", "al", "ma", "ain", "per", "ind", "is", "inc", "out", "up", "rin", "doc", "i", "input", "source", "r", "inner", "iter", "conf", "get", "oin", "isin", "im", " din", "read", "In"], "outWriter": ["outputWriting", "outwriter", "OUTWriter", "backStreamer", "outputStream", "outHandler", "backReader", "outputWrit", "OutWriting", "backWriter", "outStreamer", "backwriter", "outputHandler", " outWrite", "OutWriter", " outStreamer", " outwriter", "outputWrite", "innerStream", "outputWriter", "OutReader", "innerHandler", "outputReader", "outReader", "innerWriter", "outWriting", "OUTwriter", "outWrite", " outHandler", " outReader", "outWrit", " outWriting", "outputwriter", "OUTReader", " outStream", "outStream", "innerWrite", "OutWrit", "OUTWriting", "outputStreamer", " outWrit"], "c": ["f", "k", "u", "cs", "v", "rc", "cf", "cut", "count", "cache", "ec", "sc", "nc", "char", "unc", "cc", "e", "chain", "q", "m", "ac", "C", "col", "dc", "cap", "mc", "gc", "code", "cos", "pc", "ch", "cp", "uc", "cmp", "out", "i", "cr", "character", "bc", "r", "l", "cd", "cl", "ct", "t", "ce", "cm", "d", "cb", "lc", "cont", "n"]}}
{"id1": "22875895", "id2": "19276022", "code1": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 1, "substitutes": {"readVersion": ["parseVersion", "loadVersion", "readversion", "getVersions", "readVersions", "getVERSION", "loadversion", "parseVERSION", "getversion", "parseVersions", "readVERSION", "parseversion", "loadVersions", "getVersion", "loadVERSION"], "url": ["f", "rel", "el", "sl", "ssl", "server", "gl", "org", "v", "location", "ls", "dl", "channel", "char", "service", "github", "user", "lr", "path", "web", "ref", "str", "ll", "xml", "entry", "loader", "resource", "http", "rl", "re", "arch", "ul", "nl", "link", "ver", "browser", "URL", "file", "base", "address", "name", "system", "client", "mail", "mount", "get", "r", "uri", "Url", "l", "util", "bb", "result"], "reader": ["length", "dr", "dd", "ipper", "mr", "field", "stream", "holder", "liner", "upper", "bo", "consumer", "er", "peer", "iterator", "driver", "lr", "io", "player", "handler", "buffer", "parser", "maker", "loader", "layer", "author", "writer", "rl", "resource", "load", "runner", "worker", "control", "reading", "creator", "range", "linger", "builder", "redo", "auto", "controller", "rr", "Reader", "rar", "event", "lock", "older", "source", "r", "ner", "iter", "inner", "book", "row", "taker", "roller", "download", "timer", "read", "handle"], "line": ["cli", "column", "ve", "cmd", "record", "ine", "queue", "stream", "style", "liner", "port", "channel", "eline", "message", "level", "char", "detail", "list", "string", "e", "ln", "lo", "le", "chain", "print", "sequence", "cell", "normal", "phrase", "str", "err", "block", "lin", "entry", "rule", "text", "error", "part", "trace", "frame", "col", "nl", "Line", "link", "inline", "note", "range", "label", "comment", "item", "code", "msg", "word", "out", "display", "len", "se", "linux", "iter", "one", "cat", "l", "tab", "lines", "row", "next", "log", "LINE", "sample", "point", "job", "n"], "version": ["value", "license", "server", "v", "Version", "feature", "format", "description", "environment", "volume", "resource", "status", "usage", "ver", "tag", "name", "current", "number", "title", "source", "type", "time", "summary", "release", "date", "index", "VERSION"], "revision": ["revruction", "revvious", "preruction", "revious", "revvision", "interruction", "preision", "previous", "prevision", "reruction", "intervision", "intervious", "reision", "interision"], "sSec": ["sSecond", " sSecond", "nSecond", " sSEC", "lSEC", "nSec", "sSEC", "tDec", "tSEC", "nsec", "lsDec", "lsec", "lDec", "ssec", "tsec", "lsSEC", "sDec", "tSec", "lssec", " ssec", "lSecond", "lsSec", "nSEC"], "lSec": ["dlMs", "dlSEC", "LSec", "lSEC", "lMs", "Lsec", "nSec", " lSEC", " lDec", "LSEC", "sSEC", "nsec", "lsec", "LDec", "lDec", "dlSec", " lsec", "ssec", "lsSEC", "lsMs", "nDec", "sMs", "lssec", "dlsec", "lsSec", "nSEC"], "compileDate": ["CompileDate", "compilationDay", "composeDate", "compiledDay", "compilationate", "CompileDay", "composeDay", "compileate", "compilationDate", "composeate", "CompiledDay", "compileddate", "Compileate", "Compileddate", "compiledDate", "compiledate", "compilationdate", "CompiledDate", "compileDay", "Compiledate", "composedate"]}}
{"id1": "12454178", "id2": "471804", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"alterar": [" scalasar", " ingestar", " scalada", " consequado", " scalar", " ingestada", " ingestasar", " consequar", " alterado", " alterada", " consequada", " scalado", " alterasar", " ingestado", " consequasar"], "t": ["translation", "et", "wt", "ot", "tg", "rt", "tp", "mt", "z", "tip", "b", "p", "ht", "v", "dt", "typ", "tc", "task", "mint", "total", "te", "ent", "e", "q", "tree", "pt", "tu", "m", "st", "it", "c", "ret", "trace", "table", "ti", "qt", "ter", "to", "ts", "j", "a", "x", "nt", " ot", "y", "tr", "det", "T", "out", "txt", "h", "template", "ta", "title", "get", "i", " pt", "g", "tm", "l", "vt", "type", "ct", "o", "temp", "at", "w", "tt", "n"], "stmt": [" superstmt", " stMT", "stMT", " supersttx", " stsm", " sttxt", " superstMT", "Sttm", "StMT", "ttmp", " stmr", "sysm", " stmon", "stmk", "stm", "stmp", "stsm", "ttm", " ststat", " stmp", "sym", "stmon", "irstmk", "sttxt", "stysm", "stytx", " supersttxt", "stytm", " superstmr", " sttx", " stm", "ststat", "stym", "stymt", "Sttx", "Stmp", "sttx", "stmr", "Stmr", "ttmt", "ttstat", "Stmk", "irstmt", "irsttx", "irstMT", "symon", "Sttxt", "stymon", "sttm", " sttm", "styMT", "Stmt", "symt", " stmk", "Stm", "Ststat"], "sql": ["initial", "el", "cmd", "software", "seed", "ls", "dl", "select", "format", "description", "sd", "s", "string", "csv", "ln", "wal", "sys", "q", "pel", "xml", "sq", "scl", "table", "nl", "spec", "sv", "query", "expression", "sol", "lex", "fn", "QL", "name", "lock", "template", "sk", "su", "l", "url", "ql", "SQL", "series", "spr", "n"], "id_disciplina": ["id_disciine", "id_Discomplina", "id_disgrain", "id_disgrine", "id_disciini", "id_Discipline", "id_disciplinate", "id_discomina", "id_disgrini", "id_displine", "id_displinate", "id_disciplINA", "id_displINA", "id_descipline", "id_displina", "id_disciplain", "id_disrigINA", "id_DisciplINA", "id_desciplain", "id_discomplini", "id_discompline", "id_Discompline", "id_Disciplain", "id_disgrina", "id_displini", "id_discomplain", "id_discomain", "id_descomplini", "id_DisciplineINA", "id_disriginate", "id_discomplina", "id_Discomplain", "id_Disciplini", "id_Disciplineinate", "id_discipline", "id_descompline", "id_desciplina", "id_disriginator", "id_Disciplineina", "id_disciplineina", "id_disciina", "id_disciplinator", "id_disciplineINA", "id_disciplineinator", "id_disciplini", "id_descomplina", "id_disciplineinate", "id_discomini", "id_displinator", "id_Disciplinate", "id_descomplain", "id_Disciplina", "id_disciain", "id_Disciplinator", "id_Discomplini", "id_desciplini", "id_Disciplineinator", "id_displain", "id_disrigina", "id_discomine"], "item": ["image", "mi", "object", "tip", "store", "id", "Item", "p", "other", "hit", "match", "ex", "task", "instance", "rec", "items", "e", "me", "iso", "entry", "in", "article", "it", "bar", "link", "key", "obj", "component", "menu", "event", "word", "unit", "element", "team", "i", "iter", "row", "site", "info", "job", "local"]}}
{"id1": "2936678", "id2": "22022715", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 1, "substitutes": {"getUniqueKey": [" getUniquekey", "getRandomkey", "getRandomString", " getRandomkey", "getNewId", " getRandomKey", "getuniqueString", "getuniqueKey", "getuniqueId", "getNewString", " getUniqueString", "getUniqueString", " getUniqueId", "getRandomId", "getuniquekey", "getRandomKey", "getUniquekey", " getRandomId", " getRandomString", "getNewkey", "getNewKey", "getUniqueId"], "digest": ["contity", "displayested", " DigEST", "contests", "displayester", "digity", " digested", "integEST", "integse", "Digester", "digist", "Digested", " Diggest", "Digist", "displayest", "feedist", "validested", "digested", "DigEST", "digests", "feedested", " digEST", "validests", "digse", "validity", "integgest", " digity", "feedEST", "diggest", " digester", "Digest", " Digest", "contest", "feedest", "Digse", " Digse", "contested", "Diggest", "displayist", "digEST", "integest", "validest", "digester", "displayEST", " digests"], "md": ["pdf", "cmd", "dr", "dd", "mt", "mark", "bf", "der", "red", "nd", "dn", "mg", "dh", "mk", "sd", "od", "ms", "m", "mm", "magic", "pm", "pt", "pd", "mod", "ds", "add", "de", "ad", "mc", "mn", "ma", "df", "mp", "dm", "mand", "dig", "cond", "mb", "ind", "det", "grad", "rm", "ld", "td", "di", "wd", "cd", "bd", "fd", "hd", "d", "MD", "sm"], "timeVal": ["TimeValue", "timeDef", " timePref", "imeDef", " timeDef", "TimeDef", "TimePref", "imePref", "timeval", " timeValue", "Timeval", "timePref", "TimeVal", "timeValue", "imeVal", " timeval", "imeValue", "imeval"], "localHost": ["Localhost", "realGuest", "localAddress", "realPort", "realAddress", "localhost", "lochost", "localGuest", "LocalHost", "locValue", "realHost", " localValue", "localPort", "locPort", "localValue", "LocalPort", "locAddress", " localPort", " localAddress", " localhost", " localGuest", "locHost", "locGuest", "LocalValue", "LocalAddress"], "randVal": ["ndVal", "randval", "randStr", "randomInt", " randStr", "RandVal", "RandStr", "ndValue", "randomVal", "randomval", "Randval", "ndval", " randInt", "randomValue", "ndInt", "RandValue", "randInt", "randomStr", " randValue", "randValue", " randval"], "val": ["div", "sl", "cal", "value", "values", "v", "p", "alpha", "aval", "data", "rol", "vals", "reg", "buf", "test", "valid", "ctx", "pt", "ret", "it", "mod", "Value", "vol", "eval", "item", "VAL", "obj", "res", "al", "msg", "ival", "oval", "ind", "def", "aud", "grad", " Val", "sel", "vt", "tx", "Val", "result"]}}
{"id1": "16550855", "id2": "5632808", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"readPage": ["printPage", " readpage", "readPages", "writePage", "readArticle", "readpage", "printArticle", " readPages", "writepage", " readArticle", "printPages", "writePages", "printpage", "writeArticle"], "ignoreComments": [" ignoreTags", "hideComments", "ignoreQuotes", "hideComment", "ignoreLeaks", "hideLeaks", "hideQuotes", "oreComment", " ignoreBlocks", "ignoreComment", "ignoreTags", "oreLeaks", "hideBlocks", "hideTags", " ignoreLeaks", "hideNotes", " ignoreQuotes", "oreComments", "oreBlocks", "oreTags", "ignoreNotes", "oreNotes", " ignoreComment", " ignoreNotes", "oreQuotes", "ignoreBlocks"], "in": ["ins", "din", "cal", "copy", "en", "b", "again", "old", "sum", "IN", "inn", "con", "io", "inf", "cin", "mm", "on", "bin", "m", "from", "it", "ic", "and", "add", "all", "init", "thin", "mc", "mn", "ma", "al", "cm", "reader", "ind", "is", "inc", "client", "out", "check", "h", "rin", "get", "i", "input", "r", "doc", "inner", "up", "conf", "url", "ill", "isin", "info", " din", "read", "In"], "inputLine": ["helloNet", "inputRecord", "outputline", " inputRecord", "rawRow", "InputNet", " inputRow", " inputline", " Inputline", " InputEntry", "indexLo", "rawLine", " inputChain", "inputNet", "helloLin", " InputBlock", "inputChain", "outputRow", "latline", "helloRow", "inRecord", " inputCell", "InputEntry", "inputRow", "inputName", " inputEntry", "inputLo", "outputLine", "InputBlock", "multiLin", "helloLINE", "latLine", "inputLINE", "inLINE", "rawline", "multiLine", "latChain", "inputCell", "InputLine", " inputBlock", "Inputline", "resultRecord", " inputName", " InputLine", "helloLo", "resultLINE", "helloLine", "inLine", "multiLo", "inputLin", "inputBlock", "InputRow", "indexLINE", "rawChain", "outputBlock", "resultLine", "inputline", "inputEntry", "indexLin", "indexLine", "multiLINE", "helloBlock", " inputLINE", "resultName", "inName", " inputNet", "helloCell", "latRow", "InputCell"], "html": ["built", "detail", "err", "has", "js", "http", "emphasis", "enabled", "pretty", "page", "dump", "flash", "h", "template", "details", "title", "url", "f", "value", "https", "cache", "htm", "web", "form", "rendered", "wrapper", "multi", "view", "browser", "related", "img", "layout", "body", "current", "mail", "json", "rss", "esi", "human", "summary", "sg", "att", "result", "header", "ht", "p", "data", "message", "api", "format", "hover", "content", "attr", "theme", "str", "tml", "raw", "available", "HTML", "msg", "hash", "hard", "full", "hd", "plain", "pdf", "output", "total", "embed", "xml", "alert", "md", "height", "db", "css", "tt"]}}
{"id1": "16621499", "id2": "7499186", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadURLToBytes", "loadURLToBuff", "loadUrlToBuffer", "loadUrlToBytes", "loadUrl2Buff", "loadURL2Buffer", "loadUrl2Bytes", "loadUrl2Buffer", "loadURL2Buff", "loadURLtoBytes", "loadURLtoBuff", "loadURLtoBuffer", "loadUrlToBuff", "loadURL2Bytes"], "url": ["el", "sl", "ssl", "gl", "b", "location", "ls", "dl", "char", "bel", "web", "str", "ll", "xml", "loader", "http", "ul", "nl", "link", "page", "browser", "ur", "URL", "file", "cert", "base", "address", "name", "open", "mail", "pl", "r", "uri", "Url", "l", "log", "html", "job"], "buf": ["div", "arr", "cmd", "bl", "axe", "b", "bs", "vec", "bn", "uf", "bo", "dat", "bp", "capt", "box", "queue", "buffer", "nb", "str", "ctx", "pkg", "fb", "bar", "bh", "cv", "cap", "img", "cb", "bag", "seq", "Buff", "batch", "tmp", "nt", "msg", "bu", "tr", "BU", "bt", "txt", "br", "mus", "cat", "conv", "db", "bc", "desc", "Buffer", "rb", "mu", "tx", "buff", "bytes", "log", "font"], "data": ["div", "count", "buffer", "set", " DATA", "obj", "res", "missing", "nt", "def", "br", "done", "bus", "di", "results", "null", "mu", "info", "length", "DATA", "arr", "value", "ata", "cache", "partial", "bin", "zero", "it", "ret", "table", "size", "step", "to", "item", "batch", "name", "no", "json", "type", "default", "result", "initial", "p", "bo", "message", "dec", "format", "content", "str", "raw", "all", "tmp", "msg", "only", "out", "buff", "bytes", "action", "image", "rel", "output", "dat", "total", "list", "text", "part", "map", "a", "this", "good", "txt", "next"], "temp": ["div", "copy", "unt", "v", "cache", "dat", "tc", "alt", "tim", "dest", "partial", "test", "buffer", "tar", "EMP", "pre", "pt", "mm", "term", "mod", "ret", "em", "vol", " Temp", "emp", "nom", "ptr", "mont", "mp", "tmp", "porary", "tr", "pos", "unit", "current", "met", "txt", "rem", "template", "Temp", "ta", "mem", "tm", "tem", "fake", "null", "variable", "t", "buff", "util", "font", "tt", "deg", "result"], "iCount": ["iniLength", "giCheck", "phiLength", "ciCounter", "iLength", " iNumber", "iiCall", "piCount", "liCount", "biCheck", "aiLength", "diTotal", "giCounter", "ciCP", "iCode", "aiCounter", "iuCount", "iMark", "aicount", "dicount", "iCP", "iriCategory", "intProcess", "giCount", "iCheck", "iiProcess", "uiCall", "aiCount", "uiCount", "iriCount", "iiNow", "jTotal", "giTotal", "iCounter", "piCP", "piLength", "icount", "phiCount", "iniCount", " iCheck", " icount", "aiTotal", "iuCP", "iniMark", "iuTotal", "iCategory", "jcount", "giCode", " iMark", "iiTotal", "ciTotal", "piTotal", "biCode", "liCounter", "phiNumber", " iCode", "iniNumber", "iuCounter", "ciCount", "intNow", "intCount", "diCount", "intCategory", "iiCounter", "iriProcess", "piCounter", "jCount", "biTotal", "uiTotal", "iiCategory", "diCounter", " iCounter", "phiMark", "iNow", "liCall", " iLength", "jLength", "iCall", "giLength", "iProcess", "uiCounter", "iiCount", "liTotal", "iNumber", "biCount", "iriNow"], "iTotal": [" iLast", "miTarget", "phiTemp", "phiLast", " iCurrent", " iNew", "piFull", "jCurrent", "imtotal", "ditotal", "iiZero", "piCount", "iParent", "liCount", " iTemp", "jNow", "iuLast", "iuNew", "diTotal", "iNew", " iZero", "piDone", " iFull", "miCurrent", "ciComplete", "diNow", "liTemp", "ciToken", "itotal", " iNow", "jTotal", " iParent", "miLast", "uiFull", "aiTotal", "imTotal", "liLast", "iuTotal", "iFull", "iZero", "iitotal", "miAll", "imCount", "iiTotal", "ciTotal", "piTotal", "jtotal", "iCurrent", "miToken", "uiDone", "miComplete", "diCount", "liNew", "imZero", " itotal", "jCount", "liParent", "iComplete", "phiNew", "iLast", "iToken", "uiTotal", "aiAll", "iAll", " iTarget", "miNew", "phiTotal", "iNow", "iuTarget", "iTemp", "iDone", "jZero", "iiCount", "liTotal", "aiComplete", "piParent", "ciAll", "mitotal", "miTotal", " iDone", "miZero", "iTarget", "aiToken"], "in": ["ins", "din", "en", "b", "v", "serv", "sum", "IN", "inn", "con", "io", "inf", "cin", "mm", "on", "bin", "from", "it", "ic", "or", "by", "re", "and", "add", "mc", "mn", "al", "ma", "per", "reader", "ind", "is", "inc", "out", "check", "h", "up", "get", "i", "input", "r", "inner", "conf", "l", "isin", "info", " din", "In"]}}
{"id1": "9081749", "id2": "1598693", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"encrypt": ["compress", "comprypted", "cryption", "encrypted", "Encrypt", "crypt", "cress", "Encress", "Encryption", "encress", "Encrypted", "compryption", "crypted", "encryption", "comprypt"], "password": ["value", "Password", "p", "confirmed", "pattern", "message", "sword", "total", "email", "description", "secret", "string", "token", "path", "user", "secure", "chain", "phrase", "hello", "database", "picture", "push", "text", "request", "comment", "attribute", "prefix", "key", "expression", "address", "PASS", "word", "name", "username", "source", "pass", "input", "wd", "account", "reset", "shadow", "default", "padding", "wordpress", "command", "past"], "encryptType": ["encjectClass", "encryptype", "encveytype", "encjectTYPE", "ethjecttype", "escryptionStyle", "escryptionType", "encryptionClass", "ethryptClass", "encribeype", "encryptionStyle", "escryptStyle", "ethryptType", "encribeTy", "encryptClass", "ethjectClass", "ethryptTYPE", "encryptionTy", "encribeType", "encjecttype", "encreatTy", "escryptionTy", "escryptionype", "encryptionTYPE", "encveyClass", "encryptTy", "encveyTYPE", "encryptStyle", "encreatType", "escryptTy", "encryptTYPE", "escryptype", "encryptionype", "encryptiontype", "encreatype", "encveyType", "ethjectTYPE", "encryptionType", "encribeStyle", "escryptType", "encjectType", "encrypttype", "ethrypttype", "ethjectType", "encreatStyle"], "md": ["del", "pdf", "cmd", "dd", "dr", "mt", " MD", "der", "red", "nd", "dh", "mk", "sd", "od", "ms", "m", "mm", "me", "man", "pd", "mod", "ds", "down", "add", "de", "metadata", "dir", "obj", "mc", "mn", "ad", "df", " Md", "nt", "dm", "mand", "det", "ind", "mb", "grad", "ld", "di", "cd", "bd", "ct", "rd", "hd", "d", "MD", "sm"], "hash": ["length", "ashes", "host", "ash", "sh", "hz", "search", "here", "style", "stock", "match", "sha", "cache", "rh", "sum", "show", "total", "char", "where", "window", "color", "esh", "Hash", "how", "box", "print", "test", "stack", "sort", "block", "has", "array", "map", "score", "replace", "all", "oh", "handle", "query", "hex", "address", "shift", "mask", "height", "check", "h", "number", "her", "mac", "square", "filter", "sample", "html", "hello", "dig"], "hexString": [" HexString", "jsonBuffer", "octString", "exArray", " hexStr", "hexBuffer", "xfStatement", "exString", "xfString", " hexArray", " hexList", "jsonString", "hashStr", "jsonArray", "hexStr", "hexResult", "octArray", "hexArray", "hexStatement", "exStr", "hashBuffer", "octStatement", " HexResult", "exBuffer", "pexService", "pexArray", "xfArray", " HexStr", " hexstring", "exList", " hexService", "hashString", "hexList", "hexstring", "exStatement", "xfstring", " Hexstring", "jsonStr", "hashArray", "pexList", "exResult", "octstring", " hexResult", "pexString", "exService", "exstring", "hexService"], "i": ["cli", "mi", "ami", "u", "iq", "id", "exp", "v", "pi", "ix", "ex", "gravity", "list", "ii", "si", "e", "ai", "io", "bi", "n", "my", "m", "sim", "set", "me", "in", "iu", "ki", "multi", "ic", "ei", "it", "c", "li", "major", "ti", "a", "j", "xi", "init", "x", "ji", "ie", "phi", "y", "this", "is", "ui", "gu", "uri", "di", "gi", "oi", "json", "ci", "ip", "ski", "\u0438", "info", "qi", "point", "im", "index", "I"]}}
{"id1": "8328527", "id2": "1122585", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    private String copyImageFile(String urlString, String filePath) {\n        FileOutputStream destination = null;\n        File destination_file = null;\n        String inLine;\n        String dest_name = \"\";\n        byte[] buffer;\n        int bytes_read;\n        int last_offset = 0;\n        int offset = 0;\n        InputStream imageFile = null;\n        try {\n            URL url = new URL(urlString);\n            imageFile = url.openStream();\n            dest_name = url.getFile();\n            offset = 0;\n            last_offset = 0;\n            offset = dest_name.indexOf('/', offset + 1);\n            while (offset > -1) {\n                last_offset = offset + 1;\n                offset = dest_name.indexOf('/', offset + 1);\n            }\n            dest_name = filePath + File.separator + dest_name.substring(last_offset);\n            destination_file = new File(dest_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    if (!destination_file.canWrite()) {\n                        System.out.println(\"FileCopy: destination \" + \"file is unwriteable: \" + dest_name);\n                    }\n                    System.out.println(\"File \" + dest_name + \" already exists. File will be overwritten.\");\n                } else {\n                    System.out.println(\"FileCopy: destination \" + \"is not a file: \" + dest_name);\n                }\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory doesn't exist: \" + dest_name);\n                }\n                if (!parentdir.canWrite()) {\n                    System.out.println(\"FileCopy: destination \" + \"directory is unwriteable: \" + dest_name);\n                }\n            }\n            destination = new FileOutputStream(dest_name);\n            buffer = new byte[1024];\n            while (true) {\n                bytes_read = imageFile.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(\"Bad URL \" + urlString);\n        } catch (IOException ex) {\n            System.out.println(\" IO error: \" + ex.getMessage());\n        } finally {\n            if (imageFile != null) {\n                try {\n                    imageFile.close();\n                } catch (IOException e) {\n                }\n            }\n            if (destination != null) {\n                try {\n                    destination.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return (dest_name);\n    }\n", "label": 0, "substitutes": {"insertJobLog": [" insertJobConfig", "insertCheckHistory", "insertJLog", "insertCheckConfig", "insertCheckLog", "insertLoglog", "insertJConfig", " insertJoblog", "insertLogHistory", " insertJHistory", "insertJobConfig", " insertJLog", "insertChecklog", "insertJoblog", "insertJHistory", "insertLogLog", "insertJobHistory", " insertJConfig", "insertLogConfig", "insertJlog", " insertJobHistory", " insertJlog"], "userId": ["userDir", "authorName", "authorId", " userDir", "checkID", "usersById", " userIn", "UserID", "checkPart", " userById", "userPart", "UserId", "userName", "UserIn", "usersId", "usaDir", " userName", "UserPart", "usernameDef", "usaById", "UserById", "authorPart", "usernameById", "usersIn", "checkName", "userDef", "usernameId", "userById", "usersName", "UserName", "authorID", " userDef", "usaId", "userIn", "usernameDir", "usaDef", "userID"], "checkId": ["checkInt", " checkInfo", "workIdent", "workById", "checkID", "testById", "workInt", "ckInfo", "workID", "CheckID", "CheckById", "workId", " checkIdent", "testInfo", " checkById", " checkID", "checkIdent", "CheckInfo", "ckID", "workInfo", "checkInfo", "objInfo", "objID", "cleanIdent", "checkid", "ckById", "workid", "Checkid", "objId", "ckId", "testId", " checkInt", "objById", "cleanInt", "cleanid", "cleanId", " checkid", "testID", "checkById", "CheckId"], "checkType": ["ckKind", " checkTYPE", "testType", " checkInfo", "checkID", "ckInfo", "checkKey", "checkTypes", "okType", "CheckID", "testKind", "checkTYPE", "ckType", "defInfo", " checkID", "ckID", "checkInfo", "CheckType", "checkedID", "checkedType", "defTYPE", " checkKey", "CheckKey", "checkedKind", "okId", "ckTYPE", "checkKind", "checkedTYPE", "okKey", "defType", "testTYPE", "defTypes", "ckTypes", "testID", " checkTypes", "okID", "CheckId"], "objType": ["cbVersion", "bjTheme", "cmdType", " objVersion", " objName", "rtStyle", "ObjVersion", "checkTypes", "checkTYPE", " objStyle", "ObjType", "tmpTy", "rtTypes", "tmpType", "objVersion", "bjTy", "cbTYPE", "cbName", " objTYPE", "bjTYPE", "rtType", "objName", "objStyle", "ObjName", "objTy", "cmdTYPE", "rtTYPE", " objTypes", "ObjTYPE", "objTheme", "tmpTheme", "cmdTy", "objTypes", "objTYPE", "checkStyle", "tmpTYPE", "cbType", "cmdTheme", "bjType"], "dbo": ["dtbo", "rdBO", "rdpo", "pbo", "dbc", "dobf", "Dbc", "dtBO", "DBo", "rdBo", " dbc", "dBO", "Dpo", "DBO", "dpo", "doBo", "dtBo", "dbf", "dBo", "Dbu", " dpo", "dtbf", "doBO", "rdbo", " dbu", "Dbo", " dBO", " dbf", "dbu", "rdbu", "dobo", "pBO", "rdbc", "pBo", " dBo", "ppo"], "connection": ["context", "engine", "output", "server", "position", "computer", "bo", "Connection", "relation", "connect", "communication", "instance", "con", "net", "pointer", "handler", "generation", "database", "subject", "network", "conn", "application", "pen", "government", "collection", "resource", "writer", "table", "c", "response", "link", "socket", "usage", "creator", "session", "query", "document", "po", "function", "library", "connected", "reference", "directory", "settings", "pool", "operation", "open", "ion", "client", "current", "config", "statement", "cone", "close", "manager", "condition", "db", "associated", "t", "management", "command", "information"], "preStm": ["preStrem", "preStrcm", " prePutr", "PreStrn", "preSTam", "prestm", " preStM", "prestsm", "preTrmt", "Prestm", "preSTl", "prefixStmt", "preStrm", "presttm", "presSTsm", "prestmi", " prestr", " prePutam", "preStrdm", "priStm", "preSTem", " prestm", "prePutM", " prePutmn", "preStrmt", "priStcm", "preEstem", "preStl", "prePuttm", "preStmi", "preShmi", "prefixSTmt", "preWn", " preSTl", " preStr", "preStrl", "preStpm", " preTrem", "prestarm", "preEstm", " preSTmt", " preSTm", "PreStrdm", "priSTm", " prePutmt", "priStr", "preFormm", "preStem", "presStpm", "preSTm", " preTrm", "prestem", "preStrr", "prefixStm", "PreStmt", "preSTn", "prePutarm", "prefixStarm", "prestmt", "prePutr", "preStr", "preTrM", "preSTarm", "preFormmt", " prePutem", "preWr", "preStn", "preSTmt", "preSTpm", "preTrm", "preTrem", "preSTcm", "preStmt", "PreStn", "prePutmt", "preShtm", "prePutam", " preSTr", "presStem", "priSTem", " preStam", "preStsm", "prePostam", "preRestr", "preWdm", "presSTpm", "PreStdm", "Prestmi", "Prestmt", " preStl", " prePutl", "PreStm", "prePostem", " prePutm", "preStcm", "PreStrmt", "preWm", "prefixSTm", "prestn", "preStrM", " preStmt", "PreStrm", "PreSttm", "preStdm", "presSTem", "preStam", "preSTsm", " preStmn", "prePutmn", " preStn", "prePutmi", "Presttm", "prePostm", "preStmn", "prefixSTarm", "prefixSTem", "presStm", "preStarm", "preRestl", "priSTcm", "preSTmn", "prePostmn", "PreStmi", "preRestmt", "prePutem", "preSTr", "preStrn", "prePutl", " preTrM", "preShmt", "prestr", " prestmt", " preTrmt", "prefixStem", " prestn", "presStsm", "preWmt", "preStM", "presSTm", "preRestm", "preSttm", " preStem", "preFormdm", "prePutm", "prestl", "priSTr", "preFormn", "preEstpm", "preShm", "priStem", "prestpm", "preEstsm"], "sql": ["cmd", "quote", "ssl", "seed", "ls", "script", "dl", "description", "sd", "setup", "s", "string", "csv", "sn", "sys", "q", "ll", "xml", "conn", "sq", "pkg", "js", "san", "scl", "nl", "spec", "sv", "query", "sb", "sol", "eps", "sp", "fn", "template", "sk", "su", "db", "json", "ql", "SQL", "log", "spr"], "cleanSql": ["removeSQL", "cleanDSQL", "cleanAsml", "cleanSQL", "cleanStmt", "emptySq", "cleanDSq", "cleanSymt", "removeSql", "cleanInsq", "cleanAsq", "emptyStql", "cleanInsuff", "emptySmt", "cleanPuff", "emptySml", "cleanPQL", "cleanPql", "cleanDSuff", "removePq", "cleanStml", "cleanDSql", "cleanStq", "removePuff", "removeSuff", "cleanPq", "cleanSq", "cleanAsmt", "cleanSmt", "cleanSyml", "cleanSyql", "cleanSuff", "removePql", "cleanStql", "emptySql", "removeSq", "emptyStmt", "cleanSyq", "removePQL", "cleanInsQL", "emptyStml", "cleanAsql", "emptyStq", "cleanInsql", "cleanSml"], "dCount": ["udRes", "dlMax", "udLimit", "dRes", "udMax", "outRes", "dlCount", "dlRes", "dLimit", "outMax", "outCount", "dlLimit", "dMax", "udCount", "outLimit"], "sHaveIns": ["sHaveEx", " sHaveins", "sSeeins", "sSeeIns", "shaveIns", " sHaveINS", "shaveins", "sHavingEx", "SHaveEls", "sHaveCons", "sHasIns", "sSaveins", "sHasins", "sSaveCons", "sSeeINS", " shaveINS", "sHasCons", "sHaveins", "sHasINS", "SHadEls", "sSaveEls", "sSaveIns", "SHaveCons", "SHadins", "shaveINS", "SHaveins", "SHaveIns", "sHavingIns", "sHadins", "sHasEls", "sHasEx", "sHavingins", "SHadIns", "sHaveINS", "sHadIns", " shaveIns", "sHadEx", "sHadEls", "SHadCons", "sHadCons", " shaveins", "sHaveEls"], "j": ["k", "f", "z", "jen", "oj", "dj", "b", "exp", "v", "p", "ix", "jj", "jp", "ju", "aj", "n", "q", "Journal", "m", "Ja", "bot", "Job", "it", "js", "jump", "by", "ja", "J", "ij", "_", "key", "x", "jl", "kj", "left", "ji", "batch", "msg", "y", "ind", "jack", "bj", "out", "br", "off", "i", "uj", "g", "json", "jit", "o", "jo", "att", "job", "index", "jc"]}}
{"id1": "21979462", "id2": "21425787", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURL2JSON", " downloadURLoString", " downloadurloText", " downloadURL2String", " downloadURL2Bytes", " downloadURL2Text", " downloadurltoJSON", " downloadURLToString", " downloadURLToText", " downloadURLToJSON", " downloadURLoJSON", " downloadurloJSON", " downloadurltoText", " downloadURLtoJSON", " downloadurloBytes", " downloadurloString", " downloadURLtoText", " downloadURLoBytes", " downloadurltoBytes", " downloadurltoString", " downloadURLoText", " downloadURLToBytes", " downloadURLtoBytes"], "url": ["sl", "ssl", "domain", "gl", "id", "location", "ls", "dl", "char", "bel", "web", "ref", "un", "rect", "ll", "ret", "resource", "http", "ul", "link", "all", "ur", "browser", "URL", "file", "run", "uu", "base", "address", "name", "mount", "mail", "uri", "Url", "l", "log", "job"], "in": ["ins", "din", "copy", "again", "sum", "IN", "er", "inn", "con", "ai", "io", "inf", "cin", "gin", "on", "bin", "from", "ic", "it", "or", "by", "re", "and", "all", "thin", "mc", "mn", "al", "ma", "reader", "ind", "is", "inc", "check", "out", "up", "i", "input", "inner", "oin", "conf", "ill", "isin", "info", "read", "In"], "sb": ["ssl", "b", "bs", "bf", "bn", "SB", "ib", "sd", "bp", "nb", "rob", "gob", "sq", "sf", "ab", "bis", "bh", "bg", "xb", "wb", "sam", "gc", "eb", "sp", "bt", "erb", "lp", "gb", "bj", "mb", "pa", "sk", "lb", "kb", "db", "zb", "bsp", "pb", "bd", "ub", "rb", "sg", "bb", "cb", "sa"], "str": ["div", "arr", "del", "expr", "sl", "dr", "bl", "exec", "b", "gr", "p", "sts", "ls", "STR", "dat", "char", "list", "Str", "string", "s", "chain", "print", "err", "m", "pt", "st", "block", "set", "text", "part", "re", "vol", "comm", "j", "fr", "comment", "req", "obj", "sp", "msg", "ch", "tr", "def", "comp", "txt", "br", "i", "r", "cur", "bc", "syn", "source", "l", "iter", "cat", "t", "next", "cont", "n"]}}
{"id1": "1097146", "id2": "1985677", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getContentDigest", "getContentdigests", "getMessageDigests", "getContentDigests", "getMessageDecested", "getMessagedigested", "getContentDigested", "getMessagedigester", "getContentDigester", "getContentdigested", "getContentdigest", "getMessageDecester", "getMessagedigest", "getMessageDigester", "getContentdigester", "getMessageDigested", "getMessageDecest", "getMessageDecests", "getMessagedigests"], "input": ["image", "initial", "cmd", "output", "value", "p", "pattern", "data", "char", "format", "Input", "string", "empty", "form", "buffer", "state", "q", "any", "qi", "xml", "valid", "in", "raw", "from", "text", "request", "it", "active", "quick", "focus", "file", "missing", "uu", "address", "msg", "act", "name", "this", "check", "out", "up", "get", "source", "qa", "config", "cur", "required", "null", "url", "unknown", "human", "sample", "password", "hello"], "md": ["pdf", "cmd", "dr", "dd", "mt", "der", "mg", "dh", "mk", "sd", "med", "od", "ms", "m", "mm", "pm", "pd", "mod", "ds", "sam", "mc", "mn", " Md", "df", "managed", "mp", "nt", "ad", "dm", "mand", "det", "mb", "def", "comp", "grad", "ld", "di", "cd", "bd", "mu", "hd", "cm", "d", "MD", "sm"], "bytes": ["terms", "rings", "words", "b", "binary", "bs", "bits", "values", "videos", "ls", "classes", "clips", "s", "bles", "windows", "nets", "ms", "files", "strings", "Bytes", "outs", "bps", "users", "pieces", "reports", "forms", "tes", "seconds", "objects", "latest", "keys", "parts", "steps", "ings", "bags", "es", "pages", "lines", "versions", "groups", "units", "qs", "blocks"]}}
{"id1": "17296916", "id2": "3024970", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"logging": ["debugging", "Logging", "LogStorage", " logStorage", " logger", "debuging", "Loging", " loging", "debugger", "logger", "Logger", "loging", "debugStorage", "logStorage"], "wrap": ["store", "ew", "work", "we", "message", "window", "format", "grow", "web", "box", "nw", "chain", "form", "me", "sw", "safe", "wrapper", "pack", "use", "add", "link", "wra", "W", "gate", "shape", "x", "xf", "python", "ad", "rap", "transform", "force", "build", "wx", "wa", "sp", " wrapped", "zip", "word", "inter", "get", "wire", "create", "find", "reset", "start", "parse", "ow", "wind", "aw", "root", "pad", "ws", "w", "read", " wrapper", "handle"], "buffer": ["quote", "reply", "output", "store", "header", "surface", "binary", "flag", "position", "cache", "bo", "screen", "profile", "message", "window", "buf", "queue", "print", "phrase", "complete", "database", "sequence", "block", "face", "wrapper", "view", "layer", "button", "trace", "writer", "table", "size", "frame", "bar", "bridge", "note", "report", "attribute", "document", "builder", "console", "batch", "body", "base", "library", "directory", "reference", "flash", "word", "line", "append", "ob", "template", "display", "memory", "iter", "reset", "row", "Buffer", "buff", "bb", "command", "pb"], "encoding": ["cododer", "enryption", "coding", "enaling", "enumlanguage", "cododed", "cryption", "coder", "Encoder", "enumoding", "enging", "enclanguage", "ecoding", "Encryption", "cododing", "encging", "enoding", "encoded", "ecoded", "caling", "enumoder", "codryption", "encoder", "encaling", "enoded", "cging", "enumging", "ecoder", "Encoding", "encryption", "enoder", "ecryption", "enlanguage", "clanguage", "Encaling"], "getEncoding": ["getEnling", "getEnoding", "getEncging", "getencling", "getOrigination", " getEncination", "getEncling", "getExpoding", "getExpression", "getEncryption", " getEnoding", "getEnination", "getEnryption", "getEnging", "getencging", "getExpryption", " getEnination", "getOrigryption", "getEnression", " getEnling", "getEncression", "getencoding", " getEncryption", "getOrigoding", "getEncination", "getencryption", " getEncging", "getencination", "getencression", "getOrigling", " getEncression", "getExpging", " getEncling", " getEnging", " getEnression", " getEnryption"], "headers": ["pins", "terms", "pres", "writers", "header", "caps", "comments", "values", "rs", "drivers", "fields", "builders", "chains", "properties", "authors", "ers", "weights", "ilers", "relations", "ctors", "images", "boxes", "users", "holders", "limits", "codes", "ppers", "reports", "heads", "params", "styles", "objects", "members", "modules", "keys", "head", "ports", "ids", "names", "groups", "frames", "ters", "blocks", "tags", "checks"], "is": ["isa", "isl", "fs", "sis", "ins", "osi", "lis", "iss", "bs", "ri", "ris", "dis", "ists", "isi", "nis", "us", "si", "ys", "sys", "ms", "obs", "iso", "has", "in", "ic", "or", "bis", "tis", "ois", "ims", "as", "IS", "iris", "mis", "Is", "isc", "ui", "isd", "does", "i", "isf", "os", "\u00eds", "ip", "ais", "its", "ist", "isin", "was", "ios"], "bos": ["fs", "oos", "tops", "bs", "bits", "ows", "bones", "cs", "bes", "ubis", "bo", "stats", "banks", "isi", "lets", "bas", "windows", "bi", "ys", "sys", "nos", "obs", "ms", "bot", "bin", "js", "ots", "dos", "ps", "bis", "tis", "oids", "bh", "ts", "eros", "des", "boards", "aos", "uts", "tes", "fits", "soc", "cos", "ses", "jas", "oops", "uds", "ui", "oss", "os", "ods", "bytes", "los", "pod", "ols", "ones", "ios"], "e": ["f", "en", "p", "v", "ex", "er", "ge", "ae", "ev", "ate", "le", "ne", "ed", "E", "err", "m", "me", "c", "error", "re", "a", "de", "x", "ie", "h", "se", "r", "i", "g", "es", "oe", "exc", "o", "t", "eeee", "d", "ee", "n"]}}
{"id1": "7945594", "id2": "20519261", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 1, "substitutes": {"fileDownload": ["filedownload", "urlGet", "urlDownload", "FileUpdate", "urldownload", " fileGet", " fileUpdate", "fileGet", "FileGet", " filedownload", "fileUpdate", "FileDownload", "urlUpdate", "Filedownload"], "fAddress": ["eAdmin", "xfDomain", "hURI", "vLocation", "fiAdd", "eAdd", "fiDomain", "pValue", " fAdd", "fiAddress", "fiaddress", "fValue", "FPart", "fPart", "fdAddress", "vAddress", "fLocation", "xfLocation", "hValue", "sfOrder", "fmPart", "fURL", "feAdd", "FOrder", "fContact", "fAdmin", "sfPart", "fiURL", "pAddress", "sfContact", "FContact", "feAdmin", "fAlias", "xfAddress", "fmAddress", "fdAdd", "pAdd", "fmOrder", "fiAlias", "fdAlias", "FAdmin", "pURI", "xfURI", "vaddress", "hAdd", "xfValue", "feAddress", "fURI", "fmContact", "eOrder", "sfAddress", " fAlias", "vDomain", "fDomain", "hAddress", "xfAdd", "faddress", "fOrder", "xfaddress", " fURL", "eAddress", "FAdd", "feOrder", "fiLocation", "FAddress", "fdURL", "fAdd"], "destinationDir": ["destarationDir", "declificationFolder", "destificationFolder", "destificationDir", "declificationdir", "destinationdir", "declinationdir", "destinationsdir", "destinationsDirectory", "declificationDirectory", "destacementDir", "destacementDirectory", "declinationDir", "DestificationDirector", "destinationDirector", "destarationdir", "Destificationdir", "DestinationDirector", "destinationsFolder", "destinedDirector", "Destinationdir", "destinationDirectory", "declinationDirectory", "destinationsDir", "declinationFolder", "destacementFolder", "declificationDir", "DestinationDir", "destinedDir", "destineddir", "destinedFolder", "destificationDirectory", "DestificationDir", "DestificationFolder", "destarationDirector", "destificationDirector", "destacementdir", "destinationFolder", "destificationdir", "DestinationFolder", "destarationFolder"], "slashIndex": ["swasherIndex", "flashIndex", "swashPosition", "slugIndex", "slugindex", "sllashCount", "fllashindex", "sllashInd", "slasherCount", "slashedNumber", "slashPosition", "swasherPosition", "slashInd", "slasherNumber", "fllashInd", "sllashPosition", "slashesIndex", "fllashIndex", "slashedPosition", "slashedCount", "slugInd", "slugPosition", "sllashNumber", "swashIndex", "slasherPosition", "swasherCount", "sllashindex", "slashNumber", "swasherNumber", "flashInd", "flashPosition", "sllashIndex", "swashNumber", "slasherIndex", "swashCount", "fllashPosition", "slashindex", "slashedIndex", "flashindex", "slashesindex", "slashesInd", "slashesPosition", "slashCount"], "periodIndex": ["dollarPosition", "tickIndex", "tickPosition", "periodPosition", "tickCounter", "pieIndex", "dollarIndex", "dollarMax", "periodMax", "periodCounter", "piePosition", "tickMax", "pieCounter", "dollarCounter", "pieMax"], "fileName": ["pageKey", "FileKey", "FileInfo", "pagename", "filename", " fileInfo", " fileKey", "pageInfo", "fileKey", "FileName", "pageName", "Filename", "fileInfo", " filename"], "url": ["loc", "rel", "el", "u", "cal", "sl", "ssl", "gl", "org", "https", "com", "il", "hl", "char", "bel", "con", "github", "web", "ml", "un", "str", "ll", "xml", "conn", "raw", "ret", "or", "http", "rl", "re", "ul", "nl", "link", "www", "browser", "ur", "impl", "URL", "cert", "build", "base", "address", "mount", "mail", "client", "pl", "r", "uri", "Url", "l", "cl", "util", "job"], "uc": ["loc", "UC", "co", "ucc", "cu", "rc", "uf", "ec", "sc", "nc", "tc", "userc", "unc", "us", "con", "cc", "um", "anc", "c", "ul", "dc", "auc", "oc", "usc", "mc", "uu", "soc", "cr", "cur", "bc", "cl", "ci", "ub", "cus", "ux", "lc", "fc"], "in": ["f", "ins", "din", "en", "il", "ze", "IN", "inn", "con", "ln", "io", "inf", "gin", "cin", "on", "mm", "bin", "ic", "it", "re", "and", "init", "mc", "al", "body", "reader", "ind", "is", "inc", "rin", "i", "input", "r", "iter", "inner", "conf", "l", "ill", "isin", " din", "read", "In"], "file": ["f", "image", "pdf", "output", "port", "model", "data", "task", "fo", "message", "format", "path", "fil", "form", "io", "print", "view", "File", "resource", "table", "FILE", "spec", "to", "page", "piece", "document", "po", "base", "name", "zip", "fp", "ile", "filename", "db", "type", "log", "local", "result", "handle"], "fos": ["wos", "foss", "tOS", "fo", "fof", "Foss", "foes", "woss", "tos", "FOS", "to", "wOS", "flos", "fOS", " fof", "floes", "flof", "Fof", "Fos", "toss", " fios", "Foes", "wo", "Fios", "Fo", " foes", "flios", "fios"], "out": ["ot", "crit", "output", "OUT", "co", "gr", "v", "dis", "ex", "sum", "con", "net", "io", "print", "set", "st", "it", "outs", "writer", "OU", "news", "ou", "inv", "to", "all", "nt", "cos", "write", "g", "inner", "conv", "os", "conf", "flush", "o", "end", "Out", "at", "w", "outer", "n"], "inputLine": ["configRow", "configline", "inRow", " inputRow", " inputline", " inputCode", "textLine", "submitLine", "textLINE", "textRow", "inputRow", "InputBlock", "submitBlock", "inputLINE", "inputCode", "textCode", "configFile", "inLINE", "submitRow", "InputLine", " inputBlock", "Inputline", "InputLINE", " inputFile", "InputFile", "InputRow", "inCode", "inputBlock", "submitLINE", "inputline", " inputLINE", "configLine", "inLine", "inputFile"]}}
{"id1": "22235113", "id2": "9261777", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallEsl", "unmarshallAssl", "unmarshalXxml", "unmarshalYplex", "unmarshalYsl", "unmarshallEml", "unmarshallExml", "unmarshallYplex", "unmarshalYxml", "unmarshalXml", "unmarshallYml", "unmarshalXplex", "unmarshallAsplex", "unmarshallXplex", "unmarshallEplex", "unmarshallYsl", "unmarshallAsxml", "unmarshallXsl", "unmarshalYml", "unmarshalXsl", "unmarshallYxml", "unmarshallAsml", "unmarshallXxml"], "unmarshaller": ["unmachalling", "unmarshcallable", "unmarshelloser", "unmachallable", "unmarshCallers", "unmarshallier", "unmarshellers", "unmMarshallier", "unmachailable", "unmarshcallers", "unmarshillier", "unmarshcallier", "unmarshilloser", "unmMarshcaller", "unmarshailable", "unmarshailer", "unmachailers", "unmarshcalloser", "unmachailer", "unmarshailing", "unmMarshcallier", "unmarshiller", "unmarshallable", "unmarshalling", "unmMarshalloser", "unmMarshallers", "unmachailing", "unmachallers", "unmarshellier", "unmarshillers", "unmMarshcalloser", "unmarshcaller", "unmarshcalling", "unmMarshaller", "unmarshalloser", "unmachaller", "unmarsheller", "unmarshCalling", "unmarshallers", "unmarshailers", "unmarshCallable", "unmarshCaller", "unmMarshcallers"], "accessUrl": ["uploadURL", "aceURL", "execPath", "AccessPage", "AccessUr", "ccessUrl", "axDb", "execUrl", " accessurl", " accessUr", "Accessurl", "acePage", "aceUrl", "accessibleUr", "AccessPath", "accessibleDb", "axUrl", "accessPage", " accessPath", "ccessUr", "ccessPage", "execURL", "accessPath", " accessURL", "axURL", "uploadUrl", "accessURL", "ccessURL", "AccessDb", "aceurl", "uploadUr", "AccessUrl", "AccessURL", "accessibleURL", "accessibleUrl", "accessurl", "execUr", "accessUr", "ccessurl", "uploadurl", "axUr", "accessDb"], "nameSpace": ["wordSpace", "linkType", "whiteSp", " nameAccount", " nameType", "NameAccount", "wordspace", "NameSpace", "nameBox", "linkspace", "nameType", "whiteAccount", " nameSp", " nameBox", "namespace", "whiteSpace", "linkSp", "nameAccount", " namespace", "Namespace", "NameSp", "nameSp", "whitespace", "linkSpace", "resourcespace", "resourceBox", "wordBox", "NameType", "resourceSpace"], "replace": ["update", "cover", "same", "record", "store", "search", "strip", "old", "match", "format", "pair", "each", "string", "repl", "over", "repeat", "delete", "group", "wrapper", "look", "join", "insert", "re", "map", "remove", "add", "places", "fill", "apply", "register", "prefix", "sub", "transform", "share", "force", "change", "hash", "fix", "after", "write", "template", "place", "alter", "close", "find", "include", "save", "tool", "filter", "align", "use", "gre", "escape"], "with": ["context", "value", "here", "id", "ith", "work", "self", "where", "format", "php", "color", "path", "require", "then", "without", "repeat", "form", " WITH", "set", "xml", "which", "via", "With", "by", "join", "add", "spec", "apply", "cap", "sql", "x", "after", " without", "title", "default", "tx", "spr", "using", "now", "handle"], "url": ["u", "sl", "ssl", "https", "ls", "dl", "channel", "char", "service", "external", "bel", "web", "user", "ref", "str", "xml", "ll", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "impl", "URL", "sb", "cert", "base", "address", "this", "open", "mount", "mail", "r", "uri", "Url", "l"], "inputStream": [" inputThread", "outputStream", "activestream", "imageSteam", "activeStream", "activeSteam", "imagestream", "imageThread", "inputThread", "outputstream", " inputstream", " inputSteam", "inSteam", " InputStream", "inStream", "inputSteam", "inputstream", " Inputstream", "instream", " InputThread", "imageStream", " InputSteam", "outputSteam"], "xmlContent": ["xmlAccept", "mlValue", "mlText", " xmlValue", "xmlContents", "phpContent", "phpContents", "formContents", "jsoncontent", " xmlRaw", "textContents", "phpText", "formContent", "xfContents", " xmlContents", "textcontent", "xmlValue", "mlRaw", "xaAccept", " xmlcontent", "xmlcontent", "xaContent", "xfName", "xfContent", "textText", "textName", "xaText", "formRaw", "xaValue", "textContent", "formText", "jsonText", "jsonContent", "mlcontent", " xmlText", "xfcontent", "xmlRaw", "mlContent", " xmlName", "xmlText", "phpcontent", "xmlName", "mlContents", "mlAccept", "jsonContents", " xmlAccept"], "out": ["cn", "cmd", "copy", "output", "OUT", "co", "ex", "list", "external", "ent", "con", "user", "net", "io", "sys", "in", "conn", "outs", "writer", "ou", "to", "comment", "init", "file", "auto", "aos", "nt", "cos", "client", "write", "check", "extra", "up", "inner", "conv", "os", "null", "conf", "flush", "o", "t", "log", "Out", "at", "outer", "n"], "xmlRequestNumber": ["xmlEventNo", " xmlRequestNo", " xmlRequestCount", " xmlResponseNumber", "xmlEventCounter", "xmlRequestNo", " xmlRequestCounter", "xmlRequestCount", "xmlCounterNumber", " xmlResponseCount", "xmlRequestCounter", "xmlCounterNo", "xmlResponseNo", "xmlEventCount", " xmlResponseNo", " xmlResponseCounter", "xmlCounterCount", "xmlResponseCount", "xmlCounterCounter", "xmlResponseCounter", "xmlEventNumber", "xmlResponseNumber"], "byteArrayInputStream": ["byteArrayRawStream", "byteStreamOutputStream", "byteStreamOutputForm", "byteArrayRawForm", "byteStreamInputSet", "byteArrayOutputSet", "byteArrayInputSteam", "byteArrayStorageSteam", "byteArrayOutputForm", "byteStringOutputForm", "byteArrayReadSource", "byteStringOutputSteam", "byteStreamOutputSet", "byteArrayOutputSocket", "byteStreamInputStream", "byteArrayHttpSteam", "byteArrayIntSteam", "byteArrayInputSource", "byteArrayReadForm", "byteArrayOutputSteam", "byteArrayIntForm", "byteArrayOutputStream", "byteOrderInputForm", "byteOrderReadSource", "byteOrderInputSource", "byteArrayIntStream", "byteArrayReadStream", "byteArrayinputForm", "byteArrayinputSteam", "byteOrderReadForm", "byteArrayStorageForm", "byteArrayHttpForm", "byteArrayRawSocket", "byteStringOutputStream", "byteStreamInputForm", "byteArrayinputStream", "byteArrayReadSteam", "byteStreamInputSteam", "byteStringInputStream", "byteStringOutputSocket", "byteStreamOutputSteam", "byteOrderReadStream", "byteArrayInputSet", "byteStringInputForm", "byteArrayHttpStream", "byteOrderInputStream", "byteArrayInputSocket", "byteStringInputSocket", "byteArrayIntSet", "byteArrayStorageSet", "byteArrayOutputSource", "byteArrayStorageStream", "byteOrderInputSteam", "byteArrayinputSocket", "byteOrderReadSteam", "byteStringInputSteam", "byteArrayInputForm", "byteArrayRawSteam", "byteArrayHttpSource"], "source": ["context", "object", "scope", "copy", "store", "stream", "style", "SOURCE", "position", "relation", "where", "instance", "select", "service", "content", "cause", "target", "sequence", "ource", "state", "src", "subject", "xml", "from", "in", "ident", "resource", "status", "join", "trace", "table", "reason", "ser", "comment", "report", "expression", "file", "layout", "console", "body", "proxy", "parent", "params", "unit", "template", "details", "se", "input", "config", "inner", "json", "parse", "Source", "site", "component", "handle"]}}
{"id1": "14168494", "id2": "2668634", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyByte", " cpFile", " CopyByte", "CopyByte", " cpfile", " CopyStream", "CopyFile", " copyStream", "CopyStream", "Copyfile", " CopyFile", " cpByte", " cpStream", " copyfile", " Copyfile"], "dest": ["loc", "del", "v", "Dest", "cont", "usr", "gt", "way", "target", "nw", "origin", "pub", "st", "etc", "dist", "to", "them", "orig", "trans", "www", "dir", "des", "img", "nom", "tmp", "nt", "master", "good", "out", "doc", "source", "rest", "np", "d", "w", "temp", "result"], "src": ["loc", "rel", "iv", "ins", "sl", "rc", "rs", "ls", "sc", "usr", "sys", "from", "st", "sq", "sec", "inst", "upload", "ser", "req", "init", "sub", "img", "sb", "file", "rx", "source", "input", "cur", "sel", "start", "desc", "sr", "Source", "cont"], "srcChannel": ["sqChannel", "bgChannel", "instCh", "bgChain", " srcChan", "instCan", " srcMessage", " srcChain", "destMessage", "srcPanel", "bgPanel", "srcCh", "sysChan", "sourceChannel", "destChain", " srcCommand", "sqChain", "sqCan", "instChain", "srcChain", " srcCh", "destChan", "rcMessage", " srcchannel", "sysChannel", "srcCommand", "instChan", "rcCommand", "syschannel", "instChannel", "srcChan", "srcchannel", "sourceChan", "sqPanel", "rcChannel", "sourceCh", "rcChan", "destChannel", "rcchannel", "sysCommand", "bgCan", "rcChain", "srcCan", "srcMessage", "instPanel"], "dstChannel": ["ddestCh", "destCommand", "dbrHandler", " dstHandler", "dotButton", "pdestChannel", "dstHandler", "pstButton", " dstChan", "dotCh", "dotChan", "ddestCommand", " dstCh", " dotChannel", "dstCommand", "dstButton", "ddestClient", " dotCh", " dotChan", "ddestHandler", "dndButton", "dndCh", "pstCommand", "dndChannel", "dstChan", "ddestChannel", "pdestButton", "dstCh", "ddestChan", "pstChannel", " dstButton", " dotButton", "dndClient", "pdestClient", "destButton", "pstClient", "dndCommand", "destChannel", "dstClient", "ddestButton", " dotHandler", "pdestCommand", "destClient", "dbrCh", "dbrChannel", "dndChan", "dotChannel", "dbrChan", "dotHandler"]}}
{"id1": "23452437", "id2": "8801436", "code1": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"internalCopy": [" deepCop", " internalSave", " doCopy", " doTransfer", "internalTransfer", " doCop", " deepTransfer", " internalCop", " deepSave", " deepCopy", " doSave", "internalCop", " internalTransfer", "internalSave"], "fSource": ["fileSourceFile", "rfSource", "dataSOURCE", " fTarget", "pSource", "fileStar", "vTarget", "gSOURCE", " fSourceFile", " fSOURCE", "rfStar", "gTarget", "fmsource", "oSource", "fmSourceFile", "dataSourceFile", "pCopy", "pSourceFile", "vsource", "fCopy", " fCopy", "tTarget", "fTarget", "tSource", "fileSource", "fStar", "dataStar", "gSource", "tSourceFile", "tSOURCE", "oSOURCE", "oSourceFile", "gsource", "vSource", "psource", "dataSource", "fsource", "oTarget", "vSOURCE", "fSOURCE", "fileSOURCE", "rfSourceFile", "fSourceFile", " fsource", "fmSource", "rfSOURCE", "fmCopy"], "file": ["f", "image", "output", "th", "p", "port", "data", "message", "format", "path", "fil", "e", "chain", "print", "le", "files", "local", "io", "or", "File", "resource", "table", "FILE", "spec", "page", "base", "name", "out", "fp", "h", "ile", "txt", "source", "template", "filename", "ol", "db", "l", "null", "type", "t", "log", "use", "info", "w"], "o": ["et", "ot", "u", "output", "og", "co", "v", "ooo", "mo", "bo", "ome", "fo", "onet", "e", "lo", "io", "ko", "on", "iso", "O", "oo", "to", "ro", "ho", "obj", "po", "auto", "op", "ox", "so", "y", "no", "out", "ob", "ol", "oe", "ao", "os", "l", "\u00f3", "ow", "ok", "yo", "go", "oa"], "i": ["f", "mi", "u", "ri", "ini", "ib", "il", "I", "ii", "si", "ai", "io", "bi", "qi", "in", "ki", "iu", "it", "ic", "li", "bis", "ij", "xi", "hi", "phi", "is", "out", "ui", "iter", "di", "l", "gi", "ci", "ip", "info", "im", "oi", "pi"], "b": ["f", "z", "bl", "binary", "bf", "v", "bs", "p", "bits", "buf", "blue", "bi", "buffer", "nb", "bin", "ab", "fb", "bar", "bis", "j", "bh", "a", "bg", "B", "sb", "eb", "body", "base", "bt", "be", "erb", "mb", "gb", "bit", "br", "ob", "bus", "l", "bd", "rb", "buff", "bb", "lib", "pb"], "n": ["k", "cn", "nn", "num", "nu", "en", "v", "count", "nc", "N", "ln", "ne", "sn", "un", "an", "ns", "nb", "m", "on", "ll", "c", "nor", "a", "j", "nan", "nl", "span", "yn", "mn", "missing", "nt", "y", "ren", "after", "no", "out", "number", "len", "r", "syn", "l", "na", "gn", "ni", "t", "d"]}}
{"id1": "3330944", "id2": "14878593", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractImage": ["extlateImages", "extractFrame", "extlateimage", "ExtractImages", "Extractimage", "extractimage", "extractorFrame", "extprocessimage", "ExtractFrame", "Extprocessimage", "ExtractImage", "ExtprocessImages", "extractorimage", "extractImages", "extlateImage", "ExtprocessImage", "extractorImages", "ExtprocessFrame", "extractorImage", "extprocessFrame", "extprocessImages", "extprocessImage", "extlateFrame"], "input": ["initial", "image", "context", "ins", "rc", "seed", "p", "pattern", "data", "select", "format", "Input", "audio", "empty", "path", "string", "partial", "index", "origin", "buffer", "q", "str", "xml", "hidden", "from", "raw", "request", "it", "error", "text", "upload", "init", "prefix", "img", "query", "file", "tmp", "base", "address", "before", "this", "current", "check", "out", "txt", "source", "qa", "config", "internal", "i", "uri", "null", "start", "ip", "url", "accept", "background", "sample", "hello", "local"], "output": ["image", "OUT", "port", "format", "path", "target", "print", "icon", "hidden", "generated", "OU", "Output", "response", "STDOUT", "pretty", "to", "prefix", "file", "put", "name", "current", "out", "write", "display", "source", "filename", "oe", "type", "success", "PUT", "o", "temp", "result"], "params": ["param", "ars", "pins", "terms", "caps", "p", "pi", "par", "rs", "eters", "AMS", "jp", "Parameters", "arms", "chains", "las", "properties", "s", "types", "abilities", "actions", "pps", "mm", "m", "ctx", "options", "devices", "packages", "pkg", "gs", "images", "marks", "users", "spec", "ams", "pretty", "ims", "requires", "phys", " parameters", "eps", "phi", "styles", "settings", "changes", "members", "modules", "keys", "pro", "points", "Par", "details", "parts", "config", "proc", "results", "conf", "tools", "json", "docs", "pas", "prop", "tags", "parents", "ports", "fps", "names", "units", "photos", "ps", "stats"], "w": ["f", "wt", "wh", "ew", "v", "p", "we", "window", "e", "wal", "nw", "q", "wl", "sw", "m", "writer", "Ws", "W", "wb", "rw", "wp", "wx", "wa", "word", "hw", "Writer", "kw", "write", "h", "out", "wo", "wd", "o", "ws", "d", "wr", "n"], "in": ["f", " IN", "mi", "ins", "din", "copy", "en", "id", "old", "p", "ini", "IN", "sin", "inn", "con", "e", "ln", "path", "Input", "inf", "gin", "cin", "local", "mm", "bin", "from", "raw", "it", "ar", "vin", "all", "init", "sql", "nin", "mc", "file", "po", "edIn", "phys", "al", "ma", "base", "name", "is", "out", "rin", "i", "source", "win", "inner", "conf", "null", "one", "include", "isin", "info", " din", "read", "In"], "dest": ["loc", " destination", "p", "port", "Dest", "cont", "dat", "alt", "data", "tif", "usr", "buf", "path", "target", "way", "csv", "origin", "src", "st", "resp", "dist", "to", "orig", "trans", "des", "dir", "wb", "nom", "img", "shape", " dst", "tmp", "pipe", "opt", "out", "write", "display", "mem", "comb", "source", "txt", "cat", "oe", "lit", "decl", "desc", "pas", "prop", "rest", "end", "save", "ws", "temp", "deg", "result"], "bi": ["jiang", "ba", "mi", "bra", "bm", "b", "bits", "bf", "bs", "ibi", "ini", "ali", "bo", "ib", "umi", "isi", "bp", "ai", "bas", "yi", "qi", "nb", "bank", "bil", "bin", "rob", "ki", "abi", "li", "bis", "bh", "bg", " nib", "ji", "ble", "obi", "zi", "phi", "be", "beck", "iri", "BI", "phy", "bie", "fi", "vi", "i", "Bi", "bc", "hog", "di", "gi", "mu", "ni", "buff", "ibe", "bb", "obo", "bone", "oi", "pb", "pi"], "os": ["fs", "oos", "css", "osi", "ot", "ons", "et", "acs", "mos", "bs", "cs", "ows", "ros", "ls", "mot", "ose", "us", "s", "io", "ys", "sys", "ns", "obs", "or", "ds", "oo", "oses", "ts", "oid", "bos", "aos", "ox", "cos", "Os", "pos", "is", "oss", "ops", "es", "ks", "ow", "oes", "o", "los", "OS", "ols", "ios"]}}
{"id1": "23161545", "id2": "17111859", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandUUID", "getRandomSuid", "getRandomGid", "getRandomUUID", "getRandomCid", "getRandomCUID", "getRandomCID", "getRandomSid", "getRandGUID", "getRandomCuid", "getRandomSID", "getRandomGID", "getRandGid", "getRandGID", "getRandomUID", "getRandomUuid", "getRandUid", "getRandomSUID", "getRandUID", "getRandGuid", "getRandUuid", "getRandomUid", "getRandomGuid"], "secure": ["sensitive", "ssl", "encrypted", "server", "https", "confirmed", "security", " Secure", "weak", "stable", "sync", "service", "google", "secret", "sys", "safe", "Secure", "strong", "sec", "status", "http", "active", "pretty", "dirty", "force", "protect", "ie", "client", "clear", " securely", "trust", "prime", "sr", "quiet", "nice", " insecure"], "md5": ["md45", "dig3", "md6", " mdle", "digle", "sha5", "MD2", " md512", "md3", "dig5", "sha2", " md2", "mdle", "MD512", "MD5", "MDle", "md512", " md45", "sha6", "MD3", "md4", "metadata2", "metadata5", " md3", "metadata45", "sha3", "sha512", "dig4", " md6", "MD4", "MD45", "metadata3", " md4", "MD6", "md2"], "sbValueBeforeMD5": ["sbValueAfterMD4", "sbValueBeforemd2", "sbValueBeforeDS512", "sbValueBeforeIM5", "sbValueBeforeMTson", "sbValueBeforeMS2", "sbValueBeforeAMDson", "sbValueBeforeMAC65", "sbValueBeforeMD65", "sbValueBeforeDDFive", "sbValueWithoutMD5", "sbValueAfterND2", "sbValueBeforeAMD2", "sbValueBeforeMD2", "sbValueBeforeSM5", "sbValueBeforeMDFive", "sbValueAfterMD3", "sbValueBeforeND2", "sbValueBeforeMDFound", "sbValueAfterMDFive", "sbValueBeforeDS2", "sbValueAfterMD1", "sbValueBeforeSM4", "sbValueBeforeMD512", "sbValueBeforeOLD5", "sbValueBeforeMOD3", "sbValueBeforeDD2", "sbValueBeforeLM512", "sbValueBeforeOLD2", "sbValueAfterMDFound", "sbValueBeforeMAC5", "sbValueBeforeMACFive", "sbValueBeforeMOD5", "sbValueBeforeMS1", "sbValueBeforeIM2", "sbValueBeforeND5", "sbValueAfterND4", "sbValueBeforeOLD512", "sbValueBeforeIM1", "sbValueBeforemdFound", "sbValueBeforeMPLeft", "sbValueAfterMD5", "sbValueAfterMDLeft", "sbValueBeforeDD5", "sbValueBeforeMT2", "sbValueBeforeMT4", "sbValueBeforeMP5", "sbValueAfterMD2", "sbValueBeforeAMD5", "sbValueBeforeMD1", "sbValueBeforemdson", "sbValueAfterND5", "sbValueBeforeMD4", "sbValueWithoutDD2", "sbValueBeforemd5", "sbValueBeforeAMDFound", "sbValueAfterMDson", "sbValueBeforeDS5", "sbValueWithoutMD512", "sbValueBeforeDD65", "sbValueBeforeMS3", "sbValueWithoutMD2", "sbValueBeforeSM2", "sbValueBeforeMD3", "sbValueWithoutDD5", "sbValueAfterNDson", "sbValueBeforeMOD1", "sbValueBeforeIMLeft", "sbValueBeforeLM5", "sbValueWithoutDD512", "sbValueBeforeND4", "sbValueBeforeMS5", "sbValueBeforeMDLeft", "sbValueBeforeNDson", "sbValueBeforeMAC2", "sbValueBeforeMP2", "sbValueBeforeLM2", "sbValueAfterMD65", "sbValueBeforeMP1", "sbValueBeforeMDson", "sbValueBeforeMOD2", "sbValueBeforeDD512", "sbValueBeforeSMson", "sbValueBeforeMT5"], "time": ["length", "etime", "top", "runtime", "value", "id", "ty", "work", "when", "today", "total", "TIME", "tim", "times", "user", "duration", "set", "ime", "timeout", "size", "frame", "ts", "year", "clock", "race", "hour", "est", "name", "system", "current", "client", "counter", "age", "timer", "start", "Time", "rate", "t", "date", "now", "history", "estamp"], "rand": ["z", "dr", "rt", "Rand", "std", "uid", "id", "seed", "rc", "red", "round", "nd", "rh", "reg", "mid", "gt", "gen", "rev", "random", "did", "rid", "gz", "frac", "rank", "dist", "inv", "range", "init", "sam", "rad", "res", "pick", "roll", "sid", "nt", "hash", "pid", "quant", "serial", "cr", "r", "grad", "rss", "rate", "rd", "sample", "and", "ng", "rot"], "valueBeforeMD5": ["valueAfterND7", "valueBeforeND3", "valueBeforeMOD3", "valueBeforeMT5", "valueBeforeND7", "valueAfterND3", "valueBeforeMT2", "valueAfterMD3", "valueBeforeMD25", "valueBeforeMC25", "valueBeforeMOD5", "valueAfterMD7", "valueAfterND5", "valueBeforeMOD7", "valueBeforeMD3", "valueBeforeMC7", "valueAfterND2", "valueAfterMD2", "valueBeforeND5", "valueBeforeMT3", "valueBeforeMC3", "valueBeforeMT25", "valueBeforeMOD2", "valueBeforeND2", "valueBeforeMC5", "valueBeforeMD7", "valueBeforeMD2", "valueBeforeMC2"], "array": ["image", "length", "arr", "ash", "av", "record", "object", "sh", "var", "Array", "binary", "angle", "archive", "data", "arrow", "instance", "feature", "pair", "list", "external", "area", "audio", "RAY", "ary", "buffer", "random", "raw", "collection", "map", "response", "a", "storage", "range", "attribute", "rays", "expression", "share", "batch", "our", "address", "hash", "angular", "vector", "number", " Array", "app", "row", "atomic", "sample", "ray"], "sb": ["sth", "ssl", "abb", "sh", "bs", "bf", "SB", "ib", "bp", "si", "obs", "nb", "sw", "rob", "sq", "sf", "bps", "bis", "sv", "bh", "bg", "xb", "wb", "gc", "eb", "bt", "soc", "erb", "lp", "gb", "ob", "lb", "ctrl", "kb", "db", "zb", "bsp", "pb", "rb", "sr", "hs", "ub", "sg", "bb", "cb", "sa"], "j": ["k", "z", "dj", "v", "ix", "je", "jj", "jp", "yy", "us", "index", "ju", "aj", "q", "str", "m", "bot", "it", "js", "jump", "ja", "J", "ij", "_", "key", "jl", "obj", "kj", "ji", "msg", "__", "ind", "jack", "bj", "br", "off", "i", "uj", "g", "json", "jit", "ct", "t", "jo", "att", "job", "oj", "jc"], "b": ["k", "ba", "u", "bs", "v", "bf", "ib", "bp", "bi", "nb", "ab", "fb", "bar", "bis", "a", "bg", "B", "xb", "eb", "beta", "bt", "y", "be", "bu", "mb", "gb", "br", "bc", "db", "bd", "rb", "bound", "bb", "d", "cb"], "valueAfterMD5": ["valueAfterID7", "valueAfterID5", "valueAfterID3", "valueAfterMD3", "valueAfterMD7", "valueAftermd3", "valueBeforeMD3", "valueAftermd7", "valueAfterMD2", "valueAftermd2", "valueAfterID2", "valueBeforeMD7", "valueAftermd5", "valueBeforeMD2"]}}
{"id1": "255765", "id2": "14688886", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "label": 0, "substitutes": {"f": ["fs", "ft", "b", "cf", "fw", "v", "bf", "p", "exp", "lf", "fm", "fo", "elf", "e", "fax", "path", "form", "test", "q", "m", "tf", "sf", "c", "it", "ret", "fb", "j", "fr", "dir", "fx", "fa", "file", "df", "base", "fn", "y", "fed", "name", "fac", "def", "fp", "fi", "h", "fab", "r", "filename", "g", "l", "t", "o", "fd", "rf", "F", "d", "info", "w", "fc", "n"], "in": [" IN", "ins", "din", "en", "again", "pi", "ex", "IN", "er", "inn", "con", "ai", "lo", "io", "inf", "cin", "gin", "local", "m", "ac", "bin", "mm", "from", "on", "it", "ic", "by", "re", "add", "all", "init", "nin", "thin", "al", "ma", "im", "reader", "ind", "is", "inc", "h", "up", "rin", "get", "input", "r", "iter", "inner", "oin", "l", "make", "o", "t", "log", "info", "isin", "at", " din", "In", "n"], "cbuf": ["sbbuf", "bcdf", "cbuffy", "cdbuf", "abbbuf", "cbuff", "CBbuf", "nbuff", "gbf", "rbuff", "bcuf", "nbfg", "cfuf", "bcfg", "gbuff", "cdoff", "sbuf", "abbuf", "cduffy", "bcoff", "sbather", "rbdf", "CBuff", "rbather", "rbuffy", "cbather", "nbuf", "rboff", "cbdf", "rbfg", "gbbf", "cbf", "rbbuf", "bcuff", "cduf", "CBuffy", "abbdf", "CBf", "cbbf", "cfuff", "bcather", "cbbuf", "cff", "CBuf", "gbuf", "cboff", "nbbuf", "cduff", "abbfg", "rbuf", "bcbuf", "CBbf", "sbuff", "cbfg", "cfbf"], "read": ["core", "need", "record", "stream", "old", "ead", "count", "sync", "buffer", "q", "give", "set", "pack", "reads", "re", "load", "add", "ke", "link", "reading", "orig", "READ", "range", "report", "run", "reader", "depth", "check", "get", "feed", "se", "row", "log", "ok", "send", "length", "k", "pe", "value", "select", "saw", "io", "chain", "print", "Read", "it", "view", "error", "rank", "ret", "key", "Reader", "ind", "is", "current", "clear", "write", "find", "close", "think", "fail", "start", "parse", "default", "end", "wait", "ignore", "reach", "readable", "bind", "data", "connect", "allow", "ink", "test", "pre", "raw", "hold", "ready", "query", "dev", "roll", "x", "est", "seek", "shift", " Read", "mem", "input", "miss", "ip", "play", "ank", "index", "handle", "mix", "poll", "scan", "slow", "ai", "ed", "text", "fill", "skip", "burst", "open", "height", "r", "trust", "iter", "rate", "ly", "ext", "hello", "n"], "totRead": ["atotaFill", "tokWrite", "ltotBuild", "retotReader", "tOTLoad", "tootDisplay", "totedFill", "letrotFind", "notWrite", "tcotConnect", "ttottWrite", "tOTNeed", "tiotSend", "ttottNeed", "tokRead", "tcotDisplay", "tacotRead", "tcotRead", "ttottAdd", "totalNeed", "totalSee", "toteAdd", "tottFind", "toteFill", "ptotWrite", "ptOTRead", "ltotLoad", "retottReader", "totAdd", "tottedWrit", "totaCheck", "atotPrint", "retotWrit", "ltotaRead", "toticWrite", "tobyCheck", "notaWrite", "ltotRead", "totBreak", "toteWrite", "atotaPrint", "tottedPrint", "notalLoad", "totalWrite", "atotFill", "tobyLoad", "totVal", "tiotVal", " totFind", "totaSee", "atotaRead", "totaLength", " totRun", "ptOTFind", "letrotRead", "notaRead", " totalWrite", "tootBreak", "ptotFind", "tottNeed", "totRun", "taotDisplay", "totaPrint", "tiotFill", "ttotAdd", "toteFind", "tottWrit", "totPrint", "tiotRead", " totalRead", "ltotaBuild", "retottWrit", "notalRead", "taotRead", "tottReader", "totalRead", "trotWrite", "notalPrint", "tokLoad", "tfatWrite", "totNeed", "tOTRead", "ltotaLoad", "tottRun", "tootCheck", "totaWrite", "totalBuild", "letotSee", "tiotHave", "tottedReader", "totFill", "ltotaFill", "toticFind", "totaAdd", " totWrite", "totaLoad", "trotFind", "toteRun", "notaReader", "totaConnect", "notNeed", "totalLength", "retottRead", "totalPrint", "toteLength", "totCheck", "ttottRead", "totDisplay", "tcotSend", "totedHave", "tfatRead", "tootSend", "tfatLoad", "atotRead", "tcotCheck", "totaDisplay", "totaReader", "toticRead", "atotHave", "tacotConnect", "letotWrite", "tottWrite", "tottAdd", "tootRead", "ttotRead", "totSee", "totBuild", "toiotRead", "totConnect", "totSend", "taotCheck", "totalCheck", "ptotLoad", " totalLength", "toteRead", "totalLoad", "tiatBuild", "totFind", "tacotDisplay", " toteRun", "atotaHave", "toteNeed", "tOTFind", "tiatRead", "tiatVal", "notalWrite", "totHave", "retotPrint", "tiatFill", "totaNeed", "tootVal", "tiotBreak", "toiotSend", "totedRead", "retotRead", "notLoad", "toticRun", "tottedRead", " totLength", "tiatBreak", "notalNeed", "tiatSend", "tcotVal", "toteLoad", "totaFind", "toiotVal", "tobyRead", "tOTWrite", "notalCheck", "totaBuild", "letotFind", "tiatLoad", "tobyNeed", "totedPrint", "totWrite", "totaFill", "letrotSee", " toteFind", "taotConnect", "ptotRead", "ltotFill", "totLength", "tobyWrite", "ttotWrite", " toteRead", "notPrint", "notaLoad", "ttotNeed", "tiotWrit", "tokFind", "totLoad", "notCheck", "toteReader", "totaRead", "letrotWrite", "tottRead", "notReader", " toteWrite", "trotSee", "tottPrint", "retottPrint", "tfatReader", "notRead", "toiotBreak", "letotRead", "toteBuild", "tcotBreak", "tiotPrint", "ptOTWrite", "totaHave", "tacotCheck", "tootConnect", "totWrit", "tiotReader", " totBuild", " totalBuild", "totReader", "tobyPrint", "trotRead", "totalFind", "ptOTLoad"], "out": ["output", "OUT", "co", "b", "v", "ex", "we", "con", "s", "net", "io", "sys", "outs", "c", "or", "writer", "OU", "ou", "to", "obj", "res", "auto", "aos", "ch", "write", "up", "r", "oss", "g", "conv", "os", "o", "t", "log", "end", "Out", "at", "w", "n"], "i": ["cli", "mi", "dr", "id", "ri", "ico", "any", "q", "set", "status", "ims", "g", "di", "gi", "ci", "ski", "\u0438", "point", "info", "I", "ia", "pi", " I", "ix", "integer", "php", "us", "e", "io", "um", "print", "chain", "my", "m", "ki", "multi", "ic", "it", "li", "xi", "to", "init", "ji", "ind", "is", "l", "o", "qi", "p", "v", "ity", "s", "si", "me", "iu", "c", "j", "x", "ie", "zi", "iii", "iy", "uri", "PI", "ip", "t", "index", "you", "ami", "iq", "b", "ini", "ii", "ice", "ai", "bi", "mm", "sim", "ei", "ij", "ti", "hi", "phi", "y", "this", "ion", "client", "ui", "r", "im", "oi"]}}
{"id1": "5061606", "id2": "17557289", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNacessed", "createSettingsIfNacessesar", "createSettingsIfNecessesar", "createSettingsIfNeccesible", "createSettingsIfNecessesary", "createSettingsIfNeccesed", "createSettingsIfNacessible", "createSettingsIfNeccessary", "createSettingsIfNecessible", "createSettingsIfNacessary", "createSettingsIfNecessar", "createSettingsIfNeccessar", "createSettingsIfNacessesary", "createSettingsIfNeccessible", "createSettingsIfNecessesible", "createSettingsIfNeccessed", "createSettingsIfNeccesary", "createSettingsIfNeccesar", "createSettingsIfNacessesed", "createSettingsIfNecessesed", "createSettingsIfNacessar", "createSettingsIfNecessed", "createSettingsIfNacessesible"], "out": ["cn", "f", "max", "ot", "output", "go", "OUT", "server", "co", "again", "ex", "bo", "yes", "list", "ent", "con", "net", "io", "ne", "print", "sys", "on", "err", "conn", "outs", "it", "or", "timeout", "OU", "writer", "ou", "inv", "note", "to", "that", "report", "comment", "init", "obj", "gc", "file", "res", "aos", "nt", "cos", "ch", "ion", "client", "write", "off", "up", "can", "oss", "one", "oe", "conv", "os", "null", "cho", "flush", "t", "o", "log", "exit", "end", "Out", "w", "outer", "n"], "fSettings": ["fOptions", "sfSetup", "fsettings", " fOptions", "bfSettings", "hSettings", "fSetting", " fsettings", "eSetting", "cfSetup", "finalOptions", "finalSetting", "cfsettings", " fChanges", "finalsettings", "cfSetting", "sfSettings", "fSetup", " fSetup", "cfSettings", "finalSettings", "fChanges", " fSetting", "esettings", "hsettings", "sfOptions", "sfChanges", "bfChanges", "bfSetting", "sfSetting", "hSetting", "sfsettings", "eSettings", "bfsettings"], "src": ["loc", "rel", "rt", "th", "rc", "rs", "ls", "sc", "dest", "sys", "attr", "sq", "sf", "view", "pkg", "resource", "rl", "sit", "upload", "ser", "spec", "ur", "dir", "img", "sb", "tmp", "fn", "rx", "txt", "source", "syn", "filename", "cur", "config", "desc", "url", "sr", "root", "cont"], "in": ["ins", "din", "inside", "en", "id", "IN", "sin", "inn", "ln", "inf", "gin", "cin", "bin", "from", "vin", "and", "init", "ad", "is", "rin", "i", "input", "source", "iter", "inner", "r", "l", "isin", "info", " din", "In", "n"]}}
{"id1": "7764011", "id2": "3745402", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvViewersDocument", "readScalarpvviewingDoc", "readScalarpvviewersFile", "readScalarpvviewedDoc", "readScalarpvviewerdocument", "readScalarpvviewersdocument", "readScalarpvviewingdocument", "readScalarpvViewerDocument", "readScalarpvViewerdocument", "readScalarpvviewerFile", "readScalarpvviewersDoc", "readScalarpvviewingFile", "readScalarpvViewersDoc", "readScalarpvviewersDocument", "readScalarpvviewedFile", "readScalarpvViewerDoc", "readScalarpvviewedDocument", "readScalarpvViewersdocument", "readScalarpvViewerFile", "readScalarpvviewerDoc", "readScalarpvviewingDocument", "readScalarpvViewersFile", "readScalarpvvieweddocument"], "url": ["loc", "rel", "sl", "ssl", "b", "id", "location", "ls", "dl", "data", "char", "web", "buffer", "rect", "str", "xml", "ll", "ret", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "URL", "document", "file", "res", "cert", "address", "name", "open", "mount", "mail", "r", "uri", "Url", "l", "util"], "xmlData": ["phpdata", "mlPart", "mlText", "phpContent", "jsonQuery", "xfQuery", "phpData", "xpdata", "xmlString", "xfData", "xpString", "phpText", "xpDat", "xmlPart", "phpName", " xmlQuery", "xmlContent", "xfDat", "logData", "xmlDat", "logdata", "logDat", "jsonDat", "jsonText", " xmlText", "logString", " xmlDat", "mlContent", " xmlContent", " xmldata", "xmlText", "mldata", "mlData", " xmlName", "xmlName", "xmlQuery", "xpData", "xmldata", "mlName", "jsonData", "phpPart", " xmlPart", " xmlString", "xfText"], "in": ["ins", "din", "ri", "IN", "inn", "con", "inf", "cin", "gin", "m", "bin", "from", "re", "add", "all", "as", "thin", "mc", "file", "reader", "is", "inc", "out", "rin", "doc", "i", "input", "r", "inner", "conf", "isin", "info", " din", "In"], "line": ["record", "node", "port", " Line", "detail", "ln", "lo", "le", "normal", "section", "lin", "nl", "link", "note", "page", "comment", "range", "file", "code", "change", "lock", "check", "se", "row", "log", "point", "length", "column", "pe", "online", "string", "chain", "print", "entry", "trace", "item", "no", "l", "lines", "ine", "header", "zone", "data", "message", "content", "user", "str", "continue", "raw", "inline", "Line", "stroke", "stay", "lined", "word", "source", "field", "liner", "eline", "list", "sequence", "cell", "phrase", "block", "text", "part", "frame", "piece", "force", "iter", "next", "LINE", "sample"], "cont": ["const", "crit", "cmd", "contained", "co", "exist", "contin", "count", "keep", "each", "circ", "con", "content", "chain", "any", "valid", "str", "nav", "continue", "ont", "multi", "c", "Cont", "CONT", "control", "cart", "code", "cond", "current", "cmp", "txt", "mult", "loop", "cur", "iter", "conv", "cat", "cons", "ctr", "coll", "ct", "rest", "next", "first", "compl"], "readAdp": ["readadn", " readADping", "readadj", " readADp", " readAdlp", "ReadAdr", "readAdlp", "readAdamP", "ReadADP", "readadr", "ReadAdP", "readAdamn", "readADn", " readADr", "ReadAdlp", "Readadp", "ReadAdp", "ReadADp", "readadlp", "readAdamp", " readADj", " readADP", "ReadAdj", "readAmlp", "readadP", "readInterP", "readAmr", " readAdn", " readAdr", "readAdn", "readADP", "ReadADr", "readInterj", " readAdj", " readAdping", "ReadadP", "readAmp", "Readadj", "readadping", "readAdamping", "readInterp", "readadp", "readAdping", "readInterlp", "readAdP", "ReadADlp", "readADlp", " readADn", "Readadlp", " readADlp", "readAdj", "readADr", " readAdP", "readADping", "readAmP", "readADj", "readADp", "readAdr"], "scalarpvviewerData_Adaptor": ["scalarpvviewerData2Adaptors", "scalarpvviewerData_Axorer", "scalarpvviewerData_adapter", "scalarpvviewerData2adapto", "scalarpvviewerData2adaptr", "scalarpvviewerData_Connectable", "scalarpvviewerData2adaptOR", "scalarpvviewerData_adaptable", "scalarpvviewerData_Acceptors", "scalarpvviewerData_Adaptr", "scalarpvviewerData_ArchOR", "scalarpvviewerData_Adjustor", "scalarpvviewerData_adaptor", "scalarpvviewerData_adaptors", "scalarpvviewerData_Adjustable", "scalarpvviewerData2adaptors", "scalarpvviewerData2Adapto", "scalarpvviewerData_Adr", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Connector", "scalarpvviewerData_Acceptor", "scalarpvviewerData_Adaptors", "scalarpvviewerData_Adjustors", "scalarpvviewerData_AdjustOR", "scalarpvviewerData_Adaptorer", "scalarpvviewerData2adapter", "scalarpvviewerData2adaptor", "scalarpvviewerData_adaptr", "scalarpvviewerData2Adapter", "scalarpvviewerData_Accepter", "scalarpvviewerData2Adaptor", "scalarpvviewerData_Axable", "scalarpvviewerData2AdaptOR", "scalarpvviewerData_AxOR", "scalarpvviewerData_Adapter", "scalarpvviewerData_Adapto", "scalarpvviewerData_adapto", "scalarpvviewerData_Ado", "scalarpvviewerData_AdOR", "scalarpvviewerData_Adaptable", "scalarpvviewerData_Connectors", "scalarpvviewerData_Archorer", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Ader", "scalarpvviewerData2Adaptr", "scalarpvviewerData_adaptOR", "scalarpvviewerData_Archable", "scalarpvviewerData_Ador", "scalarpvviewerData_Axor", "scalarpvviewerData_Archor", "scalarpvviewerData_adaptorer", "scalarpvviewerData_Accepto", "scalarpvviewerData_Adors"], "params_font": ["params7Font", " params2font", "params6pen", " params_tt", "params_pen", "params_template", "params2Font", " params2Font", "params___font", "params12font", " params_Font", "params_shadow", "params_system", "params12system", "params_brand", " params_ont", "params_text", "params7font", " params_text", "params6font", "pretty_pen", "params___text", "pretty_font", "params_tt", "params_style", "params7system", "params2font", "params12shadow", "params2shadow", "params_ont", "pretty_layout", "pretty_brand", "params_Font", "params6brand", " params2shadow", " params_style", "params6layout", " params2system", "params7shadow", "params___ont", " params_template", "params___tt", "params_layout", "params2system", " params_system", "params12Font", " params_shadow"], "font_size": [" font_SIZE", " font_height", " font_speed", "font_family", " font_family", " font_width", "font_height", "font_speed", " font_Size", "font_Size", "font_SIZE", "font_width"], "style": ["value", "country", "angle", "position", "mode", "script", "show", "pattern", "class", "format", "stable", "color", "margin", "Style", "state", "theme", "weight", "error", "sche", "status", "size", "estyle", "stroke", "link", "sty", "layout", "styles", "less", "family", "role", "height", " Style", "les", "shadow", "type", " styles", "padding", "css", "font", "handle"], "font_Family": ["font_Style", " fontNamefamily", "family_Style", "fontNameRole", "font_Role", "font_family", "fontNameName", " font_family", "fontTypefamily", "family_Family", " font_Role", " fontNameRole", "fontTypeRole", "family_Name", "font_Name", "family_family", "fontNameFamily", "fontNameStyle", "fontTypeFamily", "fontNamefamily", " fontNameFamily"], "globalFont": ["globalFamily", "foreignFont", "commonFontSize", "generalFontSize", "GlobalFont", "generalFloat", "globalFontSize", "localFont", "foreignFamily", "localFamily", " globalFontSize", "commonFont", "generalONT", "localFontSize", "globalONT", "globalFloat", "generalFont", "GlobalFloat", "foreignFontSize", " globalONT", " globalFloat", "GlobalFontSize", "GlobalONT", "commonFamily"], "params_pts": ["params_xt5", "params_ntm", "params_ntjs", "params_cts", "params_ntls", "params_ntis", "params2ptts", "params_ntts", "params_ptm", "params_brts", "params_ntt", "params_ntes", "params_ptes", "params2nts", "params_ptts", "params_nties", "params2ntjs", "params2pts", "params_xts", "params_ptyis", "params_ptis", "params_ptls", "params_ctts", "params_iptes", "params2nties", "params_brs", "params2ntts", "params_brjs", "params2ptjs", "params_ctm", "params_pt5", "params_ctt", "params_iptm", "params_ctes", "params_pties", "params_nts", "params_bries", "params_xtls", "params_nt5", "params_ptys", "params_xtis", "params_cties", "params_ipts", "params_ctjs", "params_ptyls", "params_ptjs", "params_iptt", "params2pties", "params_pty5", "params_ptt"], "params_data": ["args_", "param_", " paramsPar", "argsPar", "paramPar", " params_", "params_", "paramsPar"]}}
{"id1": "11341711", "id2": "21308543", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makeDup", "makeStpoint", "makeBackpoint", "createbackupid", "makebackupid", "makeDupid", "makeDups", "makeBackups", "makeDpoint", "makeBackupid", "createBackup", "createbackpoint", "createBackupid", "makebackups", "makeStupid", "makebackpoint", "makeStups", "makeStup", "makebackup", "createbackups", "createbackup", "createBackups", "createBackpoint"], "dir": ["loc", "folder", "del", "dr", "dd", "store", " d", "ir", "dis", "dl", "dat", "data", "window", "disk", "path", "addr", "src", "in", "pkg", "or", "vol", "dist", "md", "file", "DIR", "rad", "tmp", "base", "directory", "y", "dm", "ind", "zip", "dep", "out", "mail", "doc", "iter", "wd", "db", "Directory", "url", "Dir", "direct", "fd", "d", "draw", "local", "handle"], "sourcedir": ["sourcesel", "sourceel", "soredir", "sourcedirs", "sourcedr", "isourceddir", "senderr", "sourcedire", "sourceirs", "sourceir", "isourcedir", "isourcedel", " sourcesdir", "sourcesirs", "isourcer", "sourcesr", "senderel", "sourceire", "soredirs", "sourcesdir", "soreddir", " sourcesire", "soredire", " sourcedirs", "isourceir", "isourceel", " sourcedire", "sourcesire", "sourcesir", "sourcer", "sourceddir", "isourcedr", "senderdir", "sourcedel", "senderir", " sourcesirs", " sourceddir", " sourcesir"], "destinationdir": ["destinatorir", "destinatordir", "destinationDir", "destinationdb", "estinationdir", "destinatorDir", "estinationDir", "stinationdiv", "destinationsdir", "destinationsir", "stinationsdb", "estinatordb", "estinationfolder", "stinationir", "destinationir", "destensiondb", "stinationdir", "destinationfolder", "destineddiv", "destinatordiv", "stinationsdir", "destinatordb", "stinationsdiv", "estinatorfolder", "destiondb", "destionDir", "destinationsdiv", "estinationdb", "destionfolder", "destinedir", "estinatordir", "destinationsdb", "destineddir", "destineddb", "destinationdiv", "destinatorfolder", "stinationsir", "destiondir", "destensiondir", "estinatorDir", "destensionfolder", "destensionDir", "stinationdb"], "destinationDirEnding": ["destinationDirEnditing", "destinationDirServding", "destinationDirEvening", "destinationDirectoryEndding", "destinationDirEvenING", "destinationFileEveniting", "destinationFileEvening", "destinationDirFeedING", "destinationDirEndING", "destinationDirectoryEnder", "destinationDirServer", "destinationDirENDING", "destinationDirEvenging", "destinationDirENDer", "destinationDirectoryENDing", "destinationDirectoryEnding", "destinationDirEndging", "destinationDirServing", "destinationFileEvener", "destinationFileEvenING", "destinationDirectoryENDer", "destinationFileEndING", "destinationDirEveniting", "destinationDirEvending", "destinationDirENDging", "destinationDirectoryENDging", "destinationDirENDiting", "destinationDirFeediting", "destinationFileEnditing", "destinationDirFeeding", "destinationDirEvener", "destinationDirENDding", "destinationDirServging", "destinationDirEnder", "destinationDirENDing", "destinationDirFeeder", "destinationDirectoryENDding", "destinationFileEnder", "destinationDirEndding", "destinationDirectoryEndging", "destinationFileEnding"], "files": ["fs", "assets", "words", "bs", "values", "ls", "prints", "events", "classes", "features", "fields", "list", "lets", "items", "types", "actions", "obs", "strings", "links", "issues", "headers", "Files", "images", "users", "facts", "sections", "reports", "file", "forms", "params", "objects", "ames", "members", "fixes", "modules", "keys", "resources", "details", "parts", "plates", "docs", "filename", "mails", "pages", "errors", "tools", "lines", "uploads", "ports", "projects", "parents", "its", "bytes", "ids", "names", "faces", "iles", "qs", "tests", "states"], "checkdir": ["checkeddir", "checkeddirectory", "ckdirectory", "workdir", " checkir", "checkdirectory", "checkir", "Checkfolder", "ckroom", "ckDir", "Checkblock", "keyroom", "ckfolder", "checkeddb", "checkthis", "getfolder", "getdb", " checkdb", "ckdir", "keyfolder", " checkthis", "workurl", " checkblock", "Checkdirectory", "workthis", "checkDir", " checkdirectory", " checkurl", " checkDir", "checkurl", "Checkdb", "getdir", "CheckDir", "checkedDir", "checkroom", "ckthis", "getblock", "Checkroom", "checkfolder", "checkedir", "ckdb", "checkdb", " checkfolder", "Checkdir", "Checkir", "ckurl", "workDir", "checkedfolder", "checkblock", "keydb", "keydir"], "date": ["cal", "Date", "when", "dt", "today", "zone", "dat", "data", "te", "ate", "user", "diff", "month", "iso", "set", " Date", "resource", "add", "de", "note", "day", "year", "tag", "key", " day", "late", "file", "msg", "none", "event", "get", "doc", "ATE", "close", "start", "time", "use", "d", "now"], "msec": ["mcl", "gmsec", "gmSec", "gmsc", " mcl", "gmstr", "mtct", "cmsec", "mSec", " mstr", "misec", "cmcl", "mtcl", "Mct", " msc", "msc", " mSec", "mtisec", "MSec", "mtstr", "mtSec", " mct", "mtsc", "mstr", " misec", "cmisec", "mct", "Msec", "mtsec", "cmsc"], "checkFile": ["CheckFiles", "readFile", " checkfile", "readFiles", " checkFILE", "readSourceFile", "checkfile", "updateFILE", "checkSourceFile", "checkFILE", "CheckFile", "Checkfile", "updateFile", " checkFiles", "CheckFILE", " checkSourceFile", "updateSourceFile", "readFILE", "updateFiles", "readfile", "checkFiles"], "i": ["cli", "mi", "iq", "id", "exp", "pi", "ri", "ix", "ex", "ini", "ii", "si", "ai", "io", "bi", "sequence", "my", "m", "me", "sim", "in", "ki", "iu", "multi", "ic", "ei", "it", "li", "major", "ti", "ij", "j", "xi", "init", "key", "hi", "x", "ji", "batch", "zi", "base", "phi", "y", "ie", "name", "ind", "is", "ui", "gu", "di", "gi", "ci", "ip", "info", "qi", "im", "index", "I"], "f": ["fs", "u", "ft", "b", "cf", "bf", "p", "fw", "v", "lf", "uf", "fo", "fe", "e", "m", "tf", "fb", "j", "fr", "fa", "fg", "file", "df", "fac", "fp", "fi", "l", "fl", "t", "o", "fd", "F", "d", "fc"], "g": ["tg", "og", "gl", "b", "v", "p", "gy", "ga", "ge", "s", "e", "group", "cfg", "m", "eg", "gm", "G", "gp", "gs", "j", "bg", "pg", "fg", "gc", "file", "msg", "gb", "out", "d", "graph", "gu", "config", "gg", "vg", "gi", "ig", "l", "t", "go", "gd", "w", "mg"], "destinationFile": ["destinateFiles", "destationFile", "destinationsFile", "destinatorFilename", "destinatedFile", "destinateFile", "destinatedDirectory", "DestationFile", "transinatedFiles", "transinatedFile", "destarationFilename", "DestinationFile", "destarationDirectory", "destinatorDirectory", "destinationsFilename", "destinationFilename", "transinationFile", "transinationDirectory", "destinationsEmail", "destationFiles", "destinationDirectory", "destarationFile", "DestinationEmail", "transinationFilename", "destinateFilename", "DestationFiles", "DestationEmail", "transinationFiles", "DestinationFilename", "DestinationFiles", "destinatorFiles", "destinationsFiles", "transinatedFilename", "destinatedFiles", "destinatedFilename", "destinationFiles", "destinationEmail", "destationFilename", "destarationFiles", "destinatorFile", "destationEmail", "DestationFilename", "destinateEmail", "transinatedDirectory"], "sourceFile": ["staticFILE", "staticfile", "SourceFile", "SourceFILE", "ourceFile", "sourceFILE", "srcLine", "srcFilename", "sourceLine", "SourceLine", "SourceFiles", "srcfile", "ourceFilename", "sourceFiles", "srcFile", " sourceFiles", "SourceFilename", "sourcefile", "sourceFilename", "ourcefile", "Sourcefile", "staticFiles", " sourcefile", " sourceFILE", "staticFile", "ourceLine"], "infile": ["INfile", "infield", " inblock", "pinfile", "inputfile", " instream", "insstream", "INfield", "Instream", "outline", "inblock", "inFile", "pinFile", "INFile", "Inblock", "inline", "INline", "instream", "pinline", "insfile", "inputblock", " inline", "insFile", " inFile", "pinfield", "insblock", "outblock", "inputline", "outFile", "InFile", " infield", "Infile", "inputFile"], "outfile": [" outlink", "outbuffer", "outputline", "inlink", "OutFile", "outerbuffer", "outputstream", "outerstream", "outline", "inFile", "Outstream", "outview", "Outlink", "inline", " outline", "inbuffer", " outpage", "inpage", " outbuffer", " outview", "instream", " outstream", "outputfile", "outlink", "outerfile", "inview", " outFile", "Outfile", "outputpage", "outFile", "outerview", "outpage", "outstream"], "c": ["k", "z", "u", "rc", "v", "cu", "cs", "cf", "p", "count", "cache", "ec", "sc", "nc", "char", "\u00e7", "unc", "cc", "e", "arc", "chain", "m", "ac", "err", "C", "col", "a", "dc", "ca", "x", "mc", "gc", "code", "cos", "pc", "ch", "cp", "uc", "y", "out", "cr", "r", "bc", "close", "conf", "cd", "cl", "ct", "t", "o", "ce", "cm", "d", "cb", "lc", "n"]}}
{"id1": "7458833", "id2": "21656668", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileToInfoFile", " copyParseFiletocodeFile", " copyParseFileToGoFiles", " copyParseFiletocodeFiles", " copyParseFiletocodeTable", " copyParseFileToInfoTable", " copyParseFileToCodeTable", " copyParseFileToGoTable", " copyParseFileToCodefile", " copyParseFileToGofile", " copyParseFileToCodeFiles", " copyParseFiletoCodefile", " copyParseFiletocodefile", " copyParseFiletoCodeTable", " copyParseFileTocodefile", " copyParseFiletoCodeFile", " copyParseFiletoCodeFiles", " copyParseFileToGoFile", " copyParseFileToInfofile", " copyParseFileTocodeFiles", " copyParseFileToInfoFiles", " copyParseFileTocodeTable", " copyParseFileTocodeFile"], "in": ["ins", "inside", "din", "en", "ir", "ini", "ze", "IN", "inn", "con", "ai", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ar", "ic", "it", "init", "ad", "al", "ain", "act", "ind", "is", "inc", "check", "up", "rin", "i", "input", "iter", "inner", "info", "isin", "im", "read", "In"], "out": ["cn", "ot", "output", "en", "OUT", "co", "v", "dis", "ex", "con", "net", "io", "ne", "sys", "n", "on", "outs", "it", "by", "writer", "ou", "and", "to", "obj", "res", "auto", "aos", "nt", "cos", "client", "check", "write", "up", "i", "oss", "one", "conv", "g", "os", "null", "inner", "o", "t", "Out", "at", "outer", "can"], "buffer": ["initial", "binary", "cache", "message", "window", "char", "buf", "queue", "phrase", "sequence", "stack", "print", "database", "block", "cell", "view", "button", "resource", "table", "frame", "bar", "bridge", "reason", "paste", "attribute", "comment", "document", "component", "batch", "history", "word", "append", "template", "memory", "display", "character", "iter", "row", "variable", "Buffer", "buff", "sample", "pad", "command", "bone", "temp", "result"], "length": ["distance", "maximum", "bow", "frequency", "present", "position", "angle", "integer", "count", "deep", "data", "message", "total", "capacity", "how", "lambda", "print", "sequence", "stop", "duration", "database", "closure", "volume", "collection", "availability", "load", "frame", "size", "join", "reading", "available", "impl", "shape", "ength", "amount", "family", "height", "binding", "full", "number", "len", "l", "enth", "start", "padding", "t", "point", "hello", "component", "Length", "history", "ENGTH"]}}
{"id1": "1508930", "id2": "5836744", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 1, "substitutes": {"httpRequestByPOST": ["httpGetbyGET", "httpRequestWithGET", "httpRequestbyPost", "httpRequestWithPOST", "httpRequestWithpost", "httpRequestByGET", "httpRequestByPost", "httpRequestWithPost", "httpGetbyPOST", "httpGetByPOST", "httpGetByPost", "httpGetByGET", "httpRequestViaPost", "httpRequestbyPOST", "httpGetbypost", "httpRequestbypost", "httpRequestbyGET", "httpGetbyPost", "httpRequestViapost", "httpRequestBypost", "httpRequestViaPOST", "httpGetBypost", "httpRequestViaGET"], "url": ["loc", "host", "k", "ssl", "domain", "id", "location", "ls", "dl", "pattern", "api", "format", "string", "path", "web", "ref", "str", "ll", "request", "ret", "join", "http", "method", "ur", "key", "URL", "base", "address", "name", "call", "pl", "uri", "Url", "l", "href", "remote"], "timeout": ["length", "max", "ssl", "port", "mode", "format", "delay", "duration", "size", "method", "password", "Timeout", "seconds", "batch", "body", "amount", "pool", "number", "blocking", "version", "type", "time", "sleep", "period", "padding", "wait"], "params": ["param", "terms", "pins", "values", "p", "AMS", "data", "Parameters", "list", "properties", "actions", "mm", "packages", "mas", "pps", "images", "spec", "ams", "query", "forms", " parameters", "styles", "settings", "changes", "objects", "pos", "keys", "posts", "Par", "details", "parts", "tags", "padding", "media", "names", "photos", "ps", "pi"], "response": ["onse", "object", "reply", "output", "value", "yes", "data", "message", "relation", "description", "service", "format", "content", "string", "complete", "sequence", "xml", "example", "resp", "application", "network", "request", "view", "answer", "block", "status", "text", "frame", "report", "all", "document", "connection", "body", "relative", "address", "template", "respons", "respond", "reset", "null", "Response", "version", "json", "success", "next", "remote", "command", "result"], "httpClient": ["ttpConnect", "ttpclient", " httpConnect", " httpCase", "htmlCo", " httpProxy", "sslCase", "httpConnect", "httpDo", "HttpClient", "ttpClient", "HttpProxy", " httpclient", "Httpclient", "httpCase", "HttpConnect", "httpclient", "htmlCase", "sslClient", "sslDo", "htmlDo", "ttpProxy", "sslCo", "httpCo", " httpCo", " httpDo", "htmlClient", "httpProxy"], "httpPost": ["httpPos", "httpRequest", "HTTPPost", " httpPut", "httppost", "HTTPpost", "httpPut", "statusPos", "statusPost", "statusPut", "HttpPos", "HttpPut", "statusRequest", "ttpPOST", "ttpPut", "HttpRequest", "HttpPOST", "HttpPost", "httpPOST", "thispost", " httpPOST", "thisPost", " httppost", "HTTPPut", "ttpPost", "HTTPPos", "thisPut", "HTTPRequest", "HTTPPOST", "thisPOST"], "serverResponse": ["serverBody", "ServerAnswer", "ServerStream", " serverPage", "verBody", "ServerPage", "verResponse", "ServerDescription", "httpBody", "erverLine", "serverCall", "serverLine", "statusResponse", "httpLine", "serverDescription", "serverEx", "httpResponse", " serverDescription", "statusEntity", "ServerEx", "erverCall", "descriptionAnswer", "erverBody", "serverAnswer", "verLine", "serverStream", "descriptionDescription", " serverAnswer", "verCall", "ServerEntity", "httpCall", "descriptionStream", "ServerResponse", "serverPage", "descriptionResponse", " serverStream", "statusPage", " serverEntity", "statusEx", "serverEntity", "erverResponse", " serverEx"], "statusLine": ["serviceCode", "StatusCode", "Statusline", "responsePage", "responseCode", "serverCode", "StatusLine", " statusResponse", "statCode", "serverLine", "specLine", " statusCode", "statLink", "statusResponse", "checkline", "serviceResponse", "responseline", "specline", "statline", "specCode", "checkLine", "statLine", " statusline", " statusLink", "checkCode", "statusline", "serviceLine", "statusCode", "statusLink", " statusPage", "StatusPage", "statPage", "servicePage", "serverPage", "checkPage", "responseLine", "specLink", "statusPage"], "inputStream": ["contentStream", " inputSource", " inputThread", "InputThread", "outputStream", "imageSteam", "imagestream", "outputPath", "InputSteam", "inputThread", "contentSteam", "inputPath", "InputPath", "imageReader", " inputSteam", " inputstream", " inputPath", "inSteam", "inStream", "inputstream", "inputSteam", "contentSource", "InputSource", "outputSource", "outputReader", "InputReader", "instream", "contentThread", "inReader", "InputStream", "inputSource", "imageStream"], "inputReader": ["imageStreamer", "errorLibrary", "imagereader", "Inputreader", "uploadReader", "errorReader", "imageReader", "inputStreamer", "inputEditor", "inputLibrary", " inputEditor", "serviceLibrary", "inputreader", "serviceStream", "errorStream", "InputReader", "InputStreamer", "uploadreader", "InputStream", "uploadStream", "imageStream", " inputLibrary", "errorEditor", "serviceEditor", "uploadStreamer", "serviceReader"], "bufferedReader": ["buffererWriter", "buffererredRunner", "buffereredRunner", "bederedWriter", "buffenedParser", "buffedReader", "bufferredRunner", "buffinedReader", "buffererReader", "bedenedReader", "bederedReader", "buffererredReader", "buffererStream", "bufferredWriter", "bedenedLoader", "bederedLoader", "buffenedWriter", "bufferedLoader", "bedenedWriter", "buffedLoader", "bufferredLoader", "bufferredParser", "bufferredReader", "bufferedParser", "bufferedWriter", "buffinedWriter", "bufferedStream", "bufferredStream", "bederedParser", "buffinedRunner", "buffinedStream", "buffereredReader", "buffenedReader", "buffererredStream", "buffenedLoader", "buffererRunner", "buffereredWriter", "buffedParser", "bufferedRunner", "buffererredWriter", "buffedWriter", "bedenedParser", "buffereredStream"], "buffer": ["binary", "cache", "profile", "message", "total", "window", "buf", "sequence", "print", "queue", "database", "phrase", "block", "absolute", "stack", "button", "layer", "trace", "table", "bridge", "black", "bar", "note", "comment", "document", "builder", "console", "batch", "library", "change", "mb", "append", "template", "memory", "display", "null", "Buffer", "buff", "background", "bound", "filter", "bone", "temp", "escape"], "line": ["column", "ine", "header", "liner", "online", "model", "eline", "message", "email", "string", "e", "ln", "user", "le", "chain", "print", "phrase", "cell", "sequence", "block", "lin", "entry", "rule", "text", "error", "frame", "nl", "Line", "link", "inline", "page", "stroke", "comment", "query", "file", "lane", "code", "name", "word", "l", "row", "log", "LINE", "point", "n"], "lastErrorCode": ["lastStatusMessage", " lastErCode", " lastErrorCount", "lastEventCount", "lastErClass", " lastErClass", "firstStatusCode", "lastStateClass", "lastErCode", "firstErrorCount", "lastEventClass", "lastStatusCount", "lastErrorCount", "firstStatusMessage", "lastEventMessage", "firstStatusCount", "lastStateCode", "lastErCount", "firstErrorClass", " lastErCount", "lastErrorClass", "lastStateMessage", "firstErrorMessage", " lastErrorClass", "lastEventCode", "lastStateCount", "lastStatusCode", "lastErMessage", "lastStatusClass", "firstStatusClass", "firstErrorCode", " lastErMessage"], "lastErrorMessage": [" lastErrorDetails", "lastErrorLine", "lastStatusMessage", "lastEventString", "lasterrorMessage", "lastErrorDetails", "lastErrorDescription", "lastEventDescription", "lastWarningDetails", " lastEventMessage", " lastEventDescription", "lasterrorString", "lastStatusDescription", " lastStatusDescription", "lastEventMessage", " lastStatusMsg", "lastStatusString", "lastStatusMsg", " lastStatusDetails", " lastErrorMsg", " lastErrorDescription", "lasterrorLine", "lastEventLine", " lastErrorLine", " lastEventLine", " lastStatusMessage", "lastIssueMessage", "lastStatusDetails", "lastWarningMessage", "lastWarningMsg", "lastErrorMsg", "lastStatusLine", " lastEventString", "lastIssueMsg", "lastErrorString", "lasterrorDescription", "lastIssueDescription", " lastErrorString", "lastIssueDetails", "lastWarningDescription"]}}
{"id1": "530882", "id2": "13207437", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndRewWrite", "readAndResend", "readAndRepWrite", "readAndrewrites", "readAndrewrite", "readAndRewend", "readAndRepend", "readAndResWrite", "readAndResrites", "readAndRewrites", "readAndReprites", "readAndrewend", "readAndrewWrite", "readAndReprite"], "inFile": ["initFile", " infile", "inputPlace", "inFILE", "inPlace", "inFace", "iTime", "docFilename", "iFilename", "INFILE", "INFilename", "iFILE", "INFace", "inputFace", "inTime", "initFace", "INFile", "outfile", "initFilename", "INPlace", "INTime", "infile", "docFILE", "InFilename", "docTime", "outFilename", "inFilename", "initPlace", "inputFilename", " inFilename", "InFile", "docFile", "Infile", "iFile", "inputFile"], "outFile": ["reportFILE", " outFilename", "inFILE", "reportfile", "reportFile", " outfile", "checkfile", "checkFilename", "namefile", "toFILE", "nameFilename", "checkFILE", "toFilename", "outfile", "toFile", "reportFilename", "infile", "nameFILE", "outFILE", " outFILE", "checkFile", "outFilename", "nameFile", "inFilename", "tofile"], "iis": ["Iis", " iiss", "liisc", " iris", " ii", "iiris", "iiisc", "Iiss", "iIs", "eIs", "Ii", "diis", "ii", "iiis", "iiss", " iisc", "liIs", "aiis", "iisc", "liris", "liis", "eIS", "diiss", " iIS", "iris", "aiIs", "dii", "diIs", "iiIs", " iIs", "eis", "aiIS", "iIS", "IIs"], "dcmParser": ["dgrPar", "dcmAdapter", "dfmReader", "deromReader", "dpmPrivate", "dromReader", "dmoduleAssistant", "drumPar", "dgrStatement", "dcrBuilder", "DpmPar", " dcmPar", "dpmParser", "dcfReader", "dpmLoader", "DcmAdapter", "dromAssistant", "dpmBuilder", " dpmListener", "drumParser", "dpmarser", "dmmmParser", "dmParser", "dpmPar", "dromListener", "dmmparser", "dpcAssistant", "dcrReader", "dromparser", "dcomLoader", "DpmAdapter", "dpmListener", " dcmListener", "dpmStatement", " dcmparser", "dpcReader", "dcmPar", " dpmparser", "dromParser", "decmParser", "dfmBuilder", "deromparser", "dcommParser", "dcfStatement", "dcrParser", "dpcPrivate", " dpmReader", "dcfParser", "deromParser", " dcmPrivate", "dmparser", "dmReader", "dcmReader", "dmodulePrivate", "dpmAdapter", "dmmmAdapter", "dcommListener", "dcfPar", "dcmListener", "dmarser", "dcmPrivate", "dcommAssistant", " dpmPrivate", "dmmAdapter", "dmmmReader", "DpmReader", "dmmReader", "dcmLoader", " dpmBuilder", " dcmAssistant", "dcmStatement", "dfmParser", " dpmParser", "decmReader", "dcomParser", "dmmarser", "dcmAssistant", " dcmReader", "decmarser", "DcmParser", "dfmLoader", "dmmmparser", "DpmParser", " dpmAssistant", "DpmBuilder", "DcmPar", " dcmarser", "DcmBuilder", "dcmarser", "deromarser", " dpmLoader", " dpmPar", " dcmBuilder", " dcmLoader", "dmoduleParser", " dpmStatement", "dmoduleReader", "dpcParser", "DcmReader", "dcomReader", "dromarser", "dpmReader", " dpmarser", "Dpmparser", " dcmStatement", "dpmparser", "drumBuilder", "dcmBuilder", "dmmParser", "dpmAssistant", "dgrParser", "dcrparser", "dcmparser", "decmparser", "dcommReader", "dgrReader", "dcomBuilder", "Dcmparser", "drumReader"], "ds": ["fs", "ins", "dd", "xs", "cs", "rs", "dds", " des", "dx", "ls", "dt", "der", "dl", "bs", "sets", "data", "qs", "dat", "dh", "sd", "s", "pers", "drivers", "ys", "sys", "ns", "obs", "ss", "in", "pd", "outs", "js", "gs", "da", "dos", "DS", "sv", "ads", "ims", "des", "as", " DS", "df", "eps", "vs", "tes", "eds", "aos", "services", "uds", "details", "dq", "db", "os", "es", "ils", "Ds", "bd", "hs", "ks", "its", "ods", "hd", "ws", "d", "gd", "ps"], "pdReader": ["xdHelper", "vdWriter", "ddHelper", "pdParser", "pdRead", "pedReader", "pedLoader", "dpLoader", "xdReader", "vdReader", "pdHelper", "ddParser", "hdRead", "vdHelper", "xdWriter", "pdRunner", "tdRead", "ddRead", "ddCar", "xdLoader", "pedRunner", "dpCar", "tdWriter", "ddRunner", "pdLoader", "dpRunner", "hdReader", "hdWriter", "vdLoader", "dpReader", "tdParser", "pedCar", "ddReader", "ddLoader", "ddWriter", "pdCar", "hdParser", "tdReader"], "out": ["ins", "cmd", "id", "serv", "gt", "gen", "err", "js", "status", "obj", "res", "nt", "pos", "inter", "oss", "null", "log", "OUT", "co", "cache", "ent", "io", "conn", "it", "ou", "inv", "to", "auto", "aos", "ch", " err", "name", "conv", "o", "end", "cb", "at", "w", "cn", "en", "p", "v", "ex", "screen", "data", "sum", "s", "con", "cfg", "str", "in", "raw", "outs", "c", "all", "tmp", "msg", "opt", "up", "full", "one", "os", "desc", "flush", "t", "go", "output", "gr", "we", "list", "over", "net", "sys", "on", "sw", "writer", "pool", "nr", "client", "txt", "inner", "Out", "outer", "n"], "dcmEncParam": ["dcmDecNum", "dcmEscNum", "dmmEnPar", "dcmencCmd", "dmmencParam", "dcmEncVal", "dcmEncCmd", "dmmEncMsg", "dmmEncParam", "dcmencNum", "dcmDecMsg", "dmmEncVal", "dmmEnNum", "dmmEnParam", "dmmEncNum", "dcmEnVal", "dcmEscPar", "dcmEscParam", "dcmEscVal", "dcmencPar", "dmmEncCmd", "dcmDecCmd", "dmmencMsg", "dcmEnNum", "dmmencNum", "dcmEnPar", "dmmencCmd", "dcmEncMsg", "dcmencMsg", "dcmEncPar", "dmmEncPar", "dcmencParam", "dcmEncNum", "dcmDecParam", "dcmEnParam"], "pdWriter": ["tdWrite", "PDWriter", "pidWriting", "pdWriting", "pdWrite", "pcWriting", "tdwriter", "pcWriter", "PDEditor", "pidwriter", "dpWrite", "pidWriter", "pdEditor", "pcwriter", "pcWrite", "tdWriter", "PDReader", "dpEditor", "tdEditor", "dpReader", "tdWriting", "pidWrite", "PDWrite", "pdwriter", "dpWriter", "tdReader"]}}
{"id1": "15797402", "id2": "13333160", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"parse": ["pe", "patch", "p", "scale", "format", "php", "process", "print", "parser", "xml", "resource", "ping", "map", "load", "add", "apply", "render", "dump", "transform", "shape", "tag", "build", "execute", "interpret", "slice", "split", "write", "se", "create", "close", "save", "filter", "use", "read", "handle"], "stream": ["length", "image", "Stream", "output", "channel", "archive", "data", "message", "window", "instance", "sync", "content", "iterator", "ream", "clean", "form", "chain", "sequence", "buffer", "stack", "test", "in", "resource", "http", "response", "upload", "document", "file", "console", "reader", "event", "zip", "open", "source", "input", "url", "sample", "download", "read", "cont", "handle"], "handler": ["callback", "host", "processor", "server", "message", "service", "hander", "ctx", "parser", "wrapper", "application", "loader", "writer", "resource", "worker", "storage", "shape", "management", "connection", "function", "address", "controller", "pool", "reader", "event", "h", "hand", "policy", "Handler", "password", "handle"], "metadata": ["image", "pdf", "dd", "mt", "header", "adata", "general", "data", "message", "detail", "properties", "content", "iterator", "google", "tar", "basic", "ctx", "m", "xml", "definition", "hold", "dirty", "md", "document", "MD", "managed", "java", "still", "met", "material", "template", "property", "meta", "details", "parts", "config", "memory", "policy", "td", "mem", "json", "manager", "common", "unknown", "management", "info", "module", "handle"], "context": ["translation", "location", "sc", "instance", "cc", "dict", "content", "environment", "chain", "sequence", "state", "stack", "ctx", "set", "network", "options", "collection", "resource", "frame", "response", "reason", "usage", "document", "connection", "event", "system", "current", "template", "config", "null", "condition", "ce", "command", "component", "local", "module", "Context"], "name": ["image", "pass", "value", "id", "old", "channel", "data", "nm", "description", "service", "lower", "string", "path", "on", "term", "Name", "part", "resource", "size", "nl", "alias", "reason", "comment", "NAME", "prefix", "key", "all", "label", "file", "body", "base", "none", "family", "system", "no", "client", "current", "ame", "title", "source", "filename", "common", "create", "len", "null", "l", "version", "type", "url", "time", "default", "named", "names", "local", "n"], "out": ["cn", "cmd", "output", "OUT", "co", "lay", "v", "serv", "ex", "sum", "external", "list", "gen", "con", "us", "user", "net", "io", "print", "sys", "in", "outs", "it", "OU", "writer", "table", "ou", "col", "to", "all", "obj", "file", "res", "po", "auto", "aos", "cos", "up", "oss", "one", "conv", "conf", "null", "url", "flush", "o", "Out", "outer", "n"]}}
{"id1": "22560224", "id2": "7425022", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"hashStringMD5": [" hashStringMTHash", " hashBytesMT0", " hashStringSM0", " hashStringMT0", " hashStringMT1", " hashStringMD0", " hashStringMT5", " hashStringSM5", " hashStringMDHash", " hashStringSMHash", " hashBytesMT5", " hashStringMD1", " hashStringSHA1", " hashStringSM1", " hashBytesMD1", " hashBytesMD0", " hashBytesMT1", " hashStringSHA5", " hashStringSHAHash", " hashBytesMD5", " hashBytesMTHash", " hashStringSHA0", " hashBytesMDHash"], "string": ["host", "object", "value", "v", "data", "message", "char", "format", "list", "service", "s", "content", "print", "test", "buffer", "sequence", "str", "strings", "space", "setting", "text", "ident", "array", "spec", "comment", "prefix", "sql", "file", "function", "address", "name", "word", "number", "source", "input", "filename", "null", "ring", "site", "password", "result"], "md": ["pdf", "cmd", "dd", "dr", "mt", " MD", "amd", "der", "mode", "red", "Cmd", "nd", "dh", "mk", "sd", "od", "ms", "m", "mm", "pd", "mod", "down", "and", "add", "dist", "de", "dir", "ad", "mc", "mn", " Md", "df", "nt", "dm", "mand", "cond", "ind", "mb", "det", "grad", "ld", "di", "alg", "cd", "desc", "bd", "hd", "d", "MD", "sm"], "byteData": [" byteParts", "byteDat", "viewdata", "byteCount", " byteBuffer", "seeLens", " ByteLens", "componentBuffer", " byteDo", "componentBytes", "viewData", "nodeData", "nodeLens", "wordData", "byteDo", "componentData", "nodeForm", "helloBytes", "byteBytes", "charData", "seeForm", " byteDATA", "worddata", "bytedata", "viewCount", "displaydata", "byteForm", "displayDo", "ByteDo", "ByteParts", " ByteBuffer", "ByteBuffer", " bytedata", "phraseDat", " byteBytes", " byteCount", "byteDATA", "helloData", "phraseDo", "helloDat", "componentParts", "phraseData", "nodeBuffer", "phraseBytes", "ByteBytes", "viewDo", "displayCount", "seeData", " ByteForm", "charDATA", "wordDATA", " ByteData", "byteParts", "byteLens", "chardata", "seeBuffer", "byteBuffer", "ByteData", "helloDo", "displayData", "ByteDat"], "sb": ["sth", "ssl", "sh", "b", "bs", "bf", "shell", "SB", "alph", "sc", "ib", "sync", "web", "nb", "src", "sw", "sq", "sf", "sa", "sv", "bh", "bg", "xb", "sam", "eb", "sp", "bt", "soc", "erb", "mb", "gb", "bj", "bash", "lb", "kb", "zb", "bsp", "rb", "sg", "bb", "ws", "cb", "pb"], "i": ["cli", "mi", "z", "id", "ri", "any", "q", "err", "set", "span", "gu", "g", "di", "gi", "ci", "ski", "\u0438", "point", "info", "I", "pi", "ix", "us", "io", "chain", "print", "my", "m", "ki", "multi", "ic", "it", "li", "xi", "init", "ji", "batch", "name", "conv", "json", "o", "remote", "qi", "v", "ex", "ity", "er", "si", "me", "iu", "in", "c", "j", "ie", "zi", "base", "iy", "uri", "ip", "history", "iq", "ini", "list", "ii", "ai", "bi", "cgi", "yi", "ei", "ij", "ti", "hi", "kj", "phi", "y", "this", "client", "ui", "series", "im", "oi"], "hexString": ["viewString", "sexString", " hexScreen", " hexNumber", "alphaScreen", "alphaString", "hexNumber", "exSocket", "pexSocket", " hexStr", "hexBuffer", "exString", "serialStr", "hexText", " hexText", "alphaStr", "hexSet", "pexStatement", "hexStr", "sexSocket", "hexStatement", "serialText", "hexScreen", "httpSite", " hexSet", "exStr", "httpString", "exBuffer", " hexSite", "expString", "alphaSite", "viewSet", "hexSocket", "hexSite", "serialString", "exList", "httpStr", "expSet", " hexBuffer", "exText", "exStatement", "viewNumber", "sexList", "expBuffer", "pexList", "sexStatement", "expNumber", "pexString", "httpScreen", "serialBuffer", "viewBuffer", "hexList"], "hex": ["sh", "hz", "zh", "exp", "com", "ex", "rh", "aux", "hl", " Hex", "char", "form", "print", "term", "raw", "he", "hp", "ph", "tex", "sv", "des", "dump", "rex", "x", "xf", "hi", "none", "hash", "hw", "def", "comp", "pex", "h", "full", "cmp", " ex", "cat", "lit", "json", "ip", "prop", "oct", "tx", "sex", "buff", " sex", "ext", "html", "hello", "cont", "handle"]}}
{"id1": "1954410", "id2": "19251426", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["doExecExec", "DoExecit", "DoExecute", "doCommExec", "doExecutes", "doCommute", "doEditute", "doExecit", "doEditutes", "doEditExec", "DoExecExec", "DoExecutes", "doCommutes", "doCommit", "doEditit"], "mapping": ["mapper", "mapped", "Mapped", " mapped", "smapped", " mappings", "Mappings", "mappings", "Mapper", "smapper", " mapper", "smapping", "smappings", "Mapping"], "form": ["f", "self", "format", "path", "owner", "m", " forms", "subject", "raw", "view", "map", "session", " Form", "forms", "Form", "formed", " FORM", "orm", "sam", "parent", "FORM", "template", "config", "app", "type", "command", "fc"], "request": ["question", "application", "http", "quest", "report", "impl", "address", "def", "template", "se", "url", "host", "context", "Request", "server", "store", "instance", "view", "upload", "document", "current", "version", "remote", "command", "w", "project", "initial", "container", "Upload", "message", "allow", "user", "Exception", "resource", "post", "query", "parent", "reference", "input", "create", "model", "window", "order", "sw", "xml", "QUEST", "frame", "_", "req", "session", "this", "open", "client", "true", "reset", "first", "cont"], "response": ["reply", "output", "server", "message", "content", "print", "xml", "resp", "application", "view", "status", "re", "frame", "report", "session", "connection", "res", "document", "sp", "write", "respond", "Response", "success", "ce", "send", "result"], "errors": [" moves", " Messages", " state", " requests", " states", " sessions", " warnings", " changes", " steps", " messenger", " status", " statements", " error", " logs", " managers", "ages", " mess", " fails", " updates", " manager", " elements", " problems", " flash", " storage", " messages", " flashes", "Mess", " success"], "isMultipart": ["isMultipade", "isMultiIPade", "isMultifare", "isMultospart", "isMultosparts", "isMultifarts", "isMultipod", "isMultIPade", "isMultifart", "isMultiipart", "isMultiIPare", "isMultiIPain", "isMultiade", "isMultiipain", "isMultiparts", "isMultiipod", "isMultiplade", "isMultiarts", "isMultiIPod", "isMultiipare", "isMultifain", "isMultiipade", "isMultiplod", "isMultiplarts", "isMultIParts", "isMultospain", "isMultiiparts", "isMultiIPart", "isMultospare", "isMultipare", "isMultIPart", "isMultIPain", "isMultiart", "isMultiod", "isMultIPod", "isMultiIParts", "isMultipain", "isMultiplart", "isMultIPare"], "mailInstance": [" MailBuilder", " MailInstance", "emailance", "emailInstance", " mailance", " MailInst", "emailinstance", "mailinstance", " Mailinstance", "flexInst", "flexance", "mailInst", "emailBuilder", "mailance", "emailInst", "flexInstance", "flexinstance", " mailInst", " mailBuilder", "mailBuilder", " mailinstance"], "fields": ["phones", "rows", "terms", "flags", "days", "field", "comments", "models", "drivers", "bits", "qs", "prints", "classes", "atts", "features", "lights", "properties", "types", "packs", "orders", "files", "strings", "links", "packages", "tests", "headers", "relations", "images", "balls", "boxes", "users", "holders", "sections", "reports", "lists", "forms", "workers", "dates", "objects", "members", "services", "modules", "keys", "posts", "details", "parts", "pages", "levels", "states", "lines", "locks", "ports", "plugins", "names", "rules", "groups", "faces", "frames", "tags", "views", "checks"], "attachments": [" attachitions", "achitions", " attachements", "Attachresses", "AttachMENTS", "achements", "Attachitions", "payances", "payitions", "attachions", "Attachments", "attachitions", "acheances", "attments", "attMENTS", "payements", "attachMENTS", "attachements", "payments", "achresses", "achMENTS", " attachions", "acheements", "attensions", " attachances", "attitions", "attachances", "Attachensions", "achments", "attachresses", "attachensions", "achions", "achensions", "acheitions", " attachresses", "Attachions"], "items": ["phones", "rows", " samples", " inputs", "Items", "events", "ips", "orders", "files", "actions", "packages", "issues", "apps", " files", " images", "links", "images", " results", "reports", "cases", "objects", "members", "services", "keys", "archives", "resources", "parts", "pages", "results", "lines", "its", "ids", "names", "groups", "qs", "photos", "tests", " Items"], "iter": ["loc", "el", "ipper", "store", "gener", "upper", "er", "list", "Iterator", "tif", "each", "iterator", "order", "outer", "ait", "oper", "test", "orient", "set", "walker", "maker", "it", "writer", "li", "re", "ter", "ator", "ser", "iner", "ite", "init", "dir", "tr", "reader", "ind", "cmp", "older", "inter", "loop", "i", "former", "ner", "inner", "coll", "its", "Iter", "read", "result", "altern"], "item": ["object", "record", "entity", "detail", "status", "add", "link", "page", "attribute", "obj", "file", "change", "template", "anything", "details", "app", "row", "url", "info", "local", "module", "el", "store", "Item", "ix", "match", "instance", "addr", "claim", "entry", "it", "or", "step", "spec", "related", "key", "name", "unit", "element", "internal", "json", "type", "att", "initial", "other", "ex", "data", "er", "group", "attr", "rule", "raw", "layer", "single", "resource", "word", "up", "one", "ip", "image", "atom", "area", "order", "cell", "member", "mm", "on", "xml", "event", "zip", "inner", "stat", "job"], "aux": ["max", "av", "cu", "du", "uff", "ix", "fat", "uf", "ex", "airs", "af", "area", "us", "fax", "eu", "foo", "aus", "net", "AU", "ax", "lim", "au", "imp", "vers", "etc", "fam", "fx", "fuck", "fu", "aim", "auto", "ups", "ox", "aos", "pet", "ras", "aff", "uds", "extra", "used", "off", "abs", "mu", "tx", "aw", "ux", "buff", "pad"], "part": ["object", "par", "detail", "pair", "section", "pkg", "mod", "join", "add", "Part", "prefix", "sp", "pos", " parts", "html", "pad", "point", "local", "relation", "partial", "print", "pt", "wrapper", "step", " Part", "card", "pet", "photo", "tab", "start", "version", "tx", "temp", "PART", "patch", "p", "zone", "message", "api", "format", "group", "pre", "art", "layer", "worker", "tmp", "base", "pod", "parent", "word", "comp", "parts", "component", "top", "person", "work", "half", "list", "peer", "admin", "member", "block", "piece", "split", "inner", "party", "bound", "sample", "primary", "and", "job"], "baos": ["pois", "caos", "taos", "baoses", "booss", "vaoss", "bioses", "vaols", "caOs", "poops", "baops", "taOs", "poo", "kaoss", "caOS", "boOS", "taoss", "caoss", "waoss", "pooses", "booses", "boOs", "baols", "caols", "biOS", "tais", "bios", "tao", "bao", "taops", "kaops", "bais", "waos", "waols", "bio", "boo", "baOS", "boos", "baoss", "kaos", "poos", "kais", "pooss", "baOs", "cao", "waOs", "vaOs", "vaos", "poOS"], "body": ["rel", "output", "header", "shell", "binary", "port", "data", "message", "format", "description", "detail", "content", "business", "ody", "buffer", "tree", "subject", "ODY", "bill", "Body", "scroll", "text", "size", "post", "note", "comment", "report", "tail", "foot", "layout", "file", "base", "name", "mail", "display", "template", "loop", "title", "head", "pass", "null", "json", "default", "summary", "t", "log", "html", "send", "plain"], "preferencesInstance": ["prefferencesObj", "preffiesinstance", "preferencesinstance", "prefancesInstance", "prefancesImpl", "preffiesObj", "prefancesObj", "prefutesInstance", "prefutesinstance", "prefiesImpl", "prefiesObj", "prefferencesInstance", "preferencesObj", "prefancesinstance", "prefutesObj", "prefiesInstance", "prefferencesImpl", "preffiesInstance", "preffiesImpl", "prefferencesinstance", "prefiesinstance", "prefutesImpl", "preferencesImpl"]}}
{"id1": "5620792", "id2": "13886238", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": [" SHA256", "HS1", "HS2", "shaOne", "HSOne", "SHA2", " SHAOne", "sha2", "HS256", "sha1", "sha256", " SHA2", "SHAOne", "SHA256"], "text": ["translation", "output", "value", "pattern", "data", "message", "select", "string", "content", "path", "form", "print", "test", "q", "str", "pt", "subject", "term", "comment", "prefix", "key", "document", "code", "nt", "msg", "act", "name", "word", "current", "event", "out", "txt", "TEXT", "template", "source", "input", "config", "url", "ct", "tx", "t", "ext", "password", "Text", "read", "cont"], "HASH_VALUE_SIZE": ["HASH_value_SIZE", "HASH_VAL_NO", "HASH_value_TYPE", "HASH_VAL_Size", "HASH_VALUE_NAME", "HASH_value_SOURCE", "HASH_VAL_NAME", "HASH_VALUE_DIR", "HASH_value_DIR", "HASH_VALUE_Size", "HASH_VALUE_SOURCE", "HASH_VALUE_TYPE", "HASH_VAL_SIZE", "HASH_VALUE_NO"], "md": ["cmd", "dd", "mt", " ms", "der", "mode", " cmd", " mc", "nd", " ma", "mg", " rm", "dh", "mk", "sd", " dd", "hm", "od", " sd", "ms", "m", "mm", "pd", "mod", " cd", " del", "js", "ds", "and", "add", "metadata", "dir", "ad", "mc", "mond", " Md", " mo", " mm", "df", "mp", "mn", "dm", "mand", "det", "dig", "mb", "cond", "ind", "h", "grad", "ld", " man", "td", "rm", "cd", "ctr", "bd", "hd", "d", "MD", "sm"], "sha1hash": ["sha31value", "sha1Hash", "ha1result", "SHA2str", "ha1sum", "ha2result", "sha1hex", "SHA2Hash", "ha1Hash", "sha7str", "sha1result", "sha1str", " SHA1value", "SHA1hex", "sha2value", " SHA31value", "SHA2hash", "sha1value", "ha2sum", "sha2sum", "sha5hash", " SHA1sum", " SHA31have", "ha2hash", "ha2Hash", "sha31sum", "sha3Hash", "sha3str", " SHA1have", "sha31have", " SHA31sum", "sha2hash", "sha7hash", "sha1sum", "SHA1hash", "ha1hash", "sha5sum", "sha2hex", "sha5have", "shaonehash", "sha2Hash", "sha3hash", "sha2have", " SHA31hash", "shaoneresult", "SHA1str", "sha2result", "sha31hash", "SHA2hex", "sha2str", "sha5value", "shaoneHash", "sha7hex", "sha7Hash", "sha3hex", "SHA1Hash", "sha1have", " SHA1hash", "shaonesum"]}}
{"id1": "8973505", "id2": "23152865", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"writeFileType": ["readfiletype", "writeContentInfo", "readFileType", "readfileName", "writePageType", "writefileType", "readfileType", "writeFileName", "writePageName", "writeContentName", "readfileInfo", "writefileName", "writeContentType", "readFileInfo", "writePageInfo", "readFileName", "writeFiletype", "writeFileInfo", "readFiletype", "writefiletype", "writeContenttype", "writePagetype", "writefileInfo"], "uriFile": ["URIfile", "URIFiles", "rangeFILE", "iriFILE", "URIFilename", "fileFile", "URIData", "URIFILE", "uriFiles", "URIFile", "filenameFiles", "iriFile", "fileFiles", "rangeData", "fileFilename", "rangeFile", "uriData", "filefile", "filenameFile", "uriFILE", "filenamefile", "filenameFilename", "uriFilename", "rangefile", "iriData", "urifile", "irifile"], "outputfile": ["inputbase", "imageFile", "outputFILE", "inputfile", "outbase", "imageFILE", "OutputFile", "inputport", "outfile", "Outputport", "outputFile", "outputbase", "inputFILE", "outputport", "Outputfile", "outf", "outputf", " outputFile", "inputf", " outputf", "imageport", "OutputFILE", "outFile", " outputbase", "imagefile", "inputFile"], "num": ["max", "Num", "count", "alph", "total", "nm", "con", "um", "n", "nb", "random", "m", "zero", "multi", "add", "all", "nom", "x", "current", "no", "Number", "mult", "cmp", "check", "number", "done", "nam", "NUM", "required", "end", "np", "index", "mon"], "writer": ["record", "stream", "utils", "driver", "RW", "editor", "buffer", "maker", "link", "width", "comment", "linger", "file", "wright", "widget", "journal", "Writer", "riter", "server", "writers", "external", "iterator", "owner", "term", "wrapper", "entry", "commit", "table", "runner", "to", "storage", "document", "caster", "console", "Reader", "write", "memory", "wire", "timer", "w", "director", "ener", "operator", "data", "format", "er", "service", "test", "will", "network", "loader", "layer", "author", "resource", "worker", "creator", "usher", "builder", "ner", "writing", "written", "flush", "processor", "ender", "liner", "window", "player", "handler", "connection", "writ", "function", "event", "client", "inner", "manager", "variable", "thus", "read"], "uri": ["folder", "mi", "uid", "ri", "id", "description", "bid", "http", "link", "range", "prefix", " URI", "file", "address", "details", "username", "ni", "obo", "pi", "domain", "https", "du", "doi", "iterator", "form", "chain", "multi", "browser", "ur", "uu", "unit", "wiki", "filename", "remote", "qi", "result", "copy", "general", "channel", "user", "ref", "basic", "subject", "rid", "via", "resource", "query", "reference", "iri", "source", "ugi", "ip", "uno", "verb", "image", "location", "ir", "umi", "queue", "origin", "phrase", "ource", "uni", "URI", "ei", "hi", "connection", "hyper", "sofar", "directory", "phi", "qu", "ui", "i", "inner", "href"], "counter": ["context", "cover", "const", "processor", "container", "mr", "scope", "meter", "frequency", "money", "currency", "norm", "count", "message", "total", "instance", "ounter", "ier", "cookie", "order", "iterator", "pointer", "Counter", "sequence", "phrase", "editor", "random", "buffer", "continue", "walker", "term", "loader", "entry", "another", "cms", "ter", "machine", "mill", "mer", "creator", "browser", "clock", "key", "card", "amount", "controller", "nr", "system", "TER", "loop", "number", "memory", "book", "common", "inner", "conv", "manager", "ctr", "finder", "coll", "time", "timer", "index", "outer"], "reader": ["context", "processor", "dd", "server", "liner", "upper", "er", "driver", "iterator", "player", "handler", "editor", "buffer", "parser", "entry", "loader", "layer", "resource", "rl", "runner", "method", "ro", "document", "redo", "file", "builder", "address", "rar", "Reader", "rx", "older", "ner", "input", "r", "iter", "yer", "inner", "row", "roller", "journal", "timer", "read"], "url": ["loc", "rel", "sl", "ssl", "gl", "https", "location", "dl", "il", "hl", "char", "bel", "google", "github", "web", "ref", "str", "ll", "resource", "http", "li", "re", "nl", "link", "www", "browser", "ur", "URL", "build", "base", "address", "name", "open", "mount", "mail", "client", "get", "r", "Url", "l"], "myConnection": ["myConnector", "thisConn", " myConnect", " myConn", "newConnect", "myconnection", "thisConnection", "MyConnector", "MyLink", "Myconnection", "thisLink", "newConn", "yourConnector", "yourconnection", "myConn", " myConnector", "newLink", " myconnection", "yourConnection", "MyConnection", "newConnection", "myConnect", "yourLink", " myLink", "myLink", "thisConnect"], "myReader": ["MyWriter", " myFr", " myRead", "MyParser", "yFr", "ySer", "mxFr", "yourParser", "myRead", " mySer", "mxSer", "MyRead", "yourRead", " myParser", "mxReader", "yReader", " myWriter", "mxWriter", "yourWriter", "myFr", "MyReader", "yWriter", "myParser", "yourReader", "mySer", "myWriter"], "line": ["cli", "ine", "ole", "style", "liner", "online", "channel", "eline", "message", " Line", "char", "email", "detail", "ge", "ln", "lo", "le", "user", "sequence", "cell", "side", "normal", "block", "lin", "entry", "raw", "ode", "text", "definition", "rule", "part", "trace", "frame", "inline", "Line", "stroke", "link", "page", "range", "comment", "label", "lane", "body", "code", "word", "no", " LINE", "iter", "one", "l", "row", "ip", "log", "LINE", "edge", "sample", "point"], "linecount": ["elinecounter", "elineconst", "inlinelength", " linelength", "lineconfig", "linconsider", " lineconfig", " lineamount", "strokenumber", "linecounter", "inlinecounter", " lineconsider", "strokecount", "linercount", "linelength", "Linefound", "inlineconst", "lineconst", "linerconfig", "strokeconsider", "linefound", "linerCount", "LineCount", "linerfound", "lincount", "linamount", " linenumber", " linefound", "Linecount", "inlinecount", "linenumber", "Lineconfig", "elinelength", "linnumber", " lineconst", "strokeamount", "lineconsider", "lineCount", "elinecount", " lineCount", " linecounter", "lineamount"], "hasOWL": ["hasOHS", " hasOWLS", " hasOWSR", "HasOWSB", "hasEWR", "hasOWSB", "hasROL", "hasOWS", "hasEWB", "hasOWSNL", "HasOWL", " hasOWLP", " hasOWR", "HasOWSS", "hasOWR", "hasOWNR", "hasEWL", "hasEWLP", "hasOWB", " hasEWR", "hasOHL", "hasRONL", "hasOWLP", "hasSOL", " hasOWSL", "hasEWS", "hasOHB", " hasOWSNL", "hasOWNNL", "hasROR", "hasROLP", "HasOWB", "hasOWSR", " hasOWSLP", "HasOWSLP", " hasOWNL", "hasSOR", "hasOWSL", "hasOWLS", " hasEWLS", "hasSOLS", "hasEWLS", " hasEWLP", "hasSOLP", " hasEWL", "hasOWNLP", "HasOWLP", "HasOWSL", "hasOHLP", "hasOWSS", "hasOWSLP", "hasOWNL", "hasOWSLS", "HasOWS"], "hasRDFS": ["hasRdfS", "hasRMLDS", "hasRMLM", "hasSRDFS", "hasRNFM", "hasRDFM", "hasRNFs", "hasRNFS", "hasRdfCS", "hasORDFM", "hasRDSS", "hasRDSs", "hasRRICS", "hasRRIs", "hasXDSDS", "hasRRIB", "hasXDFS", "hasORDSS", "hasXDSS", "hasRDFB", "hasRdfM", "hasSRDFs", "hasXDSM", "hasORDSM", "hasRDSB", "hasSRDFB", "hasRDFCS", "hasXDFM", "hasRdfs", "hasRRIS", "hasRDSCS", "hasRdfDS", "hasXDSs", "hasRDSDS", "hasORDSDS", "hasRDFDS", "hasSRDFCS", "hasRDSM", "hasXDFs", "hasRMLs", "hasRdfB", "hasSRDSs", "hasSRDSS", "hasORDFs", "hasXDFDS", "hasORDFDS", "hasRMLS", "hasSRDSCS", "hasSRDSB", "hasORDFS", "hasRNFDS", "hasRDFs", "hasORDSs"], "hasRDF": ["hasRADF", "hsRDF", " hasRRDS", "hasDCD", " hasRRDF", "hasRTDR", "hasRADI", "hasREDF", "hasRADT", "hsRRDI", "hasDdf", "hasRCdf", " hasDCD", "hasORDF", "hasRTDS", "hsRDT", "hasRDT", "hsRDS", " hasDdf", "hasRRDF", "hasORNF", "hasORDS", " hasRNF", "hasRDI", "hasRCNF", " hasRRDR", "hasRRDT", "hasDDF", "hasORDR", "hasREDI", "hasRCCD", "hasRCD", "hasRdf", "hasRRDR", " hasDNF", "hasRTDF", "hsRRDS", " hasRdf", " hasRDS", "hasRRCD", " hasRRNF", "hasRCDF", "hasREDT", "hsRDI", "hsRRDT", "hsRRDF", "hasRNF", "hasDNF", "hasRADS", "hasRTNF", "hasRDS", " hasDDF", "hasRRDS", " hasRCD", "hasREDS", "hasRDR", "hasRRdf", "hasRRDI", " hasRDR", "hasRRNF"]}}
{"id1": "20924119", "id2": "5035872", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"gzip": ["Gzip", "gZip", "mZip", "mzip", " garchive", " gdef", "marchive", "garchive", "Gdef", "Garchive", "GZip", "gdef", " gZip", "mdef"], "zipout": [" zipconn", "zou", "zOut", "pipein", " zipnet", " zipou", "gzo", "zipop", " zipin", "locko", "zout", "logout", "zouts", "gzin", "zipouts", " zipop", "pipenet", "logOut", "login", "zipconn", "gzconn", "pipeou", "lockconn", "lockop", "zipin", "gzOut", "pipeout", "zipo", "gzout", "gzouts", "logouts", " zipo", "lockout", "zipOut", "znet", "zipou", "gzop", "zipnet", "zin"], "buffer": ["header", "stream", "binary", "seed", "cache", "data", "message", "window", "char", "buf", "string", "device", "sequence", "stack", "queue", "database", "phrase", "block", "button", "limit", "size", "table", "frame", "paste", "attribute", "comment", "document", "batch", "code", "word", "line", "append", "mem", "memory", "number", "row", "variable", "Buffer", "buff", "bytes", "sample", "pad", "password", "command", "history", "result"], "dir": ["rel", "div", " Dir", "folder", "del", "loc", "dr", "dd", "ord", "fin", "ir", "dra", "dl", "dat", "self", "mk", "path", " director", "rect", "tree", "ory", " directory", "pkg", "part", "add", "dist", "vol", "req", "md", "file", "DIR", "df", "tmp", "directory", "parent", "det", "pos", "cond", "ind", "def", "out", "doc", "cur", "iter", "wd", "db", "cd", "desc", "Dir", "root", "direct", "fd", "d", "draw"], "in": ["ins", "inside", "din", "el", "en", "ri", "ex", "ini", "IN", "sin", "inn", "like", "form", "inf", "cin", "gin", "on", "bin", "from", "it", "ic", "and", "init", "al", "ain", "act", "reader", "ind", "is", "inc", "out", "check", "up", "rin", "i", "input", "win", "source", "inner", "iter", "oin", "isin", "im", "read", "In"], "length": ["distance", "frequency", "angle", "position", "port", "match", "count", "data", "message", "capacity", "total", "char", "SIZE", "index", "sequence", "duration", "database", "text", "volume", "join", "load", "size", "available", "impl", "shape", "tail", "ength", "body", "family", "ind", "before", "height", "full", "number", "len", "character", "needed", "l", "row", "type", "start", "time", "padding", "end", "hello", "component", "Length", "history", "read", "ENGTH"]}}
{"id1": "5744493", "id2": "755203", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" synchronizedFullMove", " doPageDownload", " synchronizedFullCopy", " synchronizedFullDownload", " synchronizedFileCopy", " doStreamCopy", " synchronizedFileDownload", " doStreamDownload", " doFullCopy", " doFileDownload", " synchronizedFileMove", " doStreamMove", " doPageMove", " doPageCopy", " doFullMove", " doFileCopy", " doFileMove", " doFullDownload"], "in": ["ins", "din", "el", "en", "b", "old", "ex", " input", "IN", "inn", "inf", "cin", "gin", "mm", "ac", "from", "ic", "it", "or", "init", "as", "file", "ain", "ind", "inc", "up", "rin", "source", "input", "i", "r", "l", "o", "isin", "ck", "In", "n"], "out": ["ot", "output", "OUT", "v", "p", "serv", "ex", "gt", "s", "net", "io", "ne", "outs", "it", "c", "ou", "to", "as", "file", "res", "po", "op", "nt", "ch", "write", "up", "check", "help", "os", "l", "null", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["dinCommand", " inChan", "cinCommand", "inConnection", "innCategory", "isinChannel", "inChan", "isinButton", "isinConnection", "vinChannel", "Inchannel", "InCh", "INStream", "vinCase", "outchannel", " inCommand", "inCategory", "innButton", "inCh", "cinButton", " inCase", "vinConnection", "INchannel", "INChannel", "innerStream", "inStream", "InChannel", "dinCase", "cinChannel", "innerchannel", "innerChan", "dinButton", "innCommand", "dinChan", "isinChan", " inCh", " inConnection", " inchannel", "outCh", "dinConnection", "inCase", "dinChannel", "inchannel", "outChan", "INChan", " inCategory", "inCommand", " inButton", "outStream", "InChan", "innerChannel", "innChannel", "cinCategory", "vinCommand", "inButton"], "outChannel": ["cosMachine", "outputCh", "aosChannel", "onChan", "outputStream", "inChan", " outCh", "outSection", "cosDisk", "newChannel", "onchannel", "outputChan", " outchannel", "outDisk", " outRoom", "outConnection", "outchannel", "OutStream", "onConnection", "aosSection", "OutCh", "OutChannel", "outerChan", "aosDisk", "cosSection", "outRoom", "upSection", "upMachine", "inStream", "onChannel", "upChannel", " outConnection", "newChan", "outCh", "outerStream", "outputChannel", "OutChan", "outerChannel", "outChan", "cosChannel", "outerRoom", "newchannel", "aosMachine", " outStream", "outStream", "outMachine", "upDisk", "inRoom", " outChan", "newConnection"], "maxCount": ["MaxCount", "minSize", "maxSize", " maxLength", " maxFlag", " maxCast", "MAXCount", "MAXFlag", "minCount", "minFlag", "minLength", "MaxLength", "MAXLength", "maxLength", "MaxCast", "minCast", "maxFlag", "MaxSize", " maxSize", "maxCast"], "size": ["length", "readable", "sent", "equal", "Size", "position", "scale", "count", "show", "sum", "message", "SIZE", "ose", "ize", "ze", "capacity", "sd", "area", "speed", "si", "total", "empty", "gets", "notice", "ms", "resolution", "any", "duration", "m", "space", "set", "scroll", "fee", "score", "south", "export", "range", "shape", "small", "body", "name", "seek", "shift", "is", "height", "keys", "write", "len", "close", "start", "bytes", "sample", "send", "read"], "pos": ["loc", "rel", "length", "exp", "p", "port", "position", "Pos", "pi", "Position", "POS", "pointer", "offset", "pt", "zero", "resp", "it", "part", "limit", "spec", "to", "page", "coord", "pg", "x", "seq", "po", "left", "sp", "cos", "pc", "pid", "no", "def", "pro", "pr", "off", "pl", "i", "len", "pass", "doc", "os", "l", "start", "row", "o", "point", "pose", "index", "slot", "ps", "n"]}}
{"id1": "16590954", "id2": "536614", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"createJAR": ["createGAR", "saveJAR", "saveIJAR", "createGART", "createPHAR", "createIJAR", "saveIJART", "saveIJARS", "createGARS", "createGAP", "createJAP", "createJARS", "createPHART", "createIJAP", "saveJART", "createPHAP", "saveIJAP", "createJART", "createIJART", "saveJAP", "createPHARS", "saveJARS", "createIJARS"], "fileString": ["fileStr", "messageString", " fileRest", "FileStr", "FileString", "ilestring", "FileRest", "pathstring", "pathStr", "ileName", "FileText", "fileRest", "pathString", "ileRest", "Filestring", "messageStr", "messageText", " fileStr", "ileString", "fileName", " filestring", "messageName", "ileStr", " fileName", "fileText", "filestring", "FileName", " fileText"], "ext": ["Ext", "cmd", "exp", "ix", "EXT", "ex", "typ", "enc", "char", "format", "external", "pat", "e", "path", "except", "str", "gz", "text", "ime", "js", "xp", "tex", "fr", "req", "ort", "prot", "suff", "name", "ind", "append", "txt", "exe", "off", "xt", "type", "desc", "end", "t", "rest", "cont"], "file": ["f", "image", "store", "output", "port", "work", "model", "class", "channel", "cache", "data", "message", "format", "list", "module", "disk", "path", "foo", "le", "io", "user", "buffer", "tree", "from", "File", "resource", "http", "table", "FILE", "link", "to", "page", "report", " File", "document", "run", "force", "base", "parent", "pool", "name", "lock", "this", "open", "line", "fp", "h", "ile", "get", "source", "input", "doc", "memory", "mail", "db", "null", "type", "url", "default", "time", "t", "log", "info", "local", "handle"], "i": ["f", " j", "mi", "ami", "ri", "id", "p", "pi", "v", "ir", "ini", "ii", "s", "si", "ai", "bi", "n", "m", "c", "li", "j", "xi", "x", "phi", "ind", "is", "ui", "di", "gi", "ci", "ip", "ati", "o", "t", "index", "I"], "dir": ["div", "loc", "folder", " Dir", "del", "rel", "dd", "dy", "org", "id", " d", "ir", "home", "disk", "path", "addr", " directory", " folder", "pkg", "mod", "part", "direction", "vol", "dist", "DIR", "star", "tmp", "directory", "ind", "done", "uri", "wd", "db", "url", "Dir", "root", "direct", "d", "lib", "project"], "jarFile": ["jarField", "jFile", "jarfile", "jarName", "pkgFile", "jarEmail", "jfile", "javaFilename", "javaFile", " jarField", " jarFILE", "tarfile", "tarFilename", "jName", "JarFilename", "tarEmail", "pkgField", "JarFILE", " jarEmail", " jarFilename", "jFilename", "tarFile", "JarFile", "JarField", "JarEmail", "jarFILE", "Jarfile", "javafile", "javaName", "jarFilename", "pkgFILE", " jarfile", " jarName"], "fstrm": [" fdrum", "fslcm", "fcrdm", "ftrmed", "fstrmed", "ftrdm", " fstrcm", " fdrmed", "fstrp", " fstrum", "fsprm", "fbstrm", "fcrm", "fsprms", "ftrms", " fdrcm", " fdrm", "fcrp", "fstrms", "fbstrdm", "fstrum", "fsprdm", "fcrms", "ftrum", "fdrcm", "fdrmed", "fslm", "fstrdm", "fbsprdm", "fbstrp", "fbstrms", "fstrcm", "fsprp", "ftrcm", "ftrp", " fstrmed", "fslum", "fslmed", "fdrum", "fdrm", "fbsprms", "fbsprm", "ftrm", "fbsprp"], "in": ["f", " IN", "ins", "din", "inside", "en", "pin", "IN", "sin", "inn", "ai", "io", "inf", "gin", "cin", "m", "mm", "bin", "from", "it", "ic", "re", "add", "init", "ind", "is", "inc", "up", "rin", "input", "r", "iter", "inner", "oin", "o", "isin", "im", " din", "read", "In", "pi"], "out": ["cn", "output", "OUT", "co", "v", "p", "serv", "ex", "channel", "s", "net", "io", "outer", "m", "conn", "outs", "c", "it", "OU", "writer", "ou", "inv", "to", "obj", "gc", "aos", "cos", "ch", "client", "conv", "inner", "os", "null", "t", "o", "cm", "Out", "at", "w", "cont", "n"], "temp": ["mt", "output", "copy", "tt", "p", "wrap", "cache", "cont", "tc", " tmp", "mint", "mk", "thread", " temporary", "path", "dest", "EMP", "buffer", "tar", "mm", "pt", "m", "tree", "term", "mod", "to", "orig", " Temp", "emp", "document", "res", "Tem", "mp", "tmp", "directory", "porary", "pool", "cp", "name", "parent", "zip", "current", "template", "Temp", "memory", "full", "mem", "tm", "tem", "fake", "null", "tx", "t", "util", "TM", "local", "stem"], "fstrm2": ["fstrp1", "fstrp7", "fstrM7", "fstrm1", "fStrm7", "fStrm2", "fstrcm2", "fstrmm1", "fstrM1", "fstrtm2", "fstrm7", "fStrtm1", "fstrmm2", "fstrcm1", "fStrp7", "fStrtm2", "fstrM2", "fStrp1", "fstrcm7", "fStrp2", "fstrtm1", "fStrm1", "fstrp2"], "ostrm": [" ostrem", "astRM", "istnm", "ostrom", "ortlamm", "astm", "istmr", "astrem", "osrem", " ostm", "ostnm", "ostrem", "ortrom", "ostlamm", "istRM", "astlamm", "osmr", "istrem", "astrom", "osRM", "astrm", "osm", "osrm", "ostm", "ortrm", " ostrom", "istrm", "ostRM", " ostnm", "oslamm", "astmr", "osnm", "istm", " ostRM", "ortRM", "ostmr", " ostlamm"], "docFile": ["Docfile", "docFiles", "documentLine", "DocFiles", "manDir", "docLine", " docPath", "manfile", "DocLine", " docfile", "docfile", "documentDir", " docDir", "docPath", " docLine", "manFile", " docFiles", "manPath", "documentFiles", "docDir", "documentFile", "DocFile", "DocDir", "DocPath"]}}
{"id1": "13757855", "id2": "1097147", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"process": ["processor", "Process", "task", "format", "processing", "load", "step", "add", "replace", "apply", "render", "transform", "run", "build", "execute", "call", "write", "display", "loop", "create", "proc", "parse", "save", "filter", "project", "handle"], "tpl": [" tPL", "tmpp", "tpp", " tph", "ptplates", "timbl", "atplate", "stopl", "stplate", "teruple", "tempr", "stbl", "ttopl", "ttpg", "tsPL", " tpp", "tuple", "tpg", "tmplates", "ttbl", "Tplates", "tmplate", "timspl", " turtle", " tld", "tPL", "typl", "tyurtle", "tsurtle", "templ", "tplug", "Tbl", "stplug", "tpr", "tld", "Tplate", "ttpl", "temPL", "itpl", "tplate", "terplate", "otbl", " tplates", "stspl", "turtle", " tplate", "timpl", "itbl", "tyPL", "timplate", "tmbl", "timplug", "itPL", "atuple", "stpg", "tspl", "ttPL", "topl", "ptbl", "TPL", "tmPL", "terld", "Tspl", "Tph", "tbl", " tuple", "tsbl", "Tpr", "atld", "otplate", "ptpl", "tembl", "ttplug", "itplate", "tspr", " tbl", "Tpp", "otpl", "tplates", "tph", "Tld", "timopl", "ptld", "stpl", "otld", "ttph", "terpl", "tmpl", "timpg", "atpl", "Tpl"], "model": ["el", "object", "record", "models", "product", "node", "M", "data", "content", "ml", "m", "tree", " Model", "md", "document", "file", "Document", "base", "parent", "Model", "log", "html", " models", "module", "project"], "packageName": [" packageFamily", "groupNames", "groupName", "packagename", "Packagename", "viewClass", " packageClass", "packageRoot", "pkgVersion", "PackageName", " packagename", "pkgNames", "groupFamily", "packageVersion", "groupVersion", "PackageClass", " packageVersion", " packageRoot", "PackageRoot", "packageNames", "pkgFamily", "packageClass", "pkgName", " packageNames", "viewName", "viewRoot", "packageFamily", "viewname"], "outFileName": ["infilePath", " outFileTime", " outFileType", "outImagename", "outFilenameType", " outFilenameType", "outDirPath", "outFileNames", "outFilePath", "outFilenameNames", " outTableSize", "outStreamNames", " outTablePath", " outfileNames", "outFName", " outFileChain", "outfileNames", " outFilenamePath", " outFilenameSize", "outImageSize", "outfilename", "outStreamType", "outTableSize", "outDirName", "outFileChain", "outTablePath", "outDirTime", "infileNames", " outFilePath", " outfileName", "outStreamTime", "outfileType", "outTableType", " outFilenameName", "outFileSize", "outTablename", "outFPath", " outFilenameChain", "outFilenamePath", " outFilenamename", "outFilenameTime", "inFileTime", "outImagePath", "infileName", " outTableTime", " outFilename", "outFname", "outTableTime", "outfileTime", "inFileType", "infileTime", " outFileNames", "outStreamPath", "outStreamName", "outTableName", "inFileName", "outfilePath", "outFilenamename", "outFilename", "inFilePath", "outfileName", " outfilename", "outDirSize", "outFilenameSize", "outFileType", "inFileNames", "outTableChain", " outFileSize", "outFNames", "outFilenameName", " outfilePath", "outFilenameChain", "outImageName", " outTableName", "outFileTime", "outfileChain", "infileType"], "xsltParam": ["xsqlParam", "xsmlParam", "xsslParam", "xmlConf", "xmlParameter", "xsltConf", "xltParam", "xsmlParameter", "xsltParameter", "xsmlConf", "xltParameter", "xmlParam", "xsqlConf", "xsslParameter", "xsqlParameter", "xsslConf", "xltConf"], "artifact": ["arifacts", " artificate", "partifacts", "anifacts", "ardifacts", " artifacts", "ardifact", "arifact", "anificial", "artifacts", "artificial", "ardificial", "ardificate", " artificial", "artificate", "partifact", "Artifact", "Artifacts", "anifact", "anificate"], "destinationPath": ["estinationPath", "destigationChain", "chaininatedPath", "destinoHost", "destensionPoint", "destinatorChain", "origininationNow", "destesticSystem", "destinationName", "destinateChain", "destinationUrl", "chaininationDisk", "destociationPoints", "desturationPath", " destociationpath", "delinationPath", "estinationName", "DestinationPod", "destensionHost", "DestensionPath", "destesticPath", "destinationTarget", "destventionPath", "destinationSystem", "destigationPath", "destinantTemp", "generinationPath", "destinoName", "destinateAt", "destinantPod", "destositoryHost", "destinatorPath", "destionPath", "estinationPart", "destositoryParent", "DestinationHost", "termininationTarget", "destinationPart", "destinoPoint", "destinoKey", "destinateDir", "delinatePoints", "destensionPath", "identinateKey", "destinateName", "termininerJar", "desturationJar", "descositoryParent", "identinateChain", "destATIONParent", "destionPoint", "destesticJar", "descositoryHost", "DestificationDir", "destacementTime", "estinoKey", "estionpath", "destociationHost", "destociationHome", "destacementName", "destinateTarget", "destociationForm", "chaininationHome", "destinatePoints", "destensionTemp", "destinateJar", "destensionDir", "desticationPath", "destationDir", "destinationDriver", "destinateTime", "destinationDisk", "DestinationUrl", "delinateForm", "delinatePath", "desturationTarget", "destinatedTarget", "destinerpath", "destationHost", "destinationParent", " destinationpath", " destociationTarget", "estationPart", "identinationPath", "estationHost", "estinationDir", "descinationParent", "origininatedPath", "generinateAt", "generinatePath", "destinationNow", "destinationKey", "destinatorHost", "descositoryPath", "destociationPath", "destationPart", "destinateForm", "destinationChain", "destationPath", "destinationPod", "destitutionPATH", "destinatorPoint", "estinationPATH", "DestensionDir", "destacementPath", "desticationTemp", "destATIONPath", "termininerTarget", "desturationpath", "DestensionTemp", "destinateSystem", "destregationDisk", "destinateNow", "destinerHost", "destociationpath", "estinationpath", "destociationDir", "destificationUrl", "destositoryPath", "estinationTime", "descinationHost", "DestificationLocation", "destinatorpath", "origininatedChain", "destinateLocation", "destinatedDriver", "destinerDir", "chaininatedHome", "desticationPod", "destificationLocation", "chaininationPath", "destinateLog", "termininationPath", "origininationChain", "identinateInfo", "DestensionHost", "destinationDir", "estationDir", "destificationDir", "destinantDir", "destinationpath", "destinatorKey", "estinationPoint", "destitutionPath", "destesticAt", "destinationLocation", "estinoPath", "destranceLog", "destinationTemp", "origininatedForm", "identinationChain", "generinateJar", "destinatedChain", "DestificationPath", "estinationHost", "destinationPort", "identinationKey", "estionPoint", "destificationPath", "estionPath", "destitutionpath", "termininerpath", "destinateInfo", "DestensionPoint", "generinationSystem", "destrancePath", "destociationDisk", "destensionPod", "destATIONPort", "destinerPath", "DestinationTemp", "DestinationDir", "identinatePath", "destigationNow", "destinateUrl", "destinationPoint", "destociationLog", "destinatedInfo", "destitutionPoint", "estinationKey", "destregationPath", "destinatedDisk", "destventionDisk", "DestensionPod", "DestinationPath", "destinerAt", "destionpath", "destinationInfo", "destventionHome", "destinatorParent", "origininatedNow", "destationLocation", "destinationTime", "destinatedpath", "destationUrl", "DestificationUrl", "estationPath", "destinatorPATH", "destinoDir", "destinerPart", "destociationTarget", "destositoryPort", "origininationPath", "destinationForm", "descinationPort", "destinerTarget", "destinationJar", "destinationHome", " destinationTarget", "destociationDriver", "termininerPath", "destinatePart", "destventionDriver", "destinatedKey", "destinateKey", "chaininationDriver", "estionPATH", "destinatorInfo", "destinatePath", "delinationPoints", "destranceForm", "delinationLog", "destinerSystem", "destinationAt", "delinateLog", "destionPATH", "descinationPath", "destinatedNow", "DestinationLocation", "generinationAt", "destinateHost", "chaininatedDriver", "destinerJar", "chaininatedDisk", "destregationTarget", " destociationPath", "descositoryPort", "termininationJar", "identinationInfo", "destinatepath", "destATIONHost", "generinateSystem", "destigationForm", "destociationPoint", "destinationPoints", "destinationLog", "destinatedPath", "destinationHost", "destinatorPort", "origininationForm", "destinoTime", "termininationpath", "destinatedForm", "destinantPath", "destinoPath", "destinationPATH", "destrancePoints", "estinoName", " destinationDisk", " destociationDisk", "generinationJar", "estinoTime", "destinatedHome", "desticationDir", "DestinationPoint", "destacementKey", "destregationpath", "delinationForm"], "in": ["f", " IN", "ins", "din", "id", "IN", "io", "m", "bin", "c", "file", "reader", "doc", "i", "input", "r", "inner", "l", "t", "o", "d", "info", "w", "In", "n"], "out": ["cn", "f", "ins", "u", "cmd", "output", "go", "OUT", "co", "gr", "v", "b", "p", "dis", "ex", "screen", "ger", "println", "cache", "list", "gen", "s", "con", "e", "ln", "net", "io", "cfg", "print", "sys", "err", "conn", "raw", "outs", "it", "or", "c", "writer", "ou", "inv", "to", "report", "all", "obj", "res", "file", "aos", "nt", "msg", "ch", "nr", "can", "client", "write", "up", "inner", "oe", "conf", "null", "l", "os", "o", "log", "t", "Out", "w", "outer", "n"], "root": ["initial", "context", "scope", "node", "id", "p", "println", "New", "data", "chain", "group", "tree", "m", "table", "de", "_", "dir", "dump", "impl", "Root", "child", "parent", " roots", "name", "def", "graph", "r", "config", "se", "create", "json", "start", "parents", "ok", "roots", "Template"]}}
{"id1": "9413074", "id2": "8079516", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"getLocation": [" getDescription", "GetDescription", " getURL", "getlocation", "getDescription", "GetLocation", "loadURI", " getLoc", " getURI", " getlocation", "GetLoc", "newLoc", "GetURI", "GetURL", "getURL", "getURI", "loadLocation", "getLoc", "newDescription", "loadDescription", "newlocation", "newLocation", "loadURL", "Getlocation"], "clazz": ["klClass", "Claz", "Clos", "Clazz", "CLazz", "scazz", "klclass", "claz", "clclass", "scaz", "clClass", "clamp", "clos", " clamp", "Clclass", "Clamp", "CLclass", "scamp", " clos", "scos", "CLaz", " claz", "klazz", "ClClass", "klaz", "CLClass"], "url": ["f", "loc", "host", "rel", "u", "sl", "ssl", "gl", "org", "https", "ls", "dl", "channel", "char", "hl", "string", "web", "ml", "ref", "user", "lr", "addr", "q", "buffer", "str", "err", "ll", "xml", "conn", "ret", "loader", "resource", "http", "rl", "ul", "nl", "link", "socket", "browser", "ur", "impl", "sql", "URL", "sb", "run", "cert", "build", "base", "address", "this", "mount", "mail", "client", "ob", "get", "r", "uri", "Url", "l", "abs", "row", "path", "log", "util", "remote", "result", "handle"], "location": ["loc", "length", "translation", "update", "scope", "value", "behavior", "position", "displayText", "language", "message", "relation", "where", "feature", "description", "area", "color", "peer", "string", "path", "origin", "resolution", "application", "Location", "region", "resource", "trace", "direction", "availability", "ocation", "nl", "usage", "comment", "range", "expression", "document", "layout", "function", "operation", "address", "directory", "none", "reference", "name", "history", "family", "library", "ion", "display", "title", "filename", "l", "row", "type", "padding", "summary", "media", "selection", "command", "local", "slot", "result"], "file": ["f", "image", "folder", "object", "entity", "pe", "output", "binary", "angle", "port", "channel", "format", "path", "user", "io", "le", "ref", "checked", "files", "ory", "block", "face", "File", "resource", "table", "FILE", "ca", "page", "dir", " File", "run", "library", "parent", "name", "out", "fp", "ile", "full", "filename", "db", "module"]}}
{"id1": "7044153", "id2": "23517481", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendErrorToClient", "sendExceptionTOHost", "sendExceptionTOServer", "sendErrorToHost", "sendExceptiontoHost", "sendErrortoHost", "sendErrortoClient", "sendExceptionTOClient", "sendErrortoServer", "sendErrorToServer", "sendExceptiontoClient", "sendExceptionToHost", "sendExceptiontoServer", "sendExceptionToClient"], "server": ["host", "store", "value", "v", "port", "serv", "channel", "env", "email", "description", "service", "localhost", "string", "test", "Server", "erver", "ser", "ver", "code", "base", "address", "client", "null", "version", "site", "remote", "password"], "ex": ["el", "ry", "exp", "ix", "com", "exclusive", "aux", "except", "e", "Exception", "EX", "an", "Ex", "any", "test", "err", "example", "ic", "it", "error", "or", "nex", "re", "rex", "x", "obj", "lex", "expl", "hex", "wx", "ox", "ception", "none", "event", "rx", "pex", "exe", "one", "exc", "eas", "fail", "tx", "ext", "xc", "exit", "Exc"], "config": ["context", "param", "rc", "cache", "env", "channel", "figure", "service", "content", "form", "cfg", "Configuration", "debug", "text", "c", "control", "cert", "params", "Config", "settings", "fig", "input", "auth", "conf", "ct", "log", "password"], "prob": [" prbj", "prbe", "Probj", " prbes", "Probes", "probj", "prb", " prb", " prbe", "prbj", "probes", "Prob", "probe", "Probe", "prbes"], "dataSB": [" dataBW", "relationBB", "atasb", "keySB", " dataSI", "keySL", "dataSF", "contentNB", "ataSW", "imageBS", "divSquare", "imageSF", "relSB", " dataSA", "divBS", "ataSN", "valueBB", "joinSF", "resourceSI", "imageBP", "valueBS", "datWB", "dataSw", "imageNB", "nextBS", "dataHB", "dateBu", "cacheBB", "nextSF", "ataBP", "ataMB", "partialSB", "dataSR", "imageSB", "windowBB", " dataNB", "datSL", "defBB", "dataBW", "listsb", "divSF", " dataBP", "cacheSB", "listSI", "listBB", "nextSB", "imageSR", "relationSL", "dataGB", "valueSW", "ataBu", " dataSw", "relationSN", " dataRB", "cacheSF", "imageQB", " dataSN", "imageSN", "relationBS", " dataSL", "datSB", "relationMB", "keyBB", "jsonsb", "dateQB", "DATASB", "ataQB", "jsonSw", "joinMB", "listSF", "partialBB", "divSN", "dataBS", "reasonSW", "mapSL", "partialSL", "ataBB", "mapHB", "reasonSF", "contentSF", "windowSL", "imageBB", " dataHB", "valueSB", "contentSN", "relationBu", "windowBS", "resourceSF", "joinWB", "defGB", "dataEB", "defSB", "mapSB", "dataSquare", "DATABS", "relationSB", "partialGB", "imageSL", "dataSW", "mapBB", "divBW", "dataSN", "dateSB", "ataSA", "keyBS", "nextGB", "relSW", "ataSF", " dataSF", "dataWB", "joinSB", "joinsb", "ataSB", "imagesb", "debugRB", "cacheSA", "cachesb", "contentSR", "nextQB", "ataEB", "windowSB", "jsonSF", "imageSM", "dateBS", "debugBB", "dataSI", "relationSF", "ataSL", "defQB", " dataMB", " dataEB", " dataSW", " dataSM", "dataMB", "datMB", "relBS", "cacheBS", "ataBS", "dataBP", "contentBS", "jsonSB", "DATASW", "joinSL", "dataNB", "relationNB", "relationRB", "cacheSM", "cacheBW", " dataSquare", "dataQB", "listMB", "divNB", "dataBB", " datasb", "mapBS", " dataBB", "ataWB", "resourceSB", "debugSB", "mapSN", "imageHB", "dataSL", "relationQB", "imageSw", "mapGB", "divBB", "ataSR", "ataNB", "listSB", "dataRB", "DATASF", "dataSA", "listEB", " dataQB", "resourcesb", "datasb", "divSB", "reasonBS", "reasonSB", "relBB", "mapSF", " dataBS", "windowSF", "contentSB", "debugSF", "dataBu", "windowSN", " dataGB", "relationSquare", "nextBB", "dataSM"], "trace": ["mt", "store", "th", "stream", "style", "data", "message", "profile", "feature", "detail", "tty", "stable", "te", "list", "thread", "chain", "stack", "buffer", "test", "sequence", "network", "debug", "table", "frame", "tile", "span", "report", "range", "comment", "dump", "transform", "track", "race", "batch", "body", "address", "tr", "be", "role", "true", "ace", "se", "create", "tm", " Trace", "fake", "time", "log", "sample", "temp", "history"]}}
{"id1": "19494842", "id2": "5543349", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "label": 1, "substitutes": {"callService": ["runservice", "runQuery", "useQuery", "useservice", "useServices", " callServices", "callServices", " callQuery", "runService", "callservice", "callQuery", "useService", " callservice", "runServices"], "url": ["sl", "ssl", "gl", "b", "ls", "dl", "channel", "hl", "char", "service", "bel", "google", "web", "str", "oul", "ll", "acl", "conn", "resource", "http", "ul", "nl", "link", "browser", "ur", "URL", "sb", "file", "base", "address", "client", "pl", "get", "r", "uri", "Url", "l"], "in": ["ins", "din", "el", "isin", "en", "b", "ri", "again", "sum", "IN", "er", "inn", "con", "io", "inf", "cin", "gin", "on", "bin", "from", "it", "ic", "all", "mc", "mn", "reader", "is", "inc", "out", "check", "rin", "i", "input", "r", "iter", "inner", "oin", "conf", "l", "ill", "and", " din", "read", "In"], "inputLine": ["parseFile", "responseRow", "outputline", "contextL", " inputRow", " inputline", "parseRow", "contextline", "helloFile", "responseLINE", "outputRow", "contextLine", "helloRow", "inputRow", "inputL", "responseline", "outputLine", "helloLINE", "inputLINE", "parseLine", "InputLine", " inputL", "Inputline", "InputLINE", "helloLine", " inputFile", "InputRow", "contextRow", "parseLINE", "inputline", " inputLINE", "responseLine", "outputL", "inputFile"], "buf": ["cmd", "cf", "vec", "bed", "uf", "alph", "aux", "nm", "mk", "area", "vet", "queue", "buffer", "block", "pkg", "bar", "inv", "comm", "bh", "fam", "cv", "bg", "cap", "cam", "img", "nom", "bag", "Buff", "gor", "msg", "bu", "br", "ob", "mem", "cur", "conv", "db", "raf", "tab", "rb", "Buffer", "mu", "buff", "cb", "pb", "hung"], "answer": ["image", "answered", "onse", "reply", "poll", "value", "ask", "search", "again", "question", "channel", "archive", "cache", "message", "equ", "review", "about", "say", "ve", "sn", "form", "print", "sequence", "entry", "continue", "array", "offer", "option", "response", "argument", "replace", "install", "report", "ver", "remember", "address", "interpret", "place", "username", "version", "accept", "exit", "command", "Answer", "send", "result"]}}
{"id1": "3024970", "id2": "3536332", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToInputstream", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamtoOutputFile", "testCopy_inputStreamtoInputstream", "testCopy_inputStreamTooutputSteam", "testCopy_inputStreamtoOutputSteam", "testCopy_inputStreamTooutputStream", "testCopy_inputStreamtoOutputStream", "testCopy_inputStreamtoInputFile", "testCopy_inputStreamtoInputSteam", "testCopy_inputStreamtoInputStream", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamTooutputstream", "testCopy_inputStreamToOutputSteam", "testCopy_inputStreamToInputSteam", "testCopy_inputStreamToInputFile", "testCopy_inputStreamtoOutputstream", "testCopy_inputStreamTooutputFile"], "in": ["mi", "ins", "din", "inside", "el", "copy", "en", "scan", "p", "ini", "IN", "sin", "inn", "con", "ai", "io", "inf", "cin", "gin", "q", "mm", "ac", "bin", "xml", "from", "on", "it", "c", "ic", "inv", "init", "sql", "nin", "mc", "al", "ain", "ind", "this", "is", "h", "rin", "up", "i", "input", "source", "r", "inner", "iter", "doc", "l", "log", "isin", "im", " din", "read", "In", "n"], "baout": ["caio", "BAin", "boout", " balog", "cain", "baouts", "Baouts", "caouts", " baot", "caout", "kaend", "baend", "oaout", "caend", "BAot", "oaio", "abaot", " bain", "balog", "baio", "calog", "kaout", "bain", "BaOut", "oain", "caOut", "boio", " baend", "BAout", "Baout", "abaout", "oaOut", "boOut", "BAOut", "abaOut", " baouts", " baOut", "abain", "boin", "kain", "baOut", "kaOut", "Balog", "baot"], "out": ["ot", "cmd", "copy", "output", "OUT", "b", "gr", "co", "serv", "ex", "sum", " Out", "list", "gt", "con", "net", "io", "sys", "set", "it", "outs", "OU", "ou", "to", "all", "obj", "res", "aos", "client", "check", "up", "oss", "g", "conv", "null", "o", "t", "log", "Out", "at", "n"], "count": ["length", "ount", "z", "num", "id", "sum", "total", "N", "nb", "resp", "c", "size", "skip", "code", "nt", "amount", "current", "found", "counter", "number", "start", "ctr", "ct", "Count", "index", "read"]}}
{"id1": "10383721", "id2": "21182766", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processENTrys", "processentrys", "processentries", " processEntrs", "processEntry", "processentry", " processEntry", "processENTry", "processENTrs", "processEntries", "processentrs", " processEntries", "processEntrs", "processENTries"], "urlStr": ["uriRest", "uriStr", "URLSt", "urlSt", "urlBr", " urlRes", "URLRes", "uriRes", "pathStr", "URLBr", "UrlDec", "pathString", "uriSt", "URLDec", "uriSTR", "urlRest", "urlRes", " urlString", "urlString", "URLStr", "pathSTR", "UrlRes", " urlBr", "uriDec", " urlSTR", "UrlStr", "urlDec", "pathRes", "URLRest", "URLSTR", "UrlString", "UrlSTR", "urlSTR", "uriBr", "UrlSt", " urlRest"], "currentFlag": ["curStatus", " currentflag", "reportedflag", "curFlag", "uniqueFlag", "newFlag", "newFlags", "currentFlags", "uniqueFlags", "currentFLAG", "curFlags", "reportedFlag", "reportedFlags", "currentStatus", " currentFlags", "curflag", "reportedFLAG", "newFLAG", "reportedStatus", "currentflag", "uniqueFLAG", " currentStatus"], "key": ["k", "column", "tip", "value", "search", "KEY", "seed", "pattern", "sum", "task", "message", "char", "description", "service", "Key", "rand", "token", "path", "chain", "member", "q", "my", "set", "entry", "pkg", "it", "by", "step", "ke", "reason", "ey", "label", "ek", "tag", "item", "prefix", "file", "base", "y", "hash", "name", "keys", "template", "sk", "filename", "default", "info", "index"], "postList": ["postMap", "postlist", "entrylist", "postGroup", " postMap", "feedMap", " postGroup", "feedlist", "feedList", " postlist", "feedGroup", "entryMap", "entryGroup"], "url": ["f", "loc", "u", "sl", "ssl", "org", "b", "https", "atl", "location", "ls", "dl", "il", "web", "str", "ll", "conn", "au", "loader", "http", "rl", "nl", "link", "browser", "ur", "impl", "URL", "document", "sb", "address", "uc", "name", "open", "get", "r", "uri", "Url", "l", "abs", "t", "log"], "connection": ["context", "server", "established", "position", "location", "channel", "language", "Connection", "connect", "relation", "communication", "description", "con", "web", "pointer", "io", "database", "network", "conn", "entry", "application", "wrapper", "c", "resource", "http", "writer", "response", "socket", "to", "creator", "session", "document", "operation", "directory", "reference", "open", "ion", "client", "number", "character", "uri", "close", "statement", "reset", "created", "creation", "condition", "opening", " Connection", "command", "information"], "reader": ["context", "stream", "data", "message", "er", "iterator", "driver", "io", "handler", "buffer", "parser", "entry", "in", "loader", "resource", "writer", "runner", "response", "reading", "ro", "document", "file", "body", "Reader", "rar", "client", "feed", "r", "input", "iter", "inner", "ner", "row", "read"], "builder": ["operator", "built", "b", "bo", "builders", "web", "handler", "buffer", "parser", "block", "loader", "sf", "layer", " builders", "building", "writer", "bridge", "bar", "control", "creator", "aker", "build", "base", "BU", "settings", "good", "full", "Builder", "bus", "ner", "manager", "hub", "row", "adder", "uild", "outer"], "doc": ["div", "dr", "Doc", "og", "git", "ree", "data", "dec", "ml", "city", "tree", "m", "xml", "man", "pub", "writer", "DOC", "dc", "dir", "Document", "document", "file", "res", "md", "dom", "body", "unit", "def", "h", "graph", "g", "db", "study", "json", "tx", "t", "html", "d", "result"], "root": ["div", "record", "rt", "node", "empty", "has", "ro", "rocket", "obj", "res", "rap", "rar", "results", "null", "row", "roots", "local", "mounted", "host", "scope", "server", "instance", "owner", "tree", "m", "entry", "zero", "or", "rank", "table", "init", "roid", "document", "body", "unit", "element", "start", "default", "remote", "result", "loc", "cover", "original", "container", "data", "oot", "self", "er", " Root", "all", "Root", "base", "parent", "right", "head", "os", "mr", "wrap", "ree", "feature", "area", "box", "central", "xml", "collection", "this", "role", "r", "primary", "first"], "grNamespace": ["GRnamespace", "GRNameset", "grNamespaces", "grNamepaces", "grnamespaces", "GRNamesSpace", "grNameset", "grNamepace", "GrNameset", "grNamesSpace", "grNameet", "GRnamespaces", "grNspace", "GrNamespace", "GRnameset", "grNameSpace", "GrNamepace", "grNset", "GrNameet", "GRNamespaces", "grnameset", "GRnamesSpace", "GrNamesSpace", "grnamespace", "grnamesSpace", "GrNameSpace", "grNsSpace", "GRNamespace"], "namespace": ["mspace", "wordsSpace", "Feed", "Namesistence", "termspaced", "namescore", "nameset", "Ent", " namespaced", "mscore", "namepace", "namespaces", "termsspace", "mspaced", "msacing", "nameSpace", "Nameset", "membersace", "context", "nameace", " namesistence", "namespaced", "New", "nspaced", "Namesspace", "space", "ameship", "amesistence", "namesistence", "nsspace", "Document", "spaced", "termspace", " namesace", "Namespace", "namesACE", "amesspace", "termsSpace", "wordsistence", "Raw", "amesACE", "Entry", "amespace", "nsSpace", " namesACE", "termsistence", "membersSpace", "membership", "namepaces", "namesacing", " namesSpace", "s", "namesSpace", "Secure", "St", "score", " nameship", "sacing", "nameet", "Namespaces", "NamesSpace", "memberspace", " nameset", "wordsACE", "mascore", "amesSpace", "maspace", "maspaced", "wordspace", "namesace", "membersspace", "E", " namesspace", "_", "namesspace", "nspace", " namespaces", "masacing", "nameistence", "nameship"], "newflag": ["nextflag", "newflags", "nextFlag", "newstatus", "continueflag", "continuestatus", "nextflags", "Newflags", "Newflag", "nextstatus", "NewFlag", "continueFlag", "newFlag", "Newstatus", "continueflags"], "title": ["tip", "value", "header", "displayText", "message", "format", "description", "Title", "phrase", "subject", "term", "lead", "text", "status", "itle", "published", "label", "prefix", "topic", "file", "name", "template", "filename", "type", "desc", "summary", "t"], "subTitle": ["shortName", "SubName", "shortText", "subtitle", " subName", "subText", "SubTitle", " subtitle", "Subtitle", "SubText", "shortTitle", "subName", " subText", "shorttitle"], "entryList": ["entrylist", "EntrySet", "ryArray", "entrySet", "postSet", "EntryList", " entryArray", "postlist", "rySet", "entArray", " entryL", "entryArray", "ryL", "entlist", "entList", "ryList", "Entrylist", "entryL", "rylist", "entL", " entrylist"], "sdf": ["ssfd", "SDF", "sfd", "sde", " sDF", "Sdf", " sfx", "ssfx", "ssdd", "psde", "dsdd", "dsfx", "ssdf", "psdef", "Sdef", "sdd", "dsfd", "sdef", " sde", " sfd", "dsdf", "sfx", "psDF", "sDF", " sdd", "Sde", "psdf", " sdef"], "e": ["f", "et", "el", "u", "entity", "pe", "en", "exp", "p", "v", "ep", "ea", "ec", "er", "fe", "te", "ele", "ge", "ent", "ve", "le", "ed", "E", "eg", "entry", "it", "c", "ei", "a", "ef", "de", "x", "eb", "ie", "Element", "y", "be", "event", "element", "ue", "se", "r", "i", "oe", "es", "l", "o", "t", "ce", "eeee", "end", "eur", "ee"], "post": ["rel", "object", "record", "store", "exp", "p", "person", "admin", "od", "process", "form", "print", "test", "pre", "pt", "set", "man", "entry", "pp", "Post", "mod", "follow", "pub", "commit", "status", "ps", "add", "link", "read", "skip", "page", "comment", "prefix", "pg", "po", "op", "wp", "put", "word", "after", "def", "check", "write", "posts", "get", "POST", "feed", "pass", "create", "ost", "row", "t", "end", "log", "info", "pod", "save", "next", "draw", "local"], "content": ["object", "ontent", "entity", "value", "header", "data", "message", "Content", "format", "description", "path", "section", "text", "status", "link", "comment", "label", "document", "layout", "child", "code", "body", "name", "template", "source", "media"]}}
{"id1": "20414923", "id2": "4461350", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 1, "substitutes": {"deleteBitstreamInfo": ["deletebitStreamInformation", "deleteBitmapInfo", "deleteBitStreamInfo", "deleteBitlogINFO", "deleteBitstreamInf", "deleteBitStreamInformation", "deleteBitmapInformation", "deleteBitlogInfo", "deletebitstreamInformation", "deletebitstreamInf", "deletebitstreamInfo", "deletebitstreamINFO", "deletebitStreamINFO", "deletebitStreamInf", "deleteBitstreamInformation", "deletebitStreamInfo", "deleteBitlogInf", "deleteBitlogInformation", "deleteBitStreamInf", "deleteBitmapInf", "deleteBitstreamINFO", "deleteBitmapINFO", "deleteBitStreamINFO"], "id": ["k", "num", "record", "uid", "p", "Id", "data", "kid", "mid", " fid", "bid", "ref", "addr", "sequence", "rid", "entry", "it", "ident", "status", "table", "size", "and", "aid", "key", "oid", "item", "connection", "sid", "ad", "md", "obj", "parent", "event", "pid", "ID", "name", "hash", "no", "vid", "ide", "number", "i", "one", "db", "version", "type", "url", "t", "ids", "d", "info", "index", "result", "n"], "conn": ["cn", "ann", "bind", "cmd", "exec", "cs", "Connection", "connect", "nc", "enc", "cc", "con", "ait", "addr", "ns", "ctx", "pt", "col", "comm", "ca", "yn", "gate", "session", "pg", "sql", "connection", "obj", "Conn", "res", "gc", "mc", "cm", "nt", "pool", "ch", "cp", "open", "client", "cur", "close", "db", "conf", "ct", "ws", "handle"], "stmt": [" stMT", " stmm", "Stem", "stgr", "Stmb", "strgr", "stMT", "istmr", "strmb", "istmm", "strtx", "tmm", "StMT", "strm", "strmt", "stmb", "Stpt", "stmm", "tmt", " stmr", "strem", "stpt", "ctnt", "stm", "stmp", "Stm", " stnt", " stpt", " stgr", " stem", "tmr", " stmp", "Stgr", " sttx", " stmb", " stm", "Sttx", "stmr", "Stmp", "sttx", "tm", "istm", "stnt", "Stnt", "ctpt", "ctmt", "Stmt", "ctMT", "strmp", "istmt", "stem"], "numDeleted": ["numDrolete", "NUMDeleted", "numDEoved", "numDuued", "numdelected", "numDElete", "numdeleted", "numDElected", "numDEanted", "numDroanted", "numDesmitted", "numDecletes", "numDeslected", "NUMDelected", "numDEined", "numDellected", "numDeanted", "umDecleted", "numDEared", "numDelared", "numDuoved", "NUMDEared", "numDroleted", "numExleted", "umDesleted", "numDEued", "numDeclet", "numDumitted", "numDeined", "numDEletes", "numDeslated", "umDeclet", "numDeclected", "NUMDeared", "numDelete", "numDuarted", "numExued", "nomDEued", "numDecleted", "umDesoved", "numDelated", "nomDeleted", "umDeanted", "numExoved", "numDemitted", "numTeleted", "umDeleted", "numDeclete", "numUnlete", " numDesmitted", "nomDEined", "numUnleted", "numUnoved", "nomDEleted", "numdeoved", "numDuined", "umDecanted", "numExined", "numUnlected", "numDelletes", "numDrolet", " numDemitted", "numDecared", "umDeoved", "NUMDEletes", "numDulated", "NUMDeletes", "numDeletes", "numDelected", " numDesleted", "numDelleted", "numDesleted", "numDeslete", "umDelet", "nomDeued", "numDelet", " numDeslated", "numTelated", " numDelated", "nomDEoved", " numDesarted", "umDeclete", "NUMDEleted", "numDuleted", "umDeslected", "numDecanted", "numdelete", "NUMDElected", "nomDeoved", "umDeslete", "numDEleted", "numDeued", "numDeared", "numDearted", "nomDeined", "numDElet", "numDesarted", "numTemitted", "numDeoved", " numDearted", "numTearted", "numDesoved", "umDelected", "umDelete"]}}
{"id1": "5148212", "id2": "411595", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyImage", "copyfile", "copfile", "clonefile", "copFile", "copyImage", "copImage", " copyfile", "cloneImage", "cloneFile"], "src": ["loc", "iv", "rel", "ins", "rc", "rs", "ls", "sc", "usr", "path", "sys", "attr", "ource", "str", "st", "sq", "from", "pkg", "sec", "ident", "sf", "inst", "sit", "ser", "req", "ur", "usc", "urg", "img", "init", "obj", "file", "ie", "inc", "txt", "ipl", "source", "input", "cur", "syn", "iter", "lit", "filename", "ost", "start", "url", "sr", "sur", "Source", "rest"], "dest": ["port", "gt", "usr", "way", "target", "path", "ident", "tom", "vol", "sit", "de", "fr", "them", "orig", "nom", "obj", "file", "sp", "gov", "comb", "cat", "null", "decl", "d", "min", "sup", "mk", "fe", "st", "spec", "to", "img", "tr", "end", "temp", "result", "loc", "ord", "v", "Dest", "nd", "data", "nw", "test", "etc", "dist", "dir", "coord", "est", "parent", "opt", "comp", "doc", "source", "foreign", "lit", "desc", "prop", "rest", "master", "deg", "crit", "output", "dat", "tif", "delete", "origin", "req", "trans", "des", "this", "good", "iter", "cont"], "bufSize": ["bufLength", "fontInfo", " bufInfo", "fontsize", "bufSIZE", "bufferSIZE", "queueLength", "bufLen", "buffersize", "ufInfo", "ufSize", " bufSIZE", "bufInfo", "BufferCount", "bufferLength", "fontSIZE", "boxSIZE", "queueSize", "ufSIZE", "boxSize", "bufferCount", "queueCount", "BufferLen", "queueLen", "bufsize", "bufCount", "fontSize", "ufsize", "bufferLen", "BufferLength", "BufferSize", " bufsize", "boxsize", "bufferSize"], "force": ["update", "pdf", " confirm", "cmd", "quote", "forced", "flag", "seed", "yes", "fast", "allow", "external", "sync", "like", "secure", "e", "require", "enable", "print", "form", "rule", "error", "frame", "reason", "replace", "apply", "vert", "dirty", "fx", "always", "auto", " override", "only", "cp", "open", "ghost", "ace", "append", "write", "forge", "raise", "Force", "start", "fail", "default", "flush", "forcing", "ce", "remote", " enforce", "use", "send", "ignore", "func", "handle"], "f": ["fs", "b", "cf", "p", "bf", "v", "exp", "lf", "uf", "fm", "fo", "elf", "s", "e", "inf", "m", "sf", "c", "part", "ef", "fr", "dir", "xf", "file", "df", "of", "fac", "fp", "fi", "h", "r", "g", "conf", "l", "ct", "t", "rf", "F", "d", "w", "fc"], "buffer": ["length", "binary", "cache", "message", "window", "char", "buf", "queue", "sequence", "stack", "print", "database", "block", "phrase", "text", "table", "frame", "bar", "stroke", "paste", "attribute", "shape", "document", "batch", "library", "base", "word", "history", "line", "write", "template", "memory", "number", "append", "iter", "row", "variable", "Buffer", "parse", "buff", "filter", "sample", "password", "command", "index", "temp", "result"], "read": ["length", "readable", "bind", "need", "pe", "record", "en", "stream", "before", "count", "select", "char", "allow", "like", "index", "gets", "print", "Read", "q", "give", "str", "valid", "raw", "it", "reads", "size", "load", "add", "ke", "fill", "skip", "reading", "READ", "range", "key", "shape", "query", "run", "take", "reader", "ind", "word", "open", " Read", "height", "check", "write", "mem", "get", "len", "input", "seek", "find", "iter", "i", "feed", "start", "ip", "parse", "time", "t", "log", "end", "info", "hello", "im", "w", "send"], "in": ["image", "mi", "ins", "inside", "din", "irm", "en", "ir", "ex", "ini", "IN", "inn", "con", "ln", "net", "io", "inf", "gin", "cin", "mm", "on", "bin", "m", "from", "ar", "it", "ic", "or", "by", "to", "init", "ma", "al", "ie", "ain", "per", "ind", "is", "inc", "client", "up", "rin", "get", "i", "input", "source", "iter", "inner", "internal", "oin", "l", "isin", "im", "local", "In"], "out": ["cn", "ot", "output", "OUT", "co", "b", "v", "ex", "cache", "list", "con", "ln", "net", "io", "ne", "user", "sys", "print", "on", "bin", "conn", "it", "outs", "or", "writer", "OU", "ou", "note", "to", "obj", "file", "aos", "nt", "parent", "cos", "ion", "client", "write", "can", "up", "full", "oss", "one", "oe", "conv", "os", "inner", "flush", "not", "o", "t", "end", "Out", "at", "outer", "n"]}}
{"id1": "8164056", "id2": "21489105", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"encode": ["enode", "Enode", " enccode", " encoder", "enoder", "genoder", "Enenc", " encenc", "Enoder", "enenc", "genode", "genenc", "gencode", "Encode"], "str": ["arr", "b", "v", "p", "STR", "data", "enc", "char", "Str", "string", "e", "print", "m", "strings", "st", "text", "c", "it", "comm", "spec", "obj", "res", "sp", "msg", "wr", "tr", "name", "this", "txt", "br", "r", "input", "conv", "ctr", "coll", "oct", "t", "w", "n"], "buf": ["cmd", "av", "output", "var", "b", "cf", "bn", "uf", "bo", "aux", "bp", "que", "foo", "box", "queue", "buffer", "block", "pkg", "bar", "aer", "bh", "cv", "bg", "cap", "bag", "obj", "Buff", "batch", "tmp", "msg", "pool", "txt", "ob", "br", "agg", "cur", "iter", "proc", "db", "bc", "rb", "Buffer", "mu", "buff", "printf", "next", "np", "bound", "cb", "temp", "pb", "hung"], "md5": [" Mdct", "md45", "dig3", "md8", "mdct", "dd5", " md8", " MD3", " MDlet", "MD12", "MD2", "dd3", "md12", "dig45", "mdlet", "dd45", "dig12", "md3", "dig5", "dd8", " md2", "MD5", "dig8", " md45", " mdlet", " Mdlet", " MDct", " mdct", "MD3", " md3", " Md3", " MD5", " md12", " Md5", "dig2", "md2"], "bytes": ["ashes", "iers", "terms", "xs", "words", "binary", "values", "b", "bs", "bits", "bes", "classes", "clips", " tmp", "vals", " chunks", "bles", "gets", "files", "xy", "Bytes", "outs", "js", "gs", "bps", "frames", "bis", " b", "pieces", "cb", "seconds", "tes", "tmp", "vs", "fixes", " buffers", "services", "gb", " slices", "parts", "steps", "pointers", "ings", "es", "pages", "sites", "fps", "its", "names", " pixels", "blocks", "ios"], "i": ["cli", "mi", "u", "b", "id", "pi", "v", "ix", "ex", "ini", "us", "si", "ii", "ai", "io", "chain", "bi", "n", "q", "m", "sim", "me", "in", "ki", "iu", "ic", "multi", "c", "it", "li", "major", "ti", "a", "j", "ij", "xi", "init", "key", "x", "hi", "ji", "batch", "ie", "phi", "y", "ind", "is", "ui", "gu", "uri", "conv", "di", "gi", "json", "ci", "ip", "ski", "\u0438", "info", "qi", "point", "im", "index", "I"], "s": ["fs", "f", "z", "sl", "b", "rs", "v", "p", "ls", "string", "gets", "S", "ns", "sw", "ss", "set", "sq", "sf", "js", "gs", "ds", "single", "join", "j", "sv", "ts", "spec", "sql", "sb", "sol", "sp", "y", "is", "txt", "h", "se", "r", "g", "conv", "os", "l", "abs", "hs", "t", "ps", "n"]}}
{"id1": "5125848", "id2": "411595", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"combineJs": ["CombineJs", "combINEJs", "combinateJs", "ComboseJs", "combinejs", "ComboseLink", "combINELink", "combineJS", "CombineJS", "combinateJS", "combINEJS", "ComboseJS", "combinatejs", "combineLink", "CombineLink", "combosejs", "combINEjs", "comboseJs", "Combinejs", "combinateLink", "comboseJS", "Combosejs", "comboseLink"], "base": ["host", " based", "server", "domain", "b", "id", "data", "api", "bas", "bid", "origin", "buffer", "absolute", "from", " basis", "re", "bottom", "based", "page", "Base", "prefix", "file", "address", " bases", "relative", " Base", "template", "source", "uri", "db", "reset", "ase", "start", "root", "site", "bound", "local"], "linkJs": ["LinkJS", "LinkJs", " linkScript", "linkjs", " linkLinks", "Linkjs", "linkedScript", "inkTags", "linkScript", "inkLinks", "inkScript", " linkTags", " linkJS", "LinkTags", "linkedLinks", "inkjs", "inkJS", "linkTags", "inkJs", "linkedJS", " linkjs", "linkLinks", "linkedJs", "linkJS"], "newFiles": ["newDocuments", "nextFiles", "newLinks", "newfiles", "linkFiles", "nextfiles", " newLinks", "nextDocuments", " newDocuments", "linkDocuments", "linkLinks", "nextLinks", " newfiles", "linkfiles"], "dir": ["div", "rel", " Dir", "folder", "loc", "fs", "dd", "dr", "id", " d", "ir", "DB", "dl", "mk", "disk", "area", "diff", "ref", "addr", "sys", "local", "tar", " directory", "pkg", "mod", "vol", "md", "file", "DIR", "auto", "tmp", "directory", "dm", "zip", "lock", "good", "def", "dep", "out", "doc", "done", "created", "wd", "db", "di", "manager", "cd", "desc", "Dir", "root", "fd", "temp", "d", "lib", "module"], "name": [" bar", " logger", " cleaner", " start", " os", " foo", " scanner", " vm", " tmp", " karma", " msg", " report", " dummy", " info", " self", " filename", " b", " manager", " parser", " browser", " prefix", " err", " rebuild", " names", " str", " db", " res", " loader", " log"], "minDir": [" minJar", "minDb", "smallDb", "miniTier", "MinNet", "smallDir", " minPref", "minTrans", "mainDir", "sortDir", "minNet", " minTier", "minuteDir", "skinLoc", " minNet", "smallFile", "miniDir", "MinFile", " minTrans", "skinDb", "minuteDar", "miniTrans", "mainLoc", "thinTier", "minPref", "MinDir", "minTier", "thinJar", "maindir", "thinDir", "minFile", " minDar", " minRel", "miniJar", "minRel", "minDar", "minuteRel", "minJar", " minFile", "smallLoc", "mainDb", "minutePref", "thinTrans", "smallNet", "sortDar", "mindir", "smalldir", "sortRel", "skinDir", "skindir", "minLoc", "sortPref"], "combineFile": ["coordineWriter", "comboiceMessage", "combINESet", "combinefile", "cominateMessage", "cominateFile", "combineSet", "coordINEFile", "comineMessage", "cominateEmail", "combineEmail", "combinerFile", "combosefile", "cominatefile", "combinSet", "comineFile", "combinerfile", "cominefile", "comboseWriter", "combinateFile", "comineEmail", "combinatefile", "combINEWriter", "combineMessage", "comboiceFile", "combinfile", "coordINESet", "comboseSet", "combINEFile", "comboiceEmail", "combinerEmail", "combinWriter", "coordINEfile", "coordinefile", "combINEfile", "comboseFile", "comboicefile", "coordINEWriter", "coordineFile", "combinateEmail", "combinFile", "combinerMessage", "coordineSet", "combinateMessage"], "concatFile": ["conCatFilename", "convertTable", "convertFilename", "concatDir", "concapFiles", "conatfile", "concFilename", "conCatDir", "concatTable", "concapfile", "covertTable", "conCatFile", "comcDir", "comcatDir", "conatFile", "cocatTable", "comcatFile", "covertFile", "covertfile", "cocatfile", "comcFile", "comcatFilename", "convertfile", "conatFiles", "concatfile", "concatFiles", "covertFiles", "concapFile", "conatTable", "concapTable", "concDir", "convertDir", "convertFiles", "comcFilename", "cocatFile", "concatFilename", "concFile", "cocatFiles", "convertFile"], "combineWriter": ["combineWrite", "combieFile", "declineReader", "combineReader", "combieReader", "combinateReader", "Combinewriter", "combinateWrite", "combinewriter", "combinateCounter", "combenCounter", "declinateFile", "combieWrite", "ComboseWriter", "declineFile", "combenwriter", "comboseWriter", "combinateFile", "ComboseCounter", "declinateReader", "combineCounter", "declinateWriter", "CombineWriter", "combenWriter", "comboseReader", "declineWriter", "comboseWrite", "Combosewriter", "comboseCounter", "comboseFile", "combosewriter", "declineWrite", "declinateWrite", "CombineCounter", "combinatewriter", "combinateWriter", "combieWriter", "combenWrite", "CombineWrite", "ComboseWrite"], "concatWriter": ["conatReader", "convertWrite", "conatWriter", "cocatWrite", "comvertWriter", "comvertReader", "conatFile", "comcatFile", "concatsReader", "convertReader", "conatWrite", "coatFile", "cocatWriter", "convertWriter", "cocatReader", "comvertFile", "concatsWrite", "coatWrite", "comcatReader", "comvertWrite", "concatsFile", "cocatFile", "concatsWriter", "concatReader", "coatReader", "comcatWriter", "coatWriter", "comcatWrite", "concatWrite", "convertFile"], "fails": ["fils", " focks", "frailing", "Failing", "focks", "facails", "failing", "facailed", "frailed", "mailing", "ifailed", "malls", "lailed", "mailed", "facocks", "Fails", "ifocks", "frils", "Failed", "mocks", "failed", "facailing", "ifails", "Fils", " failed", "frails", "lails", "lailing", "falls", "mails", "lalls", "lils", " falls", "ifailing", " failing"], "link": ["loc", "node", "mark", "match", "script", "linked", "task", "self", "relation", "ln", "ink", "links", "embed", "set", "push", "follow", "c", "li", "load", "map", "add", "inline", "skip", "child", "share", "code", "address", "open", "line", "check", "display", "Link", "source", "close", "l", "log", "remote"], "path": ["image", "loc", "id", "style", "p", "location", "match", "pattern", "data", "format", "string", "ref", "src", "str", "entry", "PATH", "text", "resource", "join", "alias", "prefix", "key", "file", "hex", "relative", "template", "full", "source", "input", "uri", "route", "prop", "Path", "root", "href", "kind", "ath"], "url": ["loc", "host", "rel", "sl", "ssl", "gl", "id", "location", "ls", "il", "hl", "char", "string", "web", "ref", "lr", "addr", "str", "ll", "request", "resource", "http", "li", "ul", "nl", "browser", "ur", "URL", "build", "address", "this", "mount", "mail", "get", "source", "r", "uri", "Url", "l", "abs", "null", "href", "html"], "inputStream": ["InputStyle", "InputTime", " inputSet", "InputSteam", "outputStyle", "inSet", "outputstream", "inTime", " inputstream", " inputSteam", "inStream", "inputSteam", "inputstream", "Inputstream", "instream", "inputStyle", " inputStyle", "InputSet", "InputStream", "outputSteam", "inputSet", "inputTime", " inputTime"], "jsFile": ["JsPath", "jFile", "jsPath", "cssFilename", "cssfile", "jPath", " jsTable", "cssTable", "jName", " jsPath", "javascriptPath", " jsName", "jsfile", "cssFile", "javascriptName", "Jsfile", "javascriptFile", "jsFilename", "jFilename", "JsFilename", " jsfile", "javascriptFilename", "javascriptfile", "jsName", "cssPath", "JsFile", "jsTable", " jsFilename", "javascriptTable"], "fileName": ["filePath", "getPath", "filename", "FileHash", "getHash", " fileHash", "fileHash", "FilePath", "FileName", "Filename", "getname", "getName", " filename", " filePath"], "outputStream": [" outputSteam", " outputStyle", "OutputSet", "Outputstream", " outputForm", "outputStyle", "inputForm", "OutputStyle", "outputstream", "OutputStream", "inputSteam", "inputstream", " outputstream", "OutputSteam", "OutputForm", "inputStyle", "writestream", "writeSet", "outputSet", "writeStream", "outputSteam", "outputForm", " outputSet", "writeSteam"], "first": ["initial", "top", "same", "important", "self", "fast", "each", "index", "then", "front", "sort", "stack", "real", "valid", "continue", "st", "natural", "quick", "must", "all", "seconds", "send", "only", "master", "latest", "false", "current", "true", "open", "ind", "last", "unique", "start", "default", "success", "second", "fourth", "next", "prev", "First", "third", "primary", "now"], "reader": ["core", "context", "mr", "stream", "rc", "rator", "data", "er", "iterator", "driver", "io", "handler", "buffer", "parser", "wrapper", "loader", "layer", "writer", "rl", "resource", "http", "runner", "ro", "builder", "file", "rr", "rar", "Reader", "this", "ner", "r", "input", "inner", "rer", "row", "read", "ocr"], "jsCompressor": ["jsCompression", "cssComposer", "jsCompiler", "jscomposer", "jscompiler", "jsComposer", "jsRepressor", "jsBuffoser", "cssCompressor", "cssRepressor", "jsBuffiler", "jsBuffressor", "jscompressor", "cssCompiler", "cssCompression", "jsRepiler", "jsReposer", "cssRepiler", "cssRepression", "jsRepression", "jscompression", "cssReposer", "jsBuffression"], "s": ["fs", "ats", "xs", "words", "cs", "ls", "ens", "pers", "ers", "S", "ns", "ms", "ss", "gs", "ds", "ts", "tes", "eds", "y", "ies", "less", "is", "full", "details", "parts", "ings", "es", "os", "l", "lines", "hs", "t", "ids", "qs", "tags", "ps"], "s1": ["ls1", " s3", "ls0", "pers1", "esFirst", "idFirst", "s0", "ys0", "s81", "ls3", "id2", "id1", " s81", "es2", "es9", "ls81", "ys81", "ps1", "s9", "ps0", "pers0", "es1", "s3", "ys3", "sFirst", "id9", " s0", "ys1"], "i": ["ia", "mi", "id", "ri", "p", "pi", "v", "ity", "ii", "us", "ai", "iti", "io", "bi", "um", "iat", "iu", "it", "ic", "li", "j", "ori", "ie", "y", "ch", "is", "ion", "ui", "di", "ig", "ip", "ci", "ati", "ifier", "o", "im", "oi", "I"], "s2": ["s02", "sSecond", "tes2", "es02", "SSecond", "S02", "gs2", "ss22", "s22", "z02", "msTwo", "z2", "tesTwo", "gsSecond", "Stwo", "S2", "ss2", "ssTwo", "gs02", "es2", "tes1", "zSecond", "stwo", "ms2", "gstwo", "ztwo", "es1", "tes02", "ms22", "esTwo", "ms02", "sTwo", "ss02"], "i1": ["e4", "e2", "it01", "eOne", "itOne", "p1", "it2", "i0", "p01", "a1", "it0", "aOne", "i01", "a2", "pOne", "o1", "a01", "p2", "i2", "it1", "p4", "it4", "o0", "o4", "e1", "oOne", "p0", "i4", "iOne"]}}
{"id1": "1156851", "id2": "11562165", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"runWeb": ["runHttp", " runHttp", "processSite", "initSite", "processHttp", "initHttp", "initWeb", "processWeb", "runSite", " runSite", " runweb", "runweb", "processweb", "initweb"], "beginURL": ["endURL", "beginHTML", "useUrl", " beginALL", "createUrl", "wardUR", "endUrl", "useHTML", "BeginALL", "startURI", "BeginUR", "beginURI", "createURL", "useURI", "BeginUrl", " beginLocation", "useURL", " beginURI", "beginUrl", "createURI", "wardURL", "startURL", "createHTML", "startLocation", "BeginURI", "wardUrl", "beginLocation", "beginALL", "endUR", "startALL", "BeginURL", "BeginLocation", "beginUR", "BeginHTML"], "contextRoot": ["Contextroot", "resourcePath", "ctxParent", "ContextRoot", "ContextParent", "resourceRoot", "resourceURL", " contextBase", "resourceData", "resourceBase", " contextBox", " contextHome", "contextData", "ContextHome", "contextParent", "contextPath", "ContextBox", "ctxBase", " contextroot", "ctxHome", "contextHome", "ContextBase", "ctxBox", "contextroot", "contextURL", "ContextPath", " contextURL", "ContextURL", "contextBox", "ctxRoot", " contextPath", " contextData", "resourceroot", "ContextData", "ctxPath", "contextBase", " contextParent"], "pageURI": ["pageUR", "puri", "PagePath", "requestFile", "Pageuri", "pageName", " pageName", "pagePath", "requestUR", "pName", "PageURI", "requestPath", "pageURL", "requestURI", "PageFile", " pageUR", "pageuri", "pURI", "PageURL", " pageURL", " pageuri", "pageFile", "PageName", "pURL", " pageFile", "PageUR", " pagePath"], "vtURLs": ["VTURLS", "vtHTTPS", "vtSRls", "vtURers", "VTURLses", "vtTLList", "vtHTTPs", "VTURers", "VTURLls", "vtURLList", "voltTLList", "vtURLS", "vtURS", "vtURa", "VTURls", "vtURses", "voltURLls", "vtURLers", "vtSRList", "vturls", "vtOLls", "vtHTTPa", "vtHTTPls", "vtURls", "vturlS", "vturlls", "voltURLs", "VTURLs", "vturla", "VTURS", "vtURs", "vtTLs", "vtURList", "voltURLList", "vtULS", "vtURLses", "voltTLs", "vtGETs", "vtGETers", "vtSRs", "vtULs", "vtOLers", "VTURa", "vtURLa", "vtGETses", "VTURLers", "VTURLa", "vtGETls", "vtURLls", "vtOLs", "vtOLses", "VTURses", "VTURs", "vtTLls", "voltTLls", "vtULls"], "vtRobots": ["vtHuborts", "vsRobots", "vtHubugs", "virtReplots", "vetRobots", "vtPlugots", "vetRubows", "vsHubotos", "vetRobows", "vtUbugs", "vtPlugugs", "virtRoborts", "vtCapotos", "virtRobots", "vtUbotos", "vtReplops", "vsRobotos", "vsRobbs", "vtRobugs", "vtRoboles", "vtCapot", "vtReplots", "vtTabots", "virtReploles", "vtHubbs", "vtHubotos", "vtLegot", "vtLegotos", "vtCapots", "vtRobops", "vtHubops", "vtTabops", "vetRobot", "vtHubots", "vtTaborts", "vtPlugbs", "virtRobops", "vetRubotos", "vtPlugotos", "vtCapows", "vetRobotos", "vtReploles", "vetRubot", "vtUbbs", "vtTaboles", "vtRobotos", "vsHubots", "vtRobot", "vsRobugs", "vtRubows", "vetRubots", "vtUbots", "virtReplops", "vtHuboles", "virtRoboles", "vtRobbs", "vtRobows", "vtReplorts", "vtRubots", "virtReplorts", "vsHubbs", "vtRoborts", "vtRubot", "vsHubugs", "vtLegots", "vtRubotos", "vtLegows"], "indexer": ["IndexReader", "documente", "Indexe", "Indexator", "indexe", "indexor", " indexener", " indexe", "documenter", "indexator", "documentReader", "indexner", "Indexener", "Indexner", "documentener", "Indexor", "mixator", "mixner", "mixor", "searchner", "searchor", " indexReader", "Indexer", "searcher", "indexener", "mixer", "indexReader", "searchator"], "indexDoc": [" indexDocument", "indexDocument", " IndexPage", " Indexdoc", "IndexDoc", " IndexDocument", "Indexdoc", " indexdoc", "indexdoc", " IndexDoc", "indexPage", "IndexDocument", "IndexPage", " indexPage"], "sxURL": ["SxeURI", "spxUR", "sxeURL", "sxyUR", "sxUrl", " sxeUR", "sxIL", "sixBL", "sfxBL", "desxUrl", " sfxELF", "sfxURI", "sxeBL", "sxeIL", " sxEL", "sxxURL", " sXUrl", "sXEL", " sxeIL", "sxELF", "desXUR", "sxUSER", "SxUrl", "sfxID", "SxeBL", "sXALL", " sXUR", " sxUrl", "sfxEL", "desxALL", "sxfEL", "sxfALL", "sxyURL", "sixID", "desxURL", " sxUR", "SxeURL", "SxID", "sfxPORT", "spxUrl", "sxfURI", "sxeID", "desxUR", "SxeID", "SxURI", "sfxUR", "sXELF", " sxIL", "SxUR", "sxxIL", "sfxUSER", "sxALL", " sfxURL", " sXURL", "sxsURL", "sixURL", "sfxIL", "sXUR", "sxBL", "SXUrl", "sXURI", "desXUrl", " sxeUrl", "sxeURI", " sfxUR", "sxfUrl", "SxBL", "sxPORT", "sxsUSER", "sxePORT", "desXALL", "sxUR", "sxyUrl", "sfxURL", "desXURL", "sxsUR", "spxURL", "sXURL", "sxxALL", "sxxUR", "sxfUR", " sxELF", " sXEL", "sfxUrl", "sxxUrl", "SXURL", " sfxUrl", " sxeURL", "spxELF", "sxID", "sxsUrl", "SXURI", "sfxELF", "sxfURL", "sxEL", "sixURI", "SxURL", "SXUR", "sxeUrl", "sXUSER", "sXUrl", "sxURI", "sxyPORT", "sxeUR"], "sxRobotURL": ["sxRoboteURL", "sxRobotSTR", "sxRobOTURL", "sxRoboSTR", "sxRoboteSTR", "sxRoboteUR", "sxLegoURL", "sxRoboUrl", "sxroboteURL", "sxLegotUR", "sxRobosSTR", "sxLegoteSTR", "sxrobotURI", "sxRobosUrl", "sxRobottSP", "sxRoboteUrl", "sxRoboySP", "sxroboteUR", "sxRobotUrl", "sxRoboURL", "sxRobotePATH", "sxLegoteUR", "sxrobotUrl", "sxroboteUrl", "sxRoboURI", "sxRobOTUR", "sxroboteURI", "sxNobosURL", "sxRoboteURI", "sxRobotSP", "sxRobosUR", "sxRoboyURL", "sxNobotUrl", "sxRobrotUrl", "sxLegotURL", "sxLegoteUrl", "sxrobotURL", "sxRobottUrl", "sxRoboPATH", "sxLegoPATH", "sxRobOTUrl", "sxRobotURI", "sxRobrotURL", "sxNobosHTTP", "sxRobosHTTP", "sxNobotSP", "sxRobottHTTP", "sxRobosURL", "sxRobrotUR", "sxRoboUR", "sxRobotHTTP", "sxrobotUR", "sxLegotUrl", "sxRobotPATH", "sxLegoUrl", "sxLegotPATH", "sxNobotURL", "sxRobrotPATH", "sxRobotUR", "sxLegoteURL", "sxRobosSP", "sxRobottURL", "sxRoboyHTTP", "sxLegoUR", "sxLegotSTR", "sxRobOTURI", "sxRoboyUrl", "sxNobosUrl", "sxNobotHTTP", "sxNobosSP"], "pd": ["dd", "PF", "p", "bf", "ht", "dt", " md", "dl", "dh", " dd", "vd", "Parser", "pm", "parser", "pps", "dp", "pp", " cd", "ds", " prod", "px", "pg", "pard", "wp", "po", "df", "cp", "rpm", "lp", "PD", " PD", "pl", "td", "cd", "bd", "fd", "hd", "d", "tp", "pb", "xd"], "cb": ["cn", "callback", "ck", "abb", "cf", "bf", "tc", "cc", "bp", "CB", " CB", "obb", "cgi", "nb", "fb", "Callback", "dc", "cv", "wb", "xb", "sb", "eb", "bt", "cp", "erb", "gb", "cr", "lb", "ctrl", "bc", "cor", "kb", "proc", "cd", "rb", "bb", "pb"], "bIndexPage": ["bSearchDocument", "bLabelPath", "bFoundLine", "bConnectPage", "bFoundFile", "blFoundLine", "bSearchpage", "bCheckPages", "blFoundFile", "bSearchFile", "bLinkPage", "bindexLine", "blIndexPage", "boolCheckPage", "bAddpage", "bIndexFile", "bConnectFile", "bindexFile", " bLinkPath", "bCheckPage", " bIndexpage", "bLinkPages", "boolIndexPages", "bFindPage", "boolIndexpage", "boolCheckpage", " bIndexDocument", "bFindpage", "bConnectpage", "bProcessLine", "bAddSite", "blIndexLine", "bIndexPath", "bFoundPage", "bLinkFile", " bIndexUrl", "bProcessPage", "bAddPages", " bLinkPage", "bIndexLine", "bLinkPath", "bLinkUrl", "bindexPage", "bSearchPage", "blIndexFile", "bFindUrl", " bIndexPath", "bFoundpage", "bIndexPages", "bCheckpage", "bAddDocument", "boolIndexSite", "bCheckSite", "boolCheckSite", " bLinkUrl", "bIndexSite", " bLinkDocument", "bIndexpage", " bLinkFile", "bFindPath", "blFoundPage", " bIndexFile", "bIndexDocument", "bLinkpage", "bProcessFile", "bLabelPage", "boolIndexPage", "bIndexUrl", "bLinkDocument", "bLinkSite", "bAddFile", "bAddPage", " bLinkpage", "bLabelpage", "boolCheckPages", "bLabelUrl"], "urlConn": [" urlconn", "urlCon", "bbConn", "nlWin", "databaseCon", " urlConnect", "urlCt", "webConnect", "urlCons", "UrlConn", " urlCons", "urlCh", " urlCo", "UrlCo", "httpconn", "bbConnect", "databaseCt", "httpCh", "httpConnect", "UrlConnect", "databaseConn", "nlConn", "urlWin", "urlconn", "URLConn", "urlConnector", "bbconn", "httpConn", "fileCon", "httpWin", "urlCo", " urlCh", "nlConnector", "UrlCons", "nlConnect", "URLCt", "webCo", "fileConn", "webCons", "urlConnect", "webConn", "URLconn", "fileconn", "databaseconn", "bbCh", "URLCon", " urlWin", "fileCt", "httpConnector", " urlConnector"], "modDate": ["modifiedGe", "modTime", "modifiedDay", "modifiedTime", "mtDay", " modGe", " modDay", "mtTime", "mtDate", "modGe", "modDay", " modTime", "modifiedDate", "mtGe"], "bfReader": ["fbReader", "fbWriter", "btReader", "fbParser", "bbParser", "bbWriter", "btParser", "bfWriter", "bbRead", "bfParser", "btRead", "fbRead", "bbReader", "bfRead", "btWriter"]}}
{"id1": "7044685", "id2": "7458833", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"encrypt": ["cryption", "encrypted", "Encrypt", "crypt", "Encryption", "encryption", "Encrypted", "crypted", " encryption", " encrypted"], "plaintext": ["plainstring", "plainText", " plainText", "plainprint", " plainprint", " plaindata", "messagetext", "mainText", "messageprint", "aintext", "aindata", "messagedata", "messageText", "maintext", "ainprint", "mainstring", "plaindata", " plainstring", "ainstring", "ainText"], "d": ["f", "z", "dd", "dr", "ord", "p", "dx", " md", "red", "dl", "nd", "dat", "dec", "dal", "dh", "sd", "ded", "e", "od", "did", "m", "debug", "pd", "mod", "c", "da", "D", "ds", "de", "md", "ad", "df", "y", "dm", "ind", "h", "done", "ld", "g", "di", "db", "l", "cd", "bd", "t", "end", "fd", "hd", "gd", "w", "dig"]}}
{"id1": "1769771", "id2": "23452437", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " CopyFiles", " copyLine", " copyFiles", " CopyStream", "CopyFiles", " CopyLine", "CopyFile", "copyFiles", " copyStream", "CopyStream", " CopyFile", "CopyLine", "copyLine"], "in": ["ins", "din", "el", "en", "b", "old", "ini", " input", "IN", "inn", "io", "inf", "cin", "gin", "on", "mm", "bin", "from", "ic", "init", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "l", "isin", "In"], "out": ["update", "ot", "output", "OUT", "b", "v", "p", "serv", "ex", "gt", "s", "net", "io", "err", "outs", "it", "c", "ou", "to", "file", "res", "po", "op", "nt", "msg", "up", "help", "os", "l", "t", "o", "log", "Out", "at", "w", "n"], "inChannel": ["insideClient", "intChan", "innCase", " inChan", "cinCommand", "inConnection", "inChan", "intCommand", "cinRoom", "inClient", "Inchannel", "inScope", "sinButton", "outConnection", "outchannel", " inCommand", "inCategory", "innButton", "sinRoom", "insideCategory", " inCase", "ainChannel", "insideChannel", "sinCommand", "InChannel", "cinChannel", "dinchannel", "ainClient", "dinChan", "intChannel", "sinChannel", "ainScope", " inConnection", " inchannel", "dinConnection", "inCase", "sinCase", "inchannel", " inClient", " inButton", "outChan", "inCommand", "dinChannel", " inScope", " inCategory", "intchannel", "InChan", " inRoom", "sinClient", "inRoom", "innChannel", "innClient", "InCommand", "ainCategory", "insideScope", "inButton"], "outChannel": ["outputCh", "aosChannel", "blockChannel", "neSection", "inChan", "blockChan", " outCh", "outSection", " outManager", "outputChan", " outchannel", "inSection", "aosMember", "cnManager", "outchannel", "outputchannel", "inCh", "outputManager", "aosSection", "cnChan", "cnChannel", "parentChan", "outMany", "blockMany", "neMember", "inMember", "outCh", "parentGate", "outputChannel", "parentMany", "inchannel", " outGate", "outChan", "outMember", "outGate", "parentChannel", " outChan", "outManager", " outMany", "neChannel", "blockGate", "aosChan", "neChan"]}}
{"id1": "335223", "id2": "13783549", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndRewWrite", "readAndResend", "readAndRepWrite", "readAndrewrites", "readAndrewrite", "readAndRewend", "readAndRepend", "readAndResWrite", "readAndResrites", "readAndRewrites", "readAndReprites", "readAndrewend", "readAndrewWrite", "readAndReprite"], "inFile": ["initFile", " infile", "inputPlace", "inFILE", "inPlace", "inFace", "iTime", "docFilename", "iFilename", "INFILE", "INFilename", "iFILE", "INFace", "inputFace", "inTime", "initFace", "INFile", "outfile", "initFilename", "INPlace", "INTime", "infile", "docFILE", "InFilename", "docTime", "outFilename", "inFilename", "initPlace", "inputFilename", " inFilename", "InFile", "docFile", "Infile", "iFile", "inputFile"], "outFile": ["reportFILE", " outFilename", "inFILE", "reportfile", "reportFile", " outfile", "checkfile", "checkFilename", "namefile", "toFILE", "nameFilename", "checkFILE", "toFilename", "outfile", "toFile", "reportFilename", "infile", "nameFILE", "outFILE", " outFILE", "checkFile", "outFilename", "nameFile", "inFilename", "tofile"], "iis": ["Iis", " iiss", "liisc", " iris", " ii", "iiris", "iiisc", "Iiss", "iIs", "eIs", "Ii", "diis", "ii", "iiis", "iiss", " iisc", "liIs", "aiis", "iisc", "liris", "liis", "eIS", "diiss", " iIS", "iris", "aiIs", "dii", "diIs", "iiIs", " iIs", "eis", "aiIS", "iIS", "IIs"], "dcmParser": ["dgrPar", "dcmAdapter", "dfmReader", "deromReader", "dpmPrivate", "dromReader", "dmoduleAssistant", "drumPar", "dgrStatement", "dcrBuilder", "DpmPar", " dcmPar", "dpmParser", "dcfReader", "dpmLoader", "DcmAdapter", "dromAssistant", "dpmBuilder", " dpmListener", "drumParser", "dpmarser", "dmmmParser", "dmParser", "dpmPar", "dromListener", "dmmparser", "dpcAssistant", "dcrReader", "dromparser", "dcomLoader", "DpmAdapter", "dpmListener", " dcmListener", "dpmStatement", " dcmparser", "dpcReader", "dcmPar", " dpmparser", "dromParser", "decmParser", "dfmBuilder", "deromparser", "dcommParser", "dcfStatement", "dcrParser", "dpcPrivate", " dpmReader", "dcfParser", "deromParser", " dcmPrivate", "dmparser", "dmReader", "dcmReader", "dmodulePrivate", "dpmAdapter", "dmmmAdapter", "dcommListener", "dcfPar", "dcmListener", "dmarser", "dcmPrivate", "dcommAssistant", " dpmPrivate", "dmmAdapter", "dmmmReader", "DpmReader", "dmmReader", "dcmLoader", " dpmBuilder", " dcmAssistant", "dcmStatement", "dfmParser", " dpmParser", "decmReader", "dcomParser", "dmmarser", "dcmAssistant", " dcmReader", "decmarser", "DcmParser", "dfmLoader", "dmmmparser", "DpmParser", " dpmAssistant", "DpmBuilder", "DcmPar", " dcmarser", "DcmBuilder", "dcmarser", "deromarser", " dpmLoader", " dpmPar", " dcmBuilder", " dcmLoader", "dmoduleParser", " dpmStatement", "dmoduleReader", "dpcParser", "DcmReader", "dcomReader", "dromarser", "dpmReader", " dpmarser", "Dpmparser", " dcmStatement", "dpmparser", "drumBuilder", "dcmBuilder", "dmmParser", "dpmAssistant", "dgrParser", "dcrparser", "dcmparser", "decmparser", "dcommReader", "dgrReader", "dcomBuilder", "Dcmparser", "drumReader"], "ds": ["fs", "ins", "dd", "xs", "cs", "rs", "dds", " des", "dx", "ls", "dt", "der", "dl", "bs", "sets", "data", "qs", "dat", "dh", "sd", "s", "pers", "drivers", "ys", "sys", "ns", "obs", "ss", "in", "pd", "outs", "js", "gs", "da", "dos", "DS", "sv", "ads", "ims", "des", "as", " DS", "df", "eps", "vs", "tes", "eds", "aos", "services", "uds", "details", "dq", "db", "os", "es", "ils", "Ds", "bd", "hs", "ks", "its", "ods", "hd", "ws", "d", "gd", "ps"], "pdReader": ["xdHelper", "vdWriter", "ddHelper", "pdParser", "pdRead", "pedReader", "pedLoader", "dpLoader", "xdReader", "vdReader", "pdHelper", "ddParser", "hdRead", "vdHelper", "xdWriter", "pdRunner", "tdRead", "ddRead", "ddCar", "xdLoader", "pedRunner", "dpCar", "tdWriter", "ddRunner", "pdLoader", "dpRunner", "hdReader", "hdWriter", "vdLoader", "dpReader", "tdParser", "pedCar", "ddReader", "ddLoader", "ddWriter", "pdCar", "hdParser", "tdReader"], "out": ["ins", "cmd", "id", "serv", "gt", "gen", "err", "js", "status", "obj", "res", "nt", "pos", "inter", "oss", "null", "log", "OUT", "co", "cache", "ent", "io", "conn", "it", "ou", "inv", "to", "auto", "aos", "ch", " err", "name", "conv", "o", "end", "cb", "at", "w", "cn", "en", "p", "v", "ex", "screen", "data", "sum", "s", "con", "cfg", "str", "in", "raw", "outs", "c", "all", "tmp", "msg", "opt", "up", "full", "one", "os", "desc", "flush", "t", "go", "output", "gr", "we", "list", "over", "net", "sys", "on", "sw", "writer", "pool", "nr", "client", "txt", "inner", "Out", "outer", "n"], "dcmEncParam": ["dcmDecNum", "dcmEscNum", "dmmEnPar", "dcmencCmd", "dmmencParam", "dcmEncVal", "dcmEncCmd", "dmmEncMsg", "dmmEncParam", "dcmencNum", "dcmDecMsg", "dmmEncVal", "dmmEnNum", "dmmEnParam", "dmmEncNum", "dcmEnVal", "dcmEscPar", "dcmEscParam", "dcmEscVal", "dcmencPar", "dmmEncCmd", "dcmDecCmd", "dmmencMsg", "dcmEnNum", "dmmencNum", "dcmEnPar", "dmmencCmd", "dcmEncMsg", "dcmencMsg", "dcmEncPar", "dmmEncPar", "dcmencParam", "dcmEncNum", "dcmDecParam", "dcmEnParam"], "pdWriter": ["tdWrite", "PDWriter", "pidWriting", "pdWriting", "pdWrite", "pcWriting", "tdwriter", "pcWriter", "PDEditor", "pidwriter", "dpWrite", "pidWriter", "pdEditor", "pcwriter", "pcWrite", "tdWriter", "PDReader", "dpEditor", "tdEditor", "dpReader", "tdWriting", "pidWrite", "PDWrite", "pdwriter", "dpWriter", "tdReader"]}}
{"id1": "442381", "id2": "1586662", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionQuery", "doVersionsUpdate", " doVersionTest", "doBuildCheck", "doFeaturecheck", "doFeatureInfo", "doFeatureQuery", " doVersionQuery", "doImageInfo", "doFeatureCheck", " doApplicationQuery", " doVersionsTest", "doVersionsTest", "doApplicationCheck", "doFeatureUpdate", "doApplicationInfo", "doImageQuery", " doVersionUpdate", " doVersionsUpdate", " doVersioncheck", "doBuildUpdate", "doBuildcheck", "doImageCheck", "doVersionscheck", " doVersionInfo", "doVersionsCheck", "doFeatureTest", "doApplicationQuery", " doApplicationCheck", " doApplicationInfo", " doVersionscheck", "doBuildTest", "doVersionInfo", "doVersioncheck", "doImageTest", " doApplicationTest", "doVersionUpdate", "doVersionTest", " doVersionsCheck", "doApplicationTest"], "view": ["image", "update", "iew", "context", "server", "engine", "VIEW", "v", "port", "model", "show", "self", "window", "review", "ml", "form", "box", "print", "buffer", "q", "cell", "tree", "subject", "block", "eye", "http", "page", "cv", "browser", "report", "query", "document", "file", "layout", "tv", "widget", "controller", "pool", "see", "this", "lock", "call", "client", "check", "display", "h", "View", "virtual", "input", "vm", "manager", "version", "row", "html", "project", "component", "index", "views"], "url": ["loc", "rel", "f", "host", "sl", "ssl", "domain", "gl", "b", "v", "dl", "hl", "char", "bel", "ref", "str", "oul", "ll", "rl", "http", "ul", "nl", "link", "browser", "ur", "URL", "file", "build", "address", "mount", "mail", "client", "pl", "get", "lb", "r", "uri", "Url", "l", "log", "html", "job"], "in": ["f", " IN", "ins", "din", "isin", "stream", "IN", "sin", "inn", "ln", "inf", "cin", "gin", "on", "from", "init", "mn", "body", "ain", "reader", "is", "inc", "can", "out", "rin", "i", "input", "source", "inner", "l", "asin", "mat", "vin", "info", " din", "In", "n"], "bin": ["ins", "din", "jin", "bl", " bins", "lib", "binary", "b", "ran", "abin", "bed", "bn", "stock", "cache", "sin", "inn", "con", "ln", "bi", "cin", "gin", "buffer", "nb", "local", "by", "re", "spin", " Bin", "bg", "all", "session", "init", "thin", "sam", "brain", "file", "body", "cos", "reader", "out", "rin", "win", "len", "inner", "db", "conv", "obin", "rb", "bur", "buff", "cb", " din", "ebin", "mon"], "line": ["column", "cmd", "record", "ine", "field", "stream", "style", "liner", "port", "channel", "eline", "zone", "message", "char", " block", "detail", "string", "ice", "ln", "lo", "le", "chain", "print", "sequence", "cell", "section", "block", "lin", "entry", "rule", "err", "part", "status", "trace", "frame", "tile", "Line", "link", "inline", "page", "stay", "comment", "range", "key", "file", "lane", "code", "base", "word", "iter", "cat", "l", "lines", "row", "parse", "next", "log", "LINE", "sample", "point", "job"], "develBuild": ["deffbuild", "DeVELbuild", "deVELLog", "develRelease", "deVELBuilder", "Develbuild", "depoBuilt", "duvelbuild", "devBoot", "desvelbuild", "desvelRelease", "duffbuild", "depobuild", "depoLog", "develLoad", "duVELBuild", "deVELbuild", "desVELbuild", "deVELBuild", "duffBuilt", "deeltaLoad", "devbuild", "DevelLog", "develbuild", "deffBuilder", "deployBuilt", "DevelBuild", "duvelBuilt", "deffBuilt", "duffBuilder", "deployLoad", "desvelLoad", "develBuilder", "duvelBuild", "duvelBuilder", "deVELBoot", "duvelBoot", "DeVELLog", "deVELLoad", "desVELRelease", "deploybuild", "deployBuilder", "DeVELBuilt", "devBuilder", "develLog", "DevelBuilt", "duffBuild", "deployBoot", "duVELBoot", "duVELbuild", "develBuilt", "DeVELBuild", "deVELRelease", "deeltaRelease", "devBuild", "deVELBuilt", "deeltaBuild", "devBuilt", "deployRelease", "depoBuild", "desVELLoad", "devLog", "desvelBuild", "deployBuild", "deffBuild", "duVELBuilder", "deeltabuild", "develBoot", "desVELBuild"], "stableBuild": ["activeMake", " stableCraft", "activeBuild", "stableBind", " unstableLong", " unstableBuild", "stableBoot", " stableBuilder", " stableMake", " unstablebuild", "stableCraft", "confirmedBoot", "secureBuilder", "devbuild", " stablebuild", " stableBoot", " stableBind", "stablebuild", "secureBuild", "activeBuilder", " unstableBuilder", "confirmedbuild", "confirmedBuild", "stableBuilder", "securebuild", " unstableBind", "devBuilder", "secureCraft", "stableLong", "devBind", " unstableCraft", "devBuild", "devMake", "stableMake", " stableLong", "confirmedLong", "activebuild", " unstableBoot"]}}
{"id1": "17475530", "id2": "5274228", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinktoImage", "testAddLinksToimage", "testAddLinkFromImages", "testAddLinkForimage", "testAddLinktoimage", "testAddLinkstoImages", "testAddLinksToImages", "testAddLinkForImages", "testAddLinkToPicture", "testAddLinkForImage", "testAddLinktoImages", "testAddLinkFromPicture", "testAddLinkToImages", "testAddLinkFromimage", "testAddLinkFromImage", "testAddLinkstoimage", "testAddLinkToimage", "testAddLinkstoImage", "testAddLinkstoPicture", "testAddLinkForPicture", "testAddLinktoPicture", "testAddLinksToImage", "testAddLinksToPicture"], "in": ["k", "ins", "din", "inside", "en", "v", "ex", "ini", "show", "sum", "IN", "er", "inn", "ed", "gin", "cin", "on", "m", "bin", "set", "from", "it", "or", "by", "vin", "re", "and", "add", "sein", "all", "init", "nin", "file", "mc", "al", "ma", "at", "ind", "is", "inc", "out", "check", "up", "rin", "doc", "source", "input", "i", "r", "inner", "get", "one", "include", "o", "password", "isin", "info", " din", "In", "pi"]}}
{"id1": "21488518", "id2": "8216539", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"createNew": ["CreateNew", "getNew", "dataNext", "getFresh", "dataNew", "createNext", "CreateNext", "getResource", "CreateResource", "CreateFresh", "getNext", "createResource", "dataFresh", "dataResource", "createFresh"], "name": ["value", "id", "old", "data", "client", "nm", "format", "description", "string", "path", "ename", "local", "normal", "Name", "part", "resource", "size", "alias", "NAME", "prefix", "handle", "key", "file", "missing", "body", "base", "address", "code", "none", "only", "word", "event", "current", "action", "lat", "ame", "template", "no", "title", "source", "filename", "one", "common", "create", "null", "version", "type", "time", "named", "end", "names", "now", "password", "use", "index", "n"], "in": ["ins", "din", "en", "b", "p", "data", "IN", "inn", "con", "s", "cin", "gin", "mm", "err", "bin", "xml", "from", "it", "c", "vin", "file", "mc", "al", "ma", "body", "reader", "ind", "is", "rin", "get", "i", "input", "r", "source", "inner", "asin", "mat", "t", "isin", "In"], "length": ["max", "value", "stream", "position", "count", "data", "message", "total", "enc", "description", "content", "path", "sequence", "buffer", "duration", "text", "size", "shape", "body", "amount", "height", "len", "input", "padding", "bytes", "password", "Length", "read"], "contentType": ["contentTypes", "mediaType", "ContentType", "ContentTypes", "contentLength", "mediaLength", "ContentLength", "mediatype", " contentLength", " contenttype", "mediaTypes", " contentTypes", "Contenttype", "contenttype"], "dest": ["loc", "there", "folder", " destination", "copy", "Dest", "dat", "self", "home", "disk", "path", "target", "origin", "src", "resp", "table", "orig", "trans", "dir", "coord", "wb", "nom", "obj", " dst", "result", "tmp", " Dest", "parent", "this", "mem", "comb", "source", "iter", "oe", "lit", "cat", "prop", "rest", "d", "temp", "cont"], "out": ["copy", "output", "en", "OUT", "co", "Out", "port", "serv", "ex", "external", "ent", "con", "s", "net", "io", "sys", "set", "conn", "outs", "it", "OU", "ou", "col", "to", "obj", "file", "res", "po", "op", "aos", "cos", "ion", "client", "write", "off", "up", "can", "oss", "conv", "os", "null", "o", "t", "log", "end", "go", "w", "outer", "n"], "request": ["Request", "ask", "search", "move", "forward", "message", "select", "begin", "pair", "enter", "user", "require", "claim", "push", "re", "QUEST", "response", "remove", "ire", "quest", "req", "report", "query", "result", "child", "library", "relative", "reference", "params", "open", "current", "input", "create", "reset", "url", "requ"]}}
{"id1": "8452134", "id2": "20019847", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"exists": ["exception", "comits", "Exinates", "exist", "xists", "Exits", " exits", "comists", "extist", "Exists", " exinates", "existinates", "comist", "existies", "xits", "comception", "xception", "extists", "exits", "existits", "xist", "existists", "extits", " exies", "exies", "extception", "Exies", "exinates"], "fileToCheck": ["pathTOTest", "fileToSee", "fileTOTest", "filetoTest", "filenameTOTest", "fileTOCheck", "filenameTocheck", "pathToWatch", "file2Test", "fileToWatch", "filenameToCheck", "filenameTOcheck", "pathTOCheck", "fileTOWatch", "pathToSee", "pathToTest", "filetoWatch", "filenameTOCheck", "pathTOSee", "fileTOcheck", "file2check", "pathToCheck", "fileTocheck", "filetoSee", "pathTOWatch", "file2Check", "filenameToTest", "fileToTest", "filetoCheck", "fileTOSee"], "ftp": ["rotps", "ldphp", "iftphp", " ftps", "cttp", "ftchange", "ffcache", "fft", "ffc", "aftpl", "aftm", "ffr", "ctp", "fabc", " ftph", " ftl", "ffphp", "aftl", "rotpl", "ctps", "lattp", " ftpl", "latphp", "fftp", "ftm", " ftchange", "latcache", "rotcp", "latp", "ftps", "aftp", "fabph", "ftcp", "ffp", "ftl", "ftpl", " ftt", "ifttp", " ftcp", "aptcp", "iftp", "ftcache", "rotm", " ftr", "rotl", "ffcp", "fabphp", "ldp", "aftchange", "aptl", " ftphp", " ftm", "ffv", "ftt", " fttp", " ftc", "rotchange", "rottp", "ftph", "fttp", "aftc", "aftcp", "aftv", "aftr", " ftv", "aptp", "ldc", "ftc", "ftv", "apttp", "afttp", "fabp", "ftr", "rotp", "aftt", "iftcache", "ldph", "ftphp", "ctcp"], "found": ["sent", "fixed", "built", "search", "id", "started", "count", "Find", "killed", "ed", "checked", "valid", "finished", "filled", "loaded", " Found", "enabled", "expected", "failed", "matched", "successfully", "result", "Found", "affected", "good", "installed", "seen", "out", "elt", "done", "full", "d", "find", "needed", "created", "results", "printed", "identified", "success", "fd", "tested", "successful", "finder", "index", "initialized"], "reply": ["onse", "pop", "mi", "record", "flag", "shell", "strip", "match", "count", "message", "sync", "back", "repl", "notice", "print", "vote", "state", "nb", "py", "embed", "continue", "zero", "push", "ret", "answer", "error", "status", "ping", "post", "response", "nl", "link", "replace", "ply", "report", "comment", "force", "code", "base", "msg", "check", "Reply", " Reply", "txt", "len", "close", "cor", "conf", "echo", "success", "next", "index", "result"]}}
{"id1": "160739", "id2": "18613870", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createInputstream", " createOutSteam", " createInputstream", "createInputStream", "createOutputFile", " createFilestream", " createFileFile", " createInputFile", " createOutputFile", " createInputStream", " createFileSteam", " createOutputstream", " createOutstream", " createOutputSteam", "createInputFile", " createFileStream", " createOutStream", "createInputSteam", " createInputSteam", "createOutputSteam", " createOutFile", "createOutputstream"], "inFile": [" infile", "dinPath", "ninFilename", "dinPort", "inputPath", " inPort", " inDir", "outPath", "outfile", "inputPort", "infile", "inPort", "inPath", "inDir", " inPath", "outFilename", "dinDir", "inputDir", "inFilename", "dinFile", " inFilename", "ninfile", "ninFile", "ninPath", "inputFile"], "outFile": ["outPort", "OutFile", "exFilename", "newPlace", "newFile", "OutFilename", "toPort", "outputPlace", "toFilename", "outfile", "toFile", "newfile", "exfile", "infile", "outputFile", "inPort", "outPlace", "outFilename", "outputfile", "outputFilename", "inFilename", "newFilename", "tofile", "exPlace", "Outfile", "exFile", "OutPort"], "k_blockSize": ["k4BlockName", "k4BlockCount", "k_batchCount", "k_byteName", "k_BlockLength", "k4BlockSize", "k_BlockSize", "k_BlockCount", "k4blockCount", "k_batchSize", "k_blockCount", "k_byteCount", "k_BlockTime", "k_byteStyle", "k_batchTime", "k2blockCount", "k_byteTime", "k2byteCount", "k_BlockName", "k4blockName", "k_byteSize", "k2blockSize", "k_blockStyle", "k2blockLength", "k2byteTime", "k4BlockStyle", "k_blockName", "k_BlockStyle", "k2byteSize", "k_blockLength", "k_blockTime", "k4blockStyle", "k2blockTime", "k_batchLength", "k4blockSize", "k2byteLength", "k_byteLength"], "byteCount": ["bitCode", "blockCheck", "byteCounter", "charCount", "charLength", " bytePtr", "bitLength", "bytePtr", "wordSize", "byteLength", " byteCounter", "byteCode", " bytecount", "byteN", "blockLength", "byteSize", "bbCount", "blockCounter", "wordCount", "charcount", "bitCounter", "wordN", "bitCount", "bitN", "linecount", "lineLength", "bytecount", "wordCode", "bbSize", "bbCode", "bitCheck", "byteCheck", "linePtr", "bitSize", " byteCheck", "charPtr", "bbN", "lineCount", " byteLength", "blockCount"], "buf": ["arr", "cmd", "bl", "b", "exp", "vec", "bn", "uf", "alph", "queue", "buffer", "str", "ctx", "block", "raw", "pkg", "cv", "bg", "cap", "img", "bag", "fg", "seq", "Buff", "batch", "cast", "msg", "txt", "mem", "doc", "cur", "bc", "conv", "db", "proc", "cat", "ctr", "Buffer", "rb", "tx", "buff", "bytes", "cb", "pb"], "ofp": ["Ofd", "Ofp", "ofd", "owlp", "ofpa", " ofpa", " ofl", "Ofpa", "ofl", "OFP", "Ofl", " ofP", "OFp", "OfP", "owld", "owlP", "OFl", "ofP", " ofd", "owlpa", "OFd"], "zos": ["zy", "sis", "z", "osi", "zh", "zes", "hz", "sbm", "zag", "sch", "bs", "std", "enos", "bes", "jp", "ze", "ws", "hess", "LOS", "zona", "zen", "webkit", "gs", "rez", "js", "zers", "south", "zik", "tis", "socket", "eros", "init", "zzle", "python", "amia", "zi", "cos", "ez", "zer", "zip", "cz", "jas", "settings", "esa", "rose", "oss", "zon", "psy", "es", "os", "zb", "zu", "nz", "rss", "ossus", "los", "zo", "css", "zl", "ps", "za", "zin"], "osw": ["sysW", "osswx", " osW", "ossrw", "ossW", "oswx", "opace", " osd", "isw", "osssw", "osew", "cosw", "owa", "osiwa", "sysrw", "oswd", "osswd", "iswx", "osiw", "ossw", "osws", "osiW", "aoswd", "aosew", "aosd", "ospace", "osd", "isW", " oswx", "aoswa", "sysw", "cosew", "osipace", "syswd", "issw", "aosws", "cosd", "cosws", "osrw", "aosrw", "aosw", "oswa", " ossw", "ow", "aospace", " osws", "oW", " osew", "aosW", "osW"], "bw": ["abew", " bx", "obwt", "nbew", " bwl", "abw", "rbw", "wbw", "pbz", "pbwy", "wbz", "sbz", "pbw", "wbwp", "bz", " bex", "pbwb", "pbwt", "wbem", "bwt", "bsw", " bsw", "abwe", "rbws", "bbem", "bbws", "wbwt", "bbz", "obz", "bwy", "wbx", " bwp", " bz", "bbex", "bbx", "bewl", "bew", "bbwp", " bem", "pbew", "nbwy", "bewk", "obwb", "nbw", "obw", "bbend", "bwk", "nbwe", "bwp", " bend", "bwl", "obsw", "bem", "bwb", "sbwt", " bwt", "bwe", "wbend", "bws", "bbwt", "obwk", " bwk", "rbz", "bend", "pbwe", "abwy", "bex", "bbw", "bx", "rbex", "sbw", "besw", " bws", "obwl", "sbwb"], "zot": ["zipot", "zipiat", "Zit", "Zott", "ziat", "ziot", "Zot", "zipiot", "zerot", "zott", "ziphot", " zor", "zero", "zerhot", "zote", "zerote", " zote", " zhot", " ziat", " zonet", "zeror", "zoonet", "zonet", " ziot", "zeriat", "zeronet", "zor", "Zote", "zerit", "zoor", "zoot", "zeriot", " zo", "zerott", "zhot", " zott", "zo", "zoo"], "ifp": [" ifth", " ifP", "ifP", "Ifth", "isP", " ifr", "iwr", "ihd", "isth", "iwd", "ihtp", "isjp", "ihp", "ifr", " ifjp", "Ifjp", " ifd", "ifth", " iftp", "isp", "iwp", "IfP", "Ifp", "ihr", "ifjp", "iftp", "iwtp", "ifd"], "zis": ["izis", "ziinit", " zi", "zic", "zois", "zipis", "zisa", "izisa", " zisc", "zoisa", "zipIS", "ziss", "zeris", "izisc", "zinit", "zisc", "zoiss", "ezisc", "ezis", " ziss", "iziss", " zIS", "zi", " zic", "zIS", "zeric", "ziis", "izinit", "ezi", "eziss", "zoinit", "zerIS", "zipic", "izi", "ziiss", "ziisa"], "isr": ["iosstr", "sisrc", " isrc", "isalpr", "issrc", " isrs", "isscr", "iossr", "siscr", "isstr", "sisrs", "isrs", "ispr", "itsr", "issrs", "sisr", "itspr", "iscr", "isalstr", "isrc", "issr", "itsstr", "isalsr", "iospr", " iscr", "isalr", "iosr", "itssr"], "br": ["hr", "rel", "yr", "ba", "dr", "bm", "mr", "bl", "b", "gr", "bf", "bn", "Fr", "BR", "bp", "vr", "lr", " Br", "bi", "str", "kr", "js", "shr", "bro", "fr", "bh", "obl", "Br", "ber", "ptr", "bt", "tr", "bj", "pr", "cr", "r", "ctr", "rb", "bd", "sr", "wr"], "zit": ["zlit", " zite", "zipist", "cziti", "oziti", "ziIt", "czunit", "zipite", " zip", "zipIT", "ziti", " zIT", "lexIt", "zeop", "zeot", "czip", "ezite", " zop", "ozunit", "ozip", "ezlit", "lexit", "czop", "zIT", "ziIT", "zop", "czot", "czit", "izip", "zite", "zeit", "zeip", "ziplit", "lexist", "zIt", "ozit", "zipIt", "zip", "ezit", "zist", "zipit", "ezIT", "ziist", "lexIT", "izit", "zunit", "ziit", "iziti", "izunit", " zlit"]}}
{"id1": "20091126", "id2": "3024970", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"copy": ["store", "move", "transfer", " Copy", "sync", "io", "delete", "Cop", "map", "load", "upload", "to", "paste", "Copy", "file", "y", "cp", "open", "system", "call", "write", "get", "clone", "create", "cat", "Transfer", "save", "download"], "in": ["ins", "din", "el", "en", "b", "id", "old", "ini", " input", "IN", "inn", "io", "inf", "gin", "cin", "mm", "from", "init", "file", "ain", "ind", "inc", "up", "rin", "i", "input", "source", "r", "inner", "l", "info", "isin", "ck", " din", "In", "n"], "out": ["ot", "output", "OUT", "b", "co", "v", "p", "ex", " os", "channel", "self", "gt", "s", "e", "net", "io", " it", "err", "it", "outs", "c", "or", "ou", "to", "_", "as", "x", "file", "res", "tmp", "nt", "msg", "y", "ch", "write", "one", "os", "null", "l", " output", "t", "o", "log", "bytes", "end", "Out", "at", "w", "result", "n"], "inChannel": ["ginChain", "InConnection", " inChan", "binChuck", "conChan", "cinCommand", "inConnection", "inChan", "inChuck", "inRow", "Inchannel", "insideRow", "binCommand", "inSection", " inSection", "insideSection", "insideCommand", "outchannel", "incChuck", " inCommand", "ginChannel", "incChain", "ginChuck", "insideChannel", "ginPanel", "INChannel", "outCommand", "conChannel", "cinChannel", "outBlock", "InChannel", " inBlock", "incChannel", " inRow", " inConnection", "binPanel", " inchannel", "binChannel", "inBlock", "cinchannel", "INConnection", "cinBlock", "innConnection", "inChain", "inchannel", "conConnection", "INChan", "inCommand", "binRow", "binChain", "innchannel", "incPanel", " inListener", "InChan", "inListener", "INListener", "inPanel", "conListener", "innChannel", "binSection", "innChan"], "outChannel": ["cmdGate", "Outchannel", "outputPassword", "inChan", " outCh", "outPassword", "OUTUser", " outManager", "cosSlot", "outputChan", " outchannel", "outchannel", "modulePassword", "outputManager", "inCh", "OutCh", "OutChannel", "inUser", "cmdChannel", "outMany", "moduleChannel", "outUser", "outSlot", "outputChannel", "OUTSlot", "skyMany", "cmdChan", "outCh", "OUTChan", "skyChannel", "OutChan", "cosChan", "inSlot", "inchannel", " outGate", "outChan", "OUTChannel", "cosUser", "moduleChan", "skyGate", "cosChannel", " outPassword", "cmdMany", "moduleManager", "outGate", "skyChan", " outChan", "outManager", " outMany"]}}
{"id1": "3809087", "id2": "13783549", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"getWave": ["setAudio", "downloadwave", "getWar", "setWar", " getwave", "getAudio", "downloadWar", "downloadWave", "downloadAudio", "setwave", "setWave", "getwave", " getWar", " getAudio"], "url": ["f", "host", "loc", "server", "id", "b", "v", "ls", "dl", "api", "string", "path", "web", "ref", "q", "str", "ll", "http", "rl", "ul", "nl", "link", "www", "ur", "key", "URL", "file", "base", "name", "word", "out", "input", "r", "uri", "Url", "l", "fl", "password", "fc"], "Word": ["WC", "words", "bow", "WF", "Password", "Week", "Weight", "Token", "Field", "Wr", "Fix", "Term", "sword", "Query", "Key", "Str", "Label", "Char", "Words", "Nob", "Name", "Bank", "File", " word", "Wave", "W", "Tag", "Message", "Part", "Form", "wp", "Win", "Letter", "Language", "word", "War", "wo", "Work", "wd", "Length", "Hack", "Wi", "Po", "User", "Wo", "w", "Text", "stem"], "FF": ["f", "UFF", "FS", "PF", "AF", "HF", " ff", "WF", "uff", "Field", "lf", "uf", "SF", "IF", "CC", "FO", "ff", "FD", "Factory", "tf", "EF", "File", "Pref", "FC", "FILE", "aft", "FP", "UF", "FN", "IFF", "aff", "FL", "fi", "DF", "Temp", "FB", "Aff", "fd", "Fi", "TF", "F", " F"], "url2": ["uri2", "str2", "lsTwo", "ls1", "Url2", "Url3", "url1", "strTwo", " url1", "lTwo", "l1", "l4", " urlTwo", "l2", "urlRel", "strRel", "str3", "uri3", "ls4", " url4", "uriTwo", "ls2", "urlTwo", "UrlRel", "url3", "UrlTwo", "url4", "uriRel"], "stream": ["length", "context", "progress", "Stream", "dd", "ssl", "v", "channel", "sc", "standard", "speed", "window", "message", "list", "sync", "iterator", "ream", "path", "form", "chain", "stack", "buffer", "src", "sw", "Steam", "steam", "view", "REAM", "http", "size", "response", " upstream", "sv", "fr", "transform", "sam", "console", "pipe", "tr", "reader", "zip", "mount", "line", "ob", "loop", "feed", "input", "ST", "iter", "inner", "conv", "source", "row", "sample", "download", "now", "history", "read"], "Fdel": ["Fdep", " Fdes", " Fel", "fdes", "PFdel", " Fdelete", "FDel", "FMdep", "FDdel", "FDdes", "FDDel", "FMdel", "PFdep", " Fdep", "FMDel", " FDel", "Fdes", "fel", "fDel", "PFDel", "PFdelete", "Fdelete", "Fel", "fdel", "FMdelete"], "outstream": ["newStream", "endconsole", "outstore", "endform", "Outconsole", "upfield", " outconsole", " outform", "upstream", "OutStream", "upform", "outputstream", "uppipe", "outerstream", "outfield", "outerpipe", "endview", "Outstream", "inStream", "outview", "newstore", "Outstore", "outputpipe", "outconsole", "outpipe", "outerform", " outview", "instream", "newstream", "outform", "outputfield", "inconsole", "outStream", "instore", "newconsole", "Outview", "outerfield", "outputform", "Outform", "endstream"], "bwriter": ["bincreator", " brunner", "bler", " bWriter", "bcreator", "rworker", "binreader", "greader", "Bwriter", "Bcreator", " bener", "cbreader", "Bler", " bworker", "gWriter", "brunner", "rreader", "cbworker", "gler", "bWriter", " bcreator", "cbrunner", "bworker", "cbwriter", "breader", "gwriter", "rrunner", "Bener", "bener", "Breader", "binener", "BWriter", " bler", " breader", "rwriter", "binwriter"], "binput": ["binarycut", "boxstr", "obinbutt", "binaryoutput", "binstr", " binoutput", "obincut", " binbutt", "bpost", "boxcut", " binpixel", "binaryPut", "binbutt", "bstr", "binarystr", "boxput", "binarypost", "obinoutput", "bPut", " binpost", "bincut", "binarybyte", " binstr", "binpixel", "boxbyte", "obinpixel", "bput", " binPut", "obinbyte", "binarypixel", "obinput", "binaryput", "binPut", "binbyte", "obinstr", "binpost", "binarybutt", "binoutput"], "len": ["length", "L", "del", "el", "num", "fun", "ellen", "bl", "en", "gl", "fin", "vec", "ls", " clen", "lf", "dl", "contin", "hl", "lan", "kl", "ln", "le", "lim", "wl", "val", "ll", "bin", "wid", "li", "size", "nl", "den", "Len", "ell", " le", "all", "ler", "nt", "pos", "cond", "ind", "lp", "no", "elt", "ld", "iter", "lit", "l", "lon", "coll", "fl", "end", "log", "compl", "n"]}}
{"id1": "11305840", "id2": "160705", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "label": 0, "substitutes": {"setUpdateCliente": [" setUpdateclientes", " setupdateCliente", " setupdateClientes", " setUpdatecliente", " setUpdatePersones", " setupdateClienta", " setupdateCliento", " setUpdateClienta", " setUpdatePersona", " setUpdatePees", " setUpdatePee", " setupdatecliento", " setUpdatePersono", " setupdatecliente", " setupdateclienta", " setUpdateClientes", " setUpdatePea", " setUpdatePeo", " setupdateclientes", " setUpdateclienta", " setUpdatePersone", " setUpdatecliento", " setUpdateCliento"], "IDcliente": ["IDparente", "idCliente", "IDcelli", "IDclientel", "IDClientee", "IDsClientE", "idClientee", "IDsClienti", "IDcodee", "IDcelle", "idclientE", "IDstai", "IDclientE", "IDcodE", "idclientoe", "IDcodel", "idclientee", "IDactiveel", "IDCliento", "IDsclienti", "IDCliente", "IDcode", "IDscliente", "IDparentee", "idcliente", "IDClientE", "IDparentE", "IDClientel", "IDClientes", "IDactivees", "IDscliento", "IDactivee", "IDClienti", "IDcodes", "idClientes", "IDclientee", "IDstaE", "IDstae", "IDcellE", "IDsCliente", "idClientel", "idclientel", "IDclientes", "IDclientoe", "IDactiveE", "IDstao", "idClientoe", "IDsclientE", "IDclienti", "idClientE", "IDcello", "IDparentoe", "IDcliento", "IDClientoe", "IDsCliento", "idclientes", "IDcodoe"], "nombre": [" nomeren", "nomer", "nometre", "numbr", "nombreb", "nombr", "nometres", " numbreb", "nometren", "nomereb", "nuclere", " nombren", " nombres", "nuclereb", "nombres", "numbreb", " nombreb", " numbren", " nombr", " nomere", "numbren", "nometr", "nomere", "nucleren", " numbre", "nucleres", "nomeres", "nombren", "numbre", "numbres", " numbres", " nomer", " nomeres", "nomeren"], "paterno": ["paterne", "taterna", "tatereno", "pattern", "tattereno", "caterlo", "pATERna", "catterno", "taterno", "catterlo", "tatern", "patterno", "pATERlo", "paterlo", "peterno", "peterlo", "caterna", "patereno", "patern", "pettereno", "petterno", "tatterno", "catterne", "pATEReno", "pattereno", "paterna", "peterna", "catterna", "patterna", "peterne", "pATERno", "pATERne", "patterlo", "petterna", "pATERn", "caterne", "patterne", "caterno", "tatterna", "tattern", "pettern"], "materno": [" matterna", "mATERno", "maternumber", "masernumber", " materNo", "paterNo", "mterNO", "mterna", "materNo", "pATERnumber", "materNO", "pATERna", " materna", "matternumber", "mterno", "matterna", "matterNo", "maserna", "pATERNo", "matterNO", "paterna", "mATERna", " matterno", "maserNo", "mATERnumber", "pATERno", "mATERNo", "matterno", " matterNO", "mterNo", "paternumber", "mATERNO", "maserno", " materNO", "materna", " matterNo"], "ocupacion": ["ocuptaci", "ocuptaton", "icupaton", "ocupanc", "icuptaton", "ocUpacion", "icuptacion", "ocueac", "incuppacion", "ocuparro", "ocuptidad", "icuptaci", "icupacion", "ocUpaton", "ocueacion", "ocupsacion", "incuparro", "icupaci", "ocuppanc", "ocueanc", "ocUpidad", "ocupaci", "ocuptac", "ocupsaton", "ocupsaci", "incuppac", "incupanc", "ocuptarro", "ocuppac", "ocupac", "incupparro", "ocupidad", "incupacion", "ocupaton", "ocupsidad", "ocuearro", "icuptidad", "ocuppacion", "ocuptacion", "ocUpaci", "incupac", "ocuptanc", "ocupparro", "icupidad", "incuppanc"], "rfc": ["trco", "mfl", "rfa", "trfc", "yrtc", "mwic", " rwic", "rfl", " rtc", " rcos", "urwic", " rfa", "rtc", "rcos", " rco", "mcos", "yrfa", "yrco", "urcos", "mfc", "trfa", " rfl", "yrfc", "rco", "trtc", "rwic", "urfc", "urfl"], "stm": ["statm", "Stem", "statM", "STm", "STma", " stmi", "Stmi", "strm", "strmt", "strem", "strmi", "stM", "STM", "statmc", " stem", "sem", "sema", "stmi", "stma", "statma", "stmt", "STmc", "semc", "seM", " stmt", "Stmt", "Stm", "stmc", "stem"], "update": ["initial", "equal", "module", "delete", "complete", "valid", "set", "continue", "it", "commit", "status", "load", "remove", "add", "fill", "replace", "apply", "report", "edit", "layout", "run", "UPDATE", "component", "build", "change", "only", "updated", "ok", "open", "out", "write", "up", "Update", "check", "feed", "append", "create", "submit", "fail", "success", "flush", "accept", "save", "include", "end", "remote", "use", "draw", "local", "send", "result"]}}
{"id1": "8747840", "id2": "1508161", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["move", "transfer", " Copy", "sync", "csv", "delete", "clip", "map", "load", "add", "link", "upload", "paste", "Copy", "gc", " mirror", "cp", "slice", "write", "clone", "create", "cat", " copying", "save", " replicate", "download", " cp", "read"], "src": ["rel", "iv", "ins", "rc", "bs", "rs", "sc", "usr", "sin", "sys", "obs", "via", "st", "sq", "sf", "pkg", "sec", "from", "inst", "sit", "ser", "req", "init", "urg", "img", "sb", "rx", "txt", "ipl", "source", "input", "syn", "cur", "start", "sur", "ctr", "sr", "Source", "cont"], "dest": ["loc", "del", "th", "https", "Dest", "self", "mk", "gt", "usr", "way", "target", "nw", "test", "origin", "mm", "pub", "st", "dist", "spec", "sit", "orig", "req", "trans", "des", "nom", "tmp", "nt", "est", "master", "good", "opt", "source", "null", "decl", "pas", "rest", "end", "d", "temp", "deg", "cont"], "in": ["ins", "din", "inside", "en", "id", "rc", "old", "ze", "IN", "inn", "con", "ln", "ai", "inf", "cin", "gin", "mm", "on", "bin", "from", "ar", "ic", "it", "init", "impl", "al", "ain", "ind", "inc", "up", "rin", "source", "input", "i", "iter", "inner", "info", "isin", "im", "In"], "out": ["ot", "output", "en", "OUT", "co", "p", "dis", "ex", "sum", "gt", "con", "over", "net", "io", "ne", "sys", "n", "on", "err", "bin", "conn", "outs", "it", "by", "writer", "ou", "to", "obj", "res", "auto", "aos", "nt", "ch", "client", "write", "oss", "g", "inner", "os", "conv", "not", "o", "t", "end", "Out", "at", "outer", "can"], "buf": ["arr", "cmd", "bl", "b", "bs", "vec", "bed", "uf", "data", "gen", "box", "ref", "queue", "buffer", "aka", "str", "block", "pkg", "fb", "col", "bar", "stab", "bh", "cv", "cap", "cam", "bag", "fg", "seq", "Buff", "batch", "msg", "mb", "good", "used", "br", "bus", "cat", "conv", "db", "tab", "rb", "Buffer", "mu", "prop", "buff", "bytes", "log", "cb", "temp"], "c": ["k", "z", "b", "cs", "co", "rc", "cu", "cf", "count", "cache", "ec", "dec", "nc", "unc", "cc", "jc", "m", "ac", "C", "cod", "a", "dc", "ca", "gc", "mc", " C", "code", "cos", "ch", "cp", "uc", "call", "i", "cr", "bc", "conf", "l", "cd", "ci", "ct", "t", "ce", "cm", "d", "cb", "lc", "fc", "cont", "n"]}}
{"id1": "7809093", "id2": "12078471", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"getContent": [" getContents", "getEntity", "readEntity", " getEntity", "readStream", " getStream", "GetData", "readContents", "getStream", " getData", "getData", "GetContents", "readData", "GetEntity", "readContent", "getContents", "GetStream", "GetContent"], "request": ["Request", "object", "search", "question", "message", "task", "instance", "email", "self", "q", "hello", "xml", "claim", "application", "resource", "post", "http", "QUEST", "quest", "attribute", "req", "item", "transform", "query", "document", "address", "execute", "event", "this", "open", "call", "template", "get", "input", "create", "start", "url", "command", "job", "project"], "sb": ["sth", "ssl", "b", "bs", "bf", "bn", "SB", "ib", "buf", "bp", "obb", "buffer", "nb", "rob", "sq", "sf", "bps", "fb", "sv", "bh", "bg", "xb", "wb", "gc", "eb", "sp", "bt", "erb", "mb", "gb", "lp", "lb", "rm", "kb", "zb", "pb", "ub", "rb", "bsp", "bd", "sg", "bb", "cb", "sa", "sm"], "client": ["cn", "cli", "context", "core", "cmd", "server", "co", "https", "cache", "grid", "tc", "connect", "api", "service", "con", "google", "secure", "web", "city", "io", "chain", "net", "cell", "conn", "wrapper", "c", "resource", "http", "control", "init", "key", "connection", "console", "force", "ch", "cp", "call", "create", "config", "cl", "ci", "ip", "ce", "remote", "Client", "cm"], "httpParams": ["httpParims", "httpPams", "httpPARams", "httpPam", "httpPARms", "apiparams", "httpPms", "httpPrAMS", "apiParAMS", "httpPerams", " httpParims", "httpPims", "httpparparams", "apiparAMS", "httpPerms", " httpPars", "httpPars", "httpParAMS", " httpParms", "httpPARims", "httpParans", " httpParars", "apiparparams", "httpPans", "httpPrparams", "httpParms", "httpPARars", " httpPams", " httpPms", " httpParans", "httpParparams", "httpParars", "apiparms", " httpParam", "httpPrams", "apiParms", "httpPeram", "httpparams", "httpPrms", "apiParparams", "httpparms", " httpPims", "httpParam", "httpPerans", "httpparAMS", "apiParams"], "response": ["image", "onse", "object", "reply", "output", "data", "message", "given", "description", "service", "sequence", "tree", "block", "resp", "entry", "application", "answer", "resource", "http", "status", "page", "that", "report", "document", "connection", "body", "pos", "out", "still", "respond", "Response", "json", "version", "success", "next", "successful", "result"], "entity": ["image", "translation", "el", "object", "quote", "pe", "encrypted", "person", "ity", "data", "enc", "email", "ent", "peer", "e", "token", "net", "form", "group", "user", "phrase", "valid", "me", "xml", "entry", "application", "Entity", "error", "resource", "status", "note", "metadata", "comment", "attribute", "document", "obj", "component", "body", "code", "existent", "event", "ee", "activity", "details", "one", "unique", "json", "ce", "info", "result"], "reader": ["readable", "dr", "dd", "stream", "data", "er", "iterator", "user", "owner", "handler", "buffer", "parser", "entry", "loader", "writer", "rl", "resource", "runner", "worker", "reading", "ro", "range", "comment", "linger", "builder", "file", "per", "rar", "Reader", "rr", "older", "ner", "r", "input", "iter", "inner", "rer", "row", "roller", "read"], "line": ["el", "ine", "license", "header", "liner", "eline", "zone", "message", "where", "email", "detail", "string", "e", "ln", "user", "le", "ice", "print", "phrase", "cell", "sequence", "chain", "block", "lin", "entry", "rule", "continue", "text", "frame", "nl", "Line", "link", "stroke", "page", "inline", "comment", "label", "day", "file", "lane", "body", "lined", "msg", "number", "source", "l", "row", "lines", "LINE", "sample", "edge", "point"]}}
{"id1": "4938100", "id2": "12242903", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 1, "substitutes": {"sha1": ["md2", "a1", "a256", "SHA3", "md3", "a2", "SHA2", "sha2", "sha256", "md1", "SHA256", "SHA1", "md256", "a3", "sha3"], "text": ["translation", "context", "value", "output", "pattern", "data", "message", "select", "content", "string", "path", "form", "print", "test", "buffer", "q", "str", "pt", "subject", "term", "aut", "comment", "prefix", "x", "document", "code", "nt", "msg", "act", "body", "name", "word", "event", "out", "txt", "TEXT", "template", "title", "input", "source", "url", "ct", "tx", "t", "ext", "now", "password", "command", "w", "Text", "read", "cont"], "UnsupportedEncodingException": ["UnsupportedEncgorithmEx", "UnsupportedChoderEx", "UnsupportedEncoderEx", "UnsupportedEncoderElement", "UnsupportedChodingEx", "UnsupportedChoderElement", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedChoderError", "UnsupportedEncodingElement", "UnsupportedChoderException", "UnsupportedChodingElement", "UnsupportedEncgorithmElement", "UnsupportedEncgorithmError", "UnsupportedEncgorithmException", "UnsupportedChodingError", "UnsupportedEncodingEx", "UnsupportedEncoderException", "UnsupportedChodingException"], "md": ["cmd", "dd", "mt", " ms", "bf", "der", "red", " cmd", " mc", "nd", "sha", " rm", "dh", "mk", "sd", " dd", "od", " sd", "ms", "m", "mm", "pd", "pkg", " cd", "mod", " df", "add", "dir", "ad", "mc", "mond", " Md", " mm", " mo", "df", "mp", "mn", "dm", "mand", "det", "ind", "mb", "h", "grad", "ld", " man", "td", "rm", "di", "cd", "ctr", "bd", "t", "hd", "d", "MD", "mg"], "sha1hash": ["sha1href", "sha1Hash", "ha1result", "haonesha", "ha1sum", "a1sha", "shaonesha", "sha1hex", "sha5result", "a1hash", "sha5hex", "sha1result", "sha5sha", "sha81hex", "sha5Hash", "a1Hash", "aonesum", "sha5href", "haonesum", "sha2sum", "sha5hash", "sha3Hash", "sha81href", " SHA1Hash", " SHA81hash", "sha3result", "haonehash", "sha2sha", "sha3sum", "sha1sha", "sha81hash", "haoneresult", " SHA81Hash", " SHA1href", "sha1sum", "sha2hash", "ha1hash", " SHA1hex", "sha5sum", "a1sum", "shaonehash", "sha3hash", "sha2Hash", "shaoneresult", " SHA81href", "sha81Hash", "ha1sha", "sha3href", "sha3sha", "shaoneHash", "sha3hex", " SHA81hex", "aonehash", "aoneHash", " SHA1hash", "aonesha", "shaonesum"]}}
{"id1": "16378239", "id2": "4164833", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"byReference": ["forRef", "ByReference", "forreference", "byreference", "forReference", " byResource", "byRef", "forResource", "Byreference", "byResource", "ByRef", "ByResource", " byreference", " byRef"], "inputStream": ["inputReader", "readableSteam", "InputSteam", "readableReader", " inputstream", " inputSteam", " inputReader", "inFile", "inSteam", "inStream", "inputSteam", "readableStream", "inputstream", "Inputstream", "InputReader", "instream", " inputFile", "InputStream", "InputFile", "readablestream", "inputFile"], "tempFile": ["poraryUrl", "poraryFile", "tmpPlace", " temporaryfile", "TempDirectory", "tempFiles", "TempFiles", " temporaryChain", "poraryDir", " tempDir", "poraryPlace", "tempfile", " tempfile", "poraryName", "empPlace", "TempPath", "tempDirectory", "tmpfile", "tmpDirectory", "TempDir", "TempUrl", " temporaryFile", "Tempfile", "tempChain", " tempUrl", "empfile", "tempName", "empName", "TempChain", " tempFiles", "empDirectory", "tempDir", "poraryfile", " tempChain", "empFile", "tempUrl", " temporaryFiles", "tmpPath", "empPath", "tmpFile", "TempFile", "tempPlace", "tmpName", "tempPath"], "out": ["ins", "output", "OUT", "co", "gr", "v", "lay", "again", "serv", "ex", "dis", "sum", "ent", "us", "con", "s", "user", "net", "io", "sys", "in", "outs", "OU", "writer", "ou", "to", "all", "as", "file", "auto", "aos", "cos", "msg", "up", "oss", "source", "one", "conv", "ao", "os", "l", "null", "o", "t", "Out", "n"]}}
{"id1": "189963", "id2": "18489832", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndRewWrite", "readAndResend", "readAndRepWrite", "readAndrewrites", "readAndrewrite", "readAndRewend", "readAndRepend", "readAndResWrite", "readAndResrites", "readAndRewrites", "readAndReprites", "readAndrewend", "readAndrewWrite", "readAndReprite"], "inFile": ["initFile", " infile", "inputPlace", "inFILE", "inPlace", "inFace", "iTime", "docFilename", "iFilename", "INFILE", "INFilename", "iFILE", "INFace", "inputFace", "inTime", "initFace", "INFile", "outfile", "initFilename", "INPlace", "INTime", "infile", "docFILE", "InFilename", "docTime", "outFilename", "inFilename", "initPlace", "inputFilename", " inFilename", "InFile", "docFile", "Infile", "iFile", "inputFile"], "outFile": ["reportFILE", " outFilename", "inFILE", "reportfile", "reportFile", " outfile", "checkfile", "checkFilename", "namefile", "toFILE", "nameFilename", "checkFILE", "toFilename", "outfile", "toFile", "reportFilename", "infile", "nameFILE", "outFILE", " outFILE", "checkFile", "outFilename", "nameFile", "inFilename", "tofile"], "iis": ["Iis", " iiss", "liisc", " iris", " ii", "iiris", "iiisc", "Iiss", "iIs", "eIs", "Ii", "diis", "ii", "iiis", "iiss", " iisc", "liIs", "aiis", "iisc", "liris", "liis", "eIS", "diiss", " iIS", "iris", "aiIs", "dii", "diIs", "iiIs", " iIs", "eis", "aiIS", "iIS", "IIs"], "dcmParser": ["dgrPar", "dcmAdapter", "dfmReader", "deromReader", "dpmPrivate", "dromReader", "dmoduleAssistant", "drumPar", "dgrStatement", "dcrBuilder", "DpmPar", " dcmPar", "dpmParser", "dcfReader", "dpmLoader", "DcmAdapter", "dromAssistant", "dpmBuilder", " dpmListener", "drumParser", "dpmarser", "dmmmParser", "dmParser", "dpmPar", "dromListener", "dmmparser", "dpcAssistant", "dcrReader", "dromparser", "dcomLoader", "DpmAdapter", "dpmListener", " dcmListener", "dpmStatement", " dcmparser", "dpcReader", "dcmPar", " dpmparser", "dromParser", "decmParser", "dfmBuilder", "deromparser", "dcommParser", "dcfStatement", "dcrParser", "dpcPrivate", " dpmReader", "dcfParser", "deromParser", " dcmPrivate", "dmparser", "dmReader", "dcmReader", "dmodulePrivate", "dpmAdapter", "dmmmAdapter", "dcommListener", "dcfPar", "dcmListener", "dmarser", "dcmPrivate", "dcommAssistant", " dpmPrivate", "dmmAdapter", "dmmmReader", "DpmReader", "dmmReader", "dcmLoader", " dpmBuilder", " dcmAssistant", "dcmStatement", "dfmParser", " dpmParser", "decmReader", "dcomParser", "dmmarser", "dcmAssistant", " dcmReader", "decmarser", "DcmParser", "dfmLoader", "dmmmparser", "DpmParser", " dpmAssistant", "DpmBuilder", "DcmPar", " dcmarser", "DcmBuilder", "dcmarser", "deromarser", " dpmLoader", " dpmPar", " dcmBuilder", " dcmLoader", "dmoduleParser", " dpmStatement", "dmoduleReader", "dpcParser", "DcmReader", "dcomReader", "dromarser", "dpmReader", " dpmarser", "Dpmparser", " dcmStatement", "dpmparser", "drumBuilder", "dcmBuilder", "dmmParser", "dpmAssistant", "dgrParser", "dcrparser", "dcmparser", "decmparser", "dcommReader", "dgrReader", "dcomBuilder", "Dcmparser", "drumReader"], "ds": ["fs", "ins", "dd", "xs", "cs", "rs", "dds", " des", "dx", "ls", "dt", "der", "dl", "bs", "sets", "data", "qs", "dat", "dh", "sd", "s", "pers", "drivers", "ys", "sys", "ns", "obs", "ss", "in", "pd", "outs", "js", "gs", "da", "dos", "DS", "sv", "ads", "ims", "des", "as", " DS", "df", "eps", "vs", "tes", "eds", "aos", "services", "uds", "details", "dq", "db", "os", "es", "ils", "Ds", "bd", "hs", "ks", "its", "ods", "hd", "ws", "d", "gd", "ps"], "pdReader": ["xdHelper", "vdWriter", "ddHelper", "pdParser", "pdRead", "pedReader", "pedLoader", "dpLoader", "xdReader", "vdReader", "pdHelper", "ddParser", "hdRead", "vdHelper", "xdWriter", "pdRunner", "tdRead", "ddRead", "ddCar", "xdLoader", "pedRunner", "dpCar", "tdWriter", "ddRunner", "pdLoader", "dpRunner", "hdReader", "hdWriter", "vdLoader", "dpReader", "tdParser", "pedCar", "ddReader", "ddLoader", "ddWriter", "pdCar", "hdParser", "tdReader"], "out": ["ins", "cmd", "id", "serv", "gt", "gen", "err", "js", "status", "obj", "res", "nt", "pos", "inter", "oss", "null", "log", "OUT", "co", "cache", "ent", "io", "conn", "it", "ou", "inv", "to", "auto", "aos", "ch", " err", "name", "conv", "o", "end", "cb", "at", "w", "cn", "en", "p", "v", "ex", "screen", "data", "sum", "s", "con", "cfg", "str", "in", "raw", "outs", "c", "all", "tmp", "msg", "opt", "up", "full", "one", "os", "desc", "flush", "t", "go", "output", "gr", "we", "list", "over", "net", "sys", "on", "sw", "writer", "pool", "nr", "client", "txt", "inner", "Out", "outer", "n"], "dcmEncParam": ["dcmDecNum", "dcmEscNum", "dmmEnPar", "dcmencCmd", "dmmencParam", "dcmEncVal", "dcmEncCmd", "dmmEncMsg", "dmmEncParam", "dcmencNum", "dcmDecMsg", "dmmEncVal", "dmmEnNum", "dmmEnParam", "dmmEncNum", "dcmEnVal", "dcmEscPar", "dcmEscParam", "dcmEscVal", "dcmencPar", "dmmEncCmd", "dcmDecCmd", "dmmencMsg", "dcmEnNum", "dmmencNum", "dcmEnPar", "dmmencCmd", "dcmEncMsg", "dcmencMsg", "dcmEncPar", "dmmEncPar", "dcmencParam", "dcmEncNum", "dcmDecParam", "dcmEnParam"], "pdWriter": ["tdWrite", "PDWriter", "pidWriting", "pdWriting", "pdWrite", "pcWriting", "tdwriter", "pcWriter", "PDEditor", "pidwriter", "dpWrite", "pidWriter", "pdEditor", "pcwriter", "pcWrite", "tdWriter", "PDReader", "dpEditor", "tdEditor", "dpReader", "tdWriting", "pidWrite", "PDWrite", "pdwriter", "dpWriter", "tdReader"]}}
{"id1": "3801655", "id2": "3184073", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"helper": ["hyporter", "duter", "duporter", "helpmer", "helporter", "helphel", "transer", "hoper", "helpter", "duper", "heler", "hyper", "hoter", "transmer", "hyter", "helmer", "hoer", "hyhel", "duhel", "helpporter", "transper", "helhel", "helpper", "helter", "homer", "transter"], "dataset": ["Datasetter", "datatet", "datassET", "dataassets", "Datassset", "Datassetter", "datarsset", "datisset", "datatets", "dataasetter", "databaseset", "dataasET", "datasets", "datassetter", "Datasset", "dataassetter", "databasesET", "datarset", "databasesets", "datasetter", "datisET", "datiset", "datasset", "datatetter", "datisets", "datbasetic", "Datassets", "dataassetic", "dataaset", "dataasetic", "datisetter", "Dataset", "datbasetter", "datassetic", "datatset", "datasET", "datasetic", "Datasets", "datisetic", "datbasET", "dataasset", "datassets", "dataassset", "dataasets", "datarsET", "dataassET", "datarsets", "datassset", "databasesset", "datbaset"], "zip": ["folder", "z", "pdf", "sea", "cf", "wrap", "archive", "zone", "ze", "box", "io", "tar", "xml", "pack", "zero", "pkg", "link", "Zip", "install", "jar", "dir", "xf", "file", "sheet", "bag", "lex", "code", "directory", "rar", "lock", "system", "comp", "mail", "feed", "se", "json", "ip", "download", "zo", "lib", "module", "project", "handle"], "entries": ["contrys", "enries", "entsents", "entables", "enresses", "tables", "entslements", "attities", "entsrys", "attries", "entities", "entires", "getries", "entresses", "entents", "entsries", "tries", "getlements", "enires", "attrys", "Entities", "currs", "Entresses", "contresses", "Entables", "trs", "contries", "attents", "entsers", "enters", "contires", "entlements", "Entries", "Entires", "Entrs", "entsities", "entrs", "curries", "enrys", "getrys", "Enters", "Entrys", "Entents", "geters", "Entlements", "trys", "currys", "curables", "entrys"], "performance": ["maximum", "work", "grade", "scale", "sum", "capacity", "speed", "due", "union", "test", "duration", "volume", "load", "ul", "dimension", "expected", "spec", "step", "storage", "shape", "force", "cost", "mult", "split", "fit", "minimum", "util", "log", "evaluate"], "index": ["length", "max", "update", "value", "count", "level", "total", "capacity", "order", "offset", "set", "limit", "size", "Index", "j", "available", "x", "connection", "pos", "lock", "ind", "open", "seek", "loop", "number", "type"], "entry": ["context", "record", "office", "ry", "match", "channel", "archive", "cont", "data", "instance", "char", "enter", "ent", "e", "io", "test", "cell", "member", "xml", "it", "or", "part", "resource", "add", "link", "jar", "key", "item", "sheet", "ie", "name", "word", "element", "ace", "se", "internal", "keeper", "row", "next", "Entry", "job", "module", "result"], "temp": ["pdf", "copy", "mt", "wrap", "tc", " tmp", "mint", "thread", "mk", " temporary", "dest", "tim", "por", "partial", "empty", "test", "tar", "EMP", "pre", "pt", "wrapper", "mod", "table", "orig", "emp", "dir", "file", "mp", "tmp", "base", "parent", "porary", "tr", "cp", "this", "current", "txt", "template", "Temp", "mem", "create", "created", "tem", "tm", "null", "fake", "tab", "tx", "t", "root", "local", "stem"], "writer": ["riter", "output", "writers", "server", "stream", "ger", "message", "window", "er", "external", "thread", "service", "driver", "iterator", "owner", "player", "handler", "print", "penter", "network", "walker", "maker", "wrapper", "loader", "wrote", "worker", "ter", "creator", "browser", "ler", "builder", "file", "document", "console", "writ", "rw", "wp", "connection", "parent", "Reader", "system", "write", "ner", "wire", "writing", "iter", "null", "variable", "Writer", "w", "master"], "reader": ["readable", "dr", "stream", "ry", "ri", "er", "peer", "iterator", "driver", "handler", "ard", "wrapper", "loader", "volume", "runner", "reading", "ro", "builder", "file", "rr", "rar", "Reader", "rx", "ner", "r", "input", "iter", "inner", "feed", "rer", "row", "roller", "rot", "handle"], "buffer": ["length", "column", "header", "binary", "cache", "message", "capacity", "window", "char", "buf", "queue", "phrase", "stack", "sequence", "database", "block", "scroll", "table", "frame", "bar", "stroke", "document", "batch", "word", "history", "append", "template", "memory", "vector", "iter", "null", "row", "variable", "Buffer", "padding", "buff", "background", "sample", "command", "font"], "read": ["length", "readable", "mix", "bind", "need", "en", "stream", "before", "old", "count", "select", "format", "each", "like", "enable", "print", "Read", "test", "q", "give", "set", "raw", "text", "hold", "reads", "size", "load", "tell", "add", "reading", "ready", "fill", "skip", "report", "READ", "query", "run", "take", "build", "seek", "word", "open", " Read", "check", "write", "used", "mem", "get", "source", "input", "create", "find", "close", "iter", "len", "start", "parse", "time", "end", "next", "send", "handle"], "outfile": ["initFile", "inputbuffer", "outbuffer", "OUTFile", "inputfile", "outchannel", "initfile", "outputstream", "initfolder", "infolder", "inFile", "inputstream", "inbuffer", "initstream", "outstream", " outbuffer", "outputfolder", "infile", "OUTfile", "outputFile", "OUTchannel", "instream", "inchannel", "outputfile", " outstream", " outFile", "outFile", "outfolder", " outchannel", "inputFile"], "line": ["column", "ine", "header", "liner", "online", "port", "eline", "message", "char", "detail", "string", "e", "ln", "lo", "le", "chain", "phrase", "cell", "sequence", "section", "block", "lin", "text", "frame", "inline", "Line", "link", "note", "page", "range", "comment", "file", "code", "msg", "word", "train", "iter", "statement", "l", "row", "lines", "log", "LINE", "sample", "point"], "parser": ["processor", "operator", " scanner", "format", "er", "pair", "cer", "arser", "iterator", "handler", "hander", "Parser", "magic", "bank", "xml", "maker", "loader", "penter", "layer", "walker", "worker", "runner", "ler", "builder", "file", "auto", "asser", "music", "lp", "system", "uler", "ner", "conv", "policy", "rer", "parse", "finder"], "list": ["LIST", "record", "output", "match", "data", "level", "detail", "dict", "listed", "group", "chain", "sequence", "print", "member", "queue", "collection", "array", "part", "map", "table", "li", "all", "range", "lists", "file", "left", "batch", "menu", "parent", "pool", "out", "l", "null", "ist", "result"], "rule": ["record", "value", "field", "node", "style", "match", "rol", "relation", "feature", "chain", "block", "definition", "rank", "rl", "re", "table", "Rule", "range", "item", "file", "run", "function", "force", "rr", "role", "ULE", "r", "statement", "policy", "row", "play", "parse", "ule", "filter", "command", "module", "result"], "measure": ["Measure", "measured", "peasuring", "peasure", "MEMeasure", "Measuring", "measuring", "peasured", "Measured", "MEasured", "MEasuring", "meMeasure", "peMeasure", "MeMeasure", "MEasure"]}}
{"id1": "12454178", "id2": "397240", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"alterar": [" scalasar", " ingestar", " scalada", " consequado", " scalar", " ingestada", " ingestasar", " consequar", " alterado", " alterada", " consequada", " scalado", " alterasar", " ingestado", " consequasar"], "t": ["translation", "et", "wt", "ot", "tg", "rt", "tp", "mt", "z", "tip", "b", "p", "ht", "v", "dt", "typ", "tc", "task", "mint", "total", "te", "ent", "e", "q", "tree", "pt", "tu", "m", "st", "it", "c", "ret", "trace", "table", "ti", "qt", "ter", "to", "ts", "j", "a", "x", "nt", " ot", "y", "tr", "det", "T", "out", "txt", "h", "template", "ta", "title", "get", "i", " pt", "g", "tm", "l", "vt", "type", "ct", "o", "temp", "at", "w", "tt", "n"], "stmt": [" superstmt", " stMT", "stMT", " supersttx", " stsm", " sttxt", " superstMT", "Sttm", "StMT", "ttmp", " stmr", "sysm", " stmon", "stmk", "stm", "stmp", "stsm", "ttm", " ststat", " stmp", "sym", "stmon", "irstmk", "sttxt", "stysm", "stytx", " supersttxt", "stytm", " superstmr", " sttx", " stm", "ststat", "stym", "stymt", "Sttx", "Stmp", "sttx", "stmr", "Stmr", "ttmt", "ttstat", "Stmk", "irstmt", "irsttx", "irstMT", "symon", "Sttxt", "stymon", "sttm", " sttm", "styMT", "Stmt", "symt", " stmk", "Stm", "Ststat"], "sql": ["initial", "el", "cmd", "software", "seed", "ls", "dl", "select", "format", "description", "sd", "s", "string", "csv", "ln", "wal", "sys", "q", "pel", "xml", "sq", "scl", "table", "nl", "spec", "sv", "query", "expression", "sol", "lex", "fn", "QL", "name", "lock", "template", "sk", "su", "l", "url", "ql", "SQL", "series", "spr", "n"], "id_disciplina": ["id_disciine", "id_Discomplina", "id_disgrain", "id_disgrine", "id_disciini", "id_Discipline", "id_disciplinate", "id_discomina", "id_disgrini", "id_displine", "id_displinate", "id_disciplINA", "id_displINA", "id_descipline", "id_displina", "id_disciplain", "id_disrigINA", "id_DisciplINA", "id_desciplain", "id_discomplini", "id_discompline", "id_Discompline", "id_Disciplain", "id_disgrina", "id_displini", "id_discomplain", "id_discomain", "id_descomplini", "id_DisciplineINA", "id_disriginate", "id_discomplina", "id_Discomplain", "id_Disciplini", "id_Disciplineinate", "id_discipline", "id_descompline", "id_desciplina", "id_disriginator", "id_Disciplineina", "id_disciplineina", "id_disciina", "id_disciplinator", "id_disciplineINA", "id_disciplineinator", "id_disciplini", "id_descomplina", "id_disciplineinate", "id_discomini", "id_displinator", "id_Disciplinate", "id_descomplain", "id_Disciplina", "id_disciain", "id_Disciplinator", "id_Discomplini", "id_desciplini", "id_Disciplineinator", "id_displain", "id_disrigina", "id_discomine"], "item": ["image", "mi", "object", "tip", "store", "id", "Item", "p", "other", "hit", "match", "ex", "task", "instance", "rec", "items", "e", "me", "iso", "entry", "in", "article", "it", "bar", "link", "key", "obj", "component", "menu", "event", "word", "unit", "element", "team", "i", "iter", "row", "site", "info", "job", "local"]}}
{"id1": "7468819", "id2": "7846688", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "code2": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"run": ["running", "invoke", "poll", "exec", "Run", "work", "profile", "task", "launch", "runs", "begin", "thread", "process", "test", "hello", "block", "runner", "execute", "unit", "call", "loop", "submit", "start", " Run", "wait", "go", "func"], "con": ["cn", "const", "cal", "cmd", "en", "co", "cf", "rc", "mos", "ran", "fin", "com", "dial", "connect", "nc", "canon", "sin", "don", "cc", "clean", "ln", "un", "conn", "c", "pen", "re", "Con", "comm", "connection", "gc", "Conn", "construct", "res", "ain", "cos", "act", "ch", "cp", "pc", "CON", "open", "client", "cur", "syn", "ctrl", "win", "conv", "cone", "create", "conf", "cons", "cl", "url", "ct", "bur", "xc", "cm", "acon", "fc", "cont", "can"], "encodedPassword": ["encachedResponse", "encodingPassword", "decodingData", "encodingpassword", "encachedpassword", "encuredResponse", "encryptedPass", "encodedData", "encuredPassword", "encressedPassword", "encodedpassword", "encodingPass", "encodedPass", "decodedUser", "enccodedPassword", "decodedResponse", "decachedResponse", "encryptedData", "encressedUser", "enccodedPass", "enccodedData", "encachedUser", "encachedPassword", "decodedPassword", "encodedUser", "decodedPass", "decodingPass", "decachedPassword", "decodingpassword", "encodedResponse", "encuredUser", "encressedResponse", "encryptedpassword", "decodedData", "decodingPassword", "encressedpassword", "encryptedPassword", "decachedUser", "encuredpassword", "enccodedpassword", "encodingData", "decodedpassword", "decachedpassword"], "encoder": [" encoding", "decoded", "Encoser", "decater", "ecODE", "decODE", "decoder", "Encoder", " encoser", "encoding", "ecoding", "enODE", "Encater", "enoding", "encoded", "ecoded", "encoser", "decoser", "enoded", "encODE", "ecoder", "Encoding", "enoder", "encater", " encater", "decoding"], "is": ["isa", "fs", "isl", "sis", "ins", "lis", "ri", "iss", "are", "ris", "bs", "rs", "ir", "ists", "isi", "ib", "il", "nis", "s", "si", "ai", "ys", "sys", "ms", "iso", "in", "it", "ic", "sit", "as", "IS", "iris", "Is", "isc", "i", "se", "isf", "es", "os", "asin", "ais", "its", "ist", "isin", "im", "was", "ios"], "rd": ["hr", "din", "dr", "dd", "rt", "mr", "ri", "rc", "rs", "red", "nd", "rh", "rg", "RD", "rand", "rect", "rid", "rob", "rl", "rn", "ru", "fr", "rw", "rr", "rar", "ren", "rx", "reader", "ind", "cr", "r", "ld", "cd", "rb", "rod", "erd", "ra", "sr", "bd", "nder", "d", "xd"], "line": ["column", "record", "ine", "header", "liner", "eline", "message", "detail", "string", "ln", "ice", "le", "chain", "print", "phrase", "cell", "sequence", "lo", "block", "lin", "entry", "re", "frame", "nl", "Line", "inline", "link", "page", "stroke", "comment", "label", "file", "lane", "code", "base", "name", "word", "se", " LINE", "l", "row", "log", "LINE", "sample", "point", "command"], "response": ["image", "onse", "reply", "output", "value", "server", "position", "model", "data", "message", "relation", "detail", "description", "service", "format", "list", "csv", "print", "sequence", "buffer", "database", "tree", "xml", "network", "resp", "application", "continue", "request", "view", "answer", "collection", "trace", "array", "table", "frame", "page", "report", "connection", "document", "res", "console", "sheet", "library", "relative", "pos", "this", "display", "template", "vector", "memory", "respons", "results", "reset", "Response", "json", "summary", "next", "command"], "lastIteraction": [" lastInteration", "lastInterate", " lastRelate", " lastiterate", " lastiterated", " lastIterated", " lastIteration", " lastiterations", " lastIterate", "lastInterated", "lastIteration", " lastRelation", " lastiteration", " lastRelated", "lastIterated", " lastIterations", " lastRelations", " lastInterations", " lastInterated", "lastIterations", "lastInterations", "lastInteration", "lastIterate", " lastInterate"], "result": ["value", "cache", "data", "message", "Result", "content", "string", "buffer", "str", "err", "request", "ret", "answer", "status", "reason", "page", "report", "query", "res", "current", "out", "r", "results", "json", "url", "success"], "e": ["f", "u", "pe", "ine", "en", "b", "p", "v", "xe", "ep", "ex", "ec", "ze", "er", "te", "ent", "ae", "ev", "s", "eu", "ne", "le", "ate", "E", "err", "m", "me", "eg", "c", "error", "ei", "or", "re", "a", "note", "x", "ie", "be", "h", "ue", "se", "r", "i", "oe", "g", "es", "exc", "l", "t", "o", "eeee", "d", "ee", "n"]}}
{"id1": "16590954", "id2": "17557289", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"createJAR": ["createGAR", "saveJAR", "saveIJAR", "createGART", "createPHAR", "createIJAR", "saveIJART", "saveIJARS", "createGARS", "createGAP", "createJAP", "createJARS", "createPHART", "createIJAP", "saveJART", "createPHAP", "saveIJAP", "createJART", "createIJART", "saveJAP", "createPHARS", "saveJARS", "createIJARS"], "fileString": ["fileStr", "messageString", " fileRest", "FileStr", "FileString", "ilestring", "FileRest", "pathstring", "pathStr", "ileName", "FileText", "fileRest", "pathString", "ileRest", "Filestring", "messageStr", "messageText", " fileStr", "ileString", "fileName", " filestring", "messageName", "ileStr", " fileName", "fileText", "filestring", "FileName", " fileText"], "ext": ["Ext", "cmd", "exp", "ix", "EXT", "ex", "typ", "enc", "char", "format", "external", "pat", "e", "path", "except", "str", "gz", "text", "ime", "js", "xp", "tex", "fr", "req", "ort", "prot", "suff", "name", "ind", "append", "txt", "exe", "off", "xt", "type", "desc", "end", "t", "rest", "cont"], "file": ["f", "image", "store", "output", "port", "work", "model", "class", "channel", "cache", "data", "message", "format", "list", "module", "disk", "path", "foo", "le", "io", "user", "buffer", "tree", "from", "File", "resource", "http", "table", "FILE", "link", "to", "page", "report", " File", "document", "run", "force", "base", "parent", "pool", "name", "lock", "this", "open", "line", "fp", "h", "ile", "get", "source", "input", "doc", "memory", "mail", "db", "null", "type", "url", "default", "time", "t", "log", "info", "local", "handle"], "i": ["f", " j", "mi", "ami", "ri", "id", "p", "pi", "v", "ir", "ini", "ii", "s", "si", "ai", "bi", "n", "m", "c", "li", "j", "xi", "x", "phi", "ind", "is", "ui", "di", "gi", "ci", "ip", "ati", "o", "t", "index", "I"], "dir": ["div", "loc", "folder", " Dir", "del", "rel", "dd", "dy", "org", "id", " d", "ir", "home", "disk", "path", "addr", " directory", " folder", "pkg", "mod", "part", "direction", "vol", "dist", "DIR", "star", "tmp", "directory", "ind", "done", "uri", "wd", "db", "url", "Dir", "root", "direct", "d", "lib", "project"], "jarFile": ["jarField", "jFile", "jarfile", "jarName", "pkgFile", "jarEmail", "jfile", "javaFilename", "javaFile", " jarField", " jarFILE", "tarfile", "tarFilename", "jName", "JarFilename", "tarEmail", "pkgField", "JarFILE", " jarEmail", " jarFilename", "jFilename", "tarFile", "JarFile", "JarField", "JarEmail", "jarFILE", "Jarfile", "javafile", "javaName", "jarFilename", "pkgFILE", " jarfile", " jarName"], "fstrm": [" fdrum", "fslcm", "fcrdm", "ftrmed", "fstrmed", "ftrdm", " fstrcm", " fdrmed", "fstrp", " fstrum", "fsprm", "fbstrm", "fcrm", "fsprms", "ftrms", " fdrcm", " fdrm", "fcrp", "fstrms", "fbstrdm", "fstrum", "fsprdm", "fcrms", "ftrum", "fdrcm", "fdrmed", "fslm", "fstrdm", "fbsprdm", "fbstrp", "fbstrms", "fstrcm", "fsprp", "ftrcm", "ftrp", " fstrmed", "fslum", "fslmed", "fdrum", "fdrm", "fbsprms", "fbsprm", "ftrm", "fbsprp"], "in": ["f", " IN", "ins", "din", "inside", "en", "pin", "IN", "sin", "inn", "ai", "io", "inf", "gin", "cin", "m", "mm", "bin", "from", "it", "ic", "re", "add", "init", "ind", "is", "inc", "up", "rin", "input", "r", "iter", "inner", "oin", "o", "isin", "im", " din", "read", "In", "pi"], "out": ["cn", "output", "OUT", "co", "v", "p", "serv", "ex", "channel", "s", "net", "io", "outer", "m", "conn", "outs", "c", "it", "OU", "writer", "ou", "inv", "to", "obj", "gc", "aos", "cos", "ch", "client", "conv", "inner", "os", "null", "t", "o", "cm", "Out", "at", "w", "cont", "n"], "temp": ["mt", "output", "copy", "tt", "p", "wrap", "cache", "cont", "tc", " tmp", "mint", "mk", "thread", " temporary", "path", "dest", "EMP", "buffer", "tar", "mm", "pt", "m", "tree", "term", "mod", "to", "orig", " Temp", "emp", "document", "res", "Tem", "mp", "tmp", "directory", "porary", "pool", "cp", "name", "parent", "zip", "current", "template", "Temp", "memory", "full", "mem", "tm", "tem", "fake", "null", "tx", "t", "util", "TM", "local", "stem"], "fstrm2": ["fstrp1", "fstrp7", "fstrM7", "fstrm1", "fStrm7", "fStrm2", "fstrcm2", "fstrmm1", "fstrM1", "fstrtm2", "fstrm7", "fStrtm1", "fstrmm2", "fstrcm1", "fStrp7", "fStrtm2", "fstrM2", "fStrp1", "fstrcm7", "fStrp2", "fstrtm1", "fStrm1", "fstrp2"], "ostrm": [" ostrem", "astRM", "istnm", "ostrom", "ortlamm", "astm", "istmr", "astrem", "osrem", " ostm", "ostnm", "ostrem", "ortrom", "ostlamm", "istRM", "astlamm", "osmr", "istrem", "astrom", "osRM", "astrm", "osm", "osrm", "ostm", "ortrm", " ostrom", "istrm", "ostRM", " ostnm", "oslamm", "astmr", "osnm", "istm", " ostRM", "ortRM", "ostmr", " ostlamm"], "docFile": ["Docfile", "docFiles", "documentLine", "DocFiles", "manDir", "docLine", " docPath", "manfile", "DocLine", " docfile", "docfile", "documentDir", " docDir", "docPath", " docLine", "manFile", " docFiles", "manPath", "documentFiles", "docDir", "documentFile", "DocFile", "DocDir", "DocPath"]}}
{"id1": "9261777", "id2": "22801734", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"source": ["context", "scope", "copy", "store", "search", "style", "SOURCE", "script", "language", "where", "char", "service", "lower", "back", "string", "content", "path", "target", "form", "origin", "sequence", "ource", "src", "subject", "tree", "str", "from", "clip", "text", "view", "resource", "status", "volume", "size", "table", "spec", "reason", "prefix", "init", "sql", "query", "expression", "file", "body", "base", "parent", "address", "check", "ui", "template", "details", "input", "filename", "uri", "se", "config", "title", "start", "Source", "sample", "ce", "info", "site", "use", "component", "index"], "destination": ["portine", "testinator", "distinant", "goodination", "declination", "portend", "distinator", "certacement", " destinator", "distinations", "goodinate", "origend", "combinant", "combination", "combinations", " destinate", "testination", "certinate", "destino", "destine", "portinator", "originator", " destino", "declinations", "certination", "declinate", "tempinate", "origination", "destinate", "goodinator", "goodacement", "destinant", "origine", " destine", "tempination", "declinator", "tempino", "portination", "combinator", "destinations", "declinant", "declacement", "testino", "destacement", "certinator", "distination", "destend", "testinate", "tempinator", "destinator", " destend"], "is": ["isa", "isl", "sis", "icks", "ins", "zes", "lis", "ri", "iss", "bits", "ris", "are", "bs", "ir", "dis", "ib", "isi", "nis", "us", "s", "si", "ms", "sys", "obs", "ns", "iso", "has", "in", "ic", "js", "webkit", "ains", "was", "bis", "tis", "ics", "ts", "ois", "ims", "init", "IS", "iris", "ie", "vis", "vs", "Is", "ires", "mis", "isc", "mus", "i", "oss", "isf", "iter", "es", "abs", "ip", "ais", "its", "ist", "info", "isin", "im", "ps", "ios"], "os": ["fs", "oos", "css", "osi", "ot", "bs", "mos", "dis", "mot", "ose", "s", "io", "ys", "sys", "ns", "obs", "ms", "on", "asis", "ss", "zero", "outs", "or", "dos", "oses", "bis", "mes", "ts", "bos", "aos", "uts", "ox", "cos", "Os", "pos", "oS", "ob", "oss", "ops", "es", "\u00f3", "ost", "ks", "oes", "o", "los", "OS", "oa", "ols", "ones", "ios"], "buffer": ["binary", "cache", "message", "total", "window", "buf", "queue", "stack", "sequence", "database", "phrase", "block", "view", "button", "table", "frame", "bar", "available", "paste", "comment", "shape", "document", "batch", "library", "event", "word", "append", "template", "memory", "display", "mem", "row", "variable", "Buffer", "padding", "buff", "background", "sample", "pad", "temp", "command", "history"], "length": ["distance", "th", "bow", "ty", "frequency", "angle", "position", "ith", " Length", "integer", "count", "capacity", "total", "string", "path", "ment", "partial", "sequence", "stop", "offset", "duration", "database", "text", "volume", "collection", "size", "load", "ence", "span", "reading", "width", "shape", "tail", "ength", "of", "family", "ind", "before", "height", "split", "display", "loop", "number", "len", "character", "last", "bus", "needed", "full", "l", "enth", "start", "type", "time", "padding", "end", "pad", "point", "hello", "component", "Length", "history", "ENGTH"]}}
{"id1": "7044685", "id2": "11005804", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encrypt": ["cryption", "encrypted", "Encrypt", "crypt", "Encryption", "encryption", "Encrypted", "crypted", " encryption", " encrypted"], "plaintext": ["plainstring", "plainText", " plainText", "plainprint", " plainprint", " plaindata", "messagetext", "mainText", "messageprint", "aintext", "aindata", "messagedata", "messageText", "maintext", "ainprint", "mainstring", "plaindata", " plainstring", "ainstring", "ainText"], "d": ["f", "z", "dd", "dr", "ord", "p", "dx", " md", "red", "dl", "nd", "dat", "dec", "dal", "dh", "sd", "ded", "e", "od", "did", "m", "debug", "pd", "mod", "c", "da", "D", "ds", "de", "md", "ad", "df", "y", "dm", "ind", "h", "done", "ld", "g", "di", "db", "l", "cd", "bd", "t", "end", "fd", "hd", "gd", "w", "dig"]}}
{"id1": "1180878", "id2": "7149578", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrlStream", "fetchUrlData", "fectURLdata", "fetchGETdata", "fectURLStream", "fectUrldata", "fetchStringdata", "fetchStringData", "fetchUrlFrame", "fetchURLFrame", "fectUrlData", "fetchStringFrame", "fetchGETStream", "fectUrlFrame", "fetchURLStream", "fetchGETData", "fetchURLdata", "fectURLFrame", "fetchUrldata", "fectUrlStream", "fectURLData", "fetchStringStream", "fetchGETFrame"], "url": ["loc", "host", "rel", "el", "sl", "ssl", "domain", "gl", "b", "https", "location", "ls", "dl", "pattern", "string", "path", "web", "ref", "print", "lim", "ll", "xml", "resource", "http", "ul", "nl", "link", "ur", "sql", "URL", "file", "base", "address", "name", "mount", "mail", "full", "pl", "uri", "Url", "l", "cl", "null", "default", "log", "html"], "proxyHost": ["slavehost", " proxyCheck", "proxyName", "slaveLabel", "slaveHost", "ProxyLabel", "ProxyUrl", "ProxyName", " proxyAddress", "roxyOver", "roxyLabel", "roxyhost", "proxyLabel", "proxyAddress", "slaveAddress", "roxyAddress", "proxyOver", "proxyhost", "serverHost", "slaveUrl", "roxyHost", "proxyUrl", " proxyName", "serverhost", "ProxyPort", "serverPort", "slaveOver", "serverName", "Proxyhost", " proxyhost", "roxyUrl", "proxyCheck", " proxyOver", "roxyCheck", "slaveCheck", "ProxyHost"], "proxyPort": ["aliasport", " proxyport", " proxyAddress", "aliasPort", "proxyAddress", "serverport", "serverHost", "proxyport", "aliasAddress", "ProxyPORT", "aliasHost", "serverPort", "ProxyPort", "Proxyport", " proxyPORT", "serverPORT", "ProxyHost", "proxyPORT", "serverAddress"], "con": ["cn", "cover", "cal", "const", "cmd", "en", "co", "cs", "ran", "fin", "cf", "mo", "ex", "dial", "com", "bo", "connect", "nc", "canon", "rec", "cc", "don", "ln", "un", "cgi", "conn", "func", "c", "pen", "col", "Con", "comm", "gate", "trans", "sub", "ver", "ocon", "connection", "mc", "Conn", "po", "cos", "pc", "ain", "cp", "cond", "act", "non", "CON", "fac", "client", "open", "call", "lock", "cur", "syn", "ctrl", "bc", "conv", "cone", "conf", "cat", "cons", "proc", "close", "pan", "xc", "go", "fc", "cont", "can"], "is": ["isa", "fs", "sis", "isl", "ins", "xs", "lis", "iss", "bits", "are", "ris", "ri", "rs", "dis", "ists", "bs", "cs", "isi", "us", "s", "si", "gets", "ys", "sys", "ms", "iso", "has", "in", "ains", "ps", "bis", "ts", "ois", "ims", "init", "as", "IS", "iris", "eps", "mis", "Is", "isc", "isp", "i", "oss", "iter", "isf", "es", "os", "abs", "ip", "ais", "its", "ist", "isin", "im", "was", "ios"], "u": ["nu", "pu", "uid", "cu", "uf", "yu", "us", "lu", "eu", "user", "un", "uni", "tu", "iu", "au", "c", " nu", "ou", "ul", "hu", "ru", "ur", "U", "fu", "uu", "bu", "uv", "ud", "ui", "up", "ue", "i", "su", "uj", "uri", "g", "mu", "o", "ut"], "proxy": ["host", "translation", "pe", "PRO", "domain", "server", "ssl", "pin", "pi", "port", "https", "cache", "bo", "profile", "jp", "friend", "token", "web", "pointer", "xy", "pre", "py", "embed", "via", "gp", "timeout", "slave", "http", "map", "ping", "alias", "link", "socket", "browser", "phone", "x", "connection", "po", " prox", "base", "pipe", "library", "pool", "cp", "zip", "Proxy", "address", "cas", "client", "pro", "pse", "aco", "policy", "prime", "null", "roxy", "version", "ip", "echo", "shadow", "cone", " proxies", "password", "go", "project", "XY"], "baos": ["vaoS", "aois", "aoos", "baose", "naoss", " baoS", "BAos", " bais", "vaOS", "poo", "poOs", "baoS", "aoOS", "vais", "BAOs", " baOs", " baose", " bao", "baows", "naos", "BAows", "bao", "bais", "naows", " baOS", "nao", "baOS", "baoss", "poos", "poose", " baoss", "baOs", "BAo", " baows", "vaos", "BAoss", "BAose", "aooS"]}}
{"id1": "3401153", "id2": "17627195", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "label": 0, "substitutes": {"getHTML": ["processPDF", " getJS", "getURL", "getJS", " getPDF", "getPDF", "processHTML", "printPDF", " getURL", "printURL", "printJS", "printHTML", "processURL", "processJS"], "pageURL": ["pageUR", "pageurl", "baseURL", "pageURI", "PageURI", "cacheUrl", "cacheURI", "cacheurl", "baseUR", "Pageurl", "pageUrl", " pageUR", "baseUrl", " pageUrl", "PageURL", " pageURI", "cacheURL", "PageUrl", "PageUR", " pageurl", "baseURI"], "encoding": ["decuation", "Encuation", "enaching", "enuation", "decoder", "Encoder", "ecoding", "enoding", "encoded", "ecoded", "decaching", "uncoder", "Encoded", "encoder", "encaching", "decoding", "ecaching", "ecoder", "Encoding", "encuation", "uncoded", "enoder", "uncoding", "Encaching", "uncaching"], "dirPath": ["viewPath", "directoryPath", " dirDirectory", "pkgPath", "dirDir", "dirPATH", "pathDir", "folderRoot", "directoryName", " dirPATH", "directoryDir", "directoryDirectory", " dirDir", "directoryPATH", "dirName", " dirFile", "dirFile", "pkgDir", "viewPATH", "pathFile", "folderDir", "folderFile", "pathPath", " dirName", "pkgName", "dirRoot", "viewDir", "pathRoot", " dirRoot", "pkgDirectory", "dirDirectory", "viewName", "folderPath"], "pageHTML": [" pagePUT", " pageMD", "viewHTML", "pageWP", " pageSQL", "pageJSON", "searchHTML", " pageWP", "searchURL", "pageHT", "pointHTML", "pointJS", "PageHTML", " pageJS", "searchHT", "displayJS", "viewPUT", "componentHTML", "searchJS", "PageJS", "pageSQL", "componentWP", "ageJSON", " pageAPI", " pageHT", "viewJSON", "componentSQL", "ageMD", "pageMD", "ageHT", "PageHT", "PageURL", "displayHTML", "PageHTTP", "pagePUT", "pageAPI", " pageHTTP", "displayURL", " pageJSON", "componentHT", "viewMD", "ageWP", "entryAPI", "displayHTTP", "agePUT", "pageJS", "pointAPI", "entryJS", "entryHTML", "entryHTTP", "pageHTTP", "ageSQL", "pointHTTP", "ageHTML"], "connection": ["processor", "engine", "server", "established", "position", "channel", "bo", "Connection", "relation", "connect", "nc", "communication", "message", "description", "con", "web", "user", "io", "generation", "database", "network", "conn", "application", "entry", "c", "government", "resource", "http", "writer", "response", "internet", "link", "socket", "to", "creator", "browser", "session", "document", "console", "operation", "connected", "reference", "directory", "library", "current", "open", "client", "ion", "number", "character", "still", "uri", "statement", "close", "condition", "creation", "remote", "command"], "url": ["f", "rel", "sl", "ssl", "gl", "b", "https", "p", "atl", "location", "ls", "dl", "api", "bel", "google", "path", "net", "web", "str", "ll", "conn", "loader", "resource", "http", "rl", "ul", "nl", "link", "ur", "URL", "base", "address", "name", "open", "client", "get", "r", "uri", "Url", "l"], "br": ["hr", "dr", "mr", "bl", "b", "bs", "bf", "BR", "er", "buf", "bp", "vr", "lr", "str", "kr", "shr", "bro", "bridge", "fr", "bh", "Br", "ber", "sp", "bt", "tr", "be", "ch", "gb", "pr", "cr", "r", "bc", "rb", "bd", "sr", "bb", "wr"], "line": ["quote", "entity", "ine", "field", "style", "liner", "online", "eline", "email", "detail", "string", "ln", "user", "le", "chain", "print", "phrase", "cell", "sequence", "section", "block", "lin", "entry", "continue", "text", "frame", "nl", "Line", "stroke", "inline", "page", "stay", "comment", "range", "label", "link", "code", "word", "number", "source", "l", "row", "log", "LINE", "sample", "point"], "e": ["f", "ine", "pe", "en", "p", "xe", "ex", "je", "ze", "er", "fe", "ge", "ae", "te", "ent", "ve", "le", "ne", "ed", "E", "err", "ode", "error", "he", "re", "ke", "de", "ite", "esome", "x", "eb", "ie", "be", "event", "see", "ue", "se", "oe", "es", "eeee", "ce", "ee"], "file": ["f", "image", "et", "el", "output", "port", "work", "data", "task", "email", "path", "web", "le", "io", "print", "buffer", "File", "resource", "table", "FILE", "tile", "link", "ca", "page", "report", "dir", " File", "base", "parent", "directory", "name", "lock", "out", "fp", "h", "ile", "mail", "db", "log", "handle"], "bufferedWriter": ["buffererWriter", "buffererMember", " bufferedwriter", "builteredWriter", "bufferedClient", "bufferedReader", "bufferredHelper", "bufferredClient", "bufferingReader", "builteringMember", "buffenedWrite", "bufferedStreamer", "buffererReader", "bufferredWriter", "buffaredStreamer", " bufferedWrite", "builteringWriter", "buffenedWriter", "bufferedHelper", "builteringReader", "bufferingWrite", "buffaredWrite", "buffenedHelper", " bufferedHelper", " bufferredwriter", "bufferredWrite", " bufferredWrite", "buffaredWriter", " bufferredClient", "builteredMember", " bufferredStreamer", "bufferingStreamer", "bufferredStreamer", " bufferedStreamer", " bufferredHelper", "bufferingClient", " bufferredWriter", "bufferedwriter", "bufferingwriter", "buffenedClient", " bufferedClient", "buffaredMember", "bufferredwriter", "bufferingMember", "bufferedMember", "buffaredReader", "bufferingHelper", "buffaredwriter", "bufferingWriter", "bufferedWrite", "builteredReader"]}}
{"id1": "13333160", "id2": "6501291", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"run": ["running", "exec", "flow", "ran", "scan", "Run", "work", "process", "wal", "test", "view", "runner", "eval", "read", "apply", "render", "query", "execute", "unit", "pass", "proc", "app", "start", "go", "action"], "xmlIn": ["xmlOut", "domOut", "jsonIn", "domIns", "jsonIns", "xOut", "domInput", "xmlInput", "htmlin", " xmlIns", "htmlIn", "fileIn", "xInput", "fileIns", "xIns", "jsonOut", " xmlin", "filein", "domIn", "xmlin", "xmlIns", "htmlIns", "jsonInput", "xIn"], "out": ["output", "OUT", "stream", "p", "v", "ex", "s", "io", "err", "set", "sw", "in", "raw", "outs", "OU", "ou", "to", "report", "obj", "file", "res", "aos", "nt", "pool", "client", "off", "up", "d", "i", "one", "os", "null", "o", "t", "end", "log", "ws", "Out", "w"], "dom": ["div", "host", "el", "dr", "Dom", "domain", "node", "p", "iam", "model", "dl", "mom", "dn", "data", "window", "atom", "utils", "process", "web", "DOM", "m", "tree", "xml", "om", "parser", "frame", "comm", "j", "fr", "page", "browser", "dem", "img", "md", "document", "df", "dm", "doc", "db", "os", "cd", "yang", "mat", "html", "d", "result"], "f": ["fs", "ft", "cf", "bf", "v", "uf", "lf", "fm", "fo", "af", "inf", "ff", "Factory", "tf", "sf", "it", "c", "fb", "fr", "fx", "xf", "fg", "df", "of", "fy", "fort", "fac", "fi", "full", "fab", "forge", "foreign", "g", "conf", "l", "conv", "fl", "fd", "rf", "F", "d", "w", "fc"], "b": ["bs", "bf", "p", "v", "e", "bi", "nb", "m", "c", "ab", "fb", "a", "j", "bh", "bg", "B", "sb", "builder", "eb", "base", "bt", "be", "mb", "gb", "Builder", "r", "bc", "g", "db", "l", "rb", "bd", "bb", "d", "pb"], "root": ["div", "object", "rt", "node", "ax", "DOM", "ro", "res", "rap", "ram", "used", "h", "get", " rooted", "null", "row", "ok", "roots", "module", "host", "scope", "instance", "owner", "chain", "tree", "m", "bot", "nav", "rank", "table", "rown", "browser", "roid", "document", "ain", "element", "mount", "start", "type", "result", "loc", "cover", "container", "p", "data", "oot", "group", "valid", "raw", "author", " Root", "available", "Root", "base", "parent", "right", "doc", "head", "create", "os", "ow", "top", "av", "mr", "gr", "wrap", "ree", "feature", "area", "box", "bank", "xml", "ul", "r", "primary", "html", "first"], "att": ["feat", "av", "rt", "adj", " attribute", "nat", "ach", "atts", "dat", "data", "alt", "aux", "aj", "addr", "attr", "acc", "apt", "pt", "set", "ac", " dat", "aria", "ar", "ts", "attribute", "ATT", " ut", "tmp", "nt", "attach", "rib", "pet", "tr", "aff", "def", "Att", "txt", "ap", "prop", "ct", "mat", " matt", "t", "info", "at", "tt"], "menu": ["header", "node", "cache", "consumer", " menus", "window", "list", "us", "admin", "um", "chain", "omo", "sequence", "queue", " Menu", "theme", "m", "nav", "tree", "block", "options", "button", "option", "ul", "li", "page", "usage", "category", "item", "Menu", "men", "parent", "library", "settings", "family", "ui", "up", "wiki", "title", "ctrl", "config", "manager", "pie", "row", "mu", "mouse", "next", "site", "summary", "cm", "command", "module", "movie"], "id": ["scope", "value", "uid", "Id", "class", "data", "description", "mid", "target", "ref", "icon", "status", "method", "link", "tag", "key", "init", "file", "name", "pid", "ID", "source", "title", "uri", "version", "type", "url", "ids"], "zout": ["zOut", "izserv", "Zaos", "zipout", "ozOut", " zin", "zipOUT", "ezouts", "zouts", "czOut", "czclient", "zipaos", "zipclient", " zor", "enzout", "zouter", "zipor", "zOUT", "ozoss", "zoss", "Zout", "enzpoint", "ozpoint", "gzout", "izout", "zerOUT", "zpoint", " zaos", "gzin", "czup", " zserv", " zup", "czout", "ozOUT", "ezpoint", "ozup", "Zin", "zserv", "ziposs", "gznet", "zup", "zerout", " zclient", "zeross", "zerot", "ozout", "zipouter", "gzor", "zor", "ezout", "zerOut", "zaos", "zot", "enzOut", "zipnet", " znet", "zipot", "izOut", "ozouter", " zpoint", " zOut", "zipup", "ZOut", "zippoint", "izaos", "zerouter", "zclient", " zouts", "zipin", "ozot", "zipserv", "ozouts", "zipOut", "znet", "zerup", "zin"], "content": ["core", "object", "cmd", "lay", "description", "path", "section", "article", "load", "reason", "page", "comment", "expression", "file", "code", "address", "template", "title", "host", "context", "ontent", "value", "search", "cache", "htm", "string", "tree", "wrapper", "size", "document", "layout", "body", "current", "json", "default", "time", "media", "command", "result", "header", "data", "message", "format", "raw", "request", "c", "metadata", "query", "x", "full", "source", "create", "config", "condition", "padding", "accept", "now", "image", "output", "position", "script", "Content", "sequence", "xml", "block", "text", "pool", "good", "txt", "cur", "inner", "ext", "ce", "html", "read", "cont"], "signal": ["seale", "seal", "signil", " signale", "scale", "scaling", "severale", "severil", " signaling", "SIGNaling", "severAL", " signil", "Signal", "seil", "signAL", "signature", "Signaling", "seAL", "SIGNature", "seature", "Signature", "signaling", " signature", "signale", "sealing", "scal", "scature", "severature", " signAL", "SIGNale", "severaling", "SIGNal", "several"], "n": ["cn", "nu", "z", "num", "nn", "en", "node", "p", "norm", "count", "dn", "nc", "nm", "index", "ln", "N", "sn", "ne", "un", "nw", "ns", "an", "nb", "m", "on", "zero", "natural", "c", "nor", "nl", "j", "nan", "nv", "tn", "mn", "nt", "pos", "nr", "no", "unn", "h", "number", "i", "len", "g", "l", "ni", "t", "o", "np", "d", "ng"], "entry": ["record", "office", "ry", "data", "instance", "enter", "ent", "e", "cell", "member", "RY", "join", "table", "insert", "quick", "add", "link", "page", "comment", "query", "sheet", "connection", "ie", "tmp", "nt", "zip", "system", "element", "cue", "line", "ace", "se", "row", "next", "pixel", "Entry", "log", "slot", "result", "escape"], "pout": ["pond", "ptnew", "zou", " pinner", "pin", "ppent", "pconn", " pconn", "jpout", "ppond", " pin", "ppout", "wpent", "pouter", "jpinner", "phpot", "ptOut", "pinner", " psys", "zinner", "phpnew", " pou", "Pout", "Pin", "pto", "ppto", "wpout", " pond", "zconn", " pto", " pOut", "pOut", "zouter", "phpout", "ppinner", "wpto", "jpou", " pent", "pot", "ptouter", "psys", "POut", "phpsys", "ppot", "ppouter", "wpond", " pnew", "zot", "Psys", "ptout", "pent", " pouter", "pou", "phpOut", "pnew", "phpin", "phpinner", "jpconn", "phpouter"]}}
{"id1": "21010945", "id2": "3745402", "code1": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"runITQLQuery": ["runATSQLCommand", "runITqlStatement", "runATQLCommand", "runITSQLCommand", "runITSQLStatement", "runITSQLquery", "runATSQLStatement", "runATQLStatement", "runITQCommand", "runITQStatement", "runITQLCommand", "runITQQuery", "runATSQLquery", "runITqlquery", "runITQLquery", "runATQLQuery", "runITQLStatement", "runITSQLQuery", "runITqlCommand", "runATQLquery", "runATSQLQuery", "runITQquery", "runITqlQuery"], "itqlQuery": ["itquStatement", "pitQLquery", "ITsqlStatement", "itsqlquery", "itQLString", "itquString", "pitqlStatement", "itququery", "ITqlQuery", "pitqlString", "itSQLquery", "itullQuery", "itqlquery", "itsqlString", "ITsqlString", "itullString", "ITqlquery", "pitQLStatement", "itsqlStatement", "itquQuery", "itsqlQuery", "itQLStatement", "itSQLStatement", "ITqlStatement", "pitqlquery", "ITsqlquery", "pitQLString", "ITqlString", "pitqlQuery", "itqlStatement", "itQLquery", "pitQLQuery", "itqlString", "itQLQuery", "itullquery", "itSQLQuery", "ITsqlQuery"], "escapedItqlQuery": ["escapedItQLRequest", "escapedItQLString", "escapedItQLStatement", "escapedItellString", "escapedItqlStatement", "escapedItsqlQuery", "escapedItsqlStatement", "escapedITqlStatement", "escapedITqlquery", "escapedItsqlString", "escapedItellquery", "escapedItqquery", "escapedItqlquery", "escapedItellRequest", "escapedItellQuery", "escapedITQLStatement", "escapedItQLQuery", "escapedITqlString", "escapedITQLQuery", "escapedItqQuery", "escapedItqlString", "escapedItsqlquery", "escapedItQLquery", "escapedItqlRequest", "escapedItsqlRequest", "escapedITqlRequest", "escapedITQLString", "escapedITQLquery", "escapedItqStatement", "escapedITqlQuery", "escapedITQLRequest"], "url": ["loc", "k", "host", "rel", "el", "u", "sl", "ssl", "server", "org", "https", "location", "ls", "dl", "window", "hl", "email", "external", "string", "web", "path", "un", "ml", "ref", "lr", "lim", "addr", "ll", "term", "resource", "http", "ul", "nl", "link", "www", "ur", "impl", "URL", "build", "base", "ud", "this", "mount", "mail", "ob", "full", "ol", "pl", "len", "uri", "Url", "l", "util"], "urlObject": ["nlOB", " urlOb", "nlObj", " urlObj", "belobject", " urlConnection", "belObject", "urlOb", "nlConnection", "urlOB", "Urlobject", "UrlConnection", " urlOB", "UrlObj", "belObj", " urlobject", "urlObj", "urlConnection", "UrlObject", "nlObject", "belOb", "UrlOB", "UrlOb", "urlobject"], "con": ["cn", "const", "cal", "go", "co", "ran", "cf", "rc", "com", "dial", "ec", "connect", "nc", "sin", "ln", "un", "conn", "c", "pen", "Con", "comm", "ver", "bon", "ocon", " Con", "connection", "mc", "Conn", "ain", "cos", "fn", "soc", "cp", "CON", "open", "fac", "cur", "syn", "ctrl", "bc", "conv", "cone", "commun", "conf", "cons", "win", "apache", "cm", "acon", "fc", "cont", "can"], "br": ["hr", "arr", "dr", "mr", "bl", "b", "bs", "gr", "rain", "bn", "BR", "er", "buf", "bp", "lr", "pre", "kr", "shr", "bro", "bridge", "fr", "bh", "ver", "Br", "ber", "ur", "res", "bt", "tr", "ch", "reader", "pr", "ob", "cr", "r", "bc", "bsp", "ctr", "rb", "bd", "wr", "n"], "arrayList": ["inputList", "arrayArray", "arraySet", "ArrayArray", "instanceList", "arrayLine", "instanceArray", " arraySet", "collectionCollection", " arrayCollection", "instanceSet", " arrayArray", "collectionLine", "collectionList", "ArraySet", "instancelist", " arrayLine", "Arraylist", " arraylist", "inputSet", "inputCollection", "collectionSet", "arraylist", "arrayCollection"], "inputLine": ["lengthLine", "focusLine", "focusline", "virtualL", "inputL", " InputLINE", "inFrom", "singleRow", "virtualLine", "inPath", "fieldFile", " InputLine", "fieldLine", "feedL", " inputPoint", "virtualBlock", "feedLINE", " inputList", "imageByte", "listRow", "inputFrom", "outputLINE", "helloline", "jsonLINE", "readline", "baseRow", "singleLINE", "dataline", " inputFrom", "imageLine", "feedBlock", "baseline", "inputLINE", "InputLine", "Inputline", "singleline", "feedLine", "outputBlock", "focusFrom", "fieldline", "inputline", "baseLINE", "outputL", "lengthline", "inLine", "inputFile", "inputList", "dataLine", "baseLine", "readLine", "jsonLine", " inputRow", " Inputline", "readLINE", "inputPath", "inputPoint", " inputPath", "inputRow", "virtualLINE", "outputLine", "inline", "helloLINE", "listLine", "lengthLINE", "feedPoint", "inputByte", "InputLINE", "helloLine", " inputFile", " inputLINE", "feedline", " inputByte", " inputline", "listList", "imageline", "listline", "InputList", "helloByte", " InputFile", "jsonline", "dataLINE", "lengthPoint", "fieldLINE", "focusPath", "readRow", "imageLINE", "inputBlock", "InputRow", "singleLine", "jsonRow"], "counter": ["cover", "processor", "container", "here", "meter", "currency", "count", "message", "total", "ounter", "cookie", "order", "chain", "Counter", "sequence", "phrase", "random", "walker", "continue", "entry", "loader", "ter", "creator", "clock", "card", "batch", "code", "controller", "amount", "system", "nr", "TER", "finger", "vector", "number", "book", "loop", "conv", "inner", "condition", "taker", "ctr", "finder", "second", "timer", "index", "outer"]}}
{"id1": "5125848", "id2": "14168494", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"combineJs": ["CombineJs", "combINEJs", "combinateJs", "ComboseJs", "combinejs", "ComboseLink", "combINELink", "combineJS", "CombineJS", "combinateJS", "combINEJS", "ComboseJS", "combinatejs", "combineLink", "CombineLink", "combosejs", "combINEjs", "comboseJs", "Combinejs", "combinateLink", "comboseJS", "Combosejs", "comboseLink"], "base": ["host", " based", "server", "domain", "b", "id", "data", "api", "bas", "bid", "origin", "buffer", "absolute", "from", " basis", "re", "bottom", "based", "page", "Base", "prefix", "file", "address", " bases", "relative", " Base", "template", "source", "uri", "db", "reset", "ase", "start", "root", "site", "bound", "local"], "linkJs": ["LinkJS", "LinkJs", " linkScript", "linkjs", " linkLinks", "Linkjs", "linkedScript", "inkTags", "linkScript", "inkLinks", "inkScript", " linkTags", " linkJS", "LinkTags", "linkedLinks", "inkjs", "inkJS", "linkTags", "inkJs", "linkedJS", " linkjs", "linkLinks", "linkedJs", "linkJS"], "newFiles": ["newDocuments", "nextFiles", "newLinks", "newfiles", "linkFiles", "nextfiles", " newLinks", "nextDocuments", " newDocuments", "linkDocuments", "linkLinks", "nextLinks", " newfiles", "linkfiles"], "dir": ["div", "rel", " Dir", "folder", "loc", "fs", "dd", "dr", "id", " d", "ir", "DB", "dl", "mk", "disk", "area", "diff", "ref", "addr", "sys", "local", "tar", " directory", "pkg", "mod", "vol", "md", "file", "DIR", "auto", "tmp", "directory", "dm", "zip", "lock", "good", "def", "dep", "out", "doc", "done", "created", "wd", "db", "di", "manager", "cd", "desc", "Dir", "root", "fd", "temp", "d", "lib", "module"], "name": [" bar", " logger", " cleaner", " start", " os", " foo", " scanner", " vm", " tmp", " karma", " msg", " report", " dummy", " info", " self", " filename", " b", " manager", " parser", " browser", " prefix", " err", " rebuild", " names", " str", " db", " res", " loader", " log"], "minDir": [" minJar", "minDb", "smallDb", "miniTier", "MinNet", "smallDir", " minPref", "minTrans", "mainDir", "sortDir", "minNet", " minTier", "minuteDir", "skinLoc", " minNet", "smallFile", "miniDir", "MinFile", " minTrans", "skinDb", "minuteDar", "miniTrans", "mainLoc", "thinTier", "minPref", "MinDir", "minTier", "thinJar", "maindir", "thinDir", "minFile", " minDar", " minRel", "miniJar", "minRel", "minDar", "minuteRel", "minJar", " minFile", "smallLoc", "mainDb", "minutePref", "thinTrans", "smallNet", "sortDar", "mindir", "smalldir", "sortRel", "skinDir", "skindir", "minLoc", "sortPref"], "combineFile": ["coordineWriter", "comboiceMessage", "combINESet", "combinefile", "cominateMessage", "cominateFile", "combineSet", "coordINEFile", "comineMessage", "cominateEmail", "combineEmail", "combinerFile", "combosefile", "cominatefile", "combinSet", "comineFile", "combinerfile", "cominefile", "comboseWriter", "combinateFile", "comineEmail", "combinatefile", "combINEWriter", "combineMessage", "comboiceFile", "combinfile", "coordINESet", "comboseSet", "combINEFile", "comboiceEmail", "combinerEmail", "combinWriter", "coordINEfile", "coordinefile", "combINEfile", "comboseFile", "comboicefile", "coordINEWriter", "coordineFile", "combinateEmail", "combinFile", "combinerMessage", "coordineSet", "combinateMessage"], "concatFile": ["conCatFilename", "convertTable", "convertFilename", "concatDir", "concapFiles", "conatfile", "concFilename", "conCatDir", "concatTable", "concapfile", "covertTable", "conCatFile", "comcDir", "comcatDir", "conatFile", "cocatTable", "comcatFile", "covertFile", "covertfile", "cocatfile", "comcFile", "comcatFilename", "convertfile", "conatFiles", "concatfile", "concatFiles", "covertFiles", "concapFile", "conatTable", "concapTable", "concDir", "convertDir", "convertFiles", "comcFilename", "cocatFile", "concatFilename", "concFile", "cocatFiles", "convertFile"], "combineWriter": ["combineWrite", "combieFile", "declineReader", "combineReader", "combieReader", "combinateReader", "Combinewriter", "combinateWrite", "combinewriter", "combinateCounter", "combenCounter", "declinateFile", "combieWrite", "ComboseWriter", "declineFile", "combenwriter", "comboseWriter", "combinateFile", "ComboseCounter", "declinateReader", "combineCounter", "declinateWriter", "CombineWriter", "combenWriter", "comboseReader", "declineWriter", "comboseWrite", "Combosewriter", "comboseCounter", "comboseFile", "combosewriter", "declineWrite", "declinateWrite", "CombineCounter", "combinatewriter", "combinateWriter", "combieWriter", "combenWrite", "CombineWrite", "ComboseWrite"], "concatWriter": ["conatReader", "convertWrite", "conatWriter", "cocatWrite", "comvertWriter", "comvertReader", "conatFile", "comcatFile", "concatsReader", "convertReader", "conatWrite", "coatFile", "cocatWriter", "convertWriter", "cocatReader", "comvertFile", "concatsWrite", "coatWrite", "comcatReader", "comvertWrite", "concatsFile", "cocatFile", "concatsWriter", "concatReader", "coatReader", "comcatWriter", "coatWriter", "comcatWrite", "concatWrite", "convertFile"], "fails": ["fils", " focks", "frailing", "Failing", "focks", "facails", "failing", "facailed", "frailed", "mailing", "ifailed", "malls", "lailed", "mailed", "facocks", "Fails", "ifocks", "frils", "Failed", "mocks", "failed", "facailing", "ifails", "Fils", " failed", "frails", "lails", "lailing", "falls", "mails", "lalls", "lils", " falls", "ifailing", " failing"], "link": ["loc", "node", "mark", "match", "script", "linked", "task", "self", "relation", "ln", "ink", "links", "embed", "set", "push", "follow", "c", "li", "load", "map", "add", "inline", "skip", "child", "share", "code", "address", "open", "line", "check", "display", "Link", "source", "close", "l", "log", "remote"], "path": ["image", "loc", "id", "style", "p", "location", "match", "pattern", "data", "format", "string", "ref", "src", "str", "entry", "PATH", "text", "resource", "join", "alias", "prefix", "key", "file", "hex", "relative", "template", "full", "source", "input", "uri", "route", "prop", "Path", "root", "href", "kind", "ath"], "url": ["loc", "host", "rel", "sl", "ssl", "gl", "id", "location", "ls", "il", "hl", "char", "string", "web", "ref", "lr", "addr", "str", "ll", "request", "resource", "http", "li", "ul", "nl", "browser", "ur", "URL", "build", "address", "this", "mount", "mail", "get", "source", "r", "uri", "Url", "l", "abs", "null", "href", "html"], "inputStream": ["InputStyle", "InputTime", " inputSet", "InputSteam", "outputStyle", "inSet", "outputstream", "inTime", " inputstream", " inputSteam", "inStream", "inputSteam", "inputstream", "Inputstream", "instream", "inputStyle", " inputStyle", "InputSet", "InputStream", "outputSteam", "inputSet", "inputTime", " inputTime"], "jsFile": ["JsPath", "jFile", "jsPath", "cssFilename", "cssfile", "jPath", " jsTable", "cssTable", "jName", " jsPath", "javascriptPath", " jsName", "jsfile", "cssFile", "javascriptName", "Jsfile", "javascriptFile", "jsFilename", "jFilename", "JsFilename", " jsfile", "javascriptFilename", "javascriptfile", "jsName", "cssPath", "JsFile", "jsTable", " jsFilename", "javascriptTable"], "fileName": ["filePath", "getPath", "filename", "FileHash", "getHash", " fileHash", "fileHash", "FilePath", "FileName", "Filename", "getname", "getName", " filename", " filePath"], "outputStream": [" outputSteam", " outputStyle", "OutputSet", "Outputstream", " outputForm", "outputStyle", "inputForm", "OutputStyle", "outputstream", "OutputStream", "inputSteam", "inputstream", " outputstream", "OutputSteam", "OutputForm", "inputStyle", "writestream", "writeSet", "outputSet", "writeStream", "outputSteam", "outputForm", " outputSet", "writeSteam"], "first": ["initial", "top", "same", "important", "self", "fast", "each", "index", "then", "front", "sort", "stack", "real", "valid", "continue", "st", "natural", "quick", "must", "all", "seconds", "send", "only", "master", "latest", "false", "current", "true", "open", "ind", "last", "unique", "start", "default", "success", "second", "fourth", "next", "prev", "First", "third", "primary", "now"], "reader": ["core", "context", "mr", "stream", "rc", "rator", "data", "er", "iterator", "driver", "io", "handler", "buffer", "parser", "wrapper", "loader", "layer", "writer", "rl", "resource", "http", "runner", "ro", "builder", "file", "rr", "rar", "Reader", "this", "ner", "r", "input", "inner", "rer", "row", "read", "ocr"], "jsCompressor": ["jsCompression", "cssComposer", "jsCompiler", "jscomposer", "jscompiler", "jsComposer", "jsRepressor", "jsBuffoser", "cssCompressor", "cssRepressor", "jsBuffiler", "jsBuffressor", "jscompressor", "cssCompiler", "cssCompression", "jsRepiler", "jsReposer", "cssRepiler", "cssRepression", "jsRepression", "jscompression", "cssReposer", "jsBuffression"], "s": ["fs", "ats", "xs", "words", "cs", "ls", "ens", "pers", "ers", "S", "ns", "ms", "ss", "gs", "ds", "ts", "tes", "eds", "y", "ies", "less", "is", "full", "details", "parts", "ings", "es", "os", "l", "lines", "hs", "t", "ids", "qs", "tags", "ps"], "s1": ["ls1", " s3", "ls0", "pers1", "esFirst", "idFirst", "s0", "ys0", "s81", "ls3", "id2", "id1", " s81", "es2", "es9", "ls81", "ys81", "ps1", "s9", "ps0", "pers0", "es1", "s3", "ys3", "sFirst", "id9", " s0", "ys1"], "i": ["ia", "mi", "id", "ri", "p", "pi", "v", "ity", "ii", "us", "ai", "iti", "io", "bi", "um", "iat", "iu", "it", "ic", "li", "j", "ori", "ie", "y", "ch", "is", "ion", "ui", "di", "ig", "ip", "ci", "ati", "ifier", "o", "im", "oi", "I"], "s2": ["s02", "sSecond", "tes2", "es02", "SSecond", "S02", "gs2", "ss22", "s22", "z02", "msTwo", "z2", "tesTwo", "gsSecond", "Stwo", "S2", "ss2", "ssTwo", "gs02", "es2", "tes1", "zSecond", "stwo", "ms2", "gstwo", "ztwo", "es1", "tes02", "ms22", "esTwo", "ms02", "sTwo", "ss02"], "i1": ["e4", "e2", "it01", "eOne", "itOne", "p1", "it2", "i0", "p01", "a1", "it0", "aOne", "i01", "a2", "pOne", "o1", "a01", "p2", "i2", "it1", "p4", "it4", "o0", "o4", "e1", "oOne", "p0", "i4", "iOne"]}}
{"id1": "16466743", "id2": "8667872", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"getmd5": [" getMD2", "getMD5", "getMD4", "getmd4", " getmd6", "getMD6", " getMD6", "getsha4", "getsha2", " getmd4", "getmd6", "getmd2", "getMD2", " getMD5", " getMD4", " getmd2", "getsha5", "getsha6"], "password": ["value", "Password", "ew", "p", " Password", "security", "pattern", "data", "message", "sword", "email", "description", "secret", "string", "token", "user", "path", "phrase", "database", "entry", "text", "login", "attribute", "prefix", "key", "code", "address", "hash", "word", "name", "username", "pass", "wd", "auth", "shadow", "padding", "wordpress", "hello", "w"], "pwHash": ["spwHash", "pWHas", " pwSum", "spwdhash", "pwdSum", "pwdhash", "pswSum", "pwSum", "spwdHash", "pwdHas", "pswhash", " pwdhash", "pwsHash", "pwtHas", "pwHas", "spwdSum", "spwdHas", " pwdSum", " pwhash", "spwHas", "pwtSum", "pwhash", " pwdHash", " pwdHas", "pwsSum", "pwshash", "spwSum", "pswHash", "pwtHash", "pWHash", "pwdHash", "pwthash", "pWSum", "pswHas", " pwHas", "pwsHas", "spwhash", "pWhash"], "md": ["del", "cmd", "dd", "mt", "exec", "der", "mo", "red", " mc", "nd", "mg", "mk", "sd", " dd", "od", "ms", "mm", "m", "man", "pm", "pd", "mod", "ds", "add", "metadata", "dir", "ad", "mc", "mn", " Md", " mo", " mm", "df", "mp", "msg", "dm", "det", "dig", "ind", "mb", "cond", "cmp", "mail", "material", "def", "mem", "doc", "grad", "ld", "rm", "td", "di", "cd", "desc", "bd", "hd", "d", "ng", "MD", "sm"], "b": ["f", "ba", "bs", "p", "v", "binary", "bf", "reb", "ib", "bp", "bas", "bi", "nb", "m", "ab", "fb", "bar", "a", "bis", "bh", "B", "sb", "obj", "eb", "batch", "bu", "y", "be", "mb", "gb", "br", "ob", "bc", "g", "db", "abs", "l", "rb", "buff", "bytes", "bb", "d", "cb", "w"], "i": ["cli", "mi", "u", "id", "p", "pi", "v", "ix", "ri", "ini", "us", "ii", "si", "ai", "io", "bi", "ms", "n", "q", "my", "m", "sim", "yi", "in", "iu", "ki", "ic", "multi", "it", "ei", "li", "a", "j", "ti", "span", "xi", "ij", "init", "x", "hi", "ji", "ie", "phi", "y", "ind", "is", "ui", "gu", "iter", "di", "gi", "oi", "json", "ci", "ip", "l", "ski", "\u0438", "next", "o", "qi", "im", "index", "I"]}}
{"id1": "20929570", "id2": "23517481", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"toMd5": ["toMMD512", "toMdHash", "toDm5", "toMm5", "toDmHash", "toMmdHash", "toDd512", "toMmd512", "toMm4", "toDd5", "toMm512", "toMd4", "toDdHash", "toDd4", "toMd512", "toMMD4", "toMmd4", "toMMD5", "toMmHash", "toMmd5", "toDm512", "toMMDHash", "toDm4"], "str": ["arr", "b", "p", "v", "STR", "data", "enc", "char", "Str", "string", "e", "s", "print", "in", "st", "text", "c", "it", "a", "obj", "sp", "msg", "wr", "ch", "name", "this", "out", "txt", "br", "cr", "r", "input", "ctr", "t", "utt", "w", "n"], "messageDigest": ["messageDefester", "applicationDigested", "messageDecests", " messageDiger", "applicationdigester", "Messagedigse", "messageDigests", "messageDigested", "applicationDigest", "MessageDigest", "messagedigEST", "messageDesignest", "messagedigist", "messageDigert", "messageDecse", "messagemdert", "messageDesignests", "messagedigse", " messageDigester", " messageDse", "messagediger", "MessageDigests", "messageDest", "MessageDigester", "Messagedigest", " messageDert", "applicationdigested", "applicationDigse", "messagedigested", "applicationdigse", "messageDesignested", " messageDest", "MessageDiger", "messageDesignse", "messageDigester", "messageDiger", "messagedigest", "messageDert", " messageDigse", "messagemdest", "MessagedigEST", "applicationDigester", "messageDefer", "messagemdester", "messageDigEST", "messageDefist", "applicationdigest", "messageDefest", "messagemdse", "messageDigse", " messageDester", "messagedigests", "messageDesignester", "messageDester", " messageDigert", " messageDigist", "Messagediger", "messageDse", "messageDecested", "messagedigester", "Messagedigester", "messageDecest", "messageDecester", "messageDefEST", "Messagedigests", "MessageDigEST", "messagedigert", "messageDigist", "MessageDigse"], "byteArray": ["byteList", "byteString", "seBuffer", " byteBuffer", "bytesArray", " byteRAY", "byteAddress", "entityList", "byteLength", "viewStream", "resourceArray", "basicarray", "bytesLength", "bytearray", " byteString", " byteAddress", "basicList", "viewBuffer", " byteList", "viewArray", "basicAddress", "fieldRAY", "seArray", " byteStream", " bytearray", "byteStream", "helloArray", "entityarray", "fieldArray", "resourceBuffer", "resourceStream", "bytesRAY", "byteRAY", "fieldLength", "bytesString", "basicBuffer", "entityBuffer", "helloBuffer", "bytesAddress", " byteLength", "byteBuffer", "basicArray", "entityArray", "basicString"], "md5StrBuff": ["md5BuffBuff", "md5StBuff", "md8StrComp", "md4Strbuff", "md5RatVert", "md7StringBuff", "md5ObjBuff", "md8RatBuffer", "md4StringBuff", "md4StrPref", "md5RatBuff", "md8StrBuff", "md5StrBu", "md5StBu", "md7StrBuff", "md5ObjBuffer", "md5Stbuff", "md5StBuffer", "md5StringDb", "md7StringBu", "md5TextCop", "md7Stringbuff", "md5BuffPref", "md7StrBu", "md5RatComp", "md65StrCop", "md8StrVert", "md5StringCop", "md5StringComp", "md5StrPref", "md5strbuff", "md5BuffDb", "md5StringBuff", "md4StringPref", "md8StrBuffer", "md65TextComp", "md7StrPref", "md5strBuffer", "md8RatBuff", "md5Buffbuff", "md5TextBuffer", "md5StringBuffer", "md5StrVert", "md65StrComp", "md65StrBuffer", "md5strBu", "md5StringPref", "md7Strbuff", "md5strComp", "md5TextComp", "md65TextBuffer", "md5StrDb", "md5StrCop", "md5StrBuffer", "md65StrBuff", "md8RatVert", "md5StCop", "md4StrDb", "md8RatComp", "md5StringBu", "md5StComp", "md5strDb", "md65TextBuff", "md5Strbuff", "md5ObjVert", "md5TextBuff", "md5ObjComp", "md4StringDb", "md5RatBuffer", "md5Stringbuff", "md5StPref", "md4Stringbuff", "md5strBuff", "md65TextCop", "md5strVert", "md7StringPref", "md5strPref", "md5StrComp", "md4StrBuff"], "i": ["cli", "mi", "u", "go", "v", "ix", "ex", "ini", "gravity", "I", "list", "us", "s", "si", "e", "ai", "ii", "io", "chain", "bi", "cgi", "n", "q", "my", "m", "me", "in", "ki", "iu", "ic", "it", "ei", "multi", "c", "status", "li", "major", "ti", "a", "j", "xi", "x", "hi", "ji", "batch", "phi", "y", "ind", "slice", "is", "ui", "h", "gu", "uri", "conv", "di", "gi", "l", "json", "ci", "ip", "t", "o", "info", "im", "index", "pi"]}}
{"id1": "3558512", "id2": "2676365", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "label": 0, "substitutes": {"serialize": ["Serialize", "initialize", " serialate", "Serialized", "erialate", "Serialization", "serialized", "finalization", "finalize", "serializer", " serializer", " serialized", "initialze", "initialization", "erialized", "serialization", "serialate", "finalized", "erializer", "Serializer", "Serialze", "finalze", "Serialate", "erialize", "initialized", "serialze"], "out": ["f", " OUT", "output", "OUT", "stream", "b", "p", "v", "serv", "sum", "io", "err", "sw", "outs", "c", "it", "OU", "ou", "a", "to", "report", "file", "res", "aos", "pool", "ch", "up", "d", "i", "os", "o", "t", "log", "Out", "w", "result", "n"], "parser": ["processor", "aser", "style", "p", "plan", "ger", "language", "instance", "format", "er", "peer", "arser", "token", "handler", "tar", "Parser", "xml", "bank", "magic", "walker", "tree", "loader", "pkg", "layer", "part", "writer", "worker", "ler", "builder", "file", "asser", "ker", "base", "per", "reader", "jack", "lp", "proc", "inner", "policy", "manager", "rer", "parse", "util", "password", "command", "job", "now", "tp"], "on_disk": ["on_download", "On2link", "on_cloud", "On2disk", "on_volume", " on_Disk", "On_cloud", "on_dis", "on_link", " on_disc", " on_volume", " on_download", "On_Disk", "On_disk", "On_file", "on_file", "on2disk", "On_link", "On2Disk", "on_disc", "on2file", " on_dis", "on_Disk", "On2file", " on_file", "on2link", "on2Disk"], "in": [" IN", "mi", "ins", "din", "inside", "en", "id", "IN", "sin", "inn", "io", "inf", "gin", "cin", "on", "bin", "from", "it", "vin", "and", "ad", "body", "ain", "ind", "is", "inc", "rin", "i", "input", "r", "inner", "isin", " din", "min", "In"]}}
{"id1": "20735941", "id2": "14450108", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"getFile": ["readSourceFile", "getFilename", "newFilename", "getfile", "newSourceFile", "openFilename", "newfile", "readFile", "newFile", "readfile", "openfile", "openFile", "openSourceFile", "getSourceFile", "readFilename"], "home": ["host", "HOME", "server", "profile", "self", "ome", "localhost", "path", "user", "owner", "Home", "omes", "join", "http", "www", "dir", "Root", "shared", "auto", "share", "base", "directory", "parent", "name", "ghost", "mail", "h", "mem", "up", "book", "wd", "hub", "Dir", "default", "root", "html", "housing", "index", "history", "project", "room", " HOME"], "fileName": ["viewFilename", "FILEString", "projectNAME", "baseDefault", "baseName", "resourcePath", "FileString", " fileDefault", "fileFile", "filenamePath", "tileFile", "fileString", " fileNames", "resourceFilename", "filenameName", "projectname", "viewFile", "projectName", "tileNAME", "fileFilename", "projectDefault", " filename", "resourcename", "FILEPath", "fileNAME", " fileFilename", "tileFilename", " fileString", "FilePath", "filenamename", "FILENames", "FILEName", "basename", " filePath", "filenameFilename", "filePath", "filename", " fileFile", "viewNAME", "resourceName", "fileNames", "FileName", "viewName", "FileNames", " fileNAME", "tileName", "baseNAME", "fileDefault"], "file": ["f", "image", "object", "output", "node", "port", "work", "model", "channel", "bo", "format", "fe", "path", "foo", "le", "user", "print", "buffer", "tree", "from", "view", "or", "File", "resource", "table", "load", "FILE", "link", "to", "page", "report", "dir", "document", "al", "run", "function", "po", "library", "base", "pool", "be", "name", "current", "used", "fp", "write", "ile", "full", "place", "filename", "db", "null", "type", "log", "use", "info", "local", "result", "handle"], "url": ["f", "rel", "loc", "host", "sl", "ssl", "gl", "org", "https", "ls", "norm", "dl", "char", "bel", "github", "lr", "path", "ref", "web", "user", "str", "ll", "ret", "resource", "http", "rl", "ul", "nl", "link", "browser", "ur", "impl", "key", "URL", "cert", "base", "address", "name", "mb", "client", "mail", "r", "uri", "Url", "l", "null", "abs", "util", "html"], "in": ["f", "ins", "din", "inside", "el", "en", "ini", "IN", "inn", "con", "s", "ai", "io", "inf", "gin", "cin", "on", "bin", "from", "it", "ic", "and", "init", "mc", "al", "body", "ind", "is", "inc", "up", "rin", "i", "input", "source", "r", "inner", "iter", "l", "o", "isin", "im", " din", "read", "In", "n"], "out": ["cn", "ot", "output", "OUT", "en", "co", "gr", "v", "con", "ln", "net", "io", "ne", "sys", "n", "on", "outs", "it", "OU", "writer", "ou", "to", "obj", "aos", "batch", "nt", "cos", "msg", "ion", "client", "check", "write", "oss", "one", "conv", "inner", "os", "null", "flush", "o", "log", "Out", "outer", "can"]}}
{"id1": "16215393", "id2": "16969205", "code1": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"importSequences": ["loadSequences", " importSlences", " importSlelines", " importsequelines", " importsequence", " importSeelines", "loadSequence", " importSeences", " importSlence", " importSeines", " importsequences", "loadSequelines", " importSequence", "loadsequines", "loadsequences", " importsequines", " importSequelines", " importSeence", "loadSequines", " importSlines", "loadsequence", " importSequines", "loadsequelines"], "names": ["Names", "sheets", "said", "onyms", "papers", "types", "times", "orders", "ns", "files", "nos", "strings", "packages", "mas", "AMES", "artifacts", "users", "people", "makers", "letters", "codes", "reports", "ames", "ren", "idents", "aps", "keys", "resources", "finals", "eas", "uploads", "named", "ids", "groups", "roots", "years", "photos", "these"], "sequences": ["seqencies", "requence", "seques", "equence", "seqames", "sequence", "enes", "Seques", "requences", "equencing", "Sequencies", "enences", "enencies", "sequames", "Sequames", "requencing", "sequelines", "seqes", "equences", "seqences", "Sequences", "sequencing", "requelines", "Sequence", "enames", "Sequencing", "Sequelines", "sequencies", "equelines"], "is": ["isa", "sis", "isl", "fs", "lis", "ri", "iss", "rs", "ris", "serv", "dis", "ists", "ls", "isi", "s", "ai", "ms", "sys", "iso", "has", "in", "re", "bis", "tis", "ois", "IS", "sb", "res", "iris", "Is", "isc", "ui", "does", "i", "se", "isf", "es", "os", "\u00eds", "ip", "ais", "its", "isin", "ios"], "helper": ["calpert", "hahelp", "hyhelp", "peripper", "helpen", " helpers", "helber", "perpers", "helporter", "perporter", "utilipper", "hapher", "calhel", "keliper", "kelhel", "helhelp", "perpen", "hhel", "hypert", "hypher", "kelpert", "helpility", "helser", "utilpper", "helppper", "haper", "utilility", "horpper", "hepert", "utilpert", "heper", "helpi", " Helser", " helser", "caliper", "calper", "helpser", " helpi", " Helpers", "utilper", "helhel", " helporter", "kelper", "hwpi", "hepher", " helber", "hpert", " Helper", "utilpers", " helpen", "helpert", "helppers", " Helber", "helpper", "hwporter", "helpers", "helipper", "helility", "perper", "perpper", "hwpen", "hiper", "hapert", "horpert", "perility", "helpber", "hyper", "perpert", "perpi", "hehelp", "horipper", "hper", "heliper", "helpher", "hwper", "horper"], "ch": ["z", "wh", "cmd", "zh", "sh", "th", " Ch", "cs", "yet", "cht", "ched", "ech", "job", "ach", "count", "tch", "char", "q", "cell", "str", "cha", "ich", "c", "che", "col", "comm", "ph", "j", "ver", "range", "och", "chan", "msg", "Ch", "cp", "CH", "vc", "change", "qu", "comp", "br", "pr", "i", "cur", "cr", "cor", "conv", "conf", "cl", "cd", "cho", "cb", "history", "cont"], "line": ["ine", "header", "shell", "online", "eline", "data", "message", "level", "list", "string", "content", "ln", "user", "le", "chain", "sequence", "cell", "phrase", "normal", "str", "block", "lin", "text", "frame", "nl", "Line", "inline", "link", "page", "range", "comment", "code", "body", "word", "source", "iter", "l", "row", "lines", "url", "log", "LINE", "info"], "tokenizer": ["Tokenize", "tokenize", "worditer", "tokeniser", "Tokeniter", " tokener", "wordizer", " tokeniser", "tokenator", " tokenize", "tokeniter", " tokenator", "tokener", "Tokenister", "wordator", "okeniser", " tokenister", "okenizer", "Tokener", "Tokenator", "Tokeniser", " tokeniter", "okenister", "tokenister", "okenize", "Tokenizer", "worder"], "name": ["value", "var", "id", "nm", "format", "string", "path", "chain", "sequence", "normal", "local", "str", "Name", "text", "ident", "part", "alias", "cap", "NAME", "label", "prefix", "key", "item", "base", "word", "family", "no", "ame", "title", "nam", "filename", "common", "type", "named", "info", "w", "n"], "seq": ["sl", "sequ", "iq", "exp", "vec", "data", "nm", "list", "buf", "gen", "queue", "sequence", "buffer", "obs", "str", "ctx", "sim", "resp", "sq", "pkg", "sec", "rez", "j", "req", "sub", "struct", "obj", "batch", "tmp", "nt", "msg", "pipe", "pos", "zip", "txt", "quit", "mem", "pse", "se", "cmp", "iter", "sel", "null", "tab", "buff", "next", "sample", "ext", "temp", "result"]}}
{"id1": "16851955", "id2": "2324868", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingbackProp", "testTrainingBackProp", "testTrainingbackprop", "testTrainingBackward", "testTestingbackend", "testTrainingbackend", "testTrainingbackward", "testTrainingBProp", "testTestingbackward", "testTestingbackprop", "testTestingBackend", "testTestingBackward", "testTrainingBend", "testTrainingBward", "testTestingBackprop", "testTrainingBprop", "testTestingBackProp", "testTestingbackProp", "testTrainingBackend"], "temp": ["loc", "copy", "output", "mt", "p", "unt", "v", "cache", "dat", "tc", " tmp", "mk", " temporary", "empty", "dest", "partial", "por", "complete", "test", "EMP", "tar", "pt", "mod", "remove", "orig", " Temp", "emp", "prefix", "file", "Tem", "mp", "tmp", "relative", "porary", "cp", "zip", "this", "out", "txt", "w", "template", "Temp", "full", "create", "created", "tem", "tm", "fake", "tab", "null", "make", "t", "local", "stem"], "layers": [" Lights", "lepackages", "listanes", "llays", " lacks", "listenses", " lenses", "llowers", "lsanes", "lienges", "lights", " lasks", "slayers", "lasks", "lanes", " lients", "vlpackages", " Lensions", "leayers", " lenges", "vlumers", "lsasks", "lipackages", "lenges", "liayers", "lienses", "llanguages", "liumers", "lacks", "lenses", " lumers", "slanguages", "liights", "lsenses", "liowers", "llenses", "listayers", "slensions", "liients", " lensions", " lpackages", "llayers", "lumers", "slenses", "leenges", "flayers", "flays", "lensions", "lowers", "lpackages", " lanes", "lients", " languages", " Languages", "lays", " lights", "lsayers", "llacks", "vlayers", "liacks", " lowers", "llients", "vlenses", " Layers", "flenses", "flanguages", "slays", "listasks", "slights", "leights", "languages"], "fann": ["flannis", "fain", "cain", "carn", "fannis", "flann", "ffannot", " farn", " fain", "Fana", "fannot", "farn", "flANN", "fANN", "fmanANN", "flana", "Fann", " fannot", "fmanann", "ffann", "FANN", "Fannis", "fmanana", "cann", "fana", "fmanannis", "ffain", "ffarn", "cannot"], "trainer": ["trrain", "Trainer", "tracy", "formayer", "formacer", "Triner", "triner", "Tracy", "bracer", "tracer", "rrain", " trayer", " tracer", "Trrain", "riner", "bruner", "Tracer", "brainer", "truner", "Trayer", "Truner", "strrain", "strainer", "runer", "racer", "formainer", "bracy", "stracer", "racy", "trayer", "rainer", "striner"], "desiredError": ["DesiredValue", "desireEr", "deseedException", "desuredException", "demuredError", "desuredValue", "desiredException", "deseedValue", "DesiredError", "DesuredException", "desIREDValue", "DesiredERROR", "desIREDERROR", "desuredError", "desiredEvent", "demuredEr", "deseedError", "desiredEr", "desireError", "desiredERROR", "deseedERROR", "desIREDError", "DesuredERROR", "desiringError", "DesuredError", "desireEvent", "demiredEvent", "demireEvent", "desiredValue", "desiringEr", "demiredEr", "demireEr", "desuredEvent", "desuredEr", "demireError", "DesuredValue", "desIREDException", "demiredError", "desuredERROR", "DesiredException", "desiringEvent", "demuredEvent"], "mse": ["mSE", "mroe", "dsem", " mSE", "Msem", "mmpe", "mrpe", "mese", "mrso", "mpe", "MSE", "Mte", " mpe", "Moe", "cmse", "moe", " mte", "Mpe", " moe", "dse", " msem", "cmese", "mte", "mmese", "mmse", "mmSE", "Mse", "mso", "Mso", "dSE", " mese", "cmpe", "cmSE", "mrse", "msem", "dte", " mso"]}}
{"id1": "9327525", "id2": "2465747", "code1": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"test02_ok": ["test02__ok", "test02AOK", "test02__Ok", "test2_full", "test02Aok", "test2_Ok", "test2_OK", "test2_ok", "test02Afull", "test2__full", "test02_Ok", "test02__full", "test2__ok", "test02__OK", "test02_OK", "test02AOk", "test2__Ok", "test02_full", "test2__OK"], "client": ["cli", "context", "core", "ssl", "server", "co", "cache", "tc", "connect", "window", "api", "service", "con", "google", "secure", "handler", "cell", "sim", "acl", "network", "conn", "wrapper", "loader", "request", "c", "collection", "resource", "http", "control", "phone", "session", "connection", "console", "pool", "cp", "system", "call", "uri", "config", "policy", "close", "null", "cl", "app", "ci", "ip", "remote", "Client", "cm", "contact", "local"], "post": ["dd", "copy", "patch", "p", "process", "form", "test", "valid", "pre", "set", "pp", "Post", "request", "push", "http", "load", "add", "method", "link", "upload", "read", "apply", "install", "wp", "op", "body", "build", "put", "zip", "call", "write", "posts", "get", "POST", "submit", "ost", "ip", "url", "row", "parse", "next", "save", "pod", "and", "send"], "nameValuePairs": ["nameValueParappings", "nameNameParars", "nameValuesPonents", "nameValueParuffs", "nameValuePararms", "nameValueCompings", "nameValueAssair", "nameNamePersings", "nameValuePersairs", "nameValuePersars", "nameValueParars", "nameValuePersuffs", "nameValueEairs", "nameValuePars", "nameNamePersars", "nameValueCharms", "nameValueAssairs", "nameNamePair", "nameValueparms", "nameValuePonents", "nameValueAppings", "nameNameParms", "nameValueAssarms", "nameValuesPings", "nameValueputes", "nameValueChappings", "nameValuesParms", "nameNamePairs", "nameValuePointarms", "nameNamePars", "nameValueChars", "nameValuepairs", "nameValuesPair", "nameValueCompairs", "nameValuePersonents", "nameValuesPars", "nameValueAssars", "nameValuespairs", "nameValueApparms", "nameValuepars", "nameNamePersairs", "nameValueParair", "nameValuePings", "nameValuePersappings", "nameValueChair", "nameValuePores", "nameValuespair", "nameValueEars", "nameValueponents", "nameValuePair", "nameValuesPappings", "nameValuePutes", "nameValueParairs", "nameNamePersarms", "nameValueCompappings", "nameValueAppairs", "nameValueEair", "nameValuespings", "nameValueMaputes", "nameNamePersutes", "nameValuepair", "nameValuePointonents", "nameValuePersutes", "nameValuePersair", "nameNameParores", "nameValuePersarms", "nameValuePointairs", "nameValuePointars", "nameValuePappings", "nameNamePutes", "nameValueCompair", "nameValuePersings", "nameValueParores", "nameNamePores", "nameValuePuffs", "nameValueChings", "nameValuesponents", "nameValuesPairs", "nameNameParairs", "nameNamePings", "nameValueCompars", "nameValueChairs", "nameValueMapairs", "nameNamePersair", "nameValuespappings", "nameValuepings", "nameValuepores", "nameValueParms", "nameValuepappings", "nameValuesparms", "nameValuespars", "nameValueMapars", "nameValuepuffs", "nameNameParair"], "response": ["onse", "object", "reply", "output", "server", "header", "model", "channel", "profile", "message", "given", "description", "service", "ve", "sequence", "tree", "block", "example", "resp", "entry", "application", "request", "view", "answer", "network", "resource", "http", "status", "frame", "volume", "page", "report", "connection", "res", "document", "console", "body", "pos", "def", "still", "respond", "Response", "json", "version", "command", "result"], "entity": ["image", "el", "object", "quote", "pe", "output", "encrypted", "person", "voice", "model", "channel", "eme", "ity", "data", "message", "instance", "ent", "e", "empty", "my", "ITY", "xml", "entry", "Entity", "error", "resource", "status", "note", "ell", "metadata", "comment", "obj", "document", "body", "code", "existent", "event", "put", "line", "activity", "details", "oe", "json", "type", "ENT", "eric", "ce", "ee", "result"], "instream": ["Inform", "inspod", "Inline", "insstream", "insline", "Instream", "inputcontext", " inform", " inStream", " inconsole", "outcontext", "inStream", "inputstream", "inline", "inputStream", "inform", "inpod", "inputform", "inputconsole", " inpod", "inscontext", "outform", "incontext", "Inconsole", " incontext", "inconsole", " inline", "outStream", "inputline", "inputpod", "outstream"], "reader": ["operator", "stream", "holder", "liner", "upper", "ader", "relation", "er", "iterator", "driver", "handler", "editor", "buffer", "parser", "maker", "loader", "writer", "rl", "runner", "reading", "READ", "builder", "file", "console", "controller", "rr", "Reader", "rar", "latest", "ner", "r", "book", "inner", "rer", "row", "roller", "read"]}}
{"id1": "8747840", "id2": "17729554", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"copy": ["move", "transfer", " Copy", "sync", "csv", "delete", "clip", "map", "load", "add", "link", "upload", "paste", "Copy", "gc", " mirror", "cp", "slice", "write", "clone", "create", "cat", " copying", "save", " replicate", "download", " cp", "read"], "src": ["rel", "iv", "ins", "rc", "bs", "rs", "sc", "usr", "sin", "sys", "obs", "via", "st", "sq", "sf", "pkg", "sec", "from", "inst", "sit", "ser", "req", "init", "urg", "img", "sb", "rx", "txt", "ipl", "source", "input", "syn", "cur", "start", "sur", "ctr", "sr", "Source", "cont"], "dest": ["loc", "del", "th", "https", "Dest", "self", "mk", "gt", "usr", "way", "target", "nw", "test", "origin", "mm", "pub", "st", "dist", "spec", "sit", "orig", "req", "trans", "des", "nom", "tmp", "nt", "est", "master", "good", "opt", "source", "null", "decl", "pas", "rest", "end", "d", "temp", "deg", "cont"], "in": ["ins", "din", "inside", "en", "id", "rc", "old", "ze", "IN", "inn", "con", "ln", "ai", "inf", "cin", "gin", "mm", "on", "bin", "from", "ar", "ic", "it", "init", "impl", "al", "ain", "ind", "inc", "up", "rin", "source", "input", "i", "iter", "inner", "info", "isin", "im", "In"], "out": ["ot", "output", "en", "OUT", "co", "p", "dis", "ex", "sum", "gt", "con", "over", "net", "io", "ne", "sys", "n", "on", "err", "bin", "conn", "outs", "it", "by", "writer", "ou", "to", "obj", "res", "auto", "aos", "nt", "ch", "client", "write", "oss", "g", "inner", "os", "conv", "not", "o", "t", "end", "Out", "at", "outer", "can"], "buf": ["arr", "cmd", "bl", "b", "bs", "vec", "bed", "uf", "data", "gen", "box", "ref", "queue", "buffer", "aka", "str", "block", "pkg", "fb", "col", "bar", "stab", "bh", "cv", "cap", "cam", "bag", "fg", "seq", "Buff", "batch", "msg", "mb", "good", "used", "br", "bus", "cat", "conv", "db", "tab", "rb", "Buffer", "mu", "prop", "buff", "bytes", "log", "cb", "temp"], "c": ["k", "z", "b", "cs", "co", "rc", "cu", "cf", "count", "cache", "ec", "dec", "nc", "unc", "cc", "jc", "m", "ac", "C", "cod", "a", "dc", "ca", "gc", "mc", " C", "code", "cos", "ch", "cp", "uc", "call", "i", "cr", "bc", "conf", "l", "cd", "ci", "ct", "t", "ce", "cm", "d", "cb", "lc", "fc", "cont", "n"]}}
{"id1": "8953394", "id2": "14464131", "code1": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"update": ["copy", "exec", "sync", "delete", "touch", "database", "set", "insert", "load", "step", "replace", "apply", "edit", "sql", "query", "UPDATE", "batch", "updated", "put", "Update", "create", "submit", "db", "flush", "save", "use", "send"], "statement": ["quote", "Statement", "mt", "message", "description", "string", "content", "delete", "sn", "print", "sequence", "phrase", "str", "rule", "article", "text", "commit", "status", "table", "comment", "session", "sql", "query", "expression", "document", "ause", "batch", "execute", "msg", "name", "word", "template", "condition", "stat", "command", "result"], "con": ["cn", "nn", "en", "co", "ran", "cu", "cf", "rc", "com", "dial", "bo", "ec", "enc", "connect", "nc", "tc", "cc", "clean", "city", "un", "cin", "ctx", "conn", "c", "pen", "Con", "ca", "connection", "mc", "Conn", "po", "ain", "soc", "pool", "ch", "cp", "cond", "CON", "client", "cur", "ctrl", "bc", "conv", "db", "conf", "cons", "coll", "ct", "cm", " conn", "fc", "can"], "do_log": ["do__save", "do_save", "do__print", " do_print", " do_quote", "do_trace", " do_trace", " do_write", "do_quote", "do_print", "do__trace", "do_write", " do_save", "do__log"], "s": ["fs", "ins", "ends", "sl", "iss", "bs", "rs", "cs", "sts", "serv", "ls", "p", "v", "gets", "S", "ms", "ns", "m", "ss", "set", "st", "sq", "js", "gs", "c", "ds", "comm", "spec", "socket", "ts", "sv", "session", "as", "sb", "sol", "ses", "less", "is", "h", "source", "se", "g", "os", "l", "hs", "t", "o", "qs", "ws", "ps", "sm"]}}
{"id1": "16557837", "id2": "7911686", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["copyFormFile", "copyFileFrom", "copyFileFile", "transferFromDir", "copyFormDir", "transferFromTo", "copyFormTo", "copyfromFile", "transferfromTo", "copyFromFrom", "copyFileDir", "transferFromFile", "copyfromDir", "copyFormFrom", "transferfromFile", "copyFromFile", "copyFromDir", "transferFromFrom", "copyfromTo", "copyfromFrom", "transferfromDir", "transferfromFrom", "copyFileTo"], "srcFile": ["srcDir", "sysPlace", "sortFiles", " srcPage", "destfile", "rcFiles", "sbFile", "srcFILE", " srcFiles", "srcSourceFile", "rcDir", "sourceFile", "ivFILE", "sortPage", "rcPage", "destDir", "sortFILE", " srcPlace", " srcFILE", "ivPage", "sortSourceFile", " srcPath", "srcPlace", "sortFile", "destPath", "sourcePath", " srcFilename", "sysFilename", "srcfile", "rcFile", "sbFilename", " srcSourceFile", "ivFile", "sbfile", "srcFiles", "ivSourceFile", "srcPage", "rcPath", "sourceDir", "sbPlace", "sourcefile", " srcDir", "sysfile", "sysFile", "rcFILE", "destPage", " srcfile", "srcFilename", "srcPath"], "destFile": ["etcFilename", "srcDir", "destFilename", " destfile", "destfile", "restDirectory", "DestFilename", "optFilename", "memfile", "restFILE", "destDir", "optDir", " destDirectory", "restFile", "etcFile", "destDirectory", "restFilename", "memFile", "descFILE", "srcFilename", "memFilename", "DestDir", "destPath", "destFiles", "srcDirectory", "descFilename", "DestFiles", "optFile", "Destfile", " destFilename", "DestPath", " destDir", "srcFiles", "DestFile", "descDir", "etcFILE", "DestDirectory", "etcDirectory", " destPath", "destFILE", "srcPath", " destFiles", "memFILE", "descFile", "optfile", "DestFILE", " destFILE"], "in": [" IN", "ins", "din", "inside", "isin", "en", "co", "id", "ex", "ini", " input", "IN", "inn", "con", "net", "io", "inf", "cin", "gin", "local", "m", "on", "bin", "mm", "conn", "from", "it", "ar", "re", "add", "all", "init", "mc", "body", "ain", "ind", "is", "can", "inc", "rin", "i", "input", "source", "iter", "inner", "l", "ci", "o", "t", "vin", "info", " din", "read", "In", "n"], "out": ["ins", "cmd", "boot", "set", "pretty", "obj", "file", "res", "nt", "inter", "g", "null", "log", "not", "store", "OUT", "co", "cache", "io", "ne", "print", "n", "tree", "conn", "term", "it", "ret", "or", "OU", "table", "ou", "inv", "to", "aos", "ch", "no", "write", "json", "summary", "o", "end", " output", "at", "w", "cn", " OUT", "unt", "p", "v", "ex", "screen", "sum", "con", "cfg", "group", "str", "outs", "c", "all", "msg", "up", "os", "desc", "t", "ot", "output", "gr", " Out", "list", "over", "net", "sys", "on", "writer", "session", "pool", "det", "ion", "client", "txt", "i", "ext", "Out", "outer", "can"], "fis": ["freis", "foois", "elfisan", "freens", "fisan", "cens", "fens", "cris", "elfos", "Fis", "fris", " fiss", "sfis", "fiss", "cfis", "freris", "Fois", "foiss", " fois", "sfos", "sfiss", "cfiss", "Fist", "sfisan", "foos", "freois", " fisan", "foens", "fist", "Fos", "cfos", "elfis", "foist", "elfiss", "cis", " fist", "Fiss", "foris", "fois", "cois", "cfois"], "fos": ["fous", " fres", "fooes", "fom", "fsys", "foss", "lis", "wos", "fioes", "fortoss", "fres", "flis", "vom", "wis", "fus", "fortres", "pis", "voss", "floss", "Foss", "foes", " foss", "lus", " fom", "fiios", "flot", "pus", "poes", "voes", "vot", " fot", " fsys", "foos", " foes", "flos", "Fsys", "fortsys", "fot", "pos", "Fres", "fortos", "wres", "Fos", " fios", "flres", "fiot", "loes", "flom", "vos", "los", "fois", "wom", "vios", "fios"], "srcModified": ["srcModsmodified", "rcModmodified", "srcTrified", "srcModsified", "srcModify", "srcMODed", "curModsified", "srcMODified", "srcTrify", "srcmodifier", "srcModsifier", "rcTrifier", "rcModifier", "srcTrined", "srcModifier", "srcModmodified", "curModsification", "srcModsined", "srcTred", "curModification", "srcHasified", "rcModed", "srcModsify", "srcMODmodified", "srcModsification", "curModsify", "rcModified", "rcModined", "srcMODification", "rcTrify", "srcHasmodified", "srcTrmodified", "curModify", "rcTrined", "srcModined", "curModsmodified", "rcTrmodified", "srcHasifier", "srcmodify", "curModified", "srcMODify", "srcMODifier", "srcModification", "srcmoded", "rcTrified", "srcmodified", "srcTrifier", "rcModify", "srcModed", "srcHasined", "curModmodified", "rcTred"]}}
{"id1": "9275622", "id2": "15799935", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " duplicateFile", "copyfile", " cpFile", " copyFiles", " cpfile", " cpFiles", " duplicateStream", "copyFiles", " copyStream", " duplicatefile", " cpStream", " copyfile", " duplicateFiles"], "_file1": ["_fileFirst", "_fileInit", "_File1", "_ileOne", "_File2", "_FileFirst", "_linkInit", "_filesFirst", "_files1", "_files2", "_linkOne", "_ileFirst", "_FileInit", "_ile1", "_ileInit", "_filesOne", "_FileOne", "_link2", "_fileOne", "_ile2", "_link1"], "_file2": ["_image02", "_File02", " _File1", " _Filetwo", "_fileTwo", "_File1", " _fileb", " _filetwo", "_File2", " _FileTwo", "_FILE1", "_image2", " _FILE1", " _FILEb", " _file02", "_image1", "_FILEb", "_FILE02", " _FILE02", "_Fileb", "_imageb", " _fileTwo", "_linktwo", "_FileTwo", "_Filetwo", "_FILE2", "_linkTwo", "_file02", "_link2", "_filetwo", " _File2", " _FILE2", "_fileb", "_link1"], "fis": ["fais", " fi", "cfris", " fris", "flis", "qos", "Fis", "fris", " fiss", "qis", "fiss", "qios", "cfis", "Fois", " fois", "ufios", "cfiss", "ufis", "Fris", "kios", "kis", " fais", "fli", "cos", "Fos", "fi", " fios", "Fios", "kais", "qiss", "cios", "cais", "cis", "ufiss", "Fiss", "fois", "ufi", "fliss", "cfois", "flios", "kos", "fios"], "fos": ["ffos", " fose", "wos", "foss", "ffoss", "mos", "hos", "sfose", "flis", " faos", "wows", "wis", "moes", "floss", "ffoes", "foes", "hose", "woss", " foss", "sfos", "hoes", "fows", "sfoes", "flos", "maos", "faos", "ffis", "floes", "mows", "waos", "woes", "hoss", " fows", "sfoss", " foes", "fose"], "canalFuente": ["canallfueree", "canalTenente", "canalUtent", "canalUtente", "canalFiente", "canalFalje", "canalFalente", "canalFuestro", "canalTenperor", "canalFalestro", "canalUteree", "canalFiperor", "canalFaleree", "canalfuenza", "canalfuperor", "canalFalent", "canallFueree", "canalTenenza", "canallFuenza", "canalKuente", "canallfuestro", "canalFienza", "canalKuent", "canalfuje", "canalUtestro", "canalFuent", "canallfuente", "canalFuperor", "canalFalperor", "canallfuperor", "canallFuent", "canalfueree", "canallfuje", "canalFuenza", "canalFueree", "canallFuestro", "canallfuenza", "canalfuente", "canalKuje", "canalKuperor", "canallFuperor", "canalTenent", "canallfuent", "canalFuje", "canallFuente", "canallFuje", "canalFient", "canalfuent", "canalfuestro"]}}
{"id1": "4982745", "id2": "12586404", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "label": 0, "substitutes": {"doJSONRequest": ["doCustomQuery", "doHTTPQuery", " doJSONConnection", "doJSONResponse", "dojsonConnection", "dojsonRequest", "doHTTPRequest", " doJSONResponse", " doHTTPResponse", "doCustomResponse", "doCustomConnection", "dojsonQuery", "doHTTPResponse", "dojsonResponse", " doHTTPQuery", "doCustomRequest", " doHTTPRequest", "doJSONQuery", "doHTTPConnection", " doJSONQuery", " doHTTPConnection", "doJSONConnection"], "jsonRequest": ["jsonPost", "JSONRequest", "JSONObject", "rawResponse", "JSONResponse", "sonPost", "jsonObject", " jsonPost", "JSONPost", "sonRequest", "rawPost", "rawObject", " jsonObject", "rawRequest", "sonResponse", "sonObject"], "request": ["initial", "update", "context", "Request", "object", "record", "copy", "search", "person", "position", "question", "message", "self", "instance", "begin", "pair", "setup", "order", "complete", "q", "hello", "first", "xml", "claim", "application", "resource", "http", "post", "QUEST", "re", "insert", "remove", "add", "req", "report", "quest", "transform", "query", "document", "address", "reference", "name", "this", "call", "client", "get", "input", "create", "close", "reset", "condition", "start", "url", "remote", "use", "command", "job", "project", "requ"], "params": ["param", "ars", "pins", "terms", "pres", "caps", "rs", "par", "eters", "Parameters", "chains", "properties", "pers", "types", "sys", "actions", "pps", "mm", "ctx", "amps", "options", "headers", "pkg", "multi", "gs", "spec", "ams", "cap", "ims", "as", "shape", "phys", " parameters", "eps", "tmp", "parent", "styles", "settings", "cp", "pool", "services", "changes", "members", "cas", "points", "posts", "details", "parts", "proc", "json", "lines", "pas", "prop", "ports", "names", "rules", "groups", "tags", "ps", "stats"], "entity": ["el", "object", "quote", "pe", "encrypted", "shell", "person", "iam", "model", "security", "eme", "ity", "enc", "email", "ent", "ae", "e", "user", "le", "environment", "buffer", "valid", "ITY", "xml", "om", "application", "entry", "iso", "Entity", "error", "resource", "em", "note", "ell", "metadata", "comment", "available", "query", "document", "obj", "connection", "orm", "code", "event", "details", "activity", "create", "account", "oe", "null", "json", "ip", "type", "ct", "ce", "component"], "t": ["f", "wt", "et", "ot", "z", "mt", "tw", "tt", "p", "ut", "dt", "tick", "tc", "total", "s", "e", "tim", "iat", "duration", "m", "pt", "st", "tf", "it", "c", "qt", "ti", "j", "ts", "x", "nt", "at", "y", "det", "txt", "w", "ta", "elt", "i", "tm", "g", "l", "vt", "time", "ct", "temp", "d", "T", "now", "tp", "n"], "response": ["onse", "object", "reply", "output", "data", "message", "given", "description", "service", "e", "environment", "sequence", "tree", "network", "resp", "application", "answer", "status", "re", "frame", "report", "document", "res", "connection", "body", "out", "client", "memory", "respond", "one", "reset", "Response", "json", "version", "success", "next", "remote", "result"], "responseString": ["ResponseText", "ResponseString", "ResponseArray", "outputText", "Responsestring", "resultObject", "messageString", "replyString", "ResponseObject", "outputString", "responseSystem", "outputStr", " responseObject", "answerStr", "replystring", "replySystem", "messagestring", " responseSystem", "ResponseSystem", "messageObject", "messageStr", " responseArray", "responseObject", "responseStr", "answerstring", "responseArray", "responsestring", " responseText", "resultStr", " responsestring", "answerString", "replyStr", "resultstring", "resultString", "outputArray", "responseText", "answerObject", "ResponseStr", " responseStr"], "jsonResponse": ["jsonAnswer", "JSONRequest", "JSONData", "xmlResp", "JSONObject", "csvStatus", "csvAnswer", "xmlAnswer", "csvResp", "JSONResponse", "jsonStatus", "xmlError", " jsonData", " jsonresponse", "xmlObject", "csvResponse", "jsonObject", "JSONresponse", "sonResp", "sonError", "sonRequest", "sonStatus", " jsonObject", "JSONAnswer", "sonAnswer", "sonResponse", " jsonResp", "jsonResp", " jsonStatus", "jsonresponse", "xmlRequest", "sonData", "sonresponse", "xmlResponse", "jsonData", " jsonAnswer", "JSONResp", "sonObject"], "jsonError": ["JSONAuth", "sonQuery", "jsonQuery", "jsonAuth", "jQuery", "JSONEr", "jEr", "JSONResponse", "javascriptError", "javascriptQuery", " jsonQuery", "javascriptEr", "sonEvent", "jError", "jAuth", "sonError", " jsonEvent", "sonResponse", "JSONQuery", "JSONEvent", "JSONError", "javascriptAuth", "jsonEvent", "jsonEr"]}}
{"id1": "12847055", "id2": "14194234", "code1": "        public MobileAgentProperties(Class declaringClass, String propertyFile) throws IOException {\n            this.defaults = (MobileAgent) AnnotationElement.getAnyAnnotation(declaringClass, MobileAgent.class);\n            URL url = getClass().getClassLoader().getResource(propertyFile);\n            if (url != null) {\n                props.load(url.openStream());\n                log.info(\"MobileAgent parameters loaded from file \" + url);\n            }\n        }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"declaringClass": ["declasingCl", "DeclaringClosure", "declarationCl", "declasingClass", "declosingFile", "DeclaringFile", "explarationClass", "declosingCl", "DeclosingClosure", "declarationPackage", "declaringClosure", "declosingPackage", "declearingCl", "explaringCl", "DeclosingCl", "DeclosingClass", "declosingClosure", "declaringCl", "declaredPackage", "declaringPackage", "DeclosingFile", "explaringClass", "explaringPackage", "declosingClass", "declasingClosure", "DeclaringClass", "explarationPackage", "declasingFile", "declaringFile", "declearingClosure", "declearingClass", "DeclaringCl", "explarationCl", "declaredClass", "declarationClass", "declearingFile", "declaredCl"], "propertyFile": [" propertyfile", "propertiesFilename", "propertiesFile", "propFile", "PropertyPath", "propfile", "Propertyfile", "propertiesfile", "PropertyFile", "propertyPath", "propPath", "propertyFilename", "propertyfile", "propertiesPath", " propertyFilename", "PropertyFilename", " propertyPath", "propFilename"], "defaults": ["platformes", "defaultd", "configes", "configs", "customes", "customaults", "configaults", "platformaults", "platformd", "platforms", "customs", "customd", "defaultes", "configd", "defaultaults"], "url": ["f", "u", "sl", "ssl", "server", "gl", "org", "id", "location", "ls", "dl", "il", "char", "external", "bel", "kl", "lr", "path", "ref", "user", "web", "buffer", "src", "str", "ll", "xml", "term", "loader", "or", "resource", "http", "rl", "ul", "nl", "fr", "browser", "ur", "impl", "sql", "URL", "sb", "file", "res", "key", "zip", "r", "uri", "Url", "l", "null", "abs", "cl", "fl", "log", "util", "bb", "html"]}}
{"id1": "2461169", "id2": "6866575", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileFileString", "decodeFileFileFiles", "decodeFileFilefile", "decodeFileFileFile", "decodeString2Files", "decodeStringTofile", "decodeFileAsFile", "decodeStringToFiles", "decodeFile2File", "decodeFileAsFiles", "decodeString2File", "decodeFileToString", "decodeFileAsString", "decodeFileTofile", "decodeFileToFiles", "decodeString2String", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFile", "decodeStringToString", "decodeString2file", "decodeFile2file"], "infile": ["isinfile", "Inbase", "frombase", "fromfilename", "inputfolder", "Infile", "Infilename", "isinname", "fromfile", "inname", "inbase", "inputfile", "outbase", "infolder", "fromFile", "inFile", "infilename", "outname", "isinFile", "inputname", "isinfolder", "outFile", "InFile", "outfilename", "outfolder", "inputFile"], "outfile": ["todir", "inFILE", "inname", "otname", "OutFile", "otFile", "otfile", " outname", "Outfilename", "outdir", "otFILE", "inFile", "infilename", "outname", "toFile", "tofilename", "outFILE", " outFILE", "indir", "tofile", " outFile", "Outfile", "Outdir", "outFile", "outfilename"], "in": ["ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "auto", "nt", "fn", "ion", "can", "write", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "paste", "attribute", "comment", "shape", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "shift", "check", "write", "before", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "scope", "sufficient", "value", "exist", " succeeds", "ratulations", "support", " succeed", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "2461169", "id2": "20602651", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileFileString", "decodeFileFileFiles", "decodeFileFilefile", "decodeFileFileFile", "decodeString2Files", "decodeStringTofile", "decodeFileAsFile", "decodeStringToFiles", "decodeFile2File", "decodeFileAsFiles", "decodeString2File", "decodeFileToString", "decodeFileAsString", "decodeFileTofile", "decodeFileToFiles", "decodeString2String", "decodeFileAsfile", "decodeFile2Files", "decodeStringToFile", "decodeStringToString", "decodeString2file", "decodeFile2file"], "infile": ["isinfile", "Inbase", "frombase", "fromfilename", "inputfolder", "Infile", "Infilename", "isinname", "fromfile", "inname", "inbase", "inputfile", "outbase", "infolder", "fromFile", "inFile", "infilename", "outname", "isinFile", "inputname", "isinfolder", "outFile", "InFile", "outfilename", "outfolder", "inputFile"], "outfile": ["todir", "inFILE", "inname", "otname", "OutFile", "otFile", "otfile", " outname", "Outfilename", "outdir", "otFILE", "inFile", "infilename", "outname", "toFile", "tofilename", "outFILE", " outFILE", "indir", "tofile", " outFile", "Outfile", "Outdir", "outFile", "outfilename"], "in": ["ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "auto", "nt", "fn", "ion", "can", "write", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "paste", "attribute", "comment", "shape", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "shift", "check", "write", "before", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "scope", "sufficient", "value", "exist", " succeeds", "ratulations", "support", " succeed", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "5441579", "id2": "19109981", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createPseudoUUID": ["createPseudoUuid", "createPseudoRandomUID", "createPseudoUID", "createPseanRandomID", "createPseudoUniqueuid", "createPseanUID", "createPseudoUniqueID", "createPseudoRandomId", "createPseanRandomUID", "createPseudoUUUID", "createPseanUId", "createPseudoUId", "createPseudoUUId", "createPseudoRandomID", "createPseanUUID", "createPseudoRandomuid", "createPseudoUniqueId", "createPseanRandomuid", "createPseudoUniqueUID", "createPseanUuid", "createPseudoUUuid", "createPseanRandomId"], "messageDigest": [" messageDiger", "messageDrise", "messageDesignist", "messageDriest", "messageDigests", "messageDigested", " messageDigment", "messageMacest", " messageDesignest", "numberDesignests", "messageDist", " messageDesignester", "messageMacse", "messageDests", "messageDesignest", "messagedigist", "numberDesignist", "numberDesignest", " messageDigested", "messageDesignests", "numberDigest", "messageHasests", "messagedigse", " messageDigifier", " messageDigester", "messagediger", "messageLocest", " messageDesignist", "numberDesignester", "messageDest", "messageHasest", "messageHasist", " messagedigest", "messagedigested", "messageLocment", " messagedigifier", "messageDesignse", "messageDigester", "messagedigest", "messageDiger", " messageDigse", "messageDigment", "messageDriist", "numberDigests", "messageDigse", "messageLocse", "messageMacested", " messageDesignse", "messageDesignester", " messagedigment", "messageMacer", "messageDester", " messageDigist", "messagedigifier", "messagedigester", "messageDigifier", "numberDigester", "numberDigist", "messagedigment", "messageDriester", " messagedigse", "messageLocifier", "messageDigist", "messageHasester"], "localHost": ["Localhost", "localServer", "LocalServer", "localAddress", "localhost", "LocalHost", "remoteHost", "remoteAddress", "localPort", "localhosthost", "LocalPort", " localPort", "localhostHost", " localAddress", " localhost", " localServer", "localhostPort", "remotehost", "remotePort", "LocalAddress", "localhostServer"], "digestBytes": ["digestedBs", "Diggestbytes", " digestKeys", "DigestParts", "diggeAttributes", " digestedbytes", "digestBs", "mixestedbytes", "DigestServices", "digestedParts", "mixestAttributes", "digestServices", " digestResults", "digesterBs", "digESTBytes", "mixestArgs", "digestParts", "digestExamples", "mixestedArgs", "digetParts", " digestedBytes", "digesterResults", "mixestedServices", "digistanceKeys", "digesterValues", " digestArgs", "Digestbytes", "diggestExamples", "digestValues", "digestedResults", "diggestbytes", "digESTArgs", "digstBytes", "digestArgs", "digesterArgs", " digestValues", "digestAttributes", "digstParts", "diggestBytes", "digistanceBytes", "DiggestBytes", "digESTLinks", "diggeParts", "digesterLinks", "diggeBytes", "digetbytes", "digstServices", "digesterbytes", "digesterParts", "digestKeys", "diggeServices", "digetBytes", "mixestedBytes", "digestbytes", "digstAttributes", " digestedValues", "mixestedAttributes", "mixestbytes", "digestedServices", "digesterBytes", "DigestBytes", "digistanceExamples", "diggestParts", "mixestedParts", "digestedbytes", "drivenestBytes", "digestedArgs", "digESTValues", "digestedAttributes", "digestedLinks", "drivenesterValues", "drivenestBs", "diggestServices", "digESTbytes", "mixestedLinks", "digestedValues", " digestExamples", "mixestLinks", "DiggestServices", "digestResults", "mixestServices", "drivenestParts", "diggestKeys", "digestLinks", "drivenesterBs", " digestbytes", "digestedBytes", " digestParts", "mixestBytes", "digetServices", "DiggestParts", "mixestParts", "drivenestValues", "drivenesterParts", "drivenesterBytes"], "sb": ["sth", "sl", "ssl", "sh", "abb", "b", "bs", "shell", "bf", "bn", "SB", "jp", "ib", "sd", "bp", "sn", "obb", "nb", "src", "sw", "esm", "gob", "rob", "sf", "bps", "fb", "ibl", "bis", "tn", "sv", "bh", "storage", "stab", "bg", "wb", "pg", "sam", "gc", "eb", "sp", "bt", "erb", "lp", "gb", "bj", "bash", "lb", "ctrl", "kb", "db", "zb", "pb", "ub", "rb", "sg", "bb", "sbm", "cb", "sa"]}}
{"id1": "7846688", "id2": "8665321", "code1": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"postData": [" Postdata", "PostText", " PostData", "storeData", "storeText", "storedata", "postdata", "storeString", " PostText", "PostString", "Postdata", "postString", "postText", "PostData", " PostString"], "protocol": ["protype", "topavior", "horotype", "retology", "rotocol", "horolean", "topocol", "topotype", "Protavior", "Protport", "horavior", "Protocol", "proace", "proturation", "roturation", "Protace", "returation", "prootype", "protol", "protace", "protology", "topol", "retocol", "terminology", "pronport", "retotype", "prototype", "rototype", "protport", "prace", "pronocol", "Protology", "procol", "protolean", "rotology", "topolean", "terminuration", "proolean", "topology", "protavior", "terminotype", "Prototype", "proocol", "pronolean", "terminocol", "prport", "proport", "rotol", "horocol", "Protol", "pronotype", "Protolean"], "host": ["loc", "context", "bind", "server", "domain", "th", "org", "node", "Host", "port", "https", "other", "campus", "pattern", "where", "format", "home", "localhost", "hook", "ether", "path", "net", "chain", "target", "addr", "on", "subject", "sche", "http", "arch", "control", "ca", "prefix", "dir", "hop", "topic", "console", "cert", "build", "address", "hash", "system", "height", "client", "check", "h", "serial", "graph", "hand", "uri", "help", "mac", "ost", "ip", "human", "root", "remote", "kind", "project", "handle"], "form": ["f", "loc", "cmd", "th", "field", "stream", "co", "old", "other", "pattern", "format", "reg", "list", "ent", "path", "user", "ac", "hidden", "term", "from", "raw", "mod", "text", "c", "request", "part", "arch", "post", "col", "method", "table", "control", "password", "fr", "session", "transform", "query", "forms", "Form", "file", "orm", "body", "act", "ch", "params", "FORM", "zip", "template", "input", "proc", "config", "auth", "brand", "tab", "row", "type", "prop", "ct", "ce", "command", "component", "fc"], "data": ["rel", "DATA", "output", "value", "ata", "dl", "cache", "dat", "message", "format", "description", "area", "string", "content", "empty", "chain", "any", "buffer", "valid", "str", "block", "zero", "raw", "text", "size", "post", "response", "password", "what", "all", "auto", "batch", "body", "missing", "only", "none", "no", "def", "input", "one", "row", "na", "default", "bytes", "t", "action", "draw", "result", "n"], "url": ["loc", "rel", "sl", "cal", "ssl", "bl", "gl", "atl", "ls", "dl", "arl", "il", "hl", "char", "bel", "str", "ll", "xml", "conn", "http", "re", "ul", "nl", "link", "www", "browser", "ur", "URL", "sb", "build", "open", "mount", "call", "pl", "r", "Url", "l", "abs", "fl", "log", "job"], "con": ["cn", "const", "cal", "en", "co", "ran", "cf", "com", "dial", "connect", "nc", "canon", "sin", "don", "ln", "un", "bin", "conn", "c", "pen", "col", "Con", "comm", "ver", "sub", "connection", "Conn", "cert", "ain", "cos", "fn", "act", "soc", "cond", "pc", "CON", "fac", "call", "open", "cur", "ctrl", "bc", "conv", "cone", "conf", "proc", "cons", "cl", "coll", "fl", "cm", "fc", "cont", "can"], "out": ["cn", "output", "en", "OUT", "co", "gr", "screen", "list", "ln", "net", "io", "group", "print", "bin", "set", "conn", "outs", "writer", "OU", "re", "ou", "pretty", "to", "ro", "all", "comment", "obj", "res", "aos", "body", "cos", "put", "can", "client", "check", "write", "oss", "inner", "help", "conv", "null", "os", "ao", "success", "flush", "summary", "o", "log", "Out", "outer", "n"], "in": ["f", "ins", "din", "el", "en", "old", "sum", "IN", "rec", "inn", "ai", "io", "inf", "cin", "gin", "on", "bin", "from", "ic", "it", "or", "all", "mn", "al", "ain", "reader", "ind", "is", "inc", "check", "up", "rin", "i", "r", "input", "iter", "inner", "win", "oin", "info", " din", "read", "In"]}}
{"id1": "6470716", "id2": "22993368", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"st": ["sth", "ft", "rt", "sh", "std", "store", "stream", "th", "sts", "nd", "service", "stable", "sn", "ust", "str", "sw", "set", "St", "sta", "inst", "step", "sty", "www", "sp", "est", "stri", "se", "ST", "ld", "ste", "start", "ost", "ist", "rest", "t", "ast", "d", "stra", "tt", "sm"], "url": ["f", "loc", "rel", "host", "el", "sl", "ssl", "domain", "gl", "shell", "location", "ls", "dl", "il", "hl", "char", "bel", "github", "string", "web", "ref", "addr", "rect", "str", "ll", "ret", "http", "li", "ul", "nl", "link", "www", "browser", "ur", "impl", "URL", "file", "cert", "build", "base", "address", "ch", "mount", "mail", "client", "pl", "r", "uri", "Url", "l", "cl", "abs", "null", "fl", "rest", "html"], "fis": ["fais", " fi", "feier", "feois", "flis", "xfois", "ef\u00eds", "fisl", "tiss", "Fis", "Fais", " fisl", "xfi", "uf\u00eds", " fiss", "fiss", "f\u00eds", "Fois", "feis", "tos", "efiss", "ufis", "tis", "fei", "tais", "flisl", " fais", "fli", "Fier", "xfis", "Fos", "xfier", "fi", "ufisl", " f\u00eds", "efis", "fier", "ufiss", "Fiss", "fliss", "fois", "efi", "ufi", "Fi"], "zis": ["zeniss", " zris", "zipes", "czIs", "zes", "ozisa", "zipis", "zisa", "ozes", "ziss", "fris", "fiss", " zisa", "zIs", "zipIs", "zenisi", "ozIs", "zos", "zhisin", "zenris", " zisi", " zos", "fisi", " ziss", "zits", "zisi", "zipos", "zhIs", "ozis", "zenis", "fits", "ozisin", " zIs", "zhes", "ozits", "czisa", "zhis", " zits", "czis", "zisin", "czits", "zris", "zipits", "zipisin"], "entry": ["record", "entity", "field", "ry", "office", "match", "pattern", "char", "enter", "list", "ent", "e", "way", "form", "chain", "cell", "member", "valid", "or", "link", "de", "fr", "comment", "attribute", "jar", "key", "item", "card", "obj", "ie", "tmp", "nt", "sp", "be", "existent", "event", "zip", "name", "system", "element", "def", "out", "inter", "line", "word", "se", "source", "null", "row", "log", "ce", "Entry", "zo", "jo", "info", "index", "result"], "count": ["length", "max", "ount", "core", "num", "match", "sum", "total", "char", "cc", "cell", "acc", "nb", "buffer", "err", "c", "size", "add", "page", "comment", "child", "force", "code", "nt", "base", "batch", "ch", "amount", "name", "ind", "depth", "current", "check", "call", "counter", "found", "number", "len", "last", "iter", "start", "ctr", "ct", "Count", "t", "end", "index", "read", "cont", "n"], "data": ["image", "DATA", "length", "output", "value", "ata", "cache", "dat", "message", "format", "area", "buf", "string", "chain", "buffer", "bin", "block", "raw", "zero", "text", "part", "size", "table", " DATA", "step", "reason", "all", "batch", "name", "good", "def", "out", "mem", "number", "done", "source", "json", "mu", "bytes", "next", "sample", "d", "result", "n"], "fos": ["fiops", "fooss", "wos", "foss", "hos", "fioss", "wis", "his", "Foss", "fol", "woss", " foss", "foops", "wOS", "foos", "fOS", "fool", "fiol", "Fol", "Fos", "fops", "hOS", "hoss", " fOS", "Fops", "fios"], "dest": ["loc", "crit", "output", "std", "exp", "Dest", "nd", "dat", "sum", "transfer", "usr", "way", "target", "origin", "test", "member", "src", "bin", "gest", "writer", "dist", "dc", "them", "trans", "gate", "coord", "des", "nom", "ptr", "result", "send", "nt", "est", "parent", "det", "pipe", "master", "out", "comp", "mem", "comb", "source", "done", "cat", "foreign", "decl", "desc", "pas", "rest", "temp", "cont"]}}
{"id1": "1097146", "id2": "12586404", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getContentDigest", "getContentdigests", "getMessageDigests", "getContentDigests", "getMessageDecested", "getMessagedigested", "getContentDigested", "getMessagedigester", "getContentDigester", "getContentdigested", "getContentdigest", "getMessageDecester", "getMessagedigest", "getMessageDigester", "getContentdigester", "getMessageDigested", "getMessageDecest", "getMessageDecests", "getMessagedigests"], "input": ["image", "initial", "cmd", "output", "value", "p", "pattern", "data", "char", "format", "Input", "string", "empty", "form", "buffer", "state", "q", "any", "qi", "xml", "valid", "in", "raw", "from", "text", "request", "it", "active", "quick", "focus", "file", "missing", "uu", "address", "msg", "act", "name", "this", "check", "out", "up", "get", "source", "qa", "config", "cur", "required", "null", "url", "unknown", "human", "sample", "password", "hello"], "md": ["pdf", "cmd", "dr", "dd", "mt", "der", "mg", "dh", "mk", "sd", "med", "od", "ms", "m", "mm", "pm", "pd", "mod", "ds", "sam", "mc", "mn", " Md", "df", "managed", "mp", "nt", "ad", "dm", "mand", "det", "mb", "def", "comp", "grad", "ld", "di", "cd", "bd", "mu", "hd", "cm", "d", "MD", "sm"], "bytes": ["terms", "rings", "words", "b", "binary", "bs", "bits", "values", "videos", "ls", "classes", "clips", "s", "bles", "windows", "nets", "ms", "files", "strings", "Bytes", "outs", "bps", "users", "pieces", "reports", "forms", "tes", "seconds", "objects", "latest", "keys", "parts", "steps", "ings", "bags", "es", "pages", "lines", "versions", "groups", "units", "qs", "blocks"]}}
{"id1": "21488518", "id2": "19113613", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["CreateNew", "getNew", "dataNext", "getFresh", "dataNew", "createNext", "CreateNext", "getResource", "CreateResource", "CreateFresh", "getNext", "createResource", "dataFresh", "dataResource", "createFresh"], "name": ["value", "id", "old", "data", "client", "nm", "format", "description", "string", "path", "ename", "local", "normal", "Name", "part", "resource", "size", "alias", "NAME", "prefix", "handle", "key", "file", "missing", "body", "base", "address", "code", "none", "only", "word", "event", "current", "action", "lat", "ame", "template", "no", "title", "source", "filename", "one", "common", "create", "null", "version", "type", "time", "named", "end", "names", "now", "password", "use", "index", "n"], "in": ["ins", "din", "en", "b", "p", "data", "IN", "inn", "con", "s", "cin", "gin", "mm", "err", "bin", "xml", "from", "it", "c", "vin", "file", "mc", "al", "ma", "body", "reader", "ind", "is", "rin", "get", "i", "input", "r", "source", "inner", "asin", "mat", "t", "isin", "In"], "length": ["max", "value", "stream", "position", "count", "data", "message", "total", "enc", "description", "content", "path", "sequence", "buffer", "duration", "text", "size", "shape", "body", "amount", "height", "len", "input", "padding", "bytes", "password", "Length", "read"], "contentType": ["contentTypes", "mediaType", "ContentType", "ContentTypes", "contentLength", "mediaLength", "ContentLength", "mediatype", " contentLength", " contenttype", "mediaTypes", " contentTypes", "Contenttype", "contenttype"], "dest": ["loc", "there", "folder", " destination", "copy", "Dest", "dat", "self", "home", "disk", "path", "target", "origin", "src", "resp", "table", "orig", "trans", "dir", "coord", "wb", "nom", "obj", " dst", "result", "tmp", " Dest", "parent", "this", "mem", "comb", "source", "iter", "oe", "lit", "cat", "prop", "rest", "d", "temp", "cont"], "out": ["copy", "output", "en", "OUT", "co", "Out", "port", "serv", "ex", "external", "ent", "con", "s", "net", "io", "sys", "set", "conn", "outs", "it", "OU", "ou", "col", "to", "obj", "file", "res", "po", "op", "aos", "cos", "ion", "client", "write", "off", "up", "can", "oss", "conv", "os", "null", "o", "t", "log", "end", "go", "w", "outer", "n"], "request": ["Request", "ask", "search", "move", "forward", "message", "select", "begin", "pair", "enter", "user", "require", "claim", "push", "re", "QUEST", "response", "remove", "ire", "quest", "req", "report", "query", "result", "child", "library", "relative", "reference", "params", "open", "current", "input", "create", "reset", "url", "requ"]}}
{"id1": "8062076", "id2": "5436973", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "label": 0, "substitutes": {"updateUser": ["UpdateAccount", "UPDATEUser", "UpdateUsers", "UPDATEAccount", "UPDATEUsers", "UpdateUser", " updatePerson", " updateAccount", "UpdatePerson", "updateUsers", "updateAccount", "updatePerson", " updateUsers", "UPDATEPerson"], "portalUserBean": ["portalUserDeann", "portalUserBEann", "portalFileBelane", "portalClientBeon", "portalUserbeane", "portalUserBEin", "portalUserBEoon", "portalClientRoan", "portalUserBeane", "portaluserBebean", "portalUserBelann", "portalUserDean", "portalUserBelan", "portalPersonProAN", "portalPersonBein", "portalPersonProen", "portalUserRoan", "portalOwnerBelann", "portalUserRoann", "portalUserSoun", "portalPersonBeen", "portalPersonPean", "portalUserRoane", "portalUserBroann", "portalUserBoan", "portalUserBrooon", "portalUserRoon", "portalPersonPeale", "portalUserBann", "portalClientRoans", "portalUserPebean", "portalOwnerBean", "portalUserBans", "portalUserBEans", "portalUserBbean", "portalUserPeen", "portalFileBebean", "portalUserSoan", "portalUserPean", "portalUserBein", "portaluserPean", "portalClientBeann", "portalPersonPeAN", "portalOwnerBeann", "portalFileBeane", "portalPersonBeAN", "portalUserBeoon", "portalUserBeann", "portalFileBelan", "portalOwnerBelun", "portaluserPebean", "portalUserSoann", "portalUserProAN", "portalClientRoon", "portalUserBeAN", "portalUserBun", "portalPersonProan", "portalUserbean", "portalPersonPeoon", "portalUserBelane", "portalUserBoann", "portalPersonBeoon", "portalClientBeans", "portalUserObjectale", "portalUserBon", "portalUserBelbean", "portalUserbeann", "portalUserPeann", "portalUserObjectan", "portalUserBoAN", "portalUserProbean", "portalPersonPeann", "portalClientBeAN", "portalUserProan", "portalUserBeon", "portalPersonBeale", "portalPersonProann", "portalOwnerBelan", "portalUserBelun", "portalClientBean", "portalUserDebean", "portalFileBean", "portalUserDeAN", "portalUserBeale", "portalUserPeAN", "portalUserBAN", "portalClientBann", "portalClientRoAN", "portalPersonBean", "portalUserbebean", "portalUserBeun", "portalUserBEon", "portalUserRoAN", "portalFileBelann", "portalClientBbean", "portaluserPeAN", "portalUserRobean", "portalClientBan", "portalUserPeale", "portalUserBoen", "portalUserBroin", "portalUserProann", "portalUserRoans", "portalUserBebean", "portalUserProen", "portalUserBeans", "portalUserBEAN", "portalClientBebean", "portalUserBroan", "portalUserProale", "portalFileBelbean", "portaluserBean", "portalUserPein", "portalClientBAN", "portalPersonBeann", "portalUserBEan", "portalFileBeann", "portalUserBan", "portalUserPeoon", "portalUserBeen", "portaluserBeAN", "portalPersonPein", "portalOwnerBeun", "portalUserObjectAN"], "authSession": ["authUser", "uthUser", " authUser", " authsession", "authsession", "authorClient", "authorSite", "authClient", "authorState", "Authsession", "aptClient", "AuthSession", "authSite", "selectSite", "aptState", "aptSite", "selectSession", "selectState", "authState", "authorSession", "selectClient", "uthsession", "aptSession", "uthSession", "AuthUser"], "dbDyn": ["dbNyn", "dbDys", "webDyn", "webDsyl", "dbGyn", "DbDyd", "dbCyp", "DbDy", "dbDbyn", "DbDoYN", "dbdyn", "dbDyd", "DbDoy", " dbDont", "dbFyn", "datCyp", "dbCreateily", "dbDsys", "dbDoy", "dbCyn", "webDsynam", "dbDoily", "dbNys", "dbdy", "dbCys", "dbGYN", "dbDoynam", "dbGys", "dbDont", "dbDoyl", "webDyl", "dbSYN", "dbDily", "dbCYN", "dbSyl", "DbDyn", "dlDyn", "dbDync", "datCys", "DbDoyn", "dbdys", "dbSyn", "dbDsyl", "dbDoyp", "dbDeyn", "webDsyn", "dbDyl", " dbDYN", "dbCont", "dbSynam", "dbDuyn", "datDyn", "dbDynam", "dbNync", "dbDYN", "dbSy", "dbBindynam", "dbdync", "webDynam", "datDYN", "dbDoYN", "dbBindily", " dbDyp", "dbGyp", "dbDuys", "dbFy", "dbSsyn", " dbDoont", "datCYN", "dbCreateynam", "webDys", "dbDsynam", "webDsys", "dlCreateyn", "dbFyp", "dbDsyn", " dbDys", "dbDoys", "DbDoyd", "dlCreateynam", "datDys", "dlDily", " dbDy", "DbDYN", "dbFYN", "dbDyp", " dbDoYN", " dbDoys", "dbDy", "datCyn", "dbSyd", "dbFys", "datDyp", "dbSys", "dbDoyn", "dlDynam", "dbCreateyn", "dbDoont", "dbDuont", "dbDuYN", "dbFyd", " dbDsyn", "dbDesyn", " dbDync", "dbDbyp", " dbDoyn", "dbNy", "dbDoyd", "dbDbys", "dbDbYN", "dbDeYN", "dbBindyn", "dlCreateily"], "ps": ["fs", "params", "ats", "pe", "pres", "cs", "p", "bs", "sts", "rs", "qs", "jp", "ips", "PS", "s", "pers", "ys", "gres", "pps", "pt", "ress", "amps", "pp", "pd", "js", "gs", "ds", "ts", "ims", "res", "ptr", "wp", "sol", "eps", "Ps", "sp", "mp", "op", "vs", "ies", "aps", "pes", "ups", "pos", "pa", "itions", "pr", "fp", "als", "posts", "pl", "pse", "points", "ops", "ils", "ples", "ip", "fps", "ports", "ks", "its", "css", "ws", "tp", "stats"], "sql": ["rel", "sl", "ssl", "shell", "seed", "plan", "ls", "dl", "s", "string", "repl", "csv", "ln", "sn", "wal", "print", "sys", "pel", "xml", "ss", "ll", "sq", "js", "status", "join", "scl", "sal", "nl", "spec", "sv", "inv", "socket", "prefix", "query", "expression", "sb", "sol", "eps", "sp", "fn", "pr", "serial", "template", "details", "statement", "url", "ql", "SQL", "log", "spr", "series", "qs", "ws", "stats"], "idList": ["infoL", " idL", "uidlist", "idsL", "idsLIST", "IdList", "idL", "idlist", "uidList", "idLIST", "infolist", "Idlist", "IdLIST", " idLIST", "idsList", "infoLIST", "idslist", " idlist", "uidLIST", "infoList"], "num": ["eng", "nu", "nn", "Num", "cal", "hum", "node", "cu", "alph", "sum", "dec", "dat", "nm", "begin", "con", "hom", "tim", "um", "un", "nb", "tu", "zero", "multi", "ret", "umber", "den", "note", "orig", "coord", "nom", "mn", "snap", "prim", "non", "unit", "fac", "no", "dim", "mult", "gre", "mem", "number", "nam", "done", "NUM", "proc", "conv", "desc", "mat", "np", "draw", "index", "mon"], "i1": ["i61", " i0", "li0", " i2", "i0", "pi0", "li2", "I0", "I2", "pi1", "i2", "pi2", "li61", "li1", " i61", "I1", "I61", "pi61"]}}
{"id1": "10361370", "id2": "21827619", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"hash": ["update", "ashes", "ash", "header", "match", "profile", "sum", "message", "Hash", "print", "test", "array", "sign", "attribute", "tag", "key", "render", "code", "check", "h", "html", "version", "crypt", "filter", "password", "index", "handle"], "saltBefore": ["SaltBefore", "sALTAfter", "sashAfter", "saveAfter", "sadePrevious", "sALTBefore", "sashBefore", "SALTBefore", " sALTBefore", " saltStart", "sashStart", "SALTPrevious", "SALTAfter", "saveBefore", "savePrevious", "sadeAfter", "sadeBefore", "sadeStart", "saltStart", "SaltPrevious", "SaltAfter", " sALTStart", "saltPrevious", "sALTPrevious", " sALTAfter", "sALTStart"], "content": ["image", "initial", "translation", "object", "record", "entity", "value", "output", "license", "present", "data", "message", "Content", "format", "description", "string", "path", "sequence", "any", "str", "subject", "xml", "example", "raw", "text", "c", "reason", "comment", "expression", "document", "file", "body", "code", "word", "current", "txt", "source", "input", "title", "config", "html", "null", "json", "url", "time", "media", "password", "cont"], "saltAfter": ["SaltBefore", "sintAfter", "sALTAfter", "saveafter", "SaltPost", "vintBefore", "soltResult", "saveAfter", "soltAfter", "SALTResult", "sALTBefore", "valtBody", "SALTBefore", "saltPost", "SALTAfter", "saveBefore", "sALTafter", "sadeResult", "saveBody", "valtAfter", "vintAfter", "vintBody", "sadeAfter", "sadeBefore", "valtBefore", "sintBefore", "sintafter", "vintafter", "sintBody", "sadePost", "saltafter", "soltBefore", "SALTPost", "SaltAfter", "sALTResult", "saltBody", "sALTPost", "valtafter", "sALTBody", "saltResult", "soltPost", "SaltResult"], "repeatedHashingCount": ["repeatedRashCC", "repeatedHashLength", "repeatedHashesCode", "repeatedRashingCounter", "repeatedHASHCount", "repeatedHachingLength", "repeatedRashingCode", "repeatedRashesCount", "repeatedHashesCC", "repeatedRashescount", "repeatedHashingLength", "repeatedHashCount", "repeatedRashCode", "repeatedRashCount", "repeatedHashingcount", "repeatedHashingCC", "repeatedHASHLength", "repeatedHashCC", "repeatedHashCode", "repeatedHashCounter", "repeatedRashesCounter", "repeatedHachingCount", "repeatedHashesLength", "repeatedHashesCount", "repeatedRashingcount", "repeatedRashingCount", "repeatedHachingCC", "repeatedHashescount", "repeatedHashesCounter", "repeatedRashingCC", "repeatedRashLength", "repeatedRashesLength", "repeatedHASHcount", "repeatedHachingCode", "repeatedRashingLength", "repeatedHashingCode", "repeatedHashingCounter", "repeatedHashcount", "repeatedHASHCounter"], "digest": ["diagnum", "compest", "digency", "Digested", "digist", "dest", "algEST", "descity", "debugency", " Digert", "commested", "fifitude", "DigEST", " digum", "dfested", "hashhash", "digesting", "algest", " digester", "dfester", "commse", "designester", "mdest", "descse", " digency", "Digute", "diagnests", "argEST", "Digester", " Digested", " Digester", "dester", "descested", "argest", "hashEST", "Digist", "dighest", "extester", "digests", "fifEST", " digesting", "fifency", "argested", "dfest", "fifest", "designesting", "printest", "fingeresting", "extest", "commest", " digse", "designested", "Dighash", "Digse", "dested", "compEST", "Digests", "diagnest", "digester", " digitude", "digitude", " digests", "digity", "extse", "descest", "extested", " digist", "argester", "hashute", "fingerhest", "digum", "algested", "printhest", "designest", " dighest", "diagnist", "digse", "comphash", " digert", " Digest", "digute", "fingerEST", "Digum", "dfesting", "printesting", " digested", "debugitude", "dighash", "mdse", "compute", "printEST", "dse", "debugEST", "mdested", "algester", "commity", "debugest", "digested", "dert", " digEST", " digity", "Digest", "hashest", "mdester", "digEST", "digert", "fingerest"], "digestLength": [" digesterLen", " digestData", "digistData", "descestLength", "digseLen", "digesterType", "descestOffset", "descesterlength", "descesterLength", "digesterLen", "descestLen", "digestlength", "digseOffset", "digestedLen", "digestedLength", " digesterData", "digestOffset", "digestedOffset", "digesterlength", " digesterType", "digestType", "digselength", "digestedData", "digestedlength", "digestLen", "digistType", "digistLength", "descestlength", "descesterLen", "digesterLength", "digestData", "descesterOffset", "digesterOffset", "digistLen", " digestLen", "digesterData", "digseLength", " digestType", " digesterLength", "digestedType"], "i": ["cli", "mi", "z", "u", "iq", "v", "ix", "ex", "ini", "I", "ii", "si", "ai", "bi", "print", "ms", "n", "q", "my", "m", "sim", "err", "me", "in", "iu", "multi", "ic", "it", "ei", "li", "ti", "j", "mill", "xi", "init", "sql", "x", "batch", "uu", "phi", "y", "ind", "is", "client", "ui", "gu", "iter", "uri", "di", "gi", "ci", "ip", "ski", "qi", "im", "index", "pi"]}}
{"id1": "5125848", "id2": "9718328", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"combineJs": ["CombineJs", "combINEJs", "combinateJs", "ComboseJs", "combinejs", "ComboseLink", "combINELink", "combineJS", "CombineJS", "combinateJS", "combINEJS", "ComboseJS", "combinatejs", "combineLink", "CombineLink", "combosejs", "combINEjs", "comboseJs", "Combinejs", "combinateLink", "comboseJS", "Combosejs", "comboseLink"], "base": ["host", " based", "server", "domain", "b", "id", "data", "api", "bas", "bid", "origin", "buffer", "absolute", "from", " basis", "re", "bottom", "based", "page", "Base", "prefix", "file", "address", " bases", "relative", " Base", "template", "source", "uri", "db", "reset", "ase", "start", "root", "site", "bound", "local"], "linkJs": ["LinkJS", "LinkJs", " linkScript", "linkjs", " linkLinks", "Linkjs", "linkedScript", "inkTags", "linkScript", "inkLinks", "inkScript", " linkTags", " linkJS", "LinkTags", "linkedLinks", "inkjs", "inkJS", "linkTags", "inkJs", "linkedJS", " linkjs", "linkLinks", "linkedJs", "linkJS"], "newFiles": ["newDocuments", "nextFiles", "newLinks", "newfiles", "linkFiles", "nextfiles", " newLinks", "nextDocuments", " newDocuments", "linkDocuments", "linkLinks", "nextLinks", " newfiles", "linkfiles"], "dir": ["div", "rel", " Dir", "folder", "loc", "fs", "dd", "dr", "id", " d", "ir", "DB", "dl", "mk", "disk", "area", "diff", "ref", "addr", "sys", "local", "tar", " directory", "pkg", "mod", "vol", "md", "file", "DIR", "auto", "tmp", "directory", "dm", "zip", "lock", "good", "def", "dep", "out", "doc", "done", "created", "wd", "db", "di", "manager", "cd", "desc", "Dir", "root", "fd", "temp", "d", "lib", "module"], "name": [" bar", " logger", " cleaner", " start", " os", " foo", " scanner", " vm", " tmp", " karma", " msg", " report", " dummy", " info", " self", " filename", " b", " manager", " parser", " browser", " prefix", " err", " rebuild", " names", " str", " db", " res", " loader", " log"], "minDir": [" minJar", "minDb", "smallDb", "miniTier", "MinNet", "smallDir", " minPref", "minTrans", "mainDir", "sortDir", "minNet", " minTier", "minuteDir", "skinLoc", " minNet", "smallFile", "miniDir", "MinFile", " minTrans", "skinDb", "minuteDar", "miniTrans", "mainLoc", "thinTier", "minPref", "MinDir", "minTier", "thinJar", "maindir", "thinDir", "minFile", " minDar", " minRel", "miniJar", "minRel", "minDar", "minuteRel", "minJar", " minFile", "smallLoc", "mainDb", "minutePref", "thinTrans", "smallNet", "sortDar", "mindir", "smalldir", "sortRel", "skinDir", "skindir", "minLoc", "sortPref"], "combineFile": ["coordineWriter", "comboiceMessage", "combINESet", "combinefile", "cominateMessage", "cominateFile", "combineSet", "coordINEFile", "comineMessage", "cominateEmail", "combineEmail", "combinerFile", "combosefile", "cominatefile", "combinSet", "comineFile", "combinerfile", "cominefile", "comboseWriter", "combinateFile", "comineEmail", "combinatefile", "combINEWriter", "combineMessage", "comboiceFile", "combinfile", "coordINESet", "comboseSet", "combINEFile", "comboiceEmail", "combinerEmail", "combinWriter", "coordINEfile", "coordinefile", "combINEfile", "comboseFile", "comboicefile", "coordINEWriter", "coordineFile", "combinateEmail", "combinFile", "combinerMessage", "coordineSet", "combinateMessage"], "concatFile": ["conCatFilename", "convertTable", "convertFilename", "concatDir", "concapFiles", "conatfile", "concFilename", "conCatDir", "concatTable", "concapfile", "covertTable", "conCatFile", "comcDir", "comcatDir", "conatFile", "cocatTable", "comcatFile", "covertFile", "covertfile", "cocatfile", "comcFile", "comcatFilename", "convertfile", "conatFiles", "concatfile", "concatFiles", "covertFiles", "concapFile", "conatTable", "concapTable", "concDir", "convertDir", "convertFiles", "comcFilename", "cocatFile", "concatFilename", "concFile", "cocatFiles", "convertFile"], "combineWriter": ["combineWrite", "combieFile", "declineReader", "combineReader", "combieReader", "combinateReader", "Combinewriter", "combinateWrite", "combinewriter", "combinateCounter", "combenCounter", "declinateFile", "combieWrite", "ComboseWriter", "declineFile", "combenwriter", "comboseWriter", "combinateFile", "ComboseCounter", "declinateReader", "combineCounter", "declinateWriter", "CombineWriter", "combenWriter", "comboseReader", "declineWriter", "comboseWrite", "Combosewriter", "comboseCounter", "comboseFile", "combosewriter", "declineWrite", "declinateWrite", "CombineCounter", "combinatewriter", "combinateWriter", "combieWriter", "combenWrite", "CombineWrite", "ComboseWrite"], "concatWriter": ["conatReader", "convertWrite", "conatWriter", "cocatWrite", "comvertWriter", "comvertReader", "conatFile", "comcatFile", "concatsReader", "convertReader", "conatWrite", "coatFile", "cocatWriter", "convertWriter", "cocatReader", "comvertFile", "concatsWrite", "coatWrite", "comcatReader", "comvertWrite", "concatsFile", "cocatFile", "concatsWriter", "concatReader", "coatReader", "comcatWriter", "coatWriter", "comcatWrite", "concatWrite", "convertFile"], "fails": ["fils", " focks", "frailing", "Failing", "focks", "facails", "failing", "facailed", "frailed", "mailing", "ifailed", "malls", "lailed", "mailed", "facocks", "Fails", "ifocks", "frils", "Failed", "mocks", "failed", "facailing", "ifails", "Fils", " failed", "frails", "lails", "lailing", "falls", "mails", "lalls", "lils", " falls", "ifailing", " failing"], "link": ["loc", "node", "mark", "match", "script", "linked", "task", "self", "relation", "ln", "ink", "links", "embed", "set", "push", "follow", "c", "li", "load", "map", "add", "inline", "skip", "child", "share", "code", "address", "open", "line", "check", "display", "Link", "source", "close", "l", "log", "remote"], "path": ["image", "loc", "id", "style", "p", "location", "match", "pattern", "data", "format", "string", "ref", "src", "str", "entry", "PATH", "text", "resource", "join", "alias", "prefix", "key", "file", "hex", "relative", "template", "full", "source", "input", "uri", "route", "prop", "Path", "root", "href", "kind", "ath"], "url": ["loc", "host", "rel", "sl", "ssl", "gl", "id", "location", "ls", "il", "hl", "char", "string", "web", "ref", "lr", "addr", "str", "ll", "request", "resource", "http", "li", "ul", "nl", "browser", "ur", "URL", "build", "address", "this", "mount", "mail", "get", "source", "r", "uri", "Url", "l", "abs", "null", "href", "html"], "inputStream": ["InputStyle", "InputTime", " inputSet", "InputSteam", "outputStyle", "inSet", "outputstream", "inTime", " inputstream", " inputSteam", "inStream", "inputSteam", "inputstream", "Inputstream", "instream", "inputStyle", " inputStyle", "InputSet", "InputStream", "outputSteam", "inputSet", "inputTime", " inputTime"], "jsFile": ["JsPath", "jFile", "jsPath", "cssFilename", "cssfile", "jPath", " jsTable", "cssTable", "jName", " jsPath", "javascriptPath", " jsName", "jsfile", "cssFile", "javascriptName", "Jsfile", "javascriptFile", "jsFilename", "jFilename", "JsFilename", " jsfile", "javascriptFilename", "javascriptfile", "jsName", "cssPath", "JsFile", "jsTable", " jsFilename", "javascriptTable"], "fileName": ["filePath", "getPath", "filename", "FileHash", "getHash", " fileHash", "fileHash", "FilePath", "FileName", "Filename", "getname", "getName", " filename", " filePath"], "outputStream": [" outputSteam", " outputStyle", "OutputSet", "Outputstream", " outputForm", "outputStyle", "inputForm", "OutputStyle", "outputstream", "OutputStream", "inputSteam", "inputstream", " outputstream", "OutputSteam", "OutputForm", "inputStyle", "writestream", "writeSet", "outputSet", "writeStream", "outputSteam", "outputForm", " outputSet", "writeSteam"], "first": ["initial", "top", "same", "important", "self", "fast", "each", "index", "then", "front", "sort", "stack", "real", "valid", "continue", "st", "natural", "quick", "must", "all", "seconds", "send", "only", "master", "latest", "false", "current", "true", "open", "ind", "last", "unique", "start", "default", "success", "second", "fourth", "next", "prev", "First", "third", "primary", "now"], "reader": ["core", "context", "mr", "stream", "rc", "rator", "data", "er", "iterator", "driver", "io", "handler", "buffer", "parser", "wrapper", "loader", "layer", "writer", "rl", "resource", "http", "runner", "ro", "builder", "file", "rr", "rar", "Reader", "this", "ner", "r", "input", "inner", "rer", "row", "read", "ocr"], "jsCompressor": ["jsCompression", "cssComposer", "jsCompiler", "jscomposer", "jscompiler", "jsComposer", "jsRepressor", "jsBuffoser", "cssCompressor", "cssRepressor", "jsBuffiler", "jsBuffressor", "jscompressor", "cssCompiler", "cssCompression", "jsRepiler", "jsReposer", "cssRepiler", "cssRepression", "jsRepression", "jscompression", "cssReposer", "jsBuffression"], "s": ["fs", "ats", "xs", "words", "cs", "ls", "ens", "pers", "ers", "S", "ns", "ms", "ss", "gs", "ds", "ts", "tes", "eds", "y", "ies", "less", "is", "full", "details", "parts", "ings", "es", "os", "l", "lines", "hs", "t", "ids", "qs", "tags", "ps"], "s1": ["ls1", " s3", "ls0", "pers1", "esFirst", "idFirst", "s0", "ys0", "s81", "ls3", "id2", "id1", " s81", "es2", "es9", "ls81", "ys81", "ps1", "s9", "ps0", "pers0", "es1", "s3", "ys3", "sFirst", "id9", " s0", "ys1"], "i": ["ia", "mi", "id", "ri", "p", "pi", "v", "ity", "ii", "us", "ai", "iti", "io", "bi", "um", "iat", "iu", "it", "ic", "li", "j", "ori", "ie", "y", "ch", "is", "ion", "ui", "di", "ig", "ip", "ci", "ati", "ifier", "o", "im", "oi", "I"], "s2": ["s02", "sSecond", "tes2", "es02", "SSecond", "S02", "gs2", "ss22", "s22", "z02", "msTwo", "z2", "tesTwo", "gsSecond", "Stwo", "S2", "ss2", "ssTwo", "gs02", "es2", "tes1", "zSecond", "stwo", "ms2", "gstwo", "ztwo", "es1", "tes02", "ms22", "esTwo", "ms02", "sTwo", "ss02"], "i1": ["e4", "e2", "it01", "eOne", "itOne", "p1", "it2", "i0", "p01", "a1", "it0", "aOne", "i01", "a2", "pOne", "o1", "a01", "p2", "i2", "it1", "p4", "it4", "o0", "o4", "e1", "oOne", "p0", "i4", "iOne"]}}
{"id1": "16851955", "id2": "3409084", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "label": 0, "substitutes": {"testTrainingBackprop": ["testTrainingbackProp", "testTrainingBackProp", "testTrainingbackprop", "testTrainingBackward", "testTestingbackend", "testTrainingbackend", "testTrainingbackward", "testTrainingBProp", "testTestingbackward", "testTestingbackprop", "testTestingBackend", "testTestingBackward", "testTrainingBend", "testTrainingBward", "testTestingBackprop", "testTrainingBprop", "testTestingBackProp", "testTestingbackProp", "testTrainingBackend"], "temp": ["loc", "copy", "output", "mt", "p", "unt", "v", "cache", "dat", "tc", " tmp", "mk", " temporary", "empty", "dest", "partial", "por", "complete", "test", "EMP", "tar", "pt", "mod", "remove", "orig", " Temp", "emp", "prefix", "file", "Tem", "mp", "tmp", "relative", "porary", "cp", "zip", "this", "out", "txt", "w", "template", "Temp", "full", "create", "created", "tem", "tm", "fake", "tab", "null", "make", "t", "local", "stem"], "layers": [" Lights", "lepackages", "listanes", "llays", " lacks", "listenses", " lenses", "llowers", "lsanes", "lienges", "lights", " lasks", "slayers", "lasks", "lanes", " lients", "vlpackages", " Lensions", "leayers", " lenges", "vlumers", "lsasks", "lipackages", "lenges", "liayers", "lienses", "llanguages", "liumers", "lacks", "lenses", " lumers", "slanguages", "liights", "lsenses", "liowers", "llenses", "listayers", "slensions", "liients", " lensions", " lpackages", "llayers", "lumers", "slenses", "leenges", "flayers", "flays", "lensions", "lowers", "lpackages", " lanes", "lients", " languages", " Languages", "lays", " lights", "lsayers", "llacks", "vlayers", "liacks", " lowers", "llients", "vlenses", " Layers", "flenses", "flanguages", "slays", "listasks", "slights", "leights", "languages"], "fann": ["flannis", "fain", "cain", "carn", "fannis", "flann", "ffannot", " farn", " fain", "Fana", "fannot", "farn", "flANN", "fANN", "fmanANN", "flana", "Fann", " fannot", "fmanann", "ffann", "FANN", "Fannis", "fmanana", "cann", "fana", "fmanannis", "ffain", "ffarn", "cannot"], "trainer": ["trrain", "Trainer", "tracy", "formayer", "formacer", "Triner", "triner", "Tracy", "bracer", "tracer", "rrain", " trayer", " tracer", "Trrain", "riner", "bruner", "Tracer", "brainer", "truner", "Trayer", "Truner", "strrain", "strainer", "runer", "racer", "formainer", "bracy", "stracer", "racy", "trayer", "rainer", "striner"], "desiredError": ["DesiredValue", "desireEr", "deseedException", "desuredException", "demuredError", "desuredValue", "desiredException", "deseedValue", "DesiredError", "DesuredException", "desIREDValue", "DesiredERROR", "desIREDERROR", "desuredError", "desiredEvent", "demuredEr", "deseedError", "desiredEr", "desireError", "desiredERROR", "deseedERROR", "desIREDError", "DesuredERROR", "desiringError", "DesuredError", "desireEvent", "demiredEvent", "demireEvent", "desiredValue", "desiringEr", "demiredEr", "demireEr", "desuredEvent", "desuredEr", "demireError", "DesuredValue", "desIREDException", "demiredError", "desuredERROR", "DesiredException", "desiringEvent", "demuredEvent"], "mse": ["mSE", "mroe", "dsem", " mSE", "Msem", "mmpe", "mrpe", "mese", "mrso", "mpe", "MSE", "Mte", " mpe", "Moe", "cmse", "moe", " mte", "Mpe", " moe", "dse", " msem", "cmese", "mte", "mmese", "mmse", "mmSE", "Mse", "mso", "Mso", "dSE", " mese", "cmpe", "cmSE", "mrse", "msem", "dte", " mso"]}}
{"id1": "18339787", "id2": "21152728", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 0, "substitutes": {"reload": ["Reload", "Replay", "rebuild", "overload", "disbuild", "disload", "ReLoad", "disLoad", "Rebuild", "overbuild", "replay", "overLoad", "reLoad", "overplay", "display"], "currentDate": ["reportedTime", "reportedYear", "currentTime", " currentDoc", " currentTime", "currentYear", " CurrentTime", "CurrentYear", " CurrentData", " currentYear", " CurrentDoc", "reportedData", "reportedDoc", "currentData", "CurrentDate", "currentDoc", "CurrentTime", "reportedDate", " CurrentDate", " currentData"], "xpath": ["dxPath", "expr", "xgraph", "expath", "xwhere", "exPath", "ixpointer", "axpath", " xprop", "axwhere", "xxath", "dxwhere", "rxpr", "dxpath", "wwhere", "xpt", "ixpath", "axgraph", " xwhere", "xprop", "ixath", "xxpointer", "txpath", "expointer", " xpt", "ixpt", "axPath", "xxpt", "wprop", "txPath", "dxprop", "xxwhere", " xPath", "rxPath", " xpr", "rxpointer", "txgraph", "wpath", "xxpath", "xtrace", " xtrace", "rxpath", " xgraph", "xpr", " xath", "xath", " xpointer", "axtrace", "xpointer", "wPath", "axpointer", "xxtrace", "xPath", "txpointer"], "docBuilderFactory": ["docBuilderFact", " docBuilderFact", " docBuilderFactor", " docBuilderClass", "docPathFactory", "docMakerFact", "docBuildInterface", "docMakerFactory", " docBuilderInterface", "docMakerInterface", "docPathFact", "docPathFactor", "docBuildClass", "docBuilderFactor", "docBuildFact", "docPathClass", "docBuildFactor", "docBuilderClass", "docMakerFactor", "docBuilderInterface", "docBuildFactory"], "docBuilder": ["DocBuild", "DocBu", "DocumentBu", " DOCBu", " docBuild", " DOCBuild", "documentbuilder", "DocBuilder", " docParser", "docbuilder", "DocumentParser", "DocumentBuild", " docbuilder", " docBu", "documentBuild", "documentBu", "docBu", "documentBuilder", "DocumentBuilder", " DOCBuilder", " DOCParser", "Docbuilder", "docParser", "docBuild"], "conn": ["loc", "cn", "ann", "cmd", "ssl", "lang", "ls", "Connection", "connect", "nc", "jp", "iw", "enc", "ws", "con", "opens", "addr", "ctx", "resp", "c", "comm", "link", "socket", "gate", "handle", "connection", "obj", "Conn", "res", "cert", "nt", "ch", "cp", "open", "client", "out", "oss", "syn", "close", "conv", "db", "ct", "cm", "cb", "n"], "url": ["f", "rel", "u", "sl", "ssl", "gl", "b", "https", "ls", "dl", "window", "char", "bel", "con", "web", "net", "ref", "str", "ll", "http", "rl", "ul", "nl", "link", "socket", "browser", "ur", "sql", "URL", "obj", "sb", "connection", "cert", "base", "cp", "mb", "open", "client", "mount", "lb", "r", "Url", "l", "abs", "util", "n"], "xml": ["image", "context", "wt", "pdf", "el", "output", "node", "p", "model", "dl", "data", "format", "php", "email", "list", "content", "path", "ml", "print", "str", "tree", "tml", "raw", "text", "http", "news", "response", "xp", "px", "page", "item", "x", "document", "xf", "file", "dom", "eps", "cert", "body", "event", "zip", "element", "mail", "txt", "full", "doc", "template", "input", "details", "config", "feed", "tm", "json", "rss", "parse", "log", "html", "ws", "date"], "exchangeRateDate": ["exactionRateDays", "excelrateMessage", "exchangeRangeDay", "exchangeCountTime", "exchangeCountDay", "exchangerateTime", "excelRateMessage", "exchangeCountDate", "exchangeRuleTime", "exchangeCountMessage", "exactionRateTime", "exchangeRangeDate", "exchangeRuleDate", "exchangerateDay", "excelrateTime", "exchangeRateDay", "exactionRateDay", "exactionRateDate", "exchangeTimeDay", "exactionrateDay", "exactionrateDate", "exchangeRangeTime", "exchangerateMessage", "excelrateDay", "exactionrateDays", "excelRateDay", "exchangeTimeDate", "exactionrateTime", "exchangeRuleDay", "exchangerateDays", "exchangeRateDays", "exchangeRateMessage", "excelRateTime", "exchangeRateTime", "exchangeRuleMessage", "exchangeRangeDays", "excelRateDate", "excelrateDate", "exchangerateDate", "exchangeTimeDays", "exchangeTimeTime"], "currenciesNode": ["curreditsN", "curriersCard", "CurrenciesN", "curthsN", "currenciesChan", "curriersN", " curriesCard", "CurriesNode", "curriesN", "curthsNode", "CurrenciesCard", "cururrenciesChan", "currenciesEvent", "currsNode", " currenciesChan", "currsList", "currenciesList", "currenciesCard", "CurrenciesList", "currencyChan", "cururrenciesNode", "currsEvent", "cururrenciesCard", "CurrenciesEvent", "CurrenciesNode", " curriesNode", "CurriesList", "CurriesEvent", "curriesEvent", "curreditsNode", " curriesChan", " currenciesCard", "CurriesN", "curriesCard", "curriersList", "curreditsList", "curriersNode", "curriesChan", "curthsCard", "curreditsEvent", "CurriesCard", "curthsList", "curriesNode", "curriesList", "currsN", "currencyCard", "currencyNode", "currenciesN"], "currencies": [" curries", "cururrencies", "constries", "correncies", "constrencies", "charurrencies", "charrates", "corables", "Curarters", "carries", "curractions", "carrencies", "crates", "corarters", "Cururrencies", "chpora", "cables", "currates", "curarters", "corrates", " curarters", "chractions", "Currencies", "curries", "carpora", "carractions", "crencies", "charrencies", "curpora", "corurrencies", "chries", "chrencies", "Curries", "constractions", "constpora", " cururrencies", "corries", "charables", "curables"], "i": ["cli", "mi", "ami", "u", "iq", "id", "ri", "ix", "ini", "I", "ii", "si", "e", "ai", "io", "bi", "sequence", "n", "ms", "m", "sim", "me", "yi", "ki", "in", "multi", "c", "it", "ic", "status", "li", "ti", "a", "j", "span", "xi", "init", "key", "x", "ji", "batch", "ie", "phi", "y", "is", "ui", "gu", "uri", "di", "oi", "gi", "ci", "ip", "\u0438", "o", "qi", "index", "pi"]}}
{"id1": "6171406", "id2": "20619879", "code1": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"createTar": ["setuptar", " createHar", "createDir", "setupHar", "setupDir", "CreateDir", "CreateHar", "setupTar", "createHar", " createtar", "CreateTar", "createtar", " createDir", "Createtar"], "directoryToPack": ["directoryTOPackage", "DirectorytoPak", "directionTOPlan", "directoryToApply", " directory2Package", " directoryOfPack", "directionToPak", "directoryOfpack", "directionTOApply", "directorytoPackage", "directoryTOPlan", "directoryFromPlan", " directoryToPackage", "directionToApply", " directoryTopack", "directoryTOPak", " directorytoPack", "directoryOfPak", " directorytoPackage", "documentToPackage", "directoryOfPack", "DirectorytoPush", "directoryTopack", "directorytoPak", "directionTOPak", "directory2Pak", "directoryTOApply", " directoryOfpack", "directionTOPackage", "directionToPack", "directorytoPush", "directory2pack", "directorytoApply", "directionToLoad", "directoryTOPush", " directoryToPak", "directoryTOPack", "directoryTOLoad", "directoryOfPackage", "directionTOLoad", "directionToPlan", "DirectorytoPack", "DirectoryToPackage", "directoryFromPackage", "directoryAsPack", "directoryToLoad", "DirectoryToPack", "directoryAsPackage", " directory2Pack", "directoryToPush", "directoryToPlan", "directoryFromApply", "DirectoryToPak", "DirectoryToPush", "directorytoLoad", "directoryToPackage", "DirectorytoPackage", "directory2Package", " directory2pack", " directorytopack", " directorytoPak", "directionTOPack", "directory2Plan", "documentToPack", "directoryFromLoad", "directorytoPack", "directoryFrompack", "directoryFromPack", "directory2Pack", "directoryFromPak", " directoryOfPak", "directorytopack", "directoryToPak", "directionToPackage"], "targetTarFile": ["targetWarField", "targetAREntry", "targetEarfile", "targetTarfile", "targetTarFilename", " targetEarFile", "targetWarFile", "targetARPath", "targetJarResource", "targetJarFormat", "targetEarString", "TargetTarFile", "targetTarFormat", "targetTarResource", "targetARLine", "targettarString", "targetARFormat", "targettarfile", "argetTarFilename", "argetEarfile", "TargetTarField", "argetTarfile", "targetARFile", "targetTarFiles", "targetArchFilename", "targetJarPath", "targetTarString", "targetWarEntry", " targetTarFormat", "targettarFilename", "targetARField", "TargetTarfile", "targetArchFiles", "TargetARField", "targetEarEntry", "targetEarFiles", "targetJarFilename", "targetEarFormat", "targetEarLine", "targetEarField", "targetCarFile", "targetArchPath", "targettarFile", "targetARFiles", " targetEarFilename", " targetEarLine", "argetEarFilename", " targetTarPath", "targetJarfile", " targetTarFiles", "TargetAREntry", "argetTarResource", "TargetARfile", "targetCarfile", "targetEarFilename", " targetTarfile", " targetTarLine", "targetWarfile", "targetTarLine", "targetEarFile", "argetEarString", " targetEarfile", "TargetTarEntry", "targetCarResource", "targetCarFilename", "targetCarLine", "targetARFilename", "targetJarFiles", " targetTarFilename", "targetTarPath", "targetTarField", "targetArchFile", "argetTarString", "TargetARFile", "targetJarFile", "argetTarFile", " targetEarFormat", "argetEarFile", "targetARfile", " targetEarFiles", "targetTarEntry"], "buffer": ["length", "object", "header", "stream", "binary", "flag", "cache", "message", "char", "buf", "string", "pointer", "print", "block", "entry", "limit", "table", "map", "comment", "attribute", "batch", "memory", "variable", "Buffer", "type", "buff"], "targetOutput": ["sourceInput", "targetTarget", " targetPUT", "sourceoutput", "Targetoutput", "argetOutput", "targetoutput", "sourceTarget", "sourceOutput", "gtPUT", "argetTarget", "TargetTarget", " targetoutput", "gtoutput", " targetInput", "targetInput", "gtInput", "argetoutput", "argetInput", "gtOutput", "TargetInput", "TargetOutput", "TargetPUT", "targetPUT"], "targetOutputTar": ["targetOutputtar", "targetInputtar", "argetOutputJar", "argetCreatedJar", "targetOutputHar", "targetCreatedHar", "argetCreatedTar", "targetTargetJar", "targetCreatedtar", " targetOutputtar", " targetOutputJar", " targetTargetJar", "argetOutputtar", "targetInputJar", "targetCreatedTar", "targetConnectionJar", "targetOutputJar", "targetInputTar", " targetTargettar", "targetInputHar", "targetConnectionTar", "argetCreatedtar", "targetTargetTar", "targetTargettar", "argetOutputTar", "argetOutputHar", "targetCreatedJar", "targetConnectiontar", "argetCreatedHar", " targetTargetTar"], "fileList": ["byteList", "Filelist", "fileSet", "FileList", "fileLIST", " filelist", "fieldlist", "fieldSet", "filelist", "FileSet", "fileStream", "byteLIST", "fieldStream", " fileLIST", " fileStream", "byteSet", " fileSet", "fieldList", "FileStream", "FileLIST", "bytelist"], "iter": ["loc", "iv", "ipper", "exec", "actor", "gener", "other", "ir", "ger", "er", "list", "cer", "iterator", "ait", "oper", "chain", "valid", "fer", "walker", "it", "loader", "writer", "li", "ter", "ator", "ser", "iner", "ver", "init", "vis", "tr", "reader", "ind", "itter", "inter", "liter", "loop", "train", "i", "ner", "former", "inner", "ip", "coll", "Iter", "outer"], "file": ["folder", "core", "object", "record", "entity", "stream", "node", "old", "port", "il", "issue", "path", "le", "application", "http", "link", "page", "comment", "attribute", "run", "line", "check", "h", "template", "title", "null", "url", "log", "use", "legal", "info", "local", "module", "f", "running", "value", "store", "icle", "date", "archive", "fe", "string", "e", "chain", "print", "files", "tree", "entry", "error", "File", "table", "FILE", "to", "item", "key", "document", "name", "current", "element", "unit", "number", "filename", "version", "type", "time", "remote", "header", "p", "class", "channel", "data", "message", "format", "fil", "user", "group", "valid", "ory", "rule", "resource", "single", "dir", "library", "base", "hash", "word", "fold", "ile", "full", "source", "fl", "ple", "handle", "image", "output", "field", "location", "model", "language", "feature", "fer", "directory", "event", "true", "db", "job"], "filePathInTar": ["filepathINHar", "fileLocationINTr", "filePathinWar", "filepathInTar", "filePathINWar", "filePathInsideWar", "filePathOutWar", "fileLocationINEar", "fileLocationIntar", "filePathInEar", "filePathINTr", "fileLocationINtar", "filePathInHar", "filePathinTar", "filePathedInTar", "filePathedInWar", "filePathINHar", "fileLocationInTar", "filePathFromEar", "filepathintar", "filePathedInHar", "filePathFromTr", "filePathINtar", "filepathINTar", "filePathInsideHar", "filepathInHar", "filePathINEar", "filePathintar", "filePathIntar", "filepathinTar", "filePathFromTar", "filePathedIntar", "filepathINWar", "filePathinTr", "filePathInsideTar", "filePathinEar", "filePathOutTar", "fileLocationINTar", "filepathinWar", "filePathINTar", "filePathInWar", "fileLocationInTr", "filePathInTr", "filepathIntar", "filepathInWar", "fileLocationInEar", "filePathFromtar", "filePathOuttar"], "tarAdd": ["tarEntry", "cotCreate", "rarAdd", " tarEntry", "cotInstall", "cotNew", "staradd", "carAdd", "TarEntry", "starNew", " tarCreate", "canNew", "canCreate", "starCreate", "tarCreate", " taradd", "rarNew", "cotAdd", "rarInstall", "TarCreate", "trAdd", " tarNew", "tarMake", "taradd", "tarInstall", "TarMake", "carCreate", "canadd", "starAdd", "trCreate", "tarNew", "carNew", " tarMake", "trEntry", "TarAdd", "carInstall", "trMake", "canAdd", "rarCreate"], "in": ["ins", "inside", "ign", "en", "id", "with", "IN", "sin", "gen", "un", "ed", "an", "on", "from", "it", "into", "by", "join", "add", "a", "to", "sub", "nin", "within", "name", "this", "current", "is", "under", "out", "ing", "source", "input", "get", "inner", "start", "t", "at", "local", "In", "n"]}}
{"id1": "8132219", "id2": "397240", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyStream", " CopyFiles", "copyfile", " copyFiles", " CopyStream", "CopyFiles", "CopyFile", "copyFiles", " copyStream", "CopyStream", "Copyfile", " CopyFile", " copyfile", " Copyfile"], "inFile": ["inRow", "dinPath", "outTemplate", "innRow", "ninFilename", "innPath", "inputTemplate", "inTemplate", "dinEmail", "innEmail", "outName", "inputName", " inRow", "inEmail", "dinRow", "inPath", " inPath", " inEmail", "outFilename", "inFilename", "dinFile", "ninTemplate", "inputFilename", "ninName", "innFile", "inName", "ninFile", "inputFile"], "outFile": ["inFILE", "destfile", "destFormat", "outFormat", "destFile", "inTable", " outfile", "outputFILE", "outfile", "ouFilename", "ouFILE", "ouTable", "outputFile", "outFILE", " outFILE", "outFilename", "outputfile", "outputFilename", "outputTable", "inFilename", "ouFile", " outFormat", "outTable", "destFILE", "outputFormat"], "in": ["ins", "din", "irm", "el", "en", "id", "old", "ir", "ini", " input", "IN", "ze", "sin", "inn", "s", "ai", "inf", "gin", "cin", "on", "bin", "from", "ic", "it", "init", "ain", "ind", "is", "inc", "up", "rin", "i", "input", "source", "inner", "o", "isin", "info", " din", "In"], "out": ["ot", "output", "OUT", "en", "b", "co", "p", "v", "ex", "gt", "e", "net", "ne", "io", "outs", "it", "c", "by", "ou", "to", "all", "file", "res", "aos", "name", "can", "client", "one", "g", "os", "t", "o", "Out", "at", "w", "n"], "inChannel": ["vinPanel", "cinHandler", "innSlot", "innCase", "ginCategory", " inChan", "isinChannel", "inConnection", "innCategory", "vinCategory", "newPanel", "inChan", "newCase", "vinChannel", "insideButton", "newChannel", "sinStream", "inCategory", "vinCase", "outchannel", "sinColumn", "outConnection", "isinCase", "ginChannel", "cinStream", "insideHandler", "cinButton", "ginCase", "insideChannel", "ginPanel", " inComponent", "inStream", "cinChannel", "outBlock", "newCategory", "innerchannel", "innerChan", "sinBlock", "inHandler", "sinChannel", "isinSlot", " inConnection", "cinColumn", " inchannel", "inComponent", "inBlock", "inCase", "cinBlock", "inchannel", "outChan", "inSlot", "sinCase", "sinCategory", " inButton", "isinCategory", " inHandler", "cinComponent", "outStream", "inPanel", "sinSlot", "insideComponent", "innerChannel", "innerConnection", "innChannel", "inColumn", "outColumn", "inButton"], "outChannel": ["outputCh", " outChain", "oChan", "inPassword", "inChan", " outClient", " outCh", "inClient", "outPassword", "outputChan", " outchannel", "outConnection", "outchannel", "nStream", "nChan", "OutCh", "OutChannel", "oClient", " outBlock", "exChain", "inStream", "outBlock", "nChannel", "outChain", "exChannel", "oPassword", " outConnection", "exChan", "outCh", "outputChannel", "OutChan", "inchannel", "outChan", "nchannel", " outPassword", "oChannel", " outStream", "outStream", "exBlock", " outChan", "outClient", "outputConnection", "OutConnection"]}}
{"id1": "12055086", "id2": "6403868", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeletging", " copyDeeleging", " copyDelingging", " copyDelingving", " copyDeeleting", " copyDeeleing", " copyDeleing", " copyDeletting", " copydeleving", " copydeletting", " copyDeeleving", " copydeletving", " copyDeletging", " copydeleging", " copydeleting", " copydeleing", " copyDelingting", " copyDelinging", " copyDeleging", " copyDeleving", " copyDeletving"], "source": ["image", "original", "scope", "store", "search", "seed", "style", "SOURCE", "service", "back", "target", "form", "origin", "ource", "src", "from", "resource", "spec", "init", "sql", "query", "body", "sp", "parent", "base", "ace", "template", "input", "se", "oss", "start", "Source", "site", "ce", "sample", "local"], "dest": ["loc", "del", "th", "exp", "https", "port", "Dest", "way", "target", "origin", "src", "mm", "bin", "pub", "st", "it", "tom", "dist", "them", "orig", "trans", "dir", "img", "nom", "sp", "est", "cas", "comb", "cat", "lit", "null", "decl", "pas", "rest", "end", "temp", "d", "w", "master"], "buf": ["arr", "cmd", "bl", "b", "cf", "bs", "vec", "uf", "alph", "data", "capt", "box", "ref", "buffer", "str", "aka", "block", "pkg", "fb", "bh", "cv", "cap", "img", "bag", "fg", "seq", "Buff", "eb", "batch", "cast", "cp", "br", "comb", "cur", "bus", "cat", "conv", "db", "bc", "meg", "tab", "rb", "Buffer", "prop", "tx", "buff", "bytes", "pause", "cb"], "in": ["ins", "din", "inside", "el", "en", "ri", "ini", "ze", "IN", "inn", "con", "ai", "user", "un", "inf", "cin", "gin", "mm", "on", "bin", "from", "ic", "it", "or", "by", "init", "al", "per", "ind", "is", "inc", "rin", "input", "i", "iter", "inner", "isin", "info", "read", "In"], "out": ["cn", "output", "OUT", "en", "co", "v", "dis", "sum", "con", "net", "io", "ne", "sys", "n", "on", "conn", "outs", "by", "writer", "ou", "to", "page", "obj", "res", "auto", "aos", "nt", "ion", "client", "write", "up", "oss", "i", "conv", "inner", "os", "flush", "o", "t", "end", "log", "Out", "at", "outer", "can"], "count": ["length", "cloud", "ount", "z", "num", "core", "max", "deep", "sum", "total", "char", "cc", "index", "q", "nb", "acc", "c", "size", "add", "span", "cap", "comment", "batch", "code", "nt", "amount", "ch", "cond", "ind", "current", "counter", "check", "found", "number", "len", "common", "conf", "start", "ctr", "coll", "ct", "Count", "t", "now", "read", "cont", "n"]}}
{"id1": "17161805", "id2": "324679", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["enode", "uncode", "ensforce", "ensode", "ensprocess", "encprocess", "unode", "unprocess", "enccode", "encforce", "enprocess", "Encode", "enforce", "Enode", "unforce", "enscode", "Enforce"], "plaintext": ["formmessage", "pronth", "plainText", " plainText", "ainmessage", " plaindata", "formtext", "mainText", "mainth", "aintext", "aindata", "mainlat", "pronlat", " plainth", "formText", "pronText", "formdata", "maintext", "plainth", "prontext", " plainlat", "plainmessage", "plainlat", " plainmessage", "plaindata", "ainText"], "md": ["del", "pdf", "cmd", "dd", "dr", "mt", " MD", "amd", "der", "mo", "red", "sha", "mg", "dh", "mk", "sd", "med", "od", "ms", "m", "mm", "pm", "pd", "mod", "add", "mc", "mn", " Md", "df", "managed", "mp", "nt", "msg", "dm", "mand", "det", "ind", "mb", "grad", "ld", "cd", "bd", "hd", "d", "ng", "MD", "sm"], "raw": ["cmd", "value", "sh", "strip", "wrap", "message", "derived", "stable", "buf", "bare", "clean", "modified", "valid", "rendered", "pack", "custom", "map", "cooked", " Raw", "orig", "des", "hex", "RAW", "def", "serial", "full", "mem", "input", "Raw", "unsigned", "inner", "json", "row", "unknown", "aw", "bytes", "bound", " RAW", "read", "n"]}}
{"id1": "22135199", "id2": "14502142", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": [" testCachingEmptyfile", " testCodingemptyStream", " testCachingEmptyFiles", " testCodingSizeStream", " testCodingemptyFiles", " testCodingFullfile", " testCachingEmptyFile", " testCodingSizefile", " testCodingSizeFiles", " testCodingFullFile", " testCachingemptyfile", " testCodingEmptyFiles", " testCachingEmptyStream", " testCodingEmptyStream", " testCodingemptyFile", " testCodingFullFiles", " testCachingemptyStream", " testCodingemptyfile", " testCachingemptyFile", " testCodingSizeFile", " testCodingFullStream", " testCodingEmptyfile", " testCachingemptyFiles"], "baos": ["caos", "taos", "booss", "taoS", "caOs", "aoos", "caoS", " baoS", "taOs", "BaOs", "boOS", "baoS", "aoOS", "aoOs", " baOs", "boOs", " bao", "aoo", "bao", "tao", "Bao", " baOS", "boo", "baOS", "boos", "baoss", "Baoss", " baoss", "baOs", "cao", "Baos"], "channel": ["context", "container", "server", "stream", "cache", "message", "window", "service", "con", "Channel", "io", "chain", "queue", "handler", "buffer", "block", "network", "application", "c", "resource", "socket", "session", "connection", "file", "console", "caster", "chan", "batch", "controller", "ch", "system", "client", "out", "input", "password", "cm", "command", "component", "room", "can"], "params": ["param", "pins", "caps", "rs", "p", "par", "AMS", "data", "Parameters", "properties", "types", "sys", "pps", "mm", "ctx", "options", "headers", "cms", "spec", "ams", "limits", "pretty", "phys", " parameters", "pool", "settings", "name", "services", "cmp", "Par", "radius", "details", "parts", "ops", "config", "proc", "conf", "json", "fps", "names", "units", "password", "tags", "ps", "pi"], "outbuf": [" outBuffer", "outbuffer", "inbuf", "inBuffer", "inbuff", "inrb", "outrb", "outputbuf", "outputbuffer", "outputrb", "outBuffer", "outputbuff", "OutBuffer", "inbuffer", "Outbuffer", " outrb", "outbuff", " outbuffer", "Outbuf", "Outbuff", " outbuff"], "metrics": ["monrors", "Metrix", "monric", "matrics", " metrices", "matrix", "mtcs", "Metrics", "mtths", "mutths", "mutrics", "metrices", "matric", " metths", "metrix", "monrics", "mtrics", "metrors", "mutrices", "Metrors", "matrors", "monrix", "metcs", "metric", "metths", "Metric", "mtrices", " metcs", "mutcs"], "encoder": [" encoding", "ecrier", "encressor", "execrier", "eniever", "Encoder", "encoding", "enressor", "enrier", "ecoding", " encoded", "enciever", "enoding", "ecressor", " encrier", "encoded", "ecoded", "enramer", "Encramer", "eciever", " encuter", "encramer", "enoded", "ecoder", "Encuter", "Encoding", " encressor", "executer", "encuter", "Encrier", "enoder", "Enciever", "encrier", " encramer", "ecramer", "execoder", "execoding"], "tmpFile": ["testfile", "fakefile", "tempFiles", "tempFILE", "tmpFILE", "imgFILE", "imgKey", "fakeFiles", "txtfile", "mpfile", "tempFile", "tempfile", "imgfile", " tmpName", "tempKey", "tmpfile", "tmpKey", "testFilename", "mpName", "txtFile", "fakeFile", " tmpfile", " tmpKey", "tempFilename", " tmpFILE", "testFile", "txtPath", " tmpFiles", " tmpFilename", "tmpFiles", "testName", "tmpPath", "fakeFilename", "mpFile", "imgFile", "mpFilename", "tmpName", " tmpPath", "tmpFilename", "tempPath"], "fout": ["sfout", "fOUT", "fOut", "lbal", "vOut", "wout", "fullOUT", "fullout", "dfbal", "fbal", "foutput", "vouts", "dfOUT", "dfoutput", "wouts", "vao", "vout", "fullbal", "dfout", "sfOut", "sfao", "wao", "fulloutput", "fao", "loutput", "fouts", "sfouts", "lOUT", "wOut", "lout"], "wrtout": ["wttn", "Wrtout", "ewrtgen", "wdrgen", "wdrout", "ewrtwriter", "wrtex", "wrtwriter", "wrdio", "wgtout", "Wrtio", "ewltwriter", "wrdout", "wrtw", "wltgen", "wgtw", "ewltout", "wdrwriter", "ewrtout", "hwrtex", "wttio", "wttwriter", "wwtout", "wltout", "wwtwriter", "wgtwriter", "hwrtwriter", "wttout", "wRTout", "hwrcex", "wrdwriter", "wltin", "wrtn", "wrdgen", "wRTio", "wrtio", "Wrdwriter", "Wrtwriter", "wrtin", "wgtex", "Wrdn", "wRTwriter", "ewltgen", "hwrcout", "hwrcw", "wrcw", "wrcex", "wrtgen", "wrdn", "hwrcwriter", "wrdin", "wdrin", "wrcout", "Wrdout", "wwtex", "Wrdio", "hwrtout", "hwrtw", "wltwriter", "ewrtin", "ewltin", "wrcwriter", "Wrtn", "wwtw", "wRTn"], "fchannel": ["FChannel", "Fchannel", "fccontroller", "fcconnection", "flChannel", "wcontroller", "wchannel", "Fnet", " fconnection", "fconnection", " fconsole", "fconsole", " fcontroller", " fchan", "Fconsole", "flnet", "fcontroller", " fChannel", "wchan", " fnet", "fnet", "fcchannel", "flconsole", "fcchan", "fchan", "fChannel", "wconnection", "flchannel"], "s": ["f", "b", "v", "p", "rs", "ls", "string", "csv", "e", "gets", "S", "ns", "str", "m", "ss", "sq", "js", "gs", "c", "ds", "a", "j", "sv", "ts", "is", "h", "i", "r", "g", "t", "sg", "qs", "ws", "w", "n"]}}
{"id1": "5676111", "id2": "12004824", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"get": [" reload", "Get", "exec", " delete", "GET", " construct", "sync", "delete", " finish", "print", " copy", "Download", "upload", "export", "init", "dump", "gc", "run", "execute", "zip", "call", " fetch", " recover", " put", " download", "download", "info"], "cnt": ["Cnc", "ccount", "aclen", "cht", "nccount", " clen", "unclen", "ncht", "Cnt", "uncnc", "CNT", "acnt", "nct", "Cct", "cct", "nnt", "nNT", "Ccount", "cnc", "cNT", "uncNT", " cht", "Cht", "nnc", " cct", "acNT", " cnc", "ncct", "clen", " ccount", "ncnt", "acnc", "uncnt", " cNT"], "url": ["loc", "f", "rel", "host", "el", "fs", "sl", "ssl", "gl", "https", "ls", "dl", "hl", "char", "bel", "con", "google", "web", "path", "ref", "addr", "str", "ll", "xml", "ret", "http", "ul", "nl", "link", "socket", "www", "browser", "ur", "URL", "cert", "build", "base", "cp", "open", "mount", "client", "mail", "pl", "r", "uri", "Url", "l", "null", "fl", "handle"], "conn": ["cn", "loc", "rel", "access", "cmd", "exec", "en", "org", "co", "com", "ens", "dial", "serv", "jp", "connect", "nc", "enc", "con", "net", "addr", "ns", "ctx", "resp", "c", "nec", "col", "comm", "nl", "ca", "yn", "init", "connection", "obj", "Conn", "cert", "nt", "act", "ch", "cp", "open", "client", "cur", "syn", "conv", "os", "l", "cons", "gn", "pas", "coll", "ct", "cm", "cb", "cont"], "is": ["isa", "isl", "fs", "icks", "ends", "ins", "lis", "ri", "iss", "bs", "ris", "rs", "dis", "ists", "isi", "ib", "nis", "us", "si", "ys", "sys", "ms", "sim", "iso", "has", "in", "imp", "it", "ic", "bis", "sit", "init", "IS", "iris", "vis", "Is", "mis", "isc", "i", "isf", "iter", "es", "os", "abs", "ip", "ais", "its", "ist", "isin", "im", "ps", "ios"], "filename": ["f", "nu", "knife", "println", "nm", "continental", "string", "fil", "path", "kl", "lua", "ename", "str", "subject", "LCS", "Filename", "FILE", "prefix", "sql", "file", "fn", "name", "ren", "family", "river", "latest", "txt", "fp", "ame", "FIL", "username", "title", "source", "til", "mson", "journal", "sbm", "stem"], "fos": [" fres", "Foses", "foss", "vaos", " faos", "fres", "floss", "Foss", "loss", "laos", "Faos", "foses", "foes", " foss", "boss", "boes", "flaos", "fows", "bos", "flos", "vres", "faos", "floes", "bows", "Fres", "Fos", " foses", "Foes", "voses", "loes", " fows", "los", "vos", " foes", "Fows"], "buffer": ["length", "output", "binary", "cache", "data", "message", "total", "window", "char", "buf", "queue", "phrase", "stack", "sequence", "print", "database", "block", "scroll", "text", "view", "button", "table", "frame", "bar", "note", "available", "page", "paste", "attribute", "comment", "document", "batch", "library", "base", "event", "append", "template", "memory", "display", "source", "mem", "iter", "variable", "Buffer", "buff", "bytes", "sample", "temp", "command", "bone", "history", "result"]}}
{"id1": "3024992", "id2": "23666867", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_NULLin", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_NULLOut", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2nullOut", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2NullOut", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_NULL_", "testCopy_readerToWriter_nullOut", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_NULLIn", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_NullOut"], "baout": ["BAin", "baouts", "cain", "abait", "BAoul", "dbin", "dbout", "caout", "baouth", "dboul", "buouts", "BAit", "bait", " bain", "gaoul", "buin", "gain", "bain", "baoul", "gaouth", "caOut", "BAout", "buout", "cait", "abaout", "BAOut", " baouts", "abaOut", " baOut", "abain", "baOut", "gaout", "BAouth", "buOut", "dbouth", "BAouts"], "out": [" OUT", "output", "OUT", "gr", "serv", "ex", "er", "gen", "net", "io", "sys", "err", "in", "outs", "it", "ser", "res", "tmp", "pool", "write", "null", "o", "Out", "result", "n"], "writer": ["riter", "processor", "output", "woman", "channel", "println", "data", "window", "er", "service", "NULL", "driver", "target", "nw", "handler", "print", "buffer", "player", "maker", "wrote", "worker", "builder", "rw", "wright", "usher", "file", "document", "widget", "writ", "killer", "reader", "this", "client", "write", "inner", "null", "Writer", "w", "outer"]}}
{"id1": "15745420", "id2": "12078471", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"download": ["update", "del", "copy", "move", "dial", "dl", "archive", "transfer", "data", " Download", "GET", "pull", "request", "view", "link", "Download", "upload", "install", "login", "dump", " downloads", "file", "zip", "split", "submit", "save", "remote"], "address": ["host", "context", "Address", "server", "domain", "search", "location", "message", "adr", "email", "description", "service", "order", "path", "express", "addr", "absolute", "network", "resource", "add", "alias", "link", "page", "comment", "attribute", "prefix", "key", "street", "shape", "connection", "report", "base", "reference", "directory", "relative", "name", "ace", "place", "uri", "route", "ip", "type", "site", "remote", "password", "contact", "command", "index"], "localFileName": ["remoteFileName", "remoteFilename", "localFullPath", "LocalFileNames", "localFilenameName", " localFilename", " localFilenameName", "LocalFilenamePath", "localFileFilename", "localDirFilename", "localTableType", "localFilePath", "LocalFileNum", "localTableName", "localFullName", "localFilename", "localFilenameNum", "localDirPath", "LocalFilePath", "localModelName", "localPageSize", "localFilenamename", "remoteFilenameType", "localfilename", "localModelNames", "localPagePath", "remoteFilenameSize", "localTablePath", "localfileSize", "localfileName", " localFilenamePath", "localPageNames", "LocalFilenameName", "LocalFilenameNames", "localModelPath", "remoteFilenamename", "localFileNum", "remoteFilenamePath", "localPageName", "localFilenameSize", "localFullname", "localFilenameFilename", "LocalFilenameNum", "localCodeName", "localFilenamePath", " localFilePath", "remoteFilePath", "localPagename", "remoteFileSize", "remoteFilenameName", " localFileFilename", "LocalFileName", "localFileType", "localDirName", "localFilenameType", "localCodeType", "localfilePath", " localFilenamename", "remoteFileType", "localFilenameNames", "localDirname", "localModelNum", "localFileNames", "localCodePath", "localFileSize", "localPageNum", " localFilenameFilename", "localFullFilename"], "ext": ["eng", "Ext", "cmd", "exp", "EXT", "typ", "pattern", "format", "pat", "content", "tim", "path", "except", "addr", "str", "sect", "text", "ret", "dist", "dir", "x", "obj", "file", "code", "prot", "sp", "name", "word", "zip", "def", "dim", "txt", "off", "fab", "config", "alg", "xt", "type", "desc", "t", "end", "not", "cont"], "temp": ["pdf", "copy", "output", "mt", "p", "perm", "cache", "dat", "tc", "tif", "mk", "empty", "dest", "box", "partial", "por", "path", "test", "EMP", "tar", "pre", "pt", "mod", "part", "table", "orig", "emp", "prefix", "dir", "file", "mp", "tmp", "base", "relative", "porary", "tr", "none", "cp", "zip", "current", "txt", "w", "template", "Temp", "mem", "memory", "tm", "tem", "created", "fake", "null", "tab", "t", "local"], "out": ["cn", "ot", "output", "go", "OUT", "b", "co", "p", "bo", "yes", "boot", "con", "e", "ln", "net", "io", "ne", "print", "sys", "ns", "on", "outs", "it", "or", "writer", "OU", "ou", "inv", "to", "obj", "file", "op", "aos", "tmp", "body", "cos", "pos", "can", "client", "write", "no", "i", "oss", "one", "conv", "ao", "os", "null", "oe", "inner", "t", "o", "end", "Out", "at", "w", "outer", "n"], "conn": ["cn", "rel", "cmd", "ssl", "co", "cs", "com", "serv", "Connection", "connect", "nc", "enc", "canon", "jp", "cc", "con", "addr", "ctx", "resp", "c", "comm", "socket", "ca", "yn", "gate", " con", "connection", "obj", "Conn", "res", "cert", "nt", "ch", "cp", "open", "client", "syn", "ctrl", "conv", "conf", "ct", "cm", "cb", "n"], "in": ["image", "ins", "din", "inside", "irm", "en", "stream", "ini", "IN", "er", "inn", "con", "ln", "net", "user", "inf", "cin", "gin", "on", "str", "bin", "from", "it", "ic", "or", "raw", "inv", "all", "init", "nin", "file", "ain", "ind", "is", "inc", "can", "client", "up", "rin", "no", "i", "input", "source", "iter", "inner", "oin", "conf", "l", "asin", "internal", "t", "isin", "In", "n"], "url": ["rel", "f", "sl", "cmd", "ssl", "gl", "ls", "dl", "il", "hl", "bel", "con", "google", "web", "net", "lr", "str", "ll", "http", "ul", "nl", "link", "www", "browser", "ur", "URL", "connection", "cert", "build", "cp", "mb", "open", "client", "mail", "pl", "r", "Url", "l"], "buffer": ["length", "initial", "column", "value", "binary", "cache", "message", "window", "buf", "queue", "sequence", "phrase", "stack", "database", "cell", "block", "raw", "view", "button", "table", "frame", "bar", "stroke", "comment", "paste", "shape", "document", "batch", "base", "word", "append", "template", "memory", "number", "source", "mem", "row", "variable", "Buffer", "padding", "buff", "filter", "sample", "password", "command", "history", "read"], "numRead": ["newSend", " numPush", "sumRead", "numberLength", "numberREAD", "numREAD", "NUMLength", "numPrint", "umLoad", "NUMLoad", " numLength", " numSend", "numLength", "numberPrint", "umPrint", "newReader", "numberWrite", " numPrint", "umRead", "umerPush", "numberRead", "numReader", "numberReader", "numberLoad", " numWrite", " numREAD", "umerRead", "NUMREAD", "numLoad", " numLoad", "numPush", "NUMRead", "newRead", "sumWrite", "umerSend", " numReader", "numWrite", "sumReader", "numSend", "umerReader", "newPush"], "numWritten": ["numberWriter", "numberWritten", "umWrite", " numWriter", "numWrit", "monWritten", "numberWrite", "monWrit", " numWrit", "umWriter", "numWriter", "NumWriter", " numWrite", "NumWrite", "monWriter", "numWrite", "umWritten", "monWrite", "NumWritten", "NumWrit"], "oldArq": ["oldArqs", "lastARch", "oldArqu", "lastARqu", "oldarQ", " oldArQ", " oldTarch", "lastARck", "oldUrch", "oldTarqs", "lastArck", "oldTariq", "oldUrq", "oldARqu", "oldLaq", "oldAQ", "oldTarq", "oldDarck", "oldUrck", "oldLaqs", "oldDarq", "lastArqu", " oldAQ", "oldTarch", "oldARq", "lastARq", "oldAch", "oldAriq", "oldTarQ", "oldarqs", " oldAch", "oldLaiq", "oldArQ", "oldLaQ", " oldTariq", "oldAq", "oldarq", " oldTarQ", " oldAriq", "oldDarqu", "oldARch", " oldAq", "oldArch", "oldArck", "lastArch", "oldDarch", "oldariq", " oldArqs", "oldUrqu", "oldARck", "oldAqs", "lastArq", " oldAqs", " oldTarq", " oldArch", " oldTarqs"], "nomeFinal": [" nomefinal", "nourseWall", "nomeFin", "NadeWall", "noursefinal", "nomesFin", "nadeWall", "nomeWall", "nadefinal", " nomFin", " nomFinal", "nadeGlobal", "nomesFinal", "nomfinal", "nomFinal", "NomeWall", "nadeFinal", " nomeFin", "nomeGlobal", "nadeFin", "nameFinal", "Nomefinal", "NadeGlobal", "namefinal", "nameWall", "NomeGlobal", "Nadefinal", "nomFin", "NadeFinal", " nomfinal", "nameGlobal", "nomesfinal", "nourseFinal", "nourseGlobal", "nomefinal", "NomeFinal"]}}
{"id1": "149935", "id2": "19276022", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"convert": ["compversion", "CONfer", "converted", "CONvert", "consversion", "converting", "unverted", "converts", "Converted", "Conversion", "compverts", "unvert", "compvert", "CONverting", "Confer", "unversion", "Convert", "Converts", "Converting", "confer", "consVERT", "unprocess", "consverting", "CONverted", "conVERT", "consvert", "unfer", "unverts", "CONVERT", "conversion", "CONversion", "conprocess", "compprocess", "ConVERT", "Conprocess"], "src": ["loc", "host", "iv", "rel", "ins", "stream", "rc", "rs", "SOURCE", "RC", "scan", "scene", "SourceFile", "sc", "ebin", "hl", "sin", "cc", "s", "usr", "path", "addr", "sys", "attr", "ource", "str", "st", "from", "sq", "pkg", "func", "http", "inst", "dist", "sit", "upload", "ser", "orig", "req", "ur", "img", "file", "rx", "buster", "txt", "ipl", "source", "input", "filename", "cur", "config", "uri", "start", "url", "sr", "its", "Source", "rest", "href", "cont"], "dest": [" destination", " Destination", "port", "Dest", "dat", "tif", " orig", "disk", "target", "test", "gin", "table", "dist", "orig", "dir", "img", " dst", " Dest", "est", "write", "txt", "source", " destinations", "foreign", "mat", "rest", "temp", "result"], "in": ["ins", "din", "el", "en", "stream", "b", "serv", "IN", "inn", "io", "inf", "cin", "m", "bin", "from", "st", "ar", "as", "sql", "ad", "file", "res", "reader", "ind", "is", "up", "rin", "d", "source", "input", "i", "r", "inner", "l", "isin", "In"], "p": ["f", "pe", "b", "jp", "php", "er", "pers", "dp", "P", "m", "pm", "parser", "py", "pt", "pp", "pd", "pre", "c", "pkg", "part", "ping", "vp", "post", "it", "ph", "j", "pg", "wp", "op", "sp", "prot", "pc", "per", "cp", "lp", "pa", "pro", "fp", "h", "ap", "pl", "i", "r", "g", "l", "parse", "rep", "t", "d", "at", "tp", "ps", "pb", "pi"], "ds": ["bs", "rs", "drivers", " os", "dl", "yes", "aws", "js", "gs", "ts", "ads", "df", "tes", "eds", "ras", "mys", "di", "nas", "ks", "ports", "its", "ods", "d", "gd", "ats", "xs", "ands", "dds", "sets", "dt", "dh", " dd", "DS", "lists", "vs", "uds", "ags", "scripts", "iffs", "ws", "tags", "els", "dd", "terms", " d", " des", "ls", "sd", "s", "tests", "outs", "posts", "docs", "ils", "os", "Ds", "hs", "hd", "ps", "dp", "cs", "sts", "ys", "ns", "obs", "ss", "pd", "dos", "des", " DS", "workers", "eps", "dates", "loads", "points", " ads", "db", "cks", "edes", "qs", "tp", "amps"], "format": ["f", "feat", "top", " Format", "ats", "mt", "output", "MAT", "id", "style", "cf", "mode", "pattern", "fm", "feature", "path", "form", "set", "it", "sche", "status", "table", "size", "spec", "pretty", "tag", "shape", "file", "layout", "act", "settings", "name", "lat", "unit", "template", "source", "title", "policy", "l", "version", "type", "parse", "ct", "mat", "t", "filter", "Format", "at", "module", "fc", "pi"], "hasPixelData": ["HasPixelDATA", "HasPixelData", "hasixelData", " hasPixeldata", " hasPixelDATA", "hasPixeldata", "hasFramedata", "HaspixelData", "HaspixelDATA", "HasPixeldata", "haspixeldata", "hasPixelDATA", "haspixelData", "haspixelDATA", "hasFrameData", "hasixeldata", "Haspixeldata", "hasFrameDATA", "hasixelDATA"], "inflate": ["incelATE", "infolate", "infolocate", "informat", "Informated", "Informat", "infolat", "Informocate", "incelate", "infolated", "invalidicate", "incelocate", "invalidATE", "inflocate", " invalidate", "informocate", "inFlate", "inflated", " inflATE", " invalidicate", "informate", "invalidocate", "Inflate", "Inflat", "inFLate", " invalidocate", "Inflated", "inFlicate", "Informate", " invalidATE", "inFLated", "inFLocate", "inFlocate", "incelicate", "informated", "Inflocate", "invalidate", " inflicate", "inflATE", " inflocate", "inflat", "inFLat", "inflicate", "inFlATE"], "pxlen": ["mxln", "tmplen", "packfun", "packls", "mxlen", "xylen", "pexln", "xpden", "tmpln", "phplength", "packln", "pexlen", "pexden", "mmlin", "pxlength", "mxdec", "phpln", "pexlength", "xylength", "pxlin", "xyln", "xylin", "pxln", "packlength", "xpln", "cplength", "pixellen", "pxls", "cpden", "cpln", "xplength", "pixelfun", "cplen", "tmplength", "packlen", "pxfun", "pexls", "pixells", "xplen", "mmln", "pxden", "mmlength", "mmlen", "tmplin", "pixellength", "phpdec", "phplen", "packdec", "mxlength", "pxdec", "pexfun"], "out": ["crit", "cmd", "output", "store", "OUT", "gr", "ex", "screen", "sum", "list", "user", "net", "io", "group", "print", "sys", "cfg", "ln", "err", "conn", "outs", "writer", "ou", "inv", "pretty", "prefix", "dir", "init", "obj", "res", "aos", "msg", "name", "client", "gov", "inter", "up", "log", "Out", "temp", "outer"]}}
{"id1": "21754659", "id2": "11484416", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getButtonSonida", "getButtonDonilo", "getButtonLeonilo", "getButtonLeonido", "getButtonLeonida", "getbuttonSonico", "getButtonDonico", "getButtonDonido", "getButtonSonilo", "getbuttonSonido", "getButtonDonida", "getbuttonSonida", "getbuttonSonilo", "getButtonLeonico", "getButtonSonico"], "buttonSonido": ["ButtonSunao", "buttonSonilo", "buttonHonilo", "secondSonito", "buttonBon\u00ed", "fieldSonido", "buttonSoningo", "buttonBonano", "secondSynito", "ButtonSunico", "buttonJonicho", "labelSonido", "buttonJonila", "buttonsonano", "buttonDenicho", "labelSONila", "keySonido", "positionJonido", "buttonHonardo", "buttonJonico", "ButtonSonao", "buttonBonida", "keyson\u00ed", "buttonJonito", "buttonNorthingo", "buttonNorthida", "buttonDenidable", "buttonJonao", "buttonJonilo", "buttonDenido", "buttonSynito", "ButtonSonico", "positionSonito", "ButtonSunido", "buttonBonico", "fieldSonida", "buttonHon\u00ed", "buttonBonao", "fieldsonida", "fieldsonido", "ButtonSunata", "buttonBonata", "buttonsoningo", "buttonSonardo", "labelSONido", "buttonSonico", "labelSonida", "buttonBonido", "buttonJonido", "buttonNorthido", "keysonilo", "secondSonido", "fieldsoningo", "buttonsonilo", "buttonSynidable", "fieldsonano", "secondSynicho", "secondSonicho", "ButtonSonido", "buttonJonata", "buttonSONico", "buttonSONido", "fieldSonano", "buttonBonilo", "buttonsonido", "buttonSONila", "labelSONida", "labelSonila", "positionSonico", "buttonJonidable", "secondSynidable", "buttonsonardo", "labelSONphp", "buttonNorthano", "buttonSynida", "buttonSonao", "buttonSunao", "positionJonilo", "buttonJonida", "buttonSynphp", "keySon\u00ed", "buttonSonphp", "secondSonidable", "buttonSonila", "keySonilo", "buttonSunilo", "buttonSonida", "buttonBonardo", "buttonSONida", "positionSonido", "positionJonito", "buttonSonano", "buttonSunido", "buttonDenito", "buttonHonido", "positionSonilo", "ButtonSonata", "buttonSunico", "buttonSynido", "buttonSunito", "buttonSONito", "buttonSonito", "buttonSunata", "keysonido", "buttonSONilo", "buttonSonata", "secondSynido", "buttonSonicho", "buttonSynila", "keySonardo", "buttonJonphp", "buttonSonidable", "buttonSynicho", "fieldSoningo", "buttonSONphp", "labelSonphp", "buttonsonida", "buttonSon\u00ed", "buttonBoningo", "positionJonico", "keysonardo", "buttonson\u00ed"], "e": [" fe", "pe", "ese", " ve", "er", "te", "ev", "ae", " pe", "ed", " ge", "E", "me", " who", "a", "ie", " ke", "act", "event", " ate", "ED", "ing", "es", " ie", "t", "AE", " sent", "ee"], "fc": ["fs", "f", "WC", "icc", "cf", "bf", "irc", "rc", "lf", "fm", "ec", "tc", "nc", "cc", "con", "abc", "anc", "tf", "c", "ic", "FC", "rl", "fb", "etc", "dc", "cv", "fa", "gc", "mc", "ifa", "soc", "pc", "vc", "fn", "uc", "inc", "fp", "fi", "isc", "fab", "ctrl", "bc", "conv", "RFC", "mac", "fl", "coll", "fd", "lc"], "returnVal": ["resultval", " returnVAL", "ReturnVal", "retValue", " returnValue", "Returnval", "returnval", "retVal", " returnval", "returnValue", "ReturnValue", "ReturnVAL", "retval", "resultVAL", "returnVAL", "resultValue", "retVAL", "resultVal"], "file": ["f", "image", "output", "channel", "show", "data", "message", "format", "fe", "disk", "path", "user", "io", "form", "files", "buffer", "valid", "tree", "block", "File", "resource", "http", "table", "single", "FILE", "link", "spec", "to", "page", "dir", "document", "base", "parent", "name", "word", "this", "fp", "ile", "get", "source", "input", "create", "full", "template", "uri", "null", "type", "url", "time", "stat", "info", "local", "handle"], "rutaGlobal": ["rutoStatic", "rutoFile", "Rutaglobal", "rutanDefault", "RutoFile", "redutanGeneral", "RutaFile", "rontoLocal", "RutoLocal", "RutaLocal", "redutaGlobal", "rutiFile", "rutenLocal", "rutiGeneral", "redutanGlobal", "rutanGeneral", "rutiDefault", "rutanGlobal", "rutanLocal", "rutaglobal", "rontoGlobal", "rutenRemote", "rutaRemote", "rutoGlobal", "rutoglobal", "redutaLocal", "rutiglobal", "rutiRemote", "rutenglobal", "rutenGlobal", "rontoGeneral", "Rutoglobal", "rutiStatic", "RutaRemote", "rutenFile", "redutanLocal", "redutanDefault", "rutoLocal", "rutaFile", "rontoDefault", "rutoRemote", "RutoRemote", "rutiLocal", "rutaDefault", "redutaGeneral", "RutoStatic", "rutiGlobal", "rutaStatic", "RutaGlobal", "rutenStatic", "rutaLocal", "redutaDefault", "rutaGeneral", "RutaStatic", "RutoGlobal"], "rutaRelativa": ["rutaRelatiiv", "rutaRelitiv", "rutaRelatiivo", "rutaRelitivo", "rutaRELitivo", "rutaRelitivas", "rutaRelATivas", "rutaRelATiv", "rutaRelantivo", "rutaRELitiv", "rutaRelantiv", "rutaRelativas", "rutaRELitiva", "rutaRELativas", "rutaRelativo", "rutaRelATiva", "rutaRELativ", "rutaRelitiva", "rutaRelativ", "rutaRELATiva", "rutaRELATivas", "rutaRelantiva", "rutaRELATiv", "rutaRelATivo", "rutaRELativo", "rutaRelatiiva", "rutaRelatiivas", "rutaRELativa", "rutaRelantivas", "rutaRELitivas", "rutaRELATivo"], "fis": ["fais", "dfis", "fisc", "flys", "flisc", "ris", "dfisa", "ros", "risc", "flis", "df\u00eds", "vois", "lfisa", " fiss", "fiss", "f\u00eds", " fois", " fys", "vais", "dfois", "rys", " fisc", "flos", " fais", "vis", "dfiss", "lfiss", "dfais", "viss", " f\u00eds", "fisa", " fisa", "fys", "fois", "lfis", "lf\u00eds"], "fos": ["vows", "wos", "foss", "mos", "ioss", "hos", "fdos", " faos", "iios", "moes", "wios", "foses", "foes", "ioses", "woss", " foss", "woses", " fops", "voes", "fows", "vops", "fdoss", "hoses", "mops", "faos", "mows", "waos", "fdaos", "woes", "hios", "fops", "hoss", "vos", " fows", " foes", "fdoes", "fios", "ios"], "canalFuente": ["canallfumelon", "canelFaente", "canalFaante", "canalFUante", "canalPotente", "canalFicer", "canalFiente", "canalFiestro", "canalFUelia", "canalFuestro", "canalFaent", "canalPotper", "canallfuencia", "canallFuencia", "canalFuelia", "canalfuante", "canalFraente", "canelFuent", "canalFuencia", "canallFucer", "canalfuelia", "canalfucer", "canelFuante", "canalFaente", "canallfuestro", "canalPotmelon", "canallFumelon", "canallfuper", "canalFraencia", "canalFuent", "canallfuente", "canalFucer", "canalfumelon", "canelFaent", "canalFUente", "canelFuelia", "canallFuent", "canelFaelia", "canallFuper", "canalFuante", "canelFaante", "canallFuestro", "canallfucer", "canalfuente", "canalPotencia", "canalFramelon", "canalFaelia", "canalFacer", "canallfuent", "canalfuencia", "canelFuente", "canalFUent", "canallFuente", "canalFraper", "canalFuper", "canalFaestro", "canalFient", "canalfuper", "canalfuent", "canalfuestro", "canalFumelon"], "canalDestino": ["canaldestina", "canalDestination", "canalNegina", "canalNeginian", "canalNegino", "canalOrigino", "canaldOrigino", "canalDescine", "canaldDestina", "canaldOrigination", "canalOrigination", "canaldestination", "canaldDestine", "canaldDestino", "canalDescina", "canalsDestina", "canaldDestination", "canalDescino", "canalOrigina", "canalDestinian", "canalsDestino", "canalDescination", "canalsdestinian", "canalDestine", "canaldestino", "canaldOrigina", "canalsDestinian", "canalsDestination", "canalsdestination", "canalOrigine", "canalsdestina", "canalDestina", "canalsdestino", "canalNegination", "canaldestinian", "canaldOrigine"]}}
{"id1": "255765", "id2": "8182932", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"f": ["fs", "ft", "b", "cf", "fw", "v", "bf", "p", "exp", "lf", "fm", "fo", "elf", "e", "fax", "path", "form", "test", "q", "m", "tf", "sf", "c", "it", "ret", "fb", "j", "fr", "dir", "fx", "fa", "file", "df", "base", "fn", "y", "fed", "name", "fac", "def", "fp", "fi", "h", "fab", "r", "filename", "g", "l", "t", "o", "fd", "rf", "F", "d", "info", "w", "fc", "n"], "in": [" IN", "ins", "din", "en", "again", "pi", "ex", "IN", "er", "inn", "con", "ai", "lo", "io", "inf", "cin", "gin", "local", "m", "ac", "bin", "mm", "from", "on", "it", "ic", "by", "re", "add", "all", "init", "nin", "thin", "al", "ma", "im", "reader", "ind", "is", "inc", "h", "up", "rin", "get", "input", "r", "iter", "inner", "oin", "l", "make", "o", "t", "log", "info", "isin", "at", " din", "In", "n"], "cbuf": ["sbbuf", "bcdf", "cbuffy", "cdbuf", "abbbuf", "cbuff", "CBbuf", "nbuff", "gbf", "rbuff", "bcuf", "nbfg", "cfuf", "bcfg", "gbuff", "cdoff", "sbuf", "abbuf", "cduffy", "bcoff", "sbather", "rbdf", "CBuff", "rbather", "rbuffy", "cbather", "nbuf", "rboff", "cbdf", "rbfg", "gbbf", "cbf", "rbbuf", "bcuff", "cduf", "CBuffy", "abbdf", "CBf", "cbbf", "cfuff", "bcather", "cbbuf", "cff", "CBuf", "gbuf", "cboff", "nbbuf", "cduff", "abbfg", "rbuf", "bcbuf", "CBbf", "sbuff", "cbfg", "cfbf"], "read": ["core", "need", "record", "stream", "old", "ead", "count", "sync", "buffer", "q", "give", "set", "pack", "reads", "re", "load", "add", "ke", "link", "reading", "orig", "READ", "range", "report", "run", "reader", "depth", "check", "get", "feed", "se", "row", "log", "ok", "send", "length", "k", "pe", "value", "select", "saw", "io", "chain", "print", "Read", "it", "view", "error", "rank", "ret", "key", "Reader", "ind", "is", "current", "clear", "write", "find", "close", "think", "fail", "start", "parse", "default", "end", "wait", "ignore", "reach", "readable", "bind", "data", "connect", "allow", "ink", "test", "pre", "raw", "hold", "ready", "query", "dev", "roll", "x", "est", "seek", "shift", " Read", "mem", "input", "miss", "ip", "play", "ank", "index", "handle", "mix", "poll", "scan", "slow", "ai", "ed", "text", "fill", "skip", "burst", "open", "height", "r", "trust", "iter", "rate", "ly", "ext", "hello", "n"], "totRead": ["atotaFill", "tokWrite", "ltotBuild", "retotReader", "tOTLoad", "tootDisplay", "totedFill", "letrotFind", "notWrite", "tcotConnect", "ttottWrite", "tOTNeed", "tiotSend", "ttottNeed", "tokRead", "tcotDisplay", "tacotRead", "tcotRead", "ttottAdd", "totalNeed", "totalSee", "toteAdd", "tottFind", "toteFill", "ptotWrite", "ptOTRead", "ltotLoad", "retottReader", "totAdd", "tottedWrit", "totaCheck", "atotPrint", "retotWrit", "ltotaRead", "toticWrite", "tobyCheck", "notaWrite", "ltotRead", "totBreak", "toteWrite", "atotaPrint", "tottedPrint", "notalLoad", "totalWrite", "atotFill", "tobyLoad", "totVal", "tiotVal", " totFind", "totaSee", "atotaRead", "totaLength", " totRun", "ptOTFind", "letrotRead", "notaRead", " totalWrite", "tootBreak", "ptotFind", "tottNeed", "totRun", "taotDisplay", "totaPrint", "tiotFill", "ttotAdd", "toteFind", "tottWrit", "totPrint", "tiotRead", " totalRead", "ltotaBuild", "retottWrit", "notalRead", "taotRead", "tottReader", "totalRead", "trotWrite", "notalPrint", "tokLoad", "tfatWrite", "totNeed", "tOTRead", "ltotaLoad", "tottRun", "tootCheck", "totaWrite", "totalBuild", "letotSee", "tiotHave", "tottedReader", "totFill", "ltotaFill", "toticFind", "totaAdd", " totWrite", "totaLoad", "trotFind", "toteRun", "notaReader", "totaConnect", "notNeed", "totalLength", "retottRead", "totalPrint", "toteLength", "totCheck", "ttottRead", "totDisplay", "tcotSend", "totedHave", "tfatRead", "tootSend", "tfatLoad", "atotRead", "tcotCheck", "totaDisplay", "totaReader", "toticRead", "atotHave", "tacotConnect", "letotWrite", "tottWrite", "tottAdd", "tootRead", "ttotRead", "totSee", "totBuild", "toiotRead", "totConnect", "totSend", "taotCheck", "totalCheck", "ptotLoad", " totalLength", "toteRead", "totalLoad", "tiatBuild", "totFind", "tacotDisplay", " toteRun", "atotaHave", "toteNeed", "tOTFind", "tiatRead", "tiatVal", "notalWrite", "totHave", "retotPrint", "tiatFill", "totaNeed", "tootVal", "tiotBreak", "toiotSend", "totedRead", "retotRead", "notLoad", "toticRun", "tottedRead", " totLength", "tiatBreak", "notalNeed", "tiatSend", "tcotVal", "toteLoad", "totaFind", "toiotVal", "tobyRead", "tOTWrite", "notalCheck", "totaBuild", "letotFind", "tiatLoad", "tobyNeed", "totedPrint", "totWrite", "totaFill", "letrotSee", " toteFind", "taotConnect", "ptotRead", "ltotFill", "totLength", "tobyWrite", "ttotWrite", " toteRead", "notPrint", "notaLoad", "ttotNeed", "tiotWrit", "tokFind", "totLoad", "notCheck", "toteReader", "totaRead", "letrotWrite", "tottRead", "notReader", " toteWrite", "trotSee", "tottPrint", "retottPrint", "tfatReader", "notRead", "toiotBreak", "letotRead", "toteBuild", "tcotBreak", "tiotPrint", "ptOTWrite", "totaHave", "tacotCheck", "tootConnect", "totWrit", "tiotReader", " totBuild", " totalBuild", "totReader", "tobyPrint", "trotRead", "totalFind", "ptOTLoad"], "out": ["output", "OUT", "co", "b", "v", "ex", "we", "con", "s", "net", "io", "sys", "outs", "c", "or", "writer", "OU", "ou", "to", "obj", "res", "auto", "aos", "ch", "write", "up", "r", "oss", "g", "conv", "os", "o", "t", "log", "end", "Out", "at", "w", "n"], "i": ["cli", "mi", "dr", "id", "ri", "ico", "any", "q", "set", "status", "ims", "g", "di", "gi", "ci", "ski", "\u0438", "point", "info", "I", "ia", "pi", " I", "ix", "integer", "php", "us", "e", "io", "um", "print", "chain", "my", "m", "ki", "multi", "ic", "it", "li", "xi", "to", "init", "ji", "ind", "is", "l", "o", "qi", "p", "v", "ity", "s", "si", "me", "iu", "c", "j", "x", "ie", "zi", "iii", "iy", "uri", "PI", "ip", "t", "index", "you", "ami", "iq", "b", "ini", "ii", "ice", "ai", "bi", "mm", "sim", "ei", "ij", "ti", "hi", "phi", "y", "this", "ion", "client", "ui", "r", "im", "oi"]}}
{"id1": "19584877", "id2": "10385815", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileAsDisk", "encodeFileFromFiles", "encodeFileFromDisk", "encodeStringToStream", "encodeStringToDisk", "encodeStringToFiles", "encodeFiletoDisk", "encodeFileAsStream", "encodeFiletoFile", "encodeFileToStream", "encodeFileFromFile", "encodeFiletoFiles", "encodeStringAsDisk", "encodeFileAsFile", "encodeStringAsStream", "encodeStringAsFiles", "encodeFileToFiles", "encodeFileAsFiles", "encodeStringAsFile", "encodeFiletoStream", "encodeStringToFile", "encodeFileFromStream", "encodeFileToDisk"], "infile": ["Inbase", "inputpath", " inbase", "inputfilename", "inbase", "outpath", "inputfile", " infilename", "outbase", "inpath", "Inpath", "inFile", "infilename", " inFile", "outFile", "outfilename", "InFile", " inpath", "Infile", "inputFile"], "outfile": ["todir", "fromfile", "inname", "newfilename", " outname", "outdir", "outfp", "newFile", "fromfp", "fromFile", "inFile", "infilename", "outname", "infp", "toFile", "fromdir", "newfile", "tofp", "newname", "indir", "tofile", " outFile", "outFile", "outfilename", " outfilename"], "in": ["image", "ins", "din", "inside", "en", "id", "pin", "ini", "IN", "inn", "con", "form", "inf", "cin", "gin", "on", "bin", "conn", "from", "it", "ar", "or", "by", "re", "ro", "amin", "init", "nin", "al", "ain", "per", "ind", "is", "inc", "up", "rin", "get", "i", "input", "source", "iter", "inner", "oin", "t", "info", "isin", "im", " din", "In"], "out": ["cn", "ot", "output", "OUT", "en", "co", "b", "ex", "gt", "con", "net", "io", "ne", "print", "sys", "on", "outs", "it", "writer", "OU", "ou", "to", "res", "file", "aos", "nt", "fn", "can", "ion", "write", "up", "opt", "oss", "g", "inner", "os", "null", "flush", "o", "t", "end", "Out", "at", "outer", "n"], "buffer": ["initial", "length", "column", "header", "binary", "cache", "message", "total", "window", "buf", "print", "stack", "sequence", "phrase", "queue", "block", "view", "button", "table", "frame", "black", "bar", "note", "available", "comment", "paste", "attribute", "document", "batch", "base", "library", "history", "append", "template", "memory", "number", "display", "mem", "character", "row", "variable", "Buffer", "padding", "buff", "sample", "pad", "info", "password", "command", "bone", "temp"], "read": ["length", "readable", "need", "stream", "count", "connect", "wait", "select", "through", "each", "allow", "print", "Read", "give", "set", "raw", "push", "text", "hold", "reads", "size", "load", "add", "reading", "ready", "skip", "READ", "req", "range", "query", "run", "reader", "ind", "seek", "open", " Read", "before", "check", "write", "get", "i", "input", "len", "find", "iter", "close", "start", "end", "ok", "first", "index", "send", "n"], "success": [" successful", "same", "crit", "sufficient", "value", "ith", "warning", "ratulations", "support", "please", "setup", "city", "complete", "valid", "first", " succ", "safe", "continue", "positive", "error", "commit", "status", " Success", "democracy", "response", "ceed", " okay", "successfully", "result", "snap", "ccess", "unity", "good", "town", "cess", "done", "photo", "submit", "release", "condition", "fail", "surv", "growth", " failure", "danger", "second", "accept", "summary", "primary", "ok", "successful", "Success", " successes"]}}
{"id1": "19335986", "id2": "88047", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncurredception", " uncuredception", "uncaughtError", " uncuredFailure", "uncuredException", "uncurredFailure", " uncuredError", "uncappedError", " uncaughtFailure", " uncuredException", " uncaughtError", "uncappedception", "uncurredException", "uncuredError", "uncaughtception", "uncurredError", "uncaughtFailure", "uncuredception", " uncaughtception", "uncappedFailure", "uncappedException", "uncuredFailure"], "t": ["f", " th", "b", "p", " tid", "task", "window", "thread", " st", "Thread", "m", "tf", "c", "to", "y", "out", " title", "h", " ti", "title", " T", "g", "l", "o", "d", "T", "w", "n"], "e": ["f", "et", "el", "u", "pe", "en", "b", "p", "xe", "ex", "ec", "ea", "er", "fe", "te", "ele", "ae", "eu", "ev", "ed", "Error", "E", "err", "m", "eg", "it", "c", "error", "a", "ef", "de", "x", "ie", "event", "se", "r", "i", "oe", "es", "exc", "o", "eeee", "ce", "d", "ee"], "display": ["output", "server", "b", "lay", "style", "position", "present", "dis", "screen", "show", "window", "list", "s", "Display", "print", "scroll", "view", "DIS", "table", "link", "browser", "report", "render", "label", "session", "layout", "console", "body", "name", "this", "details", "l", "play", "log", "d", "draw"], "shell": ["cli", "scope", "sh", "output", "server", "b", "sound", "dis", "screen", "ssh", "window", "form", "environment", "print", "buffer", "program", "tree", "Shell", "scroll", "board", "view", "or", "nl", "control", "hell", "storage", "ro", "session", "browser", "report", "expression", "sb", "layout", "console", "body", "library", "system", "ui", "quit", "help", "l", "echo", "tool", "log", "command", "handle"], "message": ["image", "translation", "object", "field", "meter", "position", "question", "show", "language", "window", "email", "detail", "description", "say", "content", "buffer", "member", "hello", "m", "subject", "application", "request", "view", "error", "button", "trace", "response", "Message", "metadata", "report", "comment", "payment", "label", "session", "document", "management", "layout", "console", "body", "menu", "msg", "system", "open", "mail", "template", "memory", "title", "one", "manager", "echo", "summary", "log", "essage", "command", "module", "result"], "e1": ["ee1", "e3", "ee3", "E0", " e0", "E3", "e2", "E1", "E2", " e3", "ee2", "e0", "ee0", " e2"]}}
{"id1": "9096319", "id2": "11305840", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeRegalledService", "handleNoderegainedServices", "handleNodeRegalledSite", "handleNoderegainedSite", "handleNoderegainsSite", "handleNodeRegalledServices", "handleNodeRegainsSite", "handleNoderegainsServices", "handleNodeRegifiedService", "handleNodeRegainedSite", "handleNodeRegifiedServices", "handleNodeRegainsServices", "handleNodeRegainedServices", "handleNoderegainsService", "handleNodeRegainsService", "handleNoderegainedService", "handleNodeRegifiedSite"], "eventID": ["serviceKey", "EventId", "eventUID", "eventId", "EventUID", "nodeType", "EventID", "nodeKey", "nodeId", " eventName", " eventType", "eventKey", "serviceTime", "nodeUID", " eventUID", "serviceId", "eventType", "serviceUID", " eventId", "EventType", "EventTime", " eventKey", "EventName", "nodeName", "nodeTime", "eventName"], "nodeID": ["NodeIT", "localJS", " nodeIT", "serverID", "moduleid", " nodeJS", "odeIDE", "odeID", "moduleIDE", "serverInfo", "nodeInfo", " nodeName", " nodeIDs", "NodeName", "moduleID", "entityId", "nodeId", " nodeId", "nodeIT", "resourceId", "serverId", "serverIDs", "instanceInfo", "NodeIDs", "localID", "volumeName", "NodeID", "moduleId", "entityJS", "volumeId", " nodeInfo", "instanceID", " nodeid", "instanceIDs", " nodeIDE", "localId", "nodeIDE", "serverName", "volumeIT", "moduleIT", "nodeJS", "instanceId", "volumeID", "entityID", "nodeid", "resourceName", "Nodeid", "resourceID", "nodeIDs", "nodeName", "NodeId", "odeId"], "ipAddr": ["ipSender", "ipAddaddr", "ipaddrt", "ipAddrt", "ipAndr", "epAddri", "ipAdder", "ipReshr", "ipAddressrar", "epAddrs", "ipAcr", " ipAddressp", "ipSendr", "epAddressl", " ipAddhr", " ipAddressrs", "ipAddl", "ipAcrs", "ipStorehr", "ipAddressp", "ipAddressri", "ipIntr", "ipAttp", "epAddr", " ipAddaddr", "ipStorer", "ipAddhr", "ipAddsn", " ipAdder", "ipIntaddr", " ipaddrs", " ipAddp", " ipAddn", "ipResrs", "ipAttr", "ipAddp", "ipAddsrs", "ipAddressrs", "ipStorers", "ipIntrs", "ipaddrs", "epAddressri", "ipSendp", "ipAndl", "ipAddresser", "ipAndp", " ipAddrt", "ipaddr", "ipAddri", " ipAttrar", " ipAddressaddr", "epAddressr", "ipAddrar", " ipAddrs", " ipAttr", " ipaddrt", " ipAddrar", " ipAddl", "ipIntp", "ipaddl", "ipResr", "ipAddressr", "ipResrt", " ipAtter", "ipAddrs", "ipAddsr", "ipAndri", "epAddressrs", "ipAddn", "ipAndrs", "ipaddp", "ipAddressaddr", "ipAcn", " ipaddp", "ipAndrt", "ipAttrar", " ipAddrb", "epAddl", " ipAttp", " ipaddr", "ipAddsrb", "ipAddressl", "ipAtter", "ipAddrb", "ipSendrar", "ipStorert", "ipAcrb", " ipAddressr"], "serviceID": [" serviceType", "serviceKey", " serviceKey", "servID", "servName", "ServiceName", "sourceId", " serviceNAME", "sourceJO", " serviceNOTE", " serviceid", "sourceID", "servId", "securityId", " serviceName", "ServiceId", "resourceId", "componentID", "servKey", "serviceLAN", "serviceNAME", " serviceLAN", "securityid", "serviceid", "serviceId", "ServiceNAME", "Serviceid", "sourceName", "serviceType", "componentName", " serviceId", "securityID", "serviceJO", "servLAN", "serviceNOTE", "servid", "componentNOTE", "serviceName", "ServiceNOTE", "componentId", "resourceName", "ServiceLAN", "securityName", "ServiceType", "ServiceID", "resourceID", "servNAME", "ServiceJO", "resourceType", "ServiceKey", " serviceJO"], "eventTime": ["ageType", "Eventtime", " eventTimes", "eventTIME", "eventtime", " eventtime", "attributeTIME", "attributeType", "attributeTime", "ventTimes", " eventType", "ventTime", "agetime", "eventType", "eventTimes", "EventType", "EventTime", "ageTime", "ventType", "EventTIME", "ventTIME", "ageTIME", "attributeTimes", " eventTIME"], "log": [" logger", "ger", "lo", "le", "pel", "err", "set", "link", "note", "de", "report", "tag", "sql", "file", "be", "lock", "pl", "se", "cat", "row", "url", "util", "use", "Log", "cal", "store", "og", "iam", "com", "enter", "ge", "entry", "ar", "it", "error", "or", "prot", "call", "mail", "conf", "l", "tab", "json", "at", "w", "en", "bug", "ex", "channel", "message", "email", "user", "blog", "debug", "base", "msg", "out", "full", "config", "t", "crit", "low", "scale", "ome", "net", "cell", "xml", "gob", "category", "LOG", "event", "zip", "db", "ext", "and", "cont"], "dbConn": ["tableObj", "sbCon", "fbConn", "Dbconn", "tableConn", " dbObj", "DbConn", " dbConnect", "DBCon", "sbObj", "dbCons", "dbconn", "bdConnect", " dbCons", "sbConnect", "bdCon", "sbConnection", "bdObj", "DBCons", " dbconn", "DBConn", "DbConnect", "cbConnection", "dbCon", "gbCon", "dbObj", "dbConnect", "dbConnection", "userCon", "gbConn", "bConn", "bCons", "gbConnect", "cbCon", "gbConnection", "fbCon", "tableCon", "userConn", "cbConn", "fbObj", "userObj", " dbCon", "bdConn", "DBConnect", "bConnect", "userConnect", "DbObj", "sbConn", "fbConnect", "cbConnect", "tableconn", "DbCon", "bCon"], "outageUpdater": ["outageUpdatedager", "outageUpnomer", "outageUpdatater", "outageUpnater", "outageUPtoder", "outageUndter", "outageUtDrer", "outageUppoder", "outageUptatter", "outageUpdatedATER", "outageUPdarer", "outageUpndATER", "outageUpnarer", "outageUpdATER", "outageUplitter", "outageUdataser", "outageUpddater", "outageUplaters", "outageUprater", "outageUpdataser", "outageUpmomer", "outageUpDarer", "outageUPtatter", "outageUdatoder", "outageUpmetter", "outageUpDaser", "outageUpmrer", "outageUPtter", "outageUpDaters", "outageUplater", "outageUpdatedarer", "outageUpmATER", "outageUPdter", "outageUpDrer", "outageUpdetter", "outageUpmaser", "outageUpDager", "outageUpdter", "outageUpdatemaser", "outageUtdater", "outageUptaser", "outageUplarer", "outageUpmter", "outageUpmater", "outageUpndater", "outageUpnditter", "outageUdetter", "outageUtdrer", "outageUPdaters", "outageUpdatedaser", "outageUpnoder", "outageUpdrer", "outageUpdager", "outageUpdomer", "outageUppater", "outageUPdATER", "outageUpdatemomer", "outageUpDatter", "outageUtDaser", "outageUptager", "outageUpdaterager", "outageUpdoder", "outageUtdaser", "outageUPdatter", "outageUptoder", "outageUptter", "outageUPdaser", "outageUptaters", "outageUpdaser", "outageUpdatemater", "outageUpnitter", "outageUdatater", "outageUprager", "outageUpDATER", "outageUndater", "outageUplATER", "outageUpDater", "outageUplter", "outageUpdaterater", "outageUpraters", "outageUptitter", "outageUPtitter", "outageUpmitter", "outageUnndter", "outageUdaser", "outageUpdatetter", "outageUpprer", "outageUPnATER", "outageUprarer", "outageUtdoder", "outageUpDoder", "outageUpdatter", "outageUptarer", "outageUPnaters", "outageUpnaser", "outageUpdatedaters", "outageUpdboder", "outageUpdbetter", "outageUdatetter", "outageUPtaser", "outageUtDoder", "outageUppaser", "outageUpnter", "outageUpnATER", "outageUndATER", "outageUdoder", "outageUnndATER", "outageUpddaser", "outageUpdaterarer", "outageUpdarer", "outageUpdatemATER", "outageUPnater", "outageUpdateraters", "outageUPdater", "outageUdater", "outageUtDater", "outageUptater", "outageUpdbater", "outageUnndater", "outageUpnatter", "outageUnditter", "outageUpdbaser", "outageUpdaters", "outageUpdatedomer", "outageUpdatedater", "outageUPditter", "outageUPdoder", "outageUpnaters", "outageUPtater", "outageUPnarer", "outageUnnditter", "outageUPtaters", "outageUploder", "outageUpdatoder", "outageUpditter", "outageUpmoder", "outageUpndter", "outageUpddomer", "outageUpddATER"]}}
{"id1": "15445861", "id2": "4798332", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"copyFile": ["copyfile", "cpFiles", " cpFile", "cpDir", "copyDir", " copyFiles", "cpfile", " cpfile", " cpFiles", " cpDir", "copyFiles", "cpFile", " copyDir", " copyfile"], "srcFile": ["srcTime", "srcDir", "sourcePage", "sqLine", " srcPage", "destfile", "rcTime", "rcDir", "synfile", "sqTime", "sourceFile", "rcLine", "rcfile", "rcPage", "sqFile", "srcLine", "sysWeb", " srcPath", " srcLine", " srcTime", " srcWeb", "sourcePath", "sourceLine", "srcfile", "rcFile", "sqPage", " srcModel", "synLine", "rcPath", "srcModel", "srcWeb", "srcPage", "synWeb", "sourceDir", "sourceModel", "sysLine", "sourcefile", "sysfile", "sysFile", " srcDir", "destPage", " srcfile", "destModel", "synFile", "srcPath"], "destFile": ["portLine", "gtPlace", "estEmail", "portPage", "gtPage", "destfile", " destfile", "gtFILE", "DestPort", "sourceFile", "expFile", "estFile", "expPlace", "destDir", "optDir", "DestTable", "gtFile", " destFolder", "potPort", "destFolder", "imgfile", "portPlace", "optFolder", "expPage", "sourceFine", "expLine", "gtLine", "DestDir", "destEmail", " destPort", "destPlace", "tomFILE", "DestFolder", "potfile", "potFile", "imgFine", "tomEmail", "optFile", "tomFile", "Destfile", " destTable", "potDir", " destDir", "optTable", "DestFile", "estFILE", "sourceDir", "portFile", "estPort", "gtEmail", "destLine", "imgDir", "destPort", "gtPort", "destTable", "destFILE", "sourcefile", "DestFine", "imgFile", "destPage", "tomPort", "destFine"], "in": ["el", "inside", "din", "irm", "ins", "en", "old", "ini", "ze", "IN", "inn", "con", "io", "inf", "cin", "gin", "on", "mm", "from", "ar", "ic", "it", "by", "init", "al", "ain", "act", "ind", "is", "inc", "up", "rin", "i", "input", "source", "iter", "inner", "info", "isin", "im", "In"], "out": ["cn", "output", "OUT", "co", "v", "dis", "ex", "cache", "sum", "con", "user", "net", "io", "ne", "sys", "n", "on", "err", "outs", "it", "c", "by", "writer", "ou", "and", "to", "obj", "res", "gc", "auto", "aos", "nt", "ch", "client", "write", "up", "one", "inner", "null", "o", "t", "log", "end", "Out", "at", "outer", "can"], "buffer": ["length", "initial", "binary", "cache", "message", "total", "window", "buf", "print", "phrase", "sequence", "stack", "queue", "bank", "block", "raw", "table", "frame", "bar", "bridge", "reason", "comment", "attribute", "paste", "document", "batch", "body", "base", "library", "word", "history", "append", "template", "memory", "display", "mem", "character", "iter", "row", "variable", "Buffer", "buff", "sample", "pad", "command", "bone", "temp"], "no": ["nn", "num", "node", "mo", "sha", "yes", "bo", "total", "orno", "NO", "lo", "un", "ne", "io", "vo", "nos", "ko", "how", "sn", "zero", " NO", "eno", "a", "read", "to", "po", "none", "pos", "No", "nr", "who", "number", "i", "never", " No", "ano", "os", "start", "na", "ni", "o", "not", "go", "index", "n"]}}
{"id1": "481364", "id2": "20920051", "code1": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"downloadFiles": ["downloadfiles", " downloadBytes", "getBytes", " downloadfiles", "getfiles", "dumpBytes", "getFiles", "downloadBytes", "dumpFiles", "dumpfiles", "downloadImages", "dumpImages", " downloadImages", "getImages"], "downloadFilesWorker": ["downloadFilesCleanler", "downloadFilesCleaner", "downloadImagesWr", "downloadFilesWer", "downloadFilesWalkER", "downloadFilesWorkr", "downloadImagesWorkER", "downloadImagesWler", "downloadImagesWorker", "downloadFilesWler", "downloadFilesCleanr", "downloadFilesWorkler", "downloadImagesWer", "downloadFilesWER", "downloadFilesCleanER", "downloadImagesWorkler", "downloadImagesWorkr", "downloadFilesWr", "downloadFilesWalker", "downloadFilesWalkler", "downloadFilesWorkER", "downloadFilesWalkr", "downloadImagesWER"], "startDownloadDate": ["startUpdateTime", "startLoadTime", "startDownloadDay", "startUpdateDate", "lastUpdateTime", "startLoadDate", " startUploadDate", "startUploadAt", "startUploadTime", "startLoadDay", "startDateDay", "startDateDate", " startDownloadDay", " startDownloadDo", "startFileAt", " startUploadTime", "startUploadDo", "startLoadDo", " startUploadDo", "lastUpdateDay", "startdownloadDate", "startFileTime", "startdownloadTime", "lastDownloadAt", "startUpdateAt", "startFileDate", " startUploadDay", "lastDownloadTime", "startUploadDay", "lastUpdateDate", "startDownloadDo", " startdownloadTime", " startdownloadDay", "startDownloadTime", " startdownloadDate", "startDownloadAt", "startUpdateDay", "startDateTime", "startUploadDate", "lastUpdateAt", "lastDownloadDay", "startdownloadDo", "startFileDay", "startdownloadDay", "lastDownloadDate", " startDownloadTime"], "refreshSpeed": ["RefetchAmount", "RefreshSpeed", "RefreshDuration", "refillDuration", "reflexTime", "reflexDuration", "refreshAmount", "RefetchTime", "refetchTime", "refetchAmount", "reflexSpeed", "RefreshTime", "refetchSpeed", "RefreshAmount", "reflexAmount", "refillTime", "refreshDuration", "RefetchDuration", "refillSpeed", "refreshTime", "refillAmount", "RefetchSpeed", "refetchDuration"], "lastDate": ["LastTime", "nextDay", "lastDay", "LastDate", " lastdate", "lastdate", "LastDay", "Lastdate", "nextTime", "nextdate", " lastTime", "nextDate", " lastDay", "lastTime"], "totalSizeRead": ["totalSizeWritten", "TotalNumberread", "totalBytesWritten", "TotalSizeReader", "totalSizeread", "totalNameread", "TotalNumberREAD", "totalBytesREAD", "totalLengthLength", "totalLengthRead", "TotalSizeread", "totalNumberLength", "TotalNumberRead", "TotalSizeREAD", "totalNumberREAD", "totalSizeLength", "totalSizeReader", "totalLengthReader", "totalBytesRead", "TotalSizeLength", "totalNumberread", "totalLengthWritten", "totalNameWritten", "TotalNumberLength", "TotalNumberWritten", "TotalNumberReader", "totalNumberWritten", "totalLengthREAD", "totalNameRead", "totalLengthread", "TotalSizeRead", "totalSizeREAD", "TotalSizeWritten", "totalNumberReader"], "totalNumberRead": ["totalSizeWritten", "TotalNumberread", "totalStringREAD", "TotalNumbersread", "totalNumberFound", "TotalNumberREAD", "totalnumberFind", "totalnumberFound", " totalNumberWritten", "totalnumberRead", "totalNumbersREAD", " totalNumbersRead", " totalNumberLength", "totalSizeFind", "totalNumberLength", "totalSizeFound", "totalCounterREAD", "TotalNumbersREAD", "TotalNumberRead", "totalStringLength", " totalNumbersREAD", " totalNumberFind", "totalnumberWritten", "totalNumberREAD", " totalNumbersLength", " totalNumbersFind", " totalNumbersFound", "totalNumberFind", "totalNumbersread", "totalSizeLength", "totalStringRead", " totalNumberFound", "totalCounterRead", " totalNumberREAD", "totalNumberread", "totalCounterread", "TotalNumbersWritten", "TotalNumberWritten", "totalNumbersWritten", "totalStringWritten", "totalNumbersLength", "TotalNumbersRead", "totalNumberWritten", "totalNumbersFound", "totalCounterWritten", "totalNumbersFind", "totalNumbersRead", " totalNumbersWritten", "totalSizeREAD"], "photo": [" photograp", "record", "Flickr", "video", " Photo", "pair", "lo", "application", "page", "phone", "pg", "file", "settings", "large", "Photo", "row", "info", "ickr", "jp", "gif", "profile", "instance", " patient", "facebook", "mop", "entry", "trip", "phot", "jpg", " microphone", "upload", "to", "item", "document", "snap", "op", " avatar", "policy", " photographer", "json", "media", "copy", " bio", "p", " photos", "api", " photograph", "post", "album", "prototype", "son", "parent", " geo", " video", " attachment", "go", "slot", "room", "handle", "image", "behavior", "person", "opus", "jj", "member", "picture", "mm", " PHOTO", "news", " logo", "vision", "pool", "song", " photography", "camera", "pixel", "primary", "job", "photos", " portrait"], "url": ["loc", "sl", "ssl", "atl", "https", "location", "ls", "dl", "arl", "api", "char", "bel", "github", "google", "web", "ml", "ref", "str", "ll", "raw", "request", "resource", "http", "ul", "nl", "link", "ur", "URL", "sb", "build", "base", "address", "name", "open", "mount", "mail", "get", "r", "uri", "Url", "l"], "connection": ["context", "online", "established", "position", "channel", "data", "Connection", "connect", "communication", "relation", "description", "con", "web", "io", "handler", "information", "database", "network", "conn", "application", "c", "resource", "response", "link", "socket", "to", "session", "sql", "console", "directory", "open", "system", "client", "ion", "uri", "created", "statement", "l", "condition", "log", "command", "opening"], "dis": ["rel", "del", "dd", "shell", " Dis", "du", "ris", "serv", "ex", "dl", "sle", "please", "sd", "lo", "sys", "mor", "lor", "DIS", "san", "disc", "bis", "nl", "dist", "de", "ser", "des", "sol", "auto", "body", "mis", "det", "is", "no", "def", "display", "se", "tem", "di", "inner", "wise", "ly", "Dis", "mil", "not"], "fos": ["eol", "wos", "foss", "fiof", "mos", "hol", "wof", "hos", "mo", "hof", "fioss", "fo", "fof", "foes", "fol", "woss", " foss", "poes", "eos", "po", "moss", " fof", "pos", "eof", "fiol", "poss", "woes", " fo", "mof", "wo", "eoss", "hoss", " foes", "fios"], "b": ["f", "z", "bl", "lib", "bs", "p", "v", "bf", "buf", "s", "blue", "bi", "buffer", "nb", "m", "bin", "ab", "c", "fb", "bar", "a", "j", "B", "sb", "eb", "base", "bt", "y", "be", "erb", "mb", "gb", "bit", "br", "ob", "h", "i", "r", "db", "l", "rb", "t", "buff", "bound", "bb", "w", "pb", "n"], "sizeRead": ["sampleread", "sumRead", "scaleWritten", "sumREAD", "SIZEREAD", "SIZEread", "seeREAD", "scaleRead", "sizeLength", " sizeWritten", " sizeWrite", "sampleRead", "sizeread", " sizeREAD", " sizeLength", "SIZERead", "sumLength", " sizeFind", "numberFind", "seeread", "sizeReader", "sizeWritten", "lengthLoad", "sizeREAD", "numberRead", "sumLoad", "statusWrite", "SizeLength", "nameReader", "statusLength", "nameRead", "sizeLoad", "statusRead", "SIZELoad", "SizeWrite", "seeReader", "sampleReader", "SizeReader", "lengthRead", "sizeWrite", "SizeRead", "seeRead", "SIZEReader", " sizeLoad", "sizeFind", "scaleReader", "lengthFind", "SIZELength", "statusReader", "nameWritten", "sampleREAD", " sizeReader", "numberLoad"], "totalDiffTime": ["totalChangeSize", " totalDiffInfo", "totalDifferentSize", "totalDifferentInfo", "totalDeltatime", " totalDiffSize", "totalDeltaInfo", "totalChangetime", "totalChangeTime", "totalDeltaTime", "totalDifferentTime", "totalDiffInfo", "totalDiffSize", " totalDifftime", "totalDifftime", "totalDeltaSize"], "totalSpeed": ["equalRate", "totalExperience", "privatePerformance", "Totalspeed", "privatespeed", "totalWeight", " totalExperience", "TotalPerformance", "totalspeed", "completeWeight", " totalSlow", "equalSpeed", " successfulRate", "completespeed", "TotalSpeed", "totalRate", "privateWeight", " successfulSlow", "TotalWeight", " successfulSpeed", " successfulExperience", " totalRate", "totalPerformance", "privateSpeed", "completeSpeed", "equalExperience", "equalSlow", "completePerformance", "totalSlow"], "list": ["top", "LIST", "v", "alist", "ls", "dl", "data", "pair", "detail", "ml", "listed", "chain", "print", "stack", "sequence", "sort", "queue", "tree", "set", "ll", "st", "collection", "array", "part", "table", "load", "ul", "range", "all", "lists", "left", "batch", "nt", "pool", "out", "l", "null", "coll", "info", "local", "history", "cont"]}}
