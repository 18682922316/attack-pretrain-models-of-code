Original Code,Extracted Variable
"static void filter_mirror_setup(NetFilterState *nf, Error **errp) { MirrorState *s = FILTER_MIRROR(nf); Chardev *chr; chr = qemu_chr_find(s->outdev); if (chr == NULL) { error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND, ""Device '%s' not found"", s->outdev); qemu_chr_fe_init(&s->chr_out, chr, errp);","[['nf'], ['errp'], ['s'], ['FILTER_MIRROR'], ['chr'], ['qemu_chr_find'], ['error_set'], ['ERROR_CLASS_DEVICE_NOT_FOUND'], ['qemu_chr_fe_init']]"
"static inline int64_t sub64(const int64_t a, const int64_t b) { return a - b; }","[['a'], ['b']]"
"void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback, void *callback_opaque, uint8_t *data, size_t len) { int arch = !!(key & FW_CFG_ARCH_LOCAL); assert(key & FW_CFG_WRITE_CHANNEL); key &= FW_CFG_ENTRY_MASK; assert(key < FW_CFG_MAX_ENTRY && len <= 65535); s->entries[arch][key].data = data; s->entries[arch][key].len = len; s->entries[arch][key].callback_opaque = callback_opaque; s->entries[arch][key].callback = callback; }","[['s'], ['key'], ['callback'], ['callback_opaque'], ['data'], ['len'], ['arch'], ['FW_CFG_ARCH_LOCAL'], ['assert'], ['FW_CFG_WRITE_CHANNEL'], ['FW_CFG_ENTRY_MASK'], ['FW_CFG_MAX_ENTRY']]"
"static void emulated_push_error(EmulatedState *card, uint64_t code) { EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent)); assert(event); event->p.error.type = EMUL_ERROR; event->p.error.code = code; emulated_push_event(card, event); }","[['card'], ['code'], ['event'], ['g_malloc'], ['EmulEvent'], ['assert'], ['EMUL_ERROR'], ['emulated_push_event']]"
"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid) { int32_t datalen; int lun; DPRINTF(""do_busid_cmd: busid 0x%x\n"", busid); lun = busid & 7; s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL); datalen = scsi_req_enqueue(s->current_req, buf); s->ti_size = datalen; if (datalen != 0) { s->rregs[ESP_RSTAT] = STAT_TC; s->dma_left = 0; s->dma_counter = 0; if (datalen > 0) { s->rregs[ESP_RSTAT] |= STAT_DI; } else { s->rregs[ESP_RSTAT] |= STAT_DO; } scsi_req_continue(s->current_req); } s->rregs[ESP_RINTR] = INTR_BS | INTR_FC; s->rregs[ESP_RSEQ] = SEQ_CD; esp_raise_irq(s); }","[['s'], ['buf'], ['busid'], ['datalen'], ['lun'], ['DPRINTF'], ['scsi_req_new'], ['scsi_req_enqueue'], ['STAT_TC'], ['STAT_DI'], ['STAT_DO'], ['scsi_req_continue'], ['INTR_BS'], ['INTR_FC'], ['SEQ_CD'], ['esp_raise_irq']]"
"static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { uint32_t config_addr = rtas_ld(args, 0); uint64_t buid = rtas_ldq(args, 1); unsigned int func = rtas_ld(args, 3); unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */ unsigned int seq_num = rtas_ld(args, 5); unsigned int ret_intr_type; unsigned int irq, max_irqs = 0, num = 0; sPAPRPHBState *phb = NULL; PCIDevice *pdev = NULL; spapr_pci_msi *msi; int *config_addr_key; switch (func) { case RTAS_CHANGE_MSI_FN: case RTAS_CHANGE_FN: ret_intr_type = RTAS_TYPE_MSI; break; case RTAS_CHANGE_MSIX_FN: ret_intr_type = RTAS_TYPE_MSIX; break; default: error_report(""rtas_ibm_change_msi(%u) is not implemented"", func); rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); return; } /* Fins sPAPRPHBState */ phb = spapr_pci_find_phb(spapr, buid); if (phb) { pdev = spapr_pci_find_dev(spapr, buid, config_addr); } if (!phb || !pdev) { rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); return; } /* Releasing MSIs */ if (!req_num) { msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr); if (!msi) { trace_spapr_pci_msi(""Releasing wrong config"", config_addr); rtas_st(rets, 0, RTAS_OUT_HW_ERROR); return; } xics_free(spapr->icp, msi->first_irq, msi->num); if (msi_present(pdev)) { spapr_msi_setmsg(pdev, 0, false, 0, num); } if (msix_present(pdev)) { spapr_msi_setmsg(pdev, 0, true, 0, num); } g_hash_table_remove(phb->msi, &config_addr); trace_spapr_pci_msi(""Released MSIs"", config_addr); rtas_st(rets, 0, RTAS_OUT_SUCCESS); rtas_st(rets, 1, 0); return; } /* Enabling MSI */ /* Check if the device supports as many IRQs as requested */ if (ret_intr_type == RTAS_TYPE_MSI) { max_irqs = msi_nr_vectors_allocated(pdev); } else if (ret_intr_type == RTAS_TYPE_MSIX) { max_irqs = pdev->msix_entries_nr; } if (!max_irqs) { error_report(""Requested interrupt type %d is not enabled for device %x"", ret_intr_type, config_addr); rtas_st(rets, 0, -1); /* Hardware error */ return; } /* Correct the number if the guest asked for too many */ if (req_num > max_irqs) { trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs); req_num = max_irqs; irq = 0; /* to avoid misleading trace */ goto out; } /* Allocate MSIs */ irq = xics_alloc_block(spapr->icp, 0, req_num, false, ret_intr_type == RTAS_TYPE_MSI); if (!irq) { error_report(""Cannot allocate MSIs for device %x"", config_addr); rtas_st(rets, 0, RTAS_OUT_HW_ERROR); return; } /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */ spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX, irq, req_num); /* Add MSI device to cache */ msi = g_new(spapr_pci_msi, 1); msi->first_irq = irq; msi->num = req_num; config_addr_key = g_new(int, 1); *config_addr_key = config_addr; g_hash_table_insert(phb->msi, config_addr_key, msi); out: rtas_st(rets, 0, RTAS_OUT_SUCCESS); rtas_st(rets, 1, req_num); rtas_st(rets, 2, ++seq_num); if (nret > 3) { rtas_st(rets, 3, ret_intr_type); } trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq); }","[['cpu'], ['spapr'], ['token'], ['nargs'], ['args'], ['nret'], ['rets'], ['config_addr'], ['rtas_ld'], ['buid'], ['rtas_ldq'], ['func'], ['req_num'], ['seq_num'], ['ret_intr_type'], ['irq'], ['max_irqs'], ['num'], ['phb'], ['pdev'], ['msi'], ['config_addr_key'], ['RTAS_CHANGE_MSI_FN'], ['RTAS_CHANGE_FN'], ['RTAS_TYPE_MSI'], ['RTAS_CHANGE_MSIX_FN'], ['RTAS_TYPE_MSIX'], ['error_report'], ['rtas_st'], ['RTAS_OUT_PARAM_ERROR'], ['spapr_pci_find_phb'], ['spapr_pci_find_dev'], ['g_hash_table_lookup'], ['trace_spapr_pci_msi'], ['RTAS_OUT_HW_ERROR'], ['xics_free'], ['msi_present'], ['spapr_msi_setmsg'], ['msix_present'], ['g_hash_table_remove'], ['RTAS_OUT_SUCCESS'], ['msi_nr_vectors_allocated'], ['trace_spapr_pci_msi_retry'], ['xics_alloc_block'], ['SPAPR_PCI_MSI_WINDOW'], ['g_new'], ['spapr_pci_msi'], ['g_hash_table_insert'], ['trace_spapr_pci_rtas_ibm_change_msi']]"
"void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...) { va_list va; char buf[256]; char *p; target_ulong addr; uint64_t i64; GDBState *s; s = gdbserver_state; if (!s) return; gdb_current_syscall_cb = cb; s->state = RS_SYSCALL; #ifndef CONFIG_USER_ONLY vm_stop(EXCP_DEBUG); #endif s->state = RS_IDLE; va_start(va, fmt); p = buf; *(p++) = 'F'; while (*fmt) { if (*fmt == '%') { fmt++; switch (*fmt++) { case 'x': addr = va_arg(va, target_ulong); p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr); break; case 'l': if (*(fmt++) != 'x') goto bad_format; i64 = va_arg(va, uint64_t); p += snprintf(p, &buf[sizeof(buf)] - p, ""%"" PRIx64, i64); break; case 's': addr = va_arg(va, target_ulong); p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx ""/%x"", addr, va_arg(va, int)); break; default: bad_format: fprintf(stderr, ""gdbstub: Bad syscall format string '%s'\n"", fmt - 1); break; } } else { *(p++) = *(fmt++); } } *p = 0; va_end(va); put_packet(s, buf); #ifdef CONFIG_USER_ONLY gdb_handlesig(s->c_cpu, 0); #else cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT); #endif }","[['cb'], ['fmt'], ['va'], ['buf'], ['p'], ['addr'], ['i64'], ['s'], ['gdbserver_state'], ['gdb_current_syscall_cb'], ['RS_SYSCALL'], ['CONFIG_USER_ONLY'], ['vm_stop'], ['EXCP_DEBUG'], ['RS_IDLE'], ['va_start'], ['va_arg'], ['target_ulong'], ['TARGET_FMT_lx'], ['uint64_t'], ['PRIx64'], ['va_end'], ['put_packet'], ['gdb_handlesig'], ['cpu_interrupt'], ['CPU_INTERRUPT_EXIT']]"
"static void gen_cp0 (CPUState *env, DisasContext *ctx, uint32_t opc, int rt, int rd) { const char *opn = ""ldst""; switch (opc) { case OPC_MFC0: if (rt == 0) { /* Treat as NOP */ return; } gen_mfc0(ctx, rd, ctx->opcode & 0x7); gen_op_store_T0_gpr(rt); opn = ""mfc0""; break; case OPC_MTC0: GEN_LOAD_REG_TN(T0, rt); gen_mtc0(ctx, rd, ctx->opcode & 0x7); opn = ""mtc0""; break; #ifdef TARGET_MIPS64 case OPC_DMFC0: if (rt == 0) { /* Treat as NOP */ return; } gen_dmfc0(ctx, rd, ctx->opcode & 0x7); gen_op_store_T0_gpr(rt); opn = ""dmfc0""; break; case OPC_DMTC0: GEN_LOAD_REG_TN(T0, rt); gen_dmtc0(ctx, rd, ctx->opcode & 0x7); opn = ""dmtc0""; break; #endif case OPC_TLBWI: opn = ""tlbwi""; if (!env->do_tlbwi) goto die; gen_op_tlbwi(); break; case OPC_TLBWR: opn = ""tlbwr""; if (!env->do_tlbwr) goto die; gen_op_tlbwr(); break; case OPC_TLBP: opn = ""tlbp""; if (!env->do_tlbp) goto die; gen_op_tlbp(); break; case OPC_TLBR: opn = ""tlbr""; if (!env->do_tlbr) goto die; gen_op_tlbr(); break; case OPC_ERET: opn = ""eret""; save_cpu_state(ctx, 0); gen_op_eret(); ctx->bstate = BS_EXCP; break; case OPC_DERET: opn = ""deret""; if (!(ctx->hflags & MIPS_HFLAG_DM)) { MIPS_INVAL(opn); generate_exception(ctx, EXCP_RI); } else { save_cpu_state(ctx, 0); gen_op_deret(); ctx->bstate = BS_EXCP; } break; case OPC_WAIT: opn = ""wait""; /* If we get an exception, we want to restart at next instruction */ ctx->pc += 4; save_cpu_state(ctx, 1); ctx->pc -= 4; gen_op_wait(); ctx->bstate = BS_EXCP; break; default: die: MIPS_INVAL(opn); generate_exception(ctx, EXCP_RI); return; } MIPS_DEBUG(""%s %s %d"", opn, regnames[rt], rd); }","[['env'], ['ctx'], ['opc'], ['rt'], ['rd'], ['opn'], ['OPC_MFC0'], ['gen_mfc0'], ['gen_op_store_T0_gpr'], ['OPC_MTC0'], ['GEN_LOAD_REG_TN'], ['T0'], ['gen_mtc0'], ['TARGET_MIPS64'], ['OPC_DMFC0'], ['gen_dmfc0'], ['OPC_DMTC0'], ['gen_dmtc0'], ['OPC_TLBWI'], ['gen_op_tlbwi'], ['OPC_TLBWR'], ['gen_op_tlbwr'], ['OPC_TLBP'], ['gen_op_tlbp'], ['OPC_TLBR'], ['gen_op_tlbr'], ['OPC_ERET'], ['save_cpu_state'], ['gen_op_eret'], ['BS_EXCP'], ['OPC_DERET'], ['MIPS_HFLAG_DM'], ['MIPS_INVAL'], ['generate_exception'], ['EXCP_RI'], ['gen_op_deret'], ['OPC_WAIT'], ['gen_op_wait'], ['MIPS_DEBUG'], ['regnames']]"
"static void tricore_cpu_initfn(Object *obj) { CPUState *cs = CPU(obj); TriCoreCPU *cpu = TRICORE_CPU(obj); CPUTriCoreState *env = &cpu->env; cs->env_ptr = env; cpu_exec_init(cs, &error_abort); if (tcg_enabled()) { tricore_tcg_init(); } }","[['obj'], ['cs'], ['CPU'], ['cpu'], ['TRICORE_CPU'], ['env'], ['cpu_exec_init'], ['error_abort'], ['tcg_enabled'], ['tricore_tcg_init']]"
"static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag) { switch (tag) { case 0x1901: mxf->packages_count = get_be32(pb); if (mxf->packages_count >= UINT_MAX / sizeof(UID)) return -1; mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID)); if (!mxf->packages_refs) return -1; url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */ get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID)); break; } return 0; }","[['mxf'], ['pb'], ['tag'], ['get_be32'], ['UINT_MAX'], ['UID'], ['av_malloc'], ['url_fskip'], ['get_buffer']]"
"int av_reallocp_array(void *ptr, size_t nmemb, size_t size) { void **ptrptr = ptr; void *ret; if (size <= 0 || nmemb >= INT_MAX / size) return AVERROR(ENOMEM); if (nmemb <= 0) { av_freep(ptr); return 0; } ret = av_realloc(*ptrptr, nmemb * size); if (!ret) { av_freep(ptr); return AVERROR(ENOMEM); } *ptrptr = ret; return 0; }","[['ptr'], ['nmemb'], ['size'], ['ptrptr'], ['ret'], ['INT_MAX'], ['AVERROR'], ['ENOMEM'], ['av_freep'], ['av_realloc']]"
"void ff_put_h264_qpel16_mc31_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride) { avc_luma_hv_qrt_16w_msa(src - 2, src - (stride * 2) + sizeof(uint8_t), stride, dst, stride, 16); }","[['dst'], ['src'], ['stride'], ['avc_luma_hv_qrt_16w_msa']]"
"struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd, bool force) { return NULL; }","[['vhost_net_init'], ['VLANClientState'], ['backend'], ['devfd'], ['bool'], ['force']]"
"static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2, ptrdiff_t stride, int h) { const uint8_t *scantable = s->intra_scantable.permutated; LOCAL_ALIGNED_16(int16_t, temp, [64]); int i, last, run, bits, level, start_i; const int esc_length = s->ac_esc_length; uint8_t *length, *last_length; av_assert2(h == 8); s->pdsp.diff_pixels(temp, src1, src2, stride); s->block_last_index[0 /* FIXME */] = last = s->fast_dct_quantize(s, temp, 0 /* FIXME */, s->qscale, &i); bits = 0; if (s->mb_intra) { start_i = 1; length = s->intra_ac_vlc_length; last_length = s->intra_ac_vlc_last_length; bits += s->luma_dc_vlc_length[temp[0] + 256]; // FIXME: chroma } else { start_i = 0; length = s->inter_ac_vlc_length; last_length = s->inter_ac_vlc_last_length; } if (last >= start_i) { run = 0; for (i = start_i; i < last; i++) { int j = scantable[i]; level = temp[j]; if (level) { level += 64; if ((level & (~127)) == 0) bits += length[UNI_AC_ENC_INDEX(run, level)]; else bits += esc_length; run = 0; } else run++; } i = scantable[last]; level = temp[i] + 64; av_assert2(level - 64); if ((level & (~127)) == 0) bits += last_length[UNI_AC_ENC_INDEX(run, level)]; else bits += esc_length; } return bits; }","[['s'], ['src1'], ['src2'], ['stride'], ['h'], ['scantable'], ['LOCAL_ALIGNED_16'], ['int16_t'], ['temp'], ['i'], ['last'], ['run'], ['bits'], ['level'], ['start_i'], ['esc_length'], ['length'], ['last_length'], ['av_assert2']]"
"static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val) { fprintf(stderr, ""EHCI doesn't handle 16-bit writes to MMIO\n""); exit(1); }","[['ptr'], ['addr'], ['val']]"
"static void xendev_class_init(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICE_CLASS(klass); dc->props = xendev_properties; set_bit(DEVICE_CATEGORY_MISC, dc->categories); }","[['klass'], ['data'], ['dc'], ['DEVICE_CLASS'], ['xendev_properties'], ['set_bit'], ['DEVICE_CATEGORY_MISC']]"
static uint64_t qdev_get_prop_mask64(Property *prop) { assert(prop->info == &qdev_prop_bit); return 0x1 << prop->bitnr; },"[['prop'], ['assert'], ['qdev_prop_bit']]"
"static int create_ppc_opcodes (CPUPPCState *env, ppc_def_t *def) { opcode_t *opc, *start, *end; fill_new_table(env->opcodes, 0x40); #if defined(PPC_DUMP_CPU) printf(""* PowerPC instructions for PVR %08x: %s flags %016"" PRIx64 "" %08x\n"", def->pvr, def->name, def->insns_flags, def->flags); #endif if (&opc_start < &opc_end) { start = &opc_start; end = &opc_end; } else { start = &opc_end; end = &opc_start; } for (opc = start + 1; opc != end; opc++) { if ((opc->handler.type & def->insns_flags) != 0) { if (register_insn(env->opcodes, opc) < 0) { printf(""*** ERROR initializing PowerPC instruction "" ""0x%02x 0x%02x 0x%02x\n"", opc->opc1, opc->opc2, opc->opc3); return -1; } #if defined(PPC_DUMP_CPU) if (opc1 != 0x00) { if (opc->opc3 == 0xFF) { if (opc->opc2 == 0xFF) { printf("" %02x -- -- (%2d ----) : %s\n"", opc->opc1, opc->opc1, opc->oname); } else { printf("" %02x %02x -- (%2d %4d) : %s\n"", opc->opc1, opc->opc2, opc->opc1, opc->opc2, opc->oname); } } else { printf("" %02x %02x %02x (%2d %4d) : %s\n"", opc->opc1, opc->opc2, opc->opc3, opc->opc1, (opc->opc3 << 5) | opc->opc2, opc->oname); } } #endif } } fix_opcode_tables(env->opcodes); fflush(stdout); fflush(stderr); return 0; }","[['env'], ['def'], ['opc'], ['start'], ['end'], ['fill_new_table'], ['PPC_DUMP_CPU'], ['PRIx64']]"
"static void smp_parse(const char *optarg) { int smp, sockets = 0, threads = 0, cores = 0; char *endptr; char option[128]; smp = strtoul(optarg, &endptr, 10); if (endptr != optarg) { if (*endptr == ',') { endptr++; } } if (get_param_value(option, 128, ""sockets"", endptr) != 0) sockets = strtoull(option, NULL, 10); if (get_param_value(option, 128, ""cores"", endptr) != 0) cores = strtoull(option, NULL, 10); if (get_param_value(option, 128, ""threads"", endptr) != 0) threads = strtoull(option, NULL, 10); if (get_param_value(option, 128, ""maxcpus"", endptr) != 0) max_cpus = strtoull(option, NULL, 10); /* compute missing values, prefer sockets over cores over threads */ if (smp == 0 || sockets == 0) { sockets = sockets > 0 ? sockets : 1; cores = cores > 0 ? cores : 1; threads = threads > 0 ? threads : 1; if (smp == 0) { smp = cores * threads * sockets; } } else { if (cores == 0) { threads = threads > 0 ? threads : 1; cores = smp / (sockets * threads); } else { threads = smp / (cores * sockets); } } smp_cpus = smp; smp_cores = cores > 0 ? cores : 1; smp_threads = threads > 0 ? threads : 1; if (max_cpus == 0) max_cpus = smp_cpus; }","[['optarg'], ['smp'], ['sockets'], ['threads'], ['cores'], ['endptr'], ['option'], ['get_param_value'], ['max_cpus'], ['smp_cpus'], ['smp_cores'], ['smp_threads']]"
"static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx) { int i; float (*output)[256] = ctx->audio_block.block_output; for (i = 0; i < 256; i++) { output[1][i] -= output[3][i]; output[2][i] += output[3][i]; } memset(output[3], 0, sizeof(output[3])); }","[['ctx'], ['i'], ['output']]"
"static int config_props(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; AVFilterLink *inlink = outlink->src->inputs[0]; ScaleContext *scale = ctx->priv; int64_t w, h; if (!(w = scale->w)) w = inlink->w; if (!(h = scale->h)) h = inlink->h; if (w == -1) w = av_rescale(h, inlink->w, inlink->h); if (h == -1) h = av_rescale(w, inlink->h, inlink->w); if (w > INT_MAX || h > INT_MAX || (h * inlink->w) > INT_MAX || (w * inlink->h) > INT_MAX) av_log(ctx, AV_LOG_ERROR, ""Rescaled value for width or height is too big.\n""); outlink->w = w; outlink->h = h; /* TODO: make algorithm configurable */ scale->sws = sws_getContext(inlink ->w, inlink ->h, inlink ->format, outlink->w, outlink->h, outlink->format, SWS_BILINEAR, NULL, NULL, NULL); av_log(ctx, AV_LOG_INFO, ""w:%d h:%d fmt:%s\n"", outlink->w, outlink->h, av_pix_fmt_descriptors[outlink->format].name); scale->input_is_pal = inlink->format == PIX_FMT_PAL8 || inlink->format == PIX_FMT_BGR4_BYTE || inlink->format == PIX_FMT_RGB4_BYTE || inlink->format == PIX_FMT_BGR8 || inlink->format == PIX_FMT_RGB8; return !scale->sws; }","[['outlink'], ['ctx'], ['inlink'], ['scale'], ['w'], ['h'], ['av_rescale'], ['INT_MAX'], ['av_log'], ['AV_LOG_ERROR'], ['sws_getContext'], ['SWS_BILINEAR'], ['AV_LOG_INFO'], ['av_pix_fmt_descriptors'], ['PIX_FMT_PAL8'], ['PIX_FMT_BGR4_BYTE'], ['PIX_FMT_RGB4_BYTE'], ['PIX_FMT_BGR8'], ['PIX_FMT_RGB8']]"
"static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr, unsigned size) { struct omap_pwt_s *s = (struct omap_pwt_s *) opaque; int offset = addr & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_read8(opaque, addr); } switch (offset) { case 0x00: /* FRC */ return s->frc; case 0x04: /* VCR */ return s->vrc; case 0x08: /* GCR */ return s->gcr; } OMAP_BAD_REG(addr); return 0; }","[['opaque'], ['addr'], ['size'], ['s'], ['offset'], ['OMAP_MPUI_REG_MASK'], ['omap_badwidth_read8'], ['OMAP_BAD_REG']]"
"uint32_t lduw_be_phys(target_phys_addr_t addr) { return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN); }","[['addr'], ['lduw_phys_internal'], ['DEVICE_BIG_ENDIAN']]"
static int find_stream_index(AVFormatContext *s) { int i; AVStream *st; if (s->nb_streams <= 0) return -1; for(i = 0; i < s->nb_streams; i++) { st = s->streams[i]; if (st->codec.codec_type == CODEC_TYPE_VIDEO) { return i; } } return 0; },"[['s'], ['i'], ['st'], ['CODEC_TYPE_VIDEO']]"
"gen_intermediate_code_internal(MIPSCPU *cpu, TranslationBlock *tb, bool search_pc) { CPUState *cs = CPU(cpu); CPUMIPSState *env = &cpu->env; DisasContext ctx; target_ulong pc_start; uint16_t *gen_opc_end; CPUBreakpoint *bp; int j, lj = -1; int num_insns; int max_insns; int insn_bytes; int is_branch; if (search_pc) qemu_log(""search pc %d\n"", search_pc); pc_start = tb->pc; gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE; ctx.pc = pc_start; ctx.saved_pc = -1; ctx.singlestep_enabled = cs->singlestep_enabled; ctx.insn_flags = env->insn_flags; ctx.tb = tb; ctx.bstate = BS_NONE; /* Restore delay slot state from the tb context. */ ctx.hflags = (uint32_t)tb->flags; /* FIXME: maybe use 64 bits here? */ restore_cpu_state(env, &ctx); #ifdef CONFIG_USER_ONLY ctx.mem_idx = MIPS_HFLAG_UM; #else ctx.mem_idx = ctx.hflags & MIPS_HFLAG_KSU; #endif num_insns = 0; max_insns = tb->cflags & CF_COUNT_MASK; if (max_insns == 0) max_insns = CF_COUNT_MASK; LOG_DISAS(""\ntb %p idx %d hflags %04x\n"", tb, ctx.mem_idx, ctx.hflags); gen_tb_start(); while (ctx.bstate == BS_NONE) { if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) { QTAILQ_FOREACH(bp, &env->breakpoints, entry) { if (bp->pc == ctx.pc) { save_cpu_state(&ctx, 1); ctx.bstate = BS_BRANCH; gen_helper_0e0i(raise_exception, EXCP_DEBUG); /* Include the breakpoint location or the tb won't * be flushed when it must be. */ ctx.pc += 4; goto done_generating; } } } if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; if (lj < j) { lj++; while (lj < j) tcg_ctx.gen_opc_instr_start[lj++] = 0; } tcg_ctx.gen_opc_pc[lj] = ctx.pc; gen_opc_hflags[lj] = ctx.hflags & MIPS_HFLAG_BMASK; gen_opc_btarget[lj] = ctx.btarget; tcg_ctx.gen_opc_instr_start[lj] = 1; tcg_ctx.gen_opc_icount[lj] = num_insns; } if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) gen_io_start(); is_branch = 0; if (!(ctx.hflags & MIPS_HFLAG_M16)) { ctx.opcode = cpu_ldl_code(env, ctx.pc); insn_bytes = 4; decode_opc(env, &ctx, &is_branch); } else if (ctx.insn_flags & ASE_MICROMIPS) { ctx.opcode = cpu_lduw_code(env, ctx.pc); insn_bytes = decode_micromips_opc(env, &ctx, &is_branch); } else if (ctx.insn_flags & ASE_MIPS16) { ctx.opcode = cpu_lduw_code(env, ctx.pc); insn_bytes = decode_mips16_opc(env, &ctx, &is_branch); } else { generate_exception(&ctx, EXCP_RI); ctx.bstate = BS_STOP; break; } if (!is_branch) { handle_delay_slot(&ctx, insn_bytes); } ctx.pc += insn_bytes; num_insns++; /* Execute a branch and its delay slot as a single instruction. This is what GDB expects and is consistent with what the hardware does (e.g. if a delay slot instruction faults, the reported PC is the PC of the branch). */ if (cs->singlestep_enabled && (ctx.hflags & MIPS_HFLAG_BMASK) == 0) { break; } if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) break; if (tcg_ctx.gen_opc_ptr >= gen_opc_end) { break; } if (num_insns >= max_insns) break; if (singlestep) break; } if (tb->cflags & CF_LAST_IO) { gen_io_end(); } if (cs->singlestep_enabled && ctx.bstate != BS_BRANCH) { save_cpu_state(&ctx, ctx.bstate == BS_NONE); gen_helper_0e0i(raise_exception, EXCP_DEBUG); } else { switch (ctx.bstate) { case BS_STOP: gen_goto_tb(&ctx, 0, ctx.pc); break; case BS_NONE: save_cpu_state(&ctx, 0); gen_goto_tb(&ctx, 0, ctx.pc); break; case BS_EXCP: tcg_gen_exit_tb(0); break; case BS_BRANCH: default: break; } } done_generating: gen_tb_end(tb, num_insns); *tcg_ctx.gen_opc_ptr = INDEX_op_end; if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; lj++; while (lj <= j) tcg_ctx.gen_opc_instr_start[lj++] = 0; } else { tb->size = ctx.pc - pc_start; tb->icount = num_insns; } #ifdef DEBUG_DISAS LOG_DISAS(""\n""); if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log(""IN: %s\n"", lookup_symbol(pc_start)); log_target_disas(env, pc_start, ctx.pc - pc_start, 0); qemu_log(""\n""); } #endif }","[['gen_intermediate_code_internal'], ['MIPSCPU'], ['cpu'], ['TranslationBlock'], ['tb'], ['bool'], ['search_pc'], ['cs'], ['CPU'], ['env'], ['ctx'], ['pc_start'], ['gen_opc_end'], ['bp'], ['j'], ['lj'], ['num_insns'], ['max_insns'], ['insn_bytes'], ['is_branch'], ['qemu_log'], ['tcg_ctx'], ['OPC_MAX_SIZE'], ['BS_NONE'], ['restore_cpu_state'], ['CONFIG_USER_ONLY'], ['MIPS_HFLAG_UM'], ['MIPS_HFLAG_KSU'], ['CF_COUNT_MASK'], ['LOG_DISAS'], ['gen_tb_start'], ['unlikely'], ['QTAILQ_EMPTY'], ['QTAILQ_FOREACH'], ['entry'], ['save_cpu_state'], ['BS_BRANCH'], ['gen_helper_0e0i'], ['raise_exception'], ['EXCP_DEBUG'], ['gen_opc_hflags'], ['MIPS_HFLAG_BMASK'], ['gen_opc_btarget'], ['CF_LAST_IO'], ['gen_io_start'], ['MIPS_HFLAG_M16'], ['cpu_ldl_code'], ['decode_opc'], ['ASE_MICROMIPS'], ['cpu_lduw_code'], ['decode_micromips_opc'], ['ASE_MIPS16'], ['decode_mips16_opc'], ['generate_exception'], ['EXCP_RI'], ['BS_STOP'], ['handle_delay_slot'], ['TARGET_PAGE_SIZE'], ['singlestep'], ['gen_io_end'], ['gen_goto_tb'], ['BS_EXCP'], ['tcg_gen_exit_tb'], ['gen_tb_end'], ['gen_opc_ptr'], ['INDEX_op_end'], ['DEBUG_DISAS'], ['qemu_loglevel_mask'], ['CPU_LOG_TB_IN_ASM'], ['lookup_symbol'], ['log_target_disas']]"
"static void parse_type_bool(Visitor *v, const char *name, bool *obj, Error **errp) { StringInputVisitor *siv = to_siv(v); if (siv->string) { if (!strcasecmp(siv->string, ""on"") || !strcasecmp(siv->string, ""yes"") || !strcasecmp(siv->string, ""true"")) { *obj = true; return; } if (!strcasecmp(siv->string, ""off"") || !strcasecmp(siv->string, ""no"") || !strcasecmp(siv->string, ""false"")) { *obj = false; return; } } error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"", ""boolean""); }","[['v'], ['name'], ['obj'], ['errp'], ['siv'], ['to_siv'], ['strcasecmp'], ['error_setg'], ['QERR_INVALID_PARAMETER_TYPE']]"
"void ff_rtsp_undo_setup(AVFormatContext *s) { RTSPState *rt = s->priv_data; int i; for (i = 0; i < rt->nb_rtsp_streams; i++) { RTSPStream *rtsp_st = rt->rtsp_streams[i]; if (!rtsp_st) continue; if (rtsp_st->transport_priv) { if (s->oformat) { AVFormatContext *rtpctx = rtsp_st->transport_priv; av_write_trailer(rtpctx); if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) { uint8_t *ptr; url_close_dyn_buf(rtpctx->pb, &ptr); av_free(ptr); } else { url_fclose(rtpctx->pb); } av_metadata_free(&rtpctx->streams[0]->metadata); av_metadata_free(&rtpctx->metadata); av_free(rtpctx->streams[0]); av_free(rtpctx); } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st->transport_priv); else if (CONFIG_RTPDEC) rtp_parse_close(rtsp_st->transport_priv); } rtsp_st->transport_priv = NULL; if (rtsp_st->rtp_handle) url_close(rtsp_st->rtp_handle); rtsp_st->rtp_handle = NULL; } }","[['s'], ['rt'], ['i'], ['rtsp_st'], ['rtpctx'], ['av_write_trailer'], ['RTSP_LOWER_TRANSPORT_TCP'], ['ptr'], ['url_close_dyn_buf'], ['av_free'], ['url_fclose'], ['av_metadata_free'], ['RTSP_TRANSPORT_RDT'], ['CONFIG_RTPDEC'], ['ff_rdt_parse_close'], ['rtp_parse_close'], ['url_close']]"
"static void musb_rx_req(MUSBState *s, int epnum) { MUSBEndPoint *ep = s->ep + epnum; int total; /* If we already have a packet, which didn't fit into the * 64 bytes of the FIFO, only move the FIFO start and return. (Obsolete) */ if (ep->packey[1].p.pid == USB_TOKEN_IN && ep->status[1] >= 0 && (ep->fifostart[1]) + ep->rxcount < ep->packey[1].p.len) { TRACE(""0x%08x, %d"", ep->fifostart[1], ep->rxcount ); ep->fifostart[1] += ep->rxcount; ep->fifolen[1] = 0; ep->rxcount = MIN(ep->packey[0].p.len - (ep->fifostart[1]), ep->maxp[1]); ep->csr[1] &= ~MGC_M_RXCSR_H_REQPKT; if (!epnum) ep->csr[0] &= ~MGC_M_CSR0_H_REQPKT; /* Clear all of the error bits first */ ep->csr[1] &= ~(MGC_M_RXCSR_H_ERROR | MGC_M_RXCSR_H_RXSTALL | MGC_M_RXCSR_DATAERROR); if (!epnum) ep->csr[0] &= ~(MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL | MGC_M_CSR0_H_NAKTIMEOUT | MGC_M_CSR0_H_NO_PING); ep->csr[1] |= MGC_M_RXCSR_FIFOFULL | MGC_M_RXCSR_RXPKTRDY; if (!epnum) ep->csr[0] |= MGC_M_CSR0_RXPKTRDY; musb_rx_intr_set(s, epnum, 1); return; } /* The driver sets maxp[1] to 64 or less because it knows the hardware * FIFO is this deep. Bigger packets get split in * usb_generic_handle_packet but we can also do the splitting locally * for performance. It turns out we can also have a bigger FIFO and * ignore the limit set in ep->maxp[1]. The Linux MUSB driver deals * OK with single packets of even 32KB and we avoid splitting, however * usb_msd.c sometimes sends a packet bigger than what Linux expects * (e.g. 8192 bytes instead of 4096) and we get an OVERRUN. Splitting * hides this overrun from Linux. Up to 4096 everything is fine * though. Currently this is disabled. * * XXX: mind ep->fifosize. */ total = MIN(ep->maxp[1] & 0x3ff, sizeof(s->buf)); #ifdef SETUPLEN_HACK /* Why should *we* do that instead of Linux? */ if (!epnum) { if (ep->packey[0].p.devaddr == 2) { total = MIN(s->setup_len, 8); } else { total = MIN(s->setup_len, 64); } s->setup_len -= total; } #endif return musb_packet(s, ep, epnum, USB_TOKEN_IN, total, musb_rx_packet_complete, 1); }","[['s'], ['epnum'], ['ep'], ['total'], ['USB_TOKEN_IN'], ['TRACE'], ['MIN'], ['MGC_M_RXCSR_H_REQPKT'], ['MGC_M_CSR0_H_REQPKT'], ['MGC_M_RXCSR_H_ERROR'], ['MGC_M_RXCSR_H_RXSTALL'], ['MGC_M_RXCSR_DATAERROR'], ['MGC_M_CSR0_H_ERROR'], ['MGC_M_CSR0_H_RXSTALL'], ['MGC_M_CSR0_H_NAKTIMEOUT'], ['MGC_M_CSR0_H_NO_PING'], ['MGC_M_RXCSR_FIFOFULL'], ['MGC_M_RXCSR_RXPKTRDY'], ['MGC_M_CSR0_RXPKTRDY'], ['musb_rx_intr_set'], ['SETUPLEN_HACK'], ['musb_packet'], ['musb_rx_packet_complete']]"
"static uint64_t sp804_read(void *opaque, target_phys_addr_t offset, unsigned size) { sp804_state *s = (sp804_state *)opaque; if (offset < 0x20) { return arm_timer_read(s->timer[0], offset); } if (offset < 0x40) { return arm_timer_read(s->timer[1], offset - 0x20); } /* TimerPeriphID */ if (offset >= 0xfe0 && offset <= 0xffc) { return sp804_ids[(offset - 0xfe0) >> 2]; } switch (offset) { /* Integration Test control registers, which we won't support */ case 0xf00: /* TimerITCR */ case 0xf04: /* TimerITOP (strictly write only but..) */ return 0; } hw_error(""%s: Bad offset %x\n"", __func__, (int)offset); return 0; }","[['opaque'], ['offset'], ['size'], ['s'], ['arm_timer_read'], ['sp804_ids'], ['hw_error']]"
static void timerlist_rearm(QEMUTimerList *timer_list) { /* Interrupt execution to force deadline recalculation. */ if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) { qemu_start_warp_timer(); } timerlist_notify(timer_list); },"[['timer_list'], ['QEMU_CLOCK_VIRTUAL'], ['qemu_start_warp_timer'], ['timerlist_notify']]"
"CharDriverState *text_console_init(DisplayState *ds, const char *p) { CharDriverState *chr; TextConsole *s; unsigned width; unsigned height; static int color_inited; chr = qemu_mallocz(sizeof(CharDriverState)); if (!chr) return NULL; s = new_console(ds, TEXT_CONSOLE); if (!s) { free(chr); return NULL; } if (!p) p = DEFAULT_MONITOR_SIZE; chr->opaque = s; chr->chr_write = console_puts; chr->chr_send_event = console_send_event; s->chr = chr; s->out_fifo.buf = s->out_fifo_buf; s->out_fifo.buf_size = sizeof(s->out_fifo_buf); s->kbd_timer = qemu_new_timer(rt_clock, kbd_send_chars, s); if (!color_inited) { color_inited = 1; console_color_init(s->ds); } s->y_displayed = 0; s->y_base = 0; s->total_height = DEFAULT_BACKSCROLL; s->x = 0; s->y = 0; width = s->ds->width; height = s->ds->height; if (p != 0) { width = strtoul(p, (char **)&p, 10); if (*p == 'C') { p++; width *= FONT_WIDTH; } if (*p == 'x') { p++; height = strtoul(p, (char **)&p, 10); if (*p == 'C') { p++; height *= FONT_HEIGHT; } } } s->g_width = width; s->g_height = height; s->hw_invalidate = text_console_invalidate; s->hw_text_update = text_console_update; s->hw = s; /* Set text attribute defaults */ s->t_attrib_default.bold = 0; s->t_attrib_default.uline = 0; s->t_attrib_default.blink = 0; s->t_attrib_default.invers = 0; s->t_attrib_default.unvisible = 0; s->t_attrib_default.fgcol = COLOR_WHITE; s->t_attrib_default.bgcol = COLOR_BLACK; /* set current text attributes to default */ s->t_attrib = s->t_attrib_default; text_console_resize(s); qemu_chr_reset(chr); return chr; }","[['text_console_init'], ['DisplayState'], ['ds'], ['p'], ['chr'], ['s'], ['height'], ['color_inited'], ['qemu_mallocz'], ['CharDriverState'], ['new_console'], ['TEXT_CONSOLE'], ['DEFAULT_MONITOR_SIZE'], ['console_puts'], ['console_send_event'], ['qemu_new_timer'], ['rt_clock'], ['kbd_send_chars'], ['console_color_init'], ['DEFAULT_BACKSCROLL'], ['FONT_WIDTH'], ['FONT_HEIGHT'], ['text_console_invalidate'], ['text_console_update'], ['COLOR_WHITE'], ['COLOR_BLACK'], ['text_console_resize'], ['qemu_chr_reset']]"
"static void tcg_liveness_analysis(TCGContext *s) { uint8_t *dead_temps, *mem_temps; int oi, oi_prev, nb_ops; nb_ops = s->gen_next_op_idx; s->op_dead_args = tcg_malloc(nb_ops * sizeof(uint16_t)); s->op_sync_args = tcg_malloc(nb_ops * sizeof(uint8_t)); dead_temps = tcg_malloc(s->nb_temps); mem_temps = tcg_malloc(s->nb_temps); tcg_la_func_end(s, dead_temps, mem_temps); for (oi = s->gen_last_op_idx; oi >= 0; oi = oi_prev) { int i, nb_iargs, nb_oargs; TCGOpcode opc_new, opc_new2; bool have_opc_new2; uint16_t dead_args; uint8_t sync_args; TCGArg arg; TCGOp * const op = &s->gen_op_buf[oi]; TCGArg * const args = &s->gen_opparam_buf[op->args]; TCGOpcode opc = op->opc; const TCGOpDef *def = &tcg_op_defs[opc]; oi_prev = op->prev; switch (opc) { case INDEX_op_call: { int call_flags; nb_oargs = op->callo; nb_iargs = op->calli; call_flags = args[nb_oargs + nb_iargs + 1]; /* pure functions can be removed if their result is unused */ if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) { for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (!dead_temps[arg] || mem_temps[arg]) { goto do_not_remove_call; } } goto do_remove; } else { do_not_remove_call: /* output args are dead */ dead_args = 0; sync_args = 0; for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (dead_temps[arg]) { dead_args |= (1 << i); } if (mem_temps[arg]) { sync_args |= (1 << i); } dead_temps[arg] = 1; mem_temps[arg] = 0; } if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) { /* globals should be synced to memory */ memset(mem_temps, 1, s->nb_globals); } if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS | TCG_CALL_NO_READ_GLOBALS))) { /* globals should go back to memory */ memset(dead_temps, 1, s->nb_globals); } /* input args are live */ for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) { arg = args[i]; if (arg != TCG_CALL_DUMMY_ARG) { if (dead_temps[arg]) { dead_args |= (1 << i); } dead_temps[arg] = 0; } } s->op_dead_args[oi] = dead_args; s->op_sync_args[oi] = sync_args; } } break; case INDEX_op_debug_insn_start: break; case INDEX_op_discard: /* mark the temporary as dead */ dead_temps[args[0]] = 1; mem_temps[args[0]] = 0; break; case INDEX_op_add2_i32: opc_new = INDEX_op_add_i32; goto do_addsub2; case INDEX_op_sub2_i32: opc_new = INDEX_op_sub_i32; goto do_addsub2; case INDEX_op_add2_i64: opc_new = INDEX_op_add_i64; goto do_addsub2; case INDEX_op_sub2_i64: opc_new = INDEX_op_sub_i64; do_addsub2: nb_iargs = 4; nb_oargs = 2; /* Test if the high part of the operation is dead, but not the low part. The result can be optimized to a simple add or sub. This happens often for x86_64 guest when the cpu mode is set to 32 bit. */ if (dead_temps[args[1]] && !mem_temps[args[1]]) { if (dead_temps[args[0]] && !mem_temps[args[0]]) { goto do_remove; } /* Replace the opcode and adjust the args in place, leaving 3 unused args at the end. */ op->opc = opc = opc_new; args[1] = args[2]; args[2] = args[4]; /* Fall through and mark the single-word operation live. */ nb_iargs = 2; nb_oargs = 1; } goto do_not_remove; case INDEX_op_mulu2_i32: opc_new = INDEX_op_mul_i32; opc_new2 = INDEX_op_muluh_i32; have_opc_new2 = TCG_TARGET_HAS_muluh_i32; goto do_mul2; case INDEX_op_muls2_i32: opc_new = INDEX_op_mul_i32; opc_new2 = INDEX_op_mulsh_i32; have_opc_new2 = TCG_TARGET_HAS_mulsh_i32; goto do_mul2; case INDEX_op_mulu2_i64: opc_new = INDEX_op_mul_i64; opc_new2 = INDEX_op_muluh_i64; have_opc_new2 = TCG_TARGET_HAS_muluh_i64; goto do_mul2; case INDEX_op_muls2_i64: opc_new = INDEX_op_mul_i64; opc_new2 = INDEX_op_mulsh_i64; have_opc_new2 = TCG_TARGET_HAS_mulsh_i64; goto do_mul2; do_mul2: nb_iargs = 2; nb_oargs = 2; if (dead_temps[args[1]] && !mem_temps[args[1]]) { if (dead_temps[args[0]] && !mem_temps[args[0]]) { /* Both parts of the operation are dead. */ goto do_remove; } /* The high part of the operation is dead; generate the low. */ op->opc = opc = opc_new; args[1] = args[2]; args[2] = args[3]; } else if (have_opc_new2 && dead_temps[args[0]] && !mem_temps[args[0]]) { /* The low part of the operation is dead; generate the high. */ op->opc = opc = opc_new2; args[0] = args[1]; args[1] = args[2]; args[2] = args[3]; } else { goto do_not_remove; } /* Mark the single-word operation live. */ nb_oargs = 1; goto do_not_remove; default: /* XXX: optimize by hardcoding common cases (e.g. triadic ops) */ nb_iargs = def->nb_iargs; nb_oargs = def->nb_oargs; /* Test if the operation can be removed because all its outputs are dead. We assume that nb_oargs == 0 implies side effects */ if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) { for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (!dead_temps[arg] || mem_temps[arg]) { goto do_not_remove; } } do_remove: tcg_op_remove(s, op); } else { do_not_remove: /* output args are dead */ dead_args = 0; sync_args = 0; for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (dead_temps[arg]) { dead_args |= (1 << i); } if (mem_temps[arg]) { sync_args |= (1 << i); } dead_temps[arg] = 1; mem_temps[arg] = 0; } /* if end of basic block, update */ if (def->flags & TCG_OPF_BB_END) { tcg_la_bb_end(s, dead_temps, mem_temps); } else if (def->flags & TCG_OPF_SIDE_EFFECTS) { /* globals should be synced to memory */ memset(mem_temps, 1, s->nb_globals); } /* input args are live */ for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) { arg = args[i]; if (dead_temps[arg]) { dead_args |= (1 << i); } dead_temps[arg] = 0; } s->op_dead_args[oi] = dead_args; s->op_sync_args[oi] = sync_args; } break; } } }","[['s'], ['dead_temps'], ['mem_temps'], ['oi'], ['oi_prev'], ['nb_ops'], ['tcg_malloc'], ['tcg_la_func_end'], ['i'], ['nb_iargs'], ['nb_oargs'], ['opc_new'], ['opc_new2'], ['have_opc_new2'], ['dead_args'], ['sync_args'], ['arg'], ['op'], ['args'], ['opc'], ['def'], ['tcg_op_defs'], ['INDEX_op_call'], ['call_flags'], ['TCG_CALL_NO_SIDE_EFFECTS'], ['TCG_CALL_NO_READ_GLOBALS'], ['TCG_CALL_NO_WRITE_GLOBALS'], ['TCG_CALL_DUMMY_ARG'], ['INDEX_op_debug_insn_start'], ['INDEX_op_discard'], ['INDEX_op_add2_i32'], ['INDEX_op_add_i32'], ['INDEX_op_sub2_i32'], ['INDEX_op_sub_i32'], ['INDEX_op_add2_i64'], ['INDEX_op_add_i64'], ['INDEX_op_sub2_i64'], ['INDEX_op_sub_i64'], ['INDEX_op_mulu2_i32'], ['INDEX_op_mul_i32'], ['INDEX_op_muluh_i32'], ['TCG_TARGET_HAS_muluh_i32'], ['INDEX_op_muls2_i32'], ['INDEX_op_mulsh_i32'], ['TCG_TARGET_HAS_mulsh_i32'], ['INDEX_op_mulu2_i64'], ['INDEX_op_mul_i64'], ['INDEX_op_muluh_i64'], ['TCG_TARGET_HAS_muluh_i64'], ['INDEX_op_muls2_i64'], ['INDEX_op_mulsh_i64'], ['TCG_TARGET_HAS_mulsh_i64'], ['TCG_OPF_SIDE_EFFECTS'], ['tcg_op_remove'], ['TCG_OPF_BB_END'], ['tcg_la_bb_end']]"
"bool error_is_type(Error *err, const char *fmt) { const char *error_class; char *ptr; char *end; if (!err) { return false; } ptr = strstr(fmt, ""'class': '""); assert(ptr != NULL); ptr += strlen(""'class': '""); end = strchr(ptr, '\''); assert(end != NULL); error_class = error_get_field(err, ""class""); if (strlen(error_class) != end - ptr) { return false; } return strncmp(ptr, error_class, end - ptr) == 0; }","[['err'], ['fmt'], ['error_class'], ['ptr'], ['end'], ['assert'], ['error_get_field']]"
"static inline int onenand_load_main(OneNANDState *s, int sec, int secn, void *dest) { if (s->bdrv_cur) return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0; else if (sec + secn > s->secs_cur) return 1; memcpy(dest, s->current + (sec << 9), secn << 9); return 0; }","[['s'], ['sec'], ['secn'], ['dest'], ['bdrv_read']]"
"static void generate_offset_lut(DiracGolombLUT *lut, int off) { int idx; for (idx = 0; idx < LUT_SIZE; idx++) { DiracGolombLUT *l = &lut[idx]; INIT_RESIDUE(res); SET_RESIDUE(res, idx, LUT_BITS); l->preamble = CONVERT_TO_RESIDUE(res >> (RSIZE_BITS - off), off); l->preamble_bits = off; l->sign = ((l->preamble >> (RSIZE_BITS - l->preamble_bits)) & 1) ? -1 : +1; search_for_golomb(l, res << off, LUT_BITS - off); } }","[['lut'], ['off'], ['idx'], ['LUT_SIZE'], ['l'], ['INIT_RESIDUE'], ['res'], ['SET_RESIDUE'], ['LUT_BITS'], ['CONVERT_TO_RESIDUE'], ['RSIZE_BITS'], ['search_for_golomb']]"
"vmxnet3_pop_next_tx_descr(VMXNET3State *s, int qidx, struct Vmxnet3_TxDesc *txd, uint32_t *descr_idx) { Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring; PCIDevice *d = PCI_DEVICE(s); vmxnet3_ring_read_curr_cell(d, ring, txd); if (txd->gen == vmxnet3_ring_curr_gen(ring)) { /* Only read after generation field verification */ smp_rmb(); /* Re-read to be sure we got the latest version */ vmxnet3_ring_read_curr_cell(d, ring, txd); VMXNET3_RING_DUMP(VMW_RIPRN, ""TX"", qidx, ring); *descr_idx = vmxnet3_ring_curr_cell_idx(ring); vmxnet3_inc_tx_consumption_counter(s, qidx); return true; } return false; }","[['vmxnet3_pop_next_tx_descr'], ['VMXNET3State'], ['s'], ['qidx'], ['Vmxnet3_TxDesc'], ['txd'], ['uint32_t'], ['descr_idx'], ['ring'], ['d'], ['PCI_DEVICE'], ['vmxnet3_ring_read_curr_cell'], ['vmxnet3_ring_curr_gen'], ['smp_rmb'], ['VMXNET3_RING_DUMP'], ['VMW_RIPRN'], ['vmxnet3_ring_curr_cell_idx'], ['vmxnet3_inc_tx_consumption_counter']]"
static void init_excp_BookE (CPUPPCState *env) { #if !defined(CONFIG_USER_ONLY) env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000; env->excp_vectors[POWERPC_EXCP_MCHECK] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DSI] = 0x00000000; env->excp_vectors[POWERPC_EXCP_ISI] = 0x00000000; env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000; env->excp_vectors[POWERPC_EXCP_ALIGN] = 0x00000000; env->excp_vectors[POWERPC_EXCP_PROGRAM] = 0x00000000; env->excp_vectors[POWERPC_EXCP_FPU] = 0x00000000; env->excp_vectors[POWERPC_EXCP_SYSCALL] = 0x00000000; env->excp_vectors[POWERPC_EXCP_APU] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DECR] = 0x00000000; env->excp_vectors[POWERPC_EXCP_FIT] = 0x00000000; env->excp_vectors[POWERPC_EXCP_WDT] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DTLB] = 0x00000000; env->excp_vectors[POWERPC_EXCP_ITLB] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DEBUG] = 0x00000000; env->excp_prefix = 0x00000000; env->ivor_mask = 0x0000FFE0; env->ivpr_mask = 0xFFFF0000; /* Hardware reset vector */ env->hreset_vector = 0xFFFFFFFCUL; #endif },"[['init_excp_BookE'], ['CPUPPCState'], ['env']]"
"DISAS_INSN(divw) { TCGv reg; TCGv tmp; TCGv src; int sign; sign = (insn & 0x100) != 0; reg = DREG(insn, 9); if (sign) { tcg_gen_ext16s_i32(QREG_DIV1, reg); } else { tcg_gen_ext16u_i32(QREG_DIV1, reg); } SRC_EA(env, src, OS_WORD, sign, NULL); tcg_gen_mov_i32(QREG_DIV2, src); if (sign) { gen_helper_divs(cpu_env, tcg_const_i32(1)); } else { gen_helper_divu(cpu_env, tcg_const_i32(1)); } tmp = tcg_temp_new(); src = tcg_temp_new(); tcg_gen_ext16u_i32(tmp, QREG_DIV1); tcg_gen_shli_i32(src, QREG_DIV2, 16); tcg_gen_or_i32(reg, tmp, src); set_cc_op(s, CC_OP_FLAGS); }","[['divw'], ['reg'], ['tmp'], ['src'], ['sign'], ['insn'], ['DREG'], ['tcg_gen_ext16s_i32'], ['QREG_DIV1'], ['tcg_gen_ext16u_i32'], ['SRC_EA'], ['env'], ['OS_WORD'], ['tcg_gen_mov_i32'], ['QREG_DIV2'], ['gen_helper_divs'], ['cpu_env'], ['tcg_const_i32'], ['gen_helper_divu'], ['tcg_temp_new'], ['tcg_gen_shli_i32'], ['tcg_gen_or_i32'], ['set_cc_op'], ['s'], ['CC_OP_FLAGS']]"
"static int msrle_decode_8_16_24_32(AVCodecContext *avctx, AVPicture *pic, int depth, const uint8_t *data, int srcsize) { uint8_t *output, *output_end; const uint8_t* src = data; int p1, p2, line=avctx->height, pos=0, i; uint16_t pix16; uint32_t pix32; output = pic->data[0] + (avctx->height - 1) * pic->linesize[0]; output_end = pic->data[0] + (avctx->height) * pic->linesize[0]; while(src < data + srcsize) { p1 = *src++; if(p1 == 0) { //Escape code p2 = *src++; if(p2 == 0) { //End-of-line output = pic->data[0] + (--line) * pic->linesize[0]; if (line < 0){ av_log(avctx, AV_LOG_ERROR, ""Next line is beyond picture bounds\n""); return -1; } pos = 0; continue; } else if(p2 == 1) { //End-of-picture return 0; } else if(p2 == 2) { //Skip p1 = *src++; p2 = *src++; line -= p2; if (line < 0){ av_log(avctx, AV_LOG_ERROR, ""Skip beyond picture bounds\n""); return -1; } pos += p1; output = pic->data[0] + line * pic->linesize[0] + pos * (depth >> 3); continue; } // Copy data if (output + p2 * (depth >> 3) > output_end) { src += p2 * (depth >> 3); continue; } if ((depth == 8) || (depth == 24)) { for(i = 0; i < p2 * (depth >> 3); i++) { *output++ = *src++; } // RLE8 copy is actually padded - and runs are not! if(depth == 8 && (p2 & 1)) { src++; } } else if (depth == 16) { for(i = 0; i < p2; i++) { pix16 = AV_RL16(src); src += 2; *(uint16_t*)output = pix16; output += 2; } } else if (depth == 32) { for(i = 0; i < p2; i++) { pix32 = AV_RL32(src); src += 4; *(uint32_t*)output = pix32; output += 4; } } pos += p2; } else { //Run of pixels uint8_t pix[3]; //original pixel switch(depth){ case 8: pix[0] = *src++; break; case 16: pix16 = AV_RL16(src); src += 2; break; case 24: pix[0] = *src++; pix[1] = *src++; pix[2] = *src++; break; case 32: pix32 = AV_RL32(src); src += 4; break; } if (output + p1 * (depth >> 3) > output_end) continue; for(i = 0; i < p1; i++) { switch(depth){ case 8: *output++ = pix[0]; break; case 16: *(uint16_t*)output = pix16; output += 2; break; case 24: *output++ = pix[0]; *output++ = pix[1]; *output++ = pix[2]; break; case 32: *(uint32_t*)output = pix32; output += 4; break; } } pos += p1; } } av_log(avctx, AV_LOG_WARNING, ""MS RLE warning: no End-of-picture code\n""); return 0; }","[['avctx'], ['pic'], ['depth'], ['data'], ['srcsize'], ['output'], ['output_end'], ['src'], ['p1'], ['p2'], ['line'], ['pos'], ['i'], ['pix16'], ['pix32']]"
"static void RENAME(vertical_compose53iL0)(uint8_t *_b0, uint8_t *_b1, uint8_t *_b2, int width) { int i; TYPE *b0 = (TYPE *)_b0; TYPE *b1 = (TYPE *)_b1; TYPE *b2 = (TYPE *)_b2; for (i = 0; i < width; i++) b1[i] -= (b0[i] + b2[i] + 2) >> 2; }",[]
"static void handle_user_command(Monitor *mon, const char *cmdline) { QDict *qdict; const mon_cmd_t *cmd; qdict = qdict_new(); cmd = monitor_parse_command(mon, cmdline, 0, mon->cmd_table, qdict); if (!cmd) goto out; if (handler_is_async(cmd)) { user_async_cmd_handler(mon, cmd, qdict); } else if (handler_is_qobject(cmd)) { QObject *data = NULL; /* XXX: ignores the error code */ cmd->mhandler.cmd_new(mon, qdict, &data); assert(!monitor_has_error(mon)); if (data) { cmd->user_print(mon, data); qobject_decref(data); } } else { cmd->mhandler.cmd(mon, qdict); } out: QDECREF(qdict); }","[['mon'], ['cmdline'], ['qdict'], ['cmd'], ['qdict_new'], ['monitor_parse_command'], ['handler_is_async'], ['user_async_cmd_handler'], ['handler_is_qobject'], ['data'], ['assert'], ['monitor_has_error'], ['qobject_decref'], ['QDECREF']]"
"static void gen_exception_return(DisasContext *s, TCGv pc) { TCGv tmp; store_reg(s, 15, pc); tmp = load_cpu_field(spsr); gen_set_cpsr(tmp, 0xffffffff); dead_tmp(tmp); s->is_jmp = DISAS_UPDATE; }","[['s'], ['pc'], ['tmp'], ['store_reg'], ['load_cpu_field'], ['spsr'], ['gen_set_cpsr'], ['dead_tmp'], ['DISAS_UPDATE']]"
"static int fourxm_read_packet(AVFormatContext *s, AVPacket *pkt) { FourxmDemuxContext *fourxm = s->priv_data; ByteIOContext *pb = &s->pb; unsigned int fourcc_tag; unsigned int size, out_size; int ret = 0; int track_number; int packet_read = 0; unsigned char header[8]; int64_t pts_inc; int audio_frame_count; while (!packet_read) { if ((ret = get_buffer(&s->pb, header, 8)) < 0) return ret; fourcc_tag = LE_32(&header[0]); size = LE_32(&header[4]); if (url_feof(pb)) return AVERROR_IO; switch (fourcc_tag) { case LIST_TAG: /* this is a good time to bump the video pts */ fourxm->video_pts += fourxm->video_pts_inc; /* skip the LIST-* tag and move on to the next fourcc */ get_le32(pb); break; case ifrm_TAG: case pfrm_TAG: case cfrm_TAG:{ /* allocate 8 more bytes than 'size' to account for fourcc * and size */ if (av_new_packet(pkt, size + 8)) return AVERROR_IO; pkt->stream_index = fourxm->video_stream_index; pkt->pts = fourxm->video_pts; memcpy(pkt->data, header, 8); ret = get_buffer(&s->pb, &pkt->data[8], size); if (ret < 0) av_free_packet(pkt); else packet_read = 1; break; } case snd__TAG: track_number = get_le32(pb); out_size= get_le32(pb); size-=8; if (track_number == fourxm->selected_track) { if (av_new_packet(pkt, size)) return AVERROR_IO; pkt->stream_index = fourxm->tracks[fourxm->selected_track].stream_index; pkt->pts = fourxm->audio_pts; ret = get_buffer(&s->pb, pkt->data, size); if (ret < 0) av_free_packet(pkt); else packet_read = 1; /* pts accounting */ audio_frame_count = size; if (fourxm->tracks[fourxm->selected_track].adpcm) audio_frame_count -= 2 * (fourxm->tracks[fourxm->selected_track].channels); audio_frame_count /= fourxm->tracks[fourxm->selected_track].channels; if (fourxm->tracks[fourxm->selected_track].adpcm) audio_frame_count *= 2; else audio_frame_count /= (fourxm->tracks[fourxm->selected_track].bits / 8); pts_inc = audio_frame_count; pts_inc *= 90000; pts_inc /= fourxm->tracks[fourxm->selected_track].sample_rate; fourxm->audio_pts += pts_inc; } else { url_fseek(pb, size, SEEK_CUR); } break; default: url_fseek(pb, size, SEEK_CUR); break; } } return ret; }","[['s'], ['pkt'], ['fourxm'], ['pb'], ['fourcc_tag'], ['size'], ['out_size'], ['ret'], ['track_number'], ['packet_read'], ['header'], ['pts_inc'], ['audio_frame_count'], ['get_buffer'], ['LE_32'], ['url_feof'], ['AVERROR_IO'], ['LIST_TAG'], ['get_le32'], ['ifrm_TAG'], ['pfrm_TAG'], ['cfrm_TAG'], ['av_new_packet'], ['av_free_packet'], ['snd__TAG'], ['url_fseek']]"
"static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin) { BdrvChild *child, *tmp; bool waited; /* Ensure any pending metadata writes are submitted to bs->file. */ bdrv_drain_invoke(bs, begin); /* Wait for drained requests to finish */ waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0); QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) { BlockDriverState *bs = child->bs; bool in_main_loop = qemu_get_current_aio_context() == qemu_get_aio_context(); assert(bs->refcnt > 0); if (in_main_loop) { /* In case the recursive bdrv_drain_recurse processes a * block_job_defer_to_main_loop BH and modifies the graph, * let's hold a reference to bs until we are done. * * IOThread doesn't have such a BH, and it is not safe to call * bdrv_unref without BQL, so skip doing it there. */ bdrv_ref(bs); } waited |= bdrv_drain_recurse(bs, begin); if (in_main_loop) { bdrv_unref(bs); } } return waited; }","[['bs'], ['begin'], ['child'], ['tmp'], ['waited'], ['bdrv_drain_invoke'], ['BDRV_POLL_WHILE'], ['atomic_read'], ['QLIST_FOREACH_SAFE'], ['next'], ['in_main_loop'], ['qemu_get_current_aio_context'], ['qemu_get_aio_context'], ['assert'], ['bdrv_ref'], ['bdrv_drain_recurse'], ['bdrv_unref']]"
"static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) { int num_pos_channels = 0; int first_cpe = 0; int sce_parity = 0; int i; for (i = *current; i < tags; i++) { if (layout_map[i][2] != pos) break; if (layout_map[i][0] == TYPE_CPE) { if (sce_parity) { if (pos == AAC_CHANNEL_FRONT || !first_cpe) { sce_parity = 0; } else { return -1; } } num_pos_channels += 2; first_cpe = 1; } else { num_pos_channels++; sce_parity ^= 1; } } if (sce_parity && ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE)) return -1; *current = i; return num_pos_channels; }",[]
"uint64_t helper_sublv (uint64_t op1, uint64_t op2) { uint64_t tmp = op1; op1 = (uint32_t)(op1 - op2); if (unlikely(((~tmp) ^ op1 ^ (-1UL)) & ((~tmp) ^ op2) & (1UL << 31))) { helper_excp(EXCP_ARITH, EXCP_ARITH_OVERFLOW); } return op1; }","[['op1'], ['op2'], ['tmp'], ['unlikely'], ['helper_excp'], ['EXCP_ARITH'], ['EXCP_ARITH_OVERFLOW']]"
"static int decode_slice(struct AVCodecContext *avctx, void *arg) { H264Context *h = *(void **)arg; int lf_x_start = h->mb_x; h->mb_skip_run = -1; av_assert0(h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * h->linesize * ((scan8[15] - scan8[0]) >> 3)); h->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME || avctx->codec_id != AV_CODEC_ID_H264 || (CONFIG_GRAY && (h->flags & CODEC_FLAG_GRAY)); if (!(h->avctx->active_thread_type & FF_THREAD_SLICE) && h->picture_structure == PICT_FRAME) { const int start_i = av_clip(h->resync_mb_x + h->resync_mb_y * h->mb_width, 0, h->mb_num - 1); if (start_i) { int prev_status = h->er.error_status_table[h->er.mb_index2xy[start_i - 1]]; prev_status &= ~ VP_START; if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END)) h->er.error_occurred = 1; } } if (h->pps.cabac) { /* realign */ align_get_bits(&h->gb); /* init cabac */ ff_init_cabac_decoder(&h->cabac, h->gb.buffer + get_bits_count(&h->gb) / 8, (get_bits_left(&h->gb) + 7) / 8); ff_h264_init_cabac_states(h); for (;;) { // START_TIMER int ret = ff_h264_decode_mb_cabac(h); int eos; // STOP_TIMER(""decode_mb_cabac"") if (ret >= 0) ff_h264_hl_decode_mb(h); // FIXME optimal? or let mb_decode decode 16x32 ? if (ret >= 0 && FRAME_MBAFF(h)) { h->mb_y++; ret = ff_h264_decode_mb_cabac(h); if (ret >= 0) ff_h264_hl_decode_mb(h); h->mb_y--; } eos = get_cabac_terminate(&h->cabac); if ((h->workaround_bugs & FF_BUG_TRUNCATED) && h->cabac.bytestream > h->cabac.bytestream_end + 2) { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); if (h->mb_x >= lf_x_start) loop_filter(h, lf_x_start, h->mb_x + 1); return 0; } if (h->cabac.bytestream > h->cabac.bytestream_end + 2 ) av_log(h->avctx, AV_LOG_DEBUG, ""bytestream overread %td\n"", h->cabac.bytestream_end - h->cabac.bytestream); if (ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 4) { av_log(h->avctx, AV_LOG_ERROR, ""error while decoding MB %d %d, bytestream (%td)\n"", h->mb_x, h->mb_y, h->cabac.bytestream_end - h->cabac.bytestream); er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_ERROR); return -1; } if (++h->mb_x >= h->mb_width) { loop_filter(h, lf_x_start, h->mb_x); h->mb_x = lf_x_start = 0; decode_finish_row(h); ++h->mb_y; if (FIELD_OR_MBAFF_PICTURE(h)) { ++h->mb_y; if (FRAME_MBAFF(h) && h->mb_y < h->mb_height) predict_field_decoding_flag(h); } } if (eos || h->mb_y >= h->mb_height) { tprintf(h->avctx, ""slice end %d %d\n"", get_bits_count(&h->gb), h->gb.size_in_bits); er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); if (h->mb_x > lf_x_start) loop_filter(h, lf_x_start, h->mb_x); return 0; } } } else { for (;;) { int ret = ff_h264_decode_mb_cavlc(h); if (ret >= 0) ff_h264_hl_decode_mb(h); // FIXME optimal? or let mb_decode decode 16x32 ? if (ret >= 0 && FRAME_MBAFF(h)) { h->mb_y++; ret = ff_h264_decode_mb_cavlc(h); if (ret >= 0) ff_h264_hl_decode_mb(h); h->mb_y--; } if (ret < 0) { av_log(h->avctx, AV_LOG_ERROR, ""error while decoding MB %d %d\n"", h->mb_x, h->mb_y); er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_ERROR); return -1; } if (++h->mb_x >= h->mb_width) { loop_filter(h, lf_x_start, h->mb_x); h->mb_x = lf_x_start = 0; decode_finish_row(h); ++h->mb_y; if (FIELD_OR_MBAFF_PICTURE(h)) { ++h->mb_y; if (FRAME_MBAFF(h) && h->mb_y < h->mb_height) predict_field_decoding_flag(h); } if (h->mb_y >= h->mb_height) { tprintf(h->avctx, ""slice end %d %d\n"", get_bits_count(&h->gb), h->gb.size_in_bits); if ( get_bits_left(&h->gb) == 0 || get_bits_left(&h->gb) > 0 && !(h->avctx->err_recognition & AV_EF_AGGRESSIVE)) { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); return 0; } else { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_END); return -1; } } } if (get_bits_left(&h->gb) <= 0 && h->mb_skip_run <= 0) { tprintf(h->avctx, ""slice end %d %d\n"", get_bits_count(&h->gb), h->gb.size_in_bits); if (get_bits_left(&h->gb) == 0) { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); if (h->mb_x > lf_x_start) loop_filter(h, lf_x_start, h->mb_x); return 0; } else { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_ERROR); return -1; } } } } }","[['avctx'], ['arg'], ['h'], ['lf_x_start'], ['av_assert0'], ['scan8'], ['FRAME_MBAFF'], ['PICT_FRAME'], ['AV_CODEC_ID_H264'], ['CONFIG_GRAY'], ['CODEC_FLAG_GRAY'], ['FF_THREAD_SLICE'], ['start_i'], ['av_clip'], ['prev_status'], ['VP_START'], ['ER_MV_END'], ['ER_DC_END'], ['ER_AC_END'], ['align_get_bits'], ['ff_init_cabac_decoder'], ['get_bits_count'], ['get_bits_left'], ['ff_h264_init_cabac_states']]"
"static int img_read_packet(AVFormatContext *s1, AVPacket *pkt) { VideoData *s = s1->priv_data; char filename[1024]; int ret; ByteIOContext f1, *f; if (get_frame_filename(filename, sizeof(filename), s->path, s->img_number) < 0) return -EIO; if (!s->is_pipe) { f = &f1; if (url_fopen(f, filename, URL_RDONLY) < 0) return -EIO; } else { f = &s1->pb; if (url_feof(f)) return -EIO; } av_new_packet(pkt, s->img_size); pkt->stream_index = 0; switch(s->img_fmt) { case IMGFMT_PGMYUV: ret = pgm_read(s, f, pkt->data, pkt->size, 1); break; case IMGFMT_PGM: ret = pgm_read(s, f, pkt->data, pkt->size, 0); break; case IMGFMT_YUV: ret = yuv_read(s, filename, pkt->data, pkt->size); break; case IMGFMT_PPM: ret = ppm_read(s, f, pkt->data, pkt->size); break; default: return -EIO; } if (!s->is_pipe) { url_fclose(f); } if (ret < 0) { av_free_packet(pkt); return -EIO; /* signal EOF */ } else { s->img_number++; return 0; } }","[['s1'], ['pkt'], ['s'], ['filename'], ['ret'], ['f1'], ['f'], ['get_frame_filename'], ['EIO'], ['url_fopen'], ['URL_RDONLY'], ['url_feof'], ['av_new_packet'], ['IMGFMT_PGMYUV'], ['pgm_read'], ['IMGFMT_PGM'], ['IMGFMT_YUV'], ['yuv_read'], ['IMGFMT_PPM'], ['ppm_read'], ['url_fclose'], ['av_free_packet'], ['img_number']]"
"void configure_alarms(char const *opt) { int i; int cur = 0; int count = ARRAY_SIZE(alarm_timers) - 1; char *arg; char *name; struct qemu_alarm_timer tmp; if (!strcmp(opt, ""?"")) { show_available_alarms(); exit(0); } arg = g_strdup(opt); /* Reorder the array */ name = strtok(arg, "",""); while (name) { for (i = 0; i < count && alarm_timers[i].name; i++) { if (!strcmp(alarm_timers[i].name, name)) break; } if (i == count) { fprintf(stderr, ""Unknown clock %s\n"", name); goto next; } if (i < cur) /* Ignore */ goto next; /* Swap */ tmp = alarm_timers[i]; alarm_timers[i] = alarm_timers[cur]; alarm_timers[cur] = tmp; cur++; next: name = strtok(NULL, "",""); } g_free(arg); if (cur) { /* Disable remaining timers */ for (i = cur; i < count; i++) alarm_timers[i].name = NULL; } else { show_available_alarms(); exit(1); } }","[['opt'], ['i'], ['cur'], ['count'], ['ARRAY_SIZE'], ['alarm_timers'], ['arg'], ['name'], ['tmp'], ['show_available_alarms'], ['g_strdup'], ['g_free']]"
