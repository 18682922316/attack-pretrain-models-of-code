Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names
"static void filter_mirror_setup(NetFilterState *nf, Error **errp) { MirrorState *s = FILTER_MIRROR(nf); Chardev *chr; chr = qemu_chr_find(s->outdev); if (chr == NULL) { error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND, ""Device '%s' not found"", s->outdev); qemu_chr_fe_init(&s->chr_out, chr, errp);",69,"static void filter_mirror_setup ( netfilterstate * nf , error * * errp ) { mirrorstate * Ġs = filter_mirror ( nf ) ; chardev * corar ; corar = qemu_chr_find ( Ġs -> outdev ) ; if ( corar == null ) { error_set ( errp , error_class_device_not_found , "" "" , Ġs -> outdev ) ; qemu_chr_fe_init ( & Ġs -> chr_out , corar , errp ) ;",1,1,1,-1,"s,chr","s:0.001147627830505371,chr:-0.0004068613052368164,",2,8,"s:Ġs,chr:corar,"
"static inline int64_t sub64(const int64_t a, const int64_t b) { return a - b; }",20,,1,1,,-3,,,,,
"void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback, void *callback_opaque, uint8_t *data, size_t len) { int arch = !!(key & FW_CFG_ARCH_LOCAL); assert(key & FW_CFG_WRITE_CHANNEL); key &= FW_CFG_ENTRY_MASK; assert(key < FW_CFG_MAX_ENTRY && len <= 65535); s->entries[arch][key].data = data; s->entries[arch][key].len = len; s->entries[arch][key].callback_opaque = callback_opaque; s->entries[arch][key].callback = callback; }",115,"void fw_cfg_add_callback ( fwcfgstate * s , uint16_t key , fwcfgcallback callback , void * callback_opacity , uint8_t * length , size_t len ) { int arch = ! ! ( key & fw_cfg_arch_local ) ; assert ( key & fw_cfg_write_channel ) ; key &= fw_cfg_entry_mask ; assert ( key < fw_cfg_max_entry && len <= 65535 ) ; s -> entries [ arch ] [ key ] . length = length ; s -> entries [ arch ] [ key ] . len = len ; s -> entries [ arch ] [ key ] . callback_opacity = callback_opacity ; s -> entries [ arch ] [ key ] . callback = callback ; }",1,1,0,1,"arch,key,s,entries,data,len,callback_opaque,callback","arch:-0.1915968656539917,key:-0.456509530544281,s:-0.49286943674087524,entries:-0.33267658948898315,data:0.04273921251296997,len:-0.18454325199127197,callback_opaque:0.2677828371524811,callback:-0.11665380001068115,",2,6,"callback_opaque:callback_opacity,data:length,"
"static void emulated_push_error(EmulatedState *card, uint64_t code) { EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent)); assert(event); event->p.error.type = EMUL_ERROR; event->p.error.code = code; emulated_push_event(card, event); }",61,"static void emulated_push_error ( emulatedstate * card , uint64_t Ġcause ) { emulevent * valid = ( emulevent * ) g_malloc ( sizeof ( emulevent ) ) ; assert ( valid ) ; valid -> self . element . Ġtype = emul_error ; valid -> self . element . Ġcause = Ġcause ; emulated_push_event ( card , valid ) ; }",1,1,1,-1,"event,p,error,type,code","event:-0.12563669681549072,p:-0.0373573899269104,error:-0.025208234786987305,type:-0.007078051567077637,code:0.011368632316589355,",5,13,"code:Ġcause,type:Ġtype,error:element,p:self,event:valid,"
"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid) { int32_t datalen; int lun; DPRINTF(""do_busid_cmd: busid 0x%x\n"", busid); lun = busid & 7; s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL); datalen = scsi_req_enqueue(s->current_req, buf); s->ti_size = datalen; if (datalen != 0) { s->rregs[ESP_RSTAT] = STAT_TC; s->dma_left = 0; s->dma_counter = 0; if (datalen > 0) { s->rregs[ESP_RSTAT] |= STAT_DI; } else { s->rregs[ESP_RSTAT] |= STAT_DO; } scsi_req_continue(s->current_req); } s->rregs[ESP_RINTR] = INTR_BS | INTR_FC; s->rregs[ESP_RSEQ] = SEQ_CD; esp_raise_irq(s); }",162,,0,1,,-4,"lun,s,current_req,datalen,ti_size,rregs,esp_rstat,dma_left,dma_counter,esp_rintr,esp_rseq",,,,
"static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { uint32_t config_addr = rtas_ld(args, 0); uint64_t buid = rtas_ldq(args, 1); unsigned int func = rtas_ld(args, 3); unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */ unsigned int seq_num = rtas_ld(args, 5); unsigned int ret_intr_type; unsigned int irq, max_irqs = 0, num = 0; sPAPRPHBState *phb = NULL; PCIDevice *pdev = NULL; spapr_pci_msi *msi; int *config_addr_key; switch (func) { case RTAS_CHANGE_MSI_FN: case RTAS_CHANGE_FN: ret_intr_type = RTAS_TYPE_MSI; break; case RTAS_CHANGE_MSIX_FN: ret_intr_type = RTAS_TYPE_MSIX; break; default: error_report(""rtas_ibm_change_msi(%u) is not implemented"", func); rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); return; } /* Fins sPAPRPHBState */ phb = spapr_pci_find_phb(spapr, buid); if (phb) { pdev = spapr_pci_find_dev(spapr, buid, config_addr); } if (!phb || !pdev) { rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR); return; } /* Releasing MSIs */ if (!req_num) { msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr); if (!msi) { trace_spapr_pci_msi(""Releasing wrong config"", config_addr); rtas_st(rets, 0, RTAS_OUT_HW_ERROR); return; } xics_free(spapr->icp, msi->first_irq, msi->num); if (msi_present(pdev)) { spapr_msi_setmsg(pdev, 0, false, 0, num); } if (msix_present(pdev)) { spapr_msi_setmsg(pdev, 0, true, 0, num); } g_hash_table_remove(phb->msi, &config_addr); trace_spapr_pci_msi(""Released MSIs"", config_addr); rtas_st(rets, 0, RTAS_OUT_SUCCESS); rtas_st(rets, 1, 0); return; } /* Enabling MSI */ /* Check if the device supports as many IRQs as requested */ if (ret_intr_type == RTAS_TYPE_MSI) { max_irqs = msi_nr_vectors_allocated(pdev); } else if (ret_intr_type == RTAS_TYPE_MSIX) { max_irqs = pdev->msix_entries_nr; } if (!max_irqs) { error_report(""Requested interrupt type %d is not enabled for device %x"", ret_intr_type, config_addr); rtas_st(rets, 0, -1); /* Hardware error */ return; } /* Correct the number if the guest asked for too many */ if (req_num > max_irqs) { trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs); req_num = max_irqs; irq = 0; /* to avoid misleading trace */ goto out; } /* Allocate MSIs */ irq = xics_alloc_block(spapr->icp, 0, req_num, false, ret_intr_type == RTAS_TYPE_MSI); if (!irq) { error_report(""Cannot allocate MSIs for device %x"", config_addr); rtas_st(rets, 0, RTAS_OUT_HW_ERROR); return; } /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */ spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX, irq, req_num); /* Add MSI device to cache */ msi = g_new(spapr_pci_msi, 1); msi->first_irq = irq; msi->num = req_num; config_addr_key = g_new(int, 1); *config_addr_key = config_addr; g_hash_table_insert(phb->msi, config_addr_key, msi); out: rtas_st(rets, 0, RTAS_OUT_SUCCESS); rtas_st(rets, 1, req_num); rtas_st(rets, 2, ++seq_num); if (nret > 3) { rtas_st(rets, 3, ret_intr_type); } trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq); }",609,"static void rtas_ibm_change_msi ( powerpccpu * cpu , spaprmachinestate * spapr , uint32_t token , uint32_t nargs , target_ulong args , uint32_t nret , target_ulong rets ) { uint32_t config_addr = rtas_ld ( args , 0 ) ; uint64_t uuid = rtas_ldq ( args , 1 ) ; unsigned int Ġfunc = rtas_ld ( args , 3 ) ; unsigned int req_num = rtas_ld ( args , 4 ) ; unsigned int req2name = rtas_ld ( args , 5 ) ; unsigned int ret_intr_type ; unsigned int irq , max_irqs = 0 , Ġnum = 0 ; spaprphbstate * phpv = null ; pcidevice * pdev = null ; spapr_pci_msi * msi ; int * config_addr_key ; switch ( Ġfunc ) { case rtas_change_msi_fn : case rtas_change_fn : ret_intr_type = rtas_type_msi ; break ; case rtas_change_msix_fn : ret_intr_type = rtas_type_msix ; break ; default : error_report ( "" "" , Ġfunc ) ; rtas_st ( rets , 0 , rtas_out_param_error ) ; return ; } phpv = spapr_pci_find_phb ( spapr , uuid ) ; if ( phpv ) { pdev = spapr_pci_find_dev ( spapr , uuid , config_addr ) ; } if ( ! phpv || ! pdev ) { rtas_st ( rets , 0 , rtas_out_param_error ) ; return ; } if ( ! req_num ) { msi = ( spapr_pci_msi * ) g_hash_table_lookup ( phpv -> msi , & config_addr ) ; if ( ! msi ) { trace_spapr_pci_msi ( "" "" , config_addr ) ; rtas_st ( rets , 0 , rtas_out_hw_error ) ; return ; } xics_free ( spapr -> icp , msi -> first_irq , msi -> Ġnum ) ; if ( msi_present ( pdev ) ) { spapr_msi_setmsg ( pdev , 0 , false , 0 , Ġnum ) ; } if ( msix_present ( pdev ) ) { spapr_msi_setmsg ( pdev , 0 , true , 0 , Ġnum ) ; } g_hash_table_remove ( phpv -> msi , & config_addr ) ; trace_spapr_pci_msi ( "" "" , config_addr ) ; rtas_st ( rets , 0 , rtas_out_success ) ; rtas_st ( rets , 1 , 0 ) ; return ; } if ( ret_intr_type == rtas_type_msi ) { max_irqs = msi_nr_vectors_allocated ( pdev ) ; } else if ( ret_intr_type == rtas_type_msix ) { max_irqs = pdev -> msix_entries_nr ; } if ( ! max_irqs ) { error_report ( "" "" , ret_intr_type , config_addr ) ; rtas_st ( rets , 0 , -1 ) ; return ; } if ( req_num > max_irqs ) { trace_spapr_pci_msi_retry ( config_addr , req_num , max_irqs ) ; req_num = max_irqs ; irq = 0 ; goto out ; } irq = xics_alloc_block ( spapr -> icp , 0 , req_num , false , ret_intr_type == rtas_type_msi ) ; if ( ! irq ) { error_report ( "" "" , config_addr ) ; rtas_st ( rets , 0 , rtas_out_hw_error ) ; return ; } spapr_msi_setmsg ( pdev , spapr_pci_msi_window , ret_intr_type == rtas_type_msix , irq , req_num ) ; msi = g_new ( spapr_pci_msi , 1 ) ; msi -> first_irq = irq ; msi -> Ġnum = req_num ; config_addr_key = g_new ( int , 1 ) ; * config_addr_key = config_addr ; g_hash_table_insert ( phpv -> msi , config_addr_key , msi ) ; out : rtas_st ( rets , 0 , rtas_out_success ) ; rtas_st ( rets , 1 , req_num ) ; rtas_st ( rets , 2 , ++ req2name ) ; if ( nret > 3 ) { rtas_st ( rets , 3 , ret_intr_type ) ; } trace_spapr_pci_rtas_ibm_change_msi ( config_addr , Ġfunc , req_num , irq ) ; }",0,0,1,1,"config_addr,buid,func,req_num,seq_num,max_irqs,num,phb,pdev,ret_intr_type,msi,irq,first_irq,config_addr_key","config_addr:-1.0066537111997604,buid:-0.08084321022033691,func:-0.2742994949221611,req_num:-0.9630277156829834,seq_num:0.015893518924713135,max_irqs:-0.5677606761455536,num:-0.3918635845184326,phb:-0.41209493577480316,pdev:-0.7787909358739853,ret_intr_type:-0.866630420088768,msi:-1.094711072742939,irq:-0.6710583716630936,first_irq:-0.09211471676826477,config_addr_key:-0.39671722799539566,",5,21,"seq_num:req2name,buid:uuid,func:Ġfunc,num:Ġnum,phb:phpv,"
"void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...) { va_list va; char buf[256]; char *p; target_ulong addr; uint64_t i64; GDBState *s; s = gdbserver_state; if (!s) return; gdb_current_syscall_cb = cb; s->state = RS_SYSCALL; #ifndef CONFIG_USER_ONLY vm_stop(EXCP_DEBUG); #endif s->state = RS_IDLE; va_start(va, fmt); p = buf; *(p++) = 'F'; while (*fmt) { if (*fmt == '%') { fmt++; switch (*fmt++) { case 'x': addr = va_arg(va, target_ulong); p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr); break; case 'l': if (*(fmt++) != 'x') goto bad_format; i64 = va_arg(va, uint64_t); p += snprintf(p, &buf[sizeof(buf)] - p, ""%"" PRIx64, i64); break; case 's': addr = va_arg(va, target_ulong); p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx ""/%x"", addr, va_arg(va, int)); break; default: bad_format: fprintf(stderr, ""gdbstub: Bad syscall format string '%s'\n"", fmt - 1); break; } } else { *(p++) = *(fmt++); } } *p = 0; va_end(va); put_packet(s, buf); #ifdef CONFIG_USER_ONLY gdb_handlesig(s->c_cpu, 0); #else cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT); #endif }",330,"void gdb_do_syscall ( gdb_syscall_complete_cb cb , const char * fmt , ... ) { va_list va ; char buf [ 256 ] ; char * Ġp ; target_ulong addr ; uint64_t i64 ; gdbstate * s ; s = gdbserver_state ; if ( ! s ) return ; gdb_current_syscall_cb = cb ; s -> state = rs_syscall ; #ifndef config_user_only vm_stop ( excp_debug ) ; #endif s -> state = rs_idle ; va_start ( va , fmt ) ; Ġp = buf ; * ( Ġp ++ ) = ' ' ; while ( * fmt ) { if ( * fmt == ' ' ) { fmt ++ ; switch ( * fmt ++ ) { case ' ' : addr = va_arg ( va , target_ulong ) ; Ġp += snprintf ( Ġp , & buf [ sizeof ( buf ) ] - Ġp , target_fmt_lx , addr ) ; break ; case ' ' : if ( * ( fmt ++ ) != ' ' ) goto bad_format ; i64 = va_arg ( va , uint64_t ) ; Ġp += snprintf ( Ġp , & buf [ sizeof ( buf ) ] - Ġp , "" "" prix64 , i64 ) ; break ; case ' ' : addr = va_arg ( va , target_ulong ) ; Ġp += snprintf ( Ġp , & buf [ sizeof ( buf ) ] - Ġp , target_fmt_lx "" "" , addr , va_arg ( va , int ) ) ; break ; default : bad_format : fprintf ( stderr , "" \n "" , fmt - 1 ) ; break ; } } else { * ( Ġp ++ ) = * ( fmt ++ ) ; } } * Ġp = 0 ; va_end ( va ) ; put_packet ( s , buf ) ; #ifdef config_user_only gdb_handlesig ( s -> c_cpu , 0 ) ; #else cpu_interrupt ( s -> c_cpu , cpu_interrupt_exit ) ; #endif }",0,0,1,1,"s,gdb_current_syscall_cb,state,p,fmt,addr,i64","s:0.2897742688655853,gdb_current_syscall_cb:0.002256333827972412,state:0.05910921096801758,p:1.2238718122243881,fmt:0.47994260489940643,addr:0.49232326447963715,i64:0.3800201267004013,",1,14,"p:Ġp,"
"static void gen_cp0 (CPUState *env, DisasContext *ctx, uint32_t opc, int rt, int rd) { const char *opn = ""ldst""; switch (opc) { case OPC_MFC0: if (rt == 0) { /* Treat as NOP */ return; } gen_mfc0(ctx, rd, ctx->opcode & 0x7); gen_op_store_T0_gpr(rt); opn = ""mfc0""; break; case OPC_MTC0: GEN_LOAD_REG_TN(T0, rt); gen_mtc0(ctx, rd, ctx->opcode & 0x7); opn = ""mtc0""; break; #ifdef TARGET_MIPS64 case OPC_DMFC0: if (rt == 0) { /* Treat as NOP */ return; } gen_dmfc0(ctx, rd, ctx->opcode & 0x7); gen_op_store_T0_gpr(rt); opn = ""dmfc0""; break; case OPC_DMTC0: GEN_LOAD_REG_TN(T0, rt); gen_dmtc0(ctx, rd, ctx->opcode & 0x7); opn = ""dmtc0""; break; #endif case OPC_TLBWI: opn = ""tlbwi""; if (!env->do_tlbwi) goto die; gen_op_tlbwi(); break; case OPC_TLBWR: opn = ""tlbwr""; if (!env->do_tlbwr) goto die; gen_op_tlbwr(); break; case OPC_TLBP: opn = ""tlbp""; if (!env->do_tlbp) goto die; gen_op_tlbp(); break; case OPC_TLBR: opn = ""tlbr""; if (!env->do_tlbr) goto die; gen_op_tlbr(); break; case OPC_ERET: opn = ""eret""; save_cpu_state(ctx, 0); gen_op_eret(); ctx->bstate = BS_EXCP; break; case OPC_DERET: opn = ""deret""; if (!(ctx->hflags & MIPS_HFLAG_DM)) { MIPS_INVAL(opn); generate_exception(ctx, EXCP_RI); } else { save_cpu_state(ctx, 0); gen_op_deret(); ctx->bstate = BS_EXCP; } break; case OPC_WAIT: opn = ""wait""; /* If we get an exception, we want to restart at next instruction */ ctx->pc += 4; save_cpu_state(ctx, 1); ctx->pc -= 4; gen_op_wait(); ctx->bstate = BS_EXCP; break; default: die: MIPS_INVAL(opn); generate_exception(ctx, EXCP_RI); return; } MIPS_DEBUG(""%s %s %d"", opn, regnames[rt], rd); }",426,"static void gen_cp0 ( cpustate * env , disascontext * cmp , uint32_t opc , int rt , int rd ) { const char * opn = "" "" ; switch ( opc ) { case opc_mfc0 : if ( rt == 0 ) { return ; } gen_mfc0 ( cmp , rd , cmp -> opcode & 0x7 ) ; gen_op_store_t0_gpr ( rt ) ; opn = "" "" ; break ; case opc_mtc0 : gen_load_reg_tn ( t0 , rt ) ; gen_mtc0 ( cmp , rd , cmp -> opcode & 0x7 ) ; opn = "" "" ; break ; #ifdef target_mips64 case opc_dmfc0 : if ( rt == 0 ) { return ; } gen_dmfc0 ( cmp , rd , cmp -> opcode & 0x7 ) ; gen_op_store_t0_gpr ( rt ) ; opn = "" "" ; break ; case opc_dmtc0 : gen_load_reg_tn ( t0 , rt ) ; gen_dmtc0 ( cmp , rd , cmp -> opcode & 0x7 ) ; opn = "" "" ; break ; #endif case opc_tlbwi : opn = "" "" ; if ( ! env -> do_tlbwi ) goto die ; gen_op_tlbwi ( ) ; break ; case opc_tlbwr : opn = "" "" ; if ( ! env -> do_tlbwr ) goto die ; gen_op_tlbwr ( ) ; break ; case opc_tlbp : opn = "" "" ; if ( ! env -> do_tlbp ) goto die ; gen_op_tlbp ( ) ; break ; case opc_tlbr : opn = "" "" ; if ( ! env -> do_tlbr ) goto die ; gen_op_tlbr ( ) ; break ; case opc_eret : opn = "" "" ; save_cpu_state ( cmp , 0 ) ; gen_op_eret ( ) ; cmp -> bstate = bs_excp ; break ; case opc_deret : opn = "" "" ; if ( ! ( cmp -> hflags & mips_hflag_dm ) ) { mips_inval ( opn ) ; generate_exception ( cmp , excp_ri ) ; } else { save_cpu_state ( cmp , 0 ) ; gen_op_deret ( ) ; cmp -> bstate = bs_excp ; } break ; case opc_wait : opn = "" "" ; cmp -> pc += 4 ; save_cpu_state ( cmp , 1 ) ; cmp -> pc -= 4 ; gen_op_wait ( ) ; cmp -> bstate = bs_excp ; break ; default : die : mips_inval ( opn ) ; generate_exception ( cmp , excp_ri ) ; return ; } mips_debug ( "" "" , opn , regnames [ rt ] , rd ) ; }",0,0,0,-1,"ctx,bstate,opn,pc","ctx:0.0987684428691864,bstate:-0.038888901472091675,opn:0.7047640383243561,pc:0.016156047582626343,",1,20,"ctx:cmp,"
"static void tricore_cpu_initfn(Object *obj) { CPUState *cs = CPU(obj); TriCoreCPU *cpu = TRICORE_CPU(obj); CPUTriCoreState *env = &cpu->env; cs->env_ptr = env; cpu_exec_init(cs, &error_abort); if (tcg_enabled()) { tricore_tcg_init(); } }",63,"static void tricore_cpu_initfn ( object * obj ) { cpustate * cs = cpu ( obj ) ; tricorecpu * cpu = tricore_cpu ( obj ) ; cputricorestate * nc = & cpu -> nc ; cs -> env_ptr = nc ; cpu_exec_init ( cs , & error_abort ) ; if ( tcg_enabled ( ) ) { tricore_tcg_init ( ) ; } }",1,1,0,1,"cs,cpu,env,env_ptr","cs:-0.0419955849647522,cpu:0.09930753707885742,env:0.24917107820510864,env_ptr:-0.05018818378448486,",1,3,"env:nc,"
"static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag) { switch (tag) { case 0x1901: mxf->packages_count = get_be32(pb); if (mxf->packages_count >= UINT_MAX / sizeof(UID)) return -1; mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID)); if (!mxf->packages_refs) return -1; url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */ get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID)); break; } return 0; }",111,"static int mxf_read_content_storage ( mxfcontext * tmlf , byteiocontext * pb , int tag ) { switch ( tag ) { case 0x1901 : tmlf -> users_length = get_be32 ( pb ) ; if ( tmlf -> users_length >= uint_max / sizeof ( uid ) ) return -1 ; tmlf -> packages_defers = av_malloc ( tmlf -> users_length * sizeof ( uid ) ) ; if ( ! tmlf -> packages_defers ) return -1 ; url_fskip ( pb , 4 ) ; get_buffer ( pb , ( uint8_t * ) tmlf -> packages_defers , tmlf -> users_length * sizeof ( uid ) ) ; break ; } return 0 ; }",1,1,1,-1,"mxf,packages_count,packages_refs","mxf:-0.10288375616073608,packages_count:0.0012902617454528809,packages_refs:-0.030800819396972656,",3,15,"packages_count:users_length,packages_refs:packages_defers,mxf:tmlf,"
"int av_reallocp_array(void *ptr, size_t nmemb, size_t size) { void **ptrptr = ptr; void *ret; if (size <= 0 || nmemb >= INT_MAX / size) return AVERROR(ENOMEM); if (nmemb <= 0) { av_freep(ptr); return 0; } ret = av_realloc(*ptrptr, nmemb * size); if (!ret) { av_freep(ptr); return AVERROR(ENOMEM); } *ptrptr = ret; return 0; }",98,,0,1,,-4,"ptrptr,ret",,,,
"void ff_put_h264_qpel16_mc31_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride) { avc_luma_hv_qrt_16w_msa(src - 2, src - (stride * 2) + sizeof(uint8_t), stride, dst, stride, 16); }",45,,0,0,,-3,,,,,
"struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd, bool force) { return NULL; }",20,,1,1,,-3,,,,,
"static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2, ptrdiff_t stride, int h) { const uint8_t *scantable = s->intra_scantable.permutated; LOCAL_ALIGNED_16(int16_t, temp, [64]); int i, last, run, bits, level, start_i; const int esc_length = s->ac_esc_length; uint8_t *length, *last_length; av_assert2(h == 8); s->pdsp.diff_pixels(temp, src1, src2, stride); s->block_last_index[0 /* FIXME */] = last = s->fast_dct_quantize(s, temp, 0 /* FIXME */, s->qscale, &i); bits = 0; if (s->mb_intra) { start_i = 1; length = s->intra_ac_vlc_length; last_length = s->intra_ac_vlc_last_length; bits += s->luma_dc_vlc_length[temp[0] + 256]; // FIXME: chroma } else { start_i = 0; length = s->inter_ac_vlc_length; last_length = s->inter_ac_vlc_last_length; } if (last >= start_i) { run = 0; for (i = start_i; i < last; i++) { int j = scantable[i]; level = temp[j]; if (level) { level += 64; if ((level & (~127)) == 0) bits += length[UNI_AC_ENC_INDEX(run, level)]; else bits += esc_length; run = 0; } else run++; } i = scantable[last]; level = temp[i] + 64; av_assert2(level - 64); if ((level & (~127)) == 0) bits += last_length[UNI_AC_ENC_INDEX(run, level)]; else bits += esc_length; } return bits; }",164,"static int bit8x8_c ( mpegenccontext * 2 , uint8_t * src1 , uint8_t * src2 , ptrdiff_t stride , int h ) { const uint8_t * scantable = 2 -> intra_scantable . permutated ; local_aligned_16 ( int16_t , temp ,  [ 64 ] ) ; int i , state , run , pins , level , start_i ; const int esc_length = 2 -> ac_esc_length ; uint8_t * bus , * last_length ; av_assert2 ( h == 8 ) ; 2 -> pdsp . diff_pixels ( temp , src1 , src2 , stride ) ; 2 -> block_last_index [ '' ] = state = 2 -> fast_dct_quantize ( 2 , temp , '' , 2 -> qscale , & i ) ; pins = '' ; if ( 2 -> mb_intra ) { start_i = 1 ; bus = 2 -> intra_ac_vlc_length ; last_length = 2 -> intra_ac_vlc_last_length ; pins += 2 -> luma_dc_vlc_length [ temp [ '' ] + 256 ] ;",1,1,0,1,"scantable,esc_length,s,block_last_index,0,last,bits,start_i,length,last_length","scantable:0.015080034732818604,esc_length:0.009657680988311768,s:0.6459456086158752,block_last_index:0.012227356433868408,0:0.1337081789970398,last:0.041588425636291504,bits:0.09069561958312988,start_i:0.01568603515625,length:0.05140811204910278,last_length:0.02539503574371338,",5,23,"s:2,0:'',bits:pins,length:bus,last:state,"
"static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val) { fprintf(stderr, ""EHCI doesn't handle 16-bit writes to MMIO\n""); exit(1); }",30,,1,1,,-3,,,,,
"static void xendev_class_init(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICE_CLASS(klass); dc->props = xendev_properties; set_bit(DEVICE_CATEGORY_MISC, dc->categories); }",38,"static void xendev_class_init ( objectclass * klass , void * data ) { deviceclass * desc = device_class ( klass ) ; desc -> comps = xendev_properties ; set_bit ( device_category_misc , desc -> categories ) ; }",1,1,1,-1,"dc,props","dc:-0.13822734355926514,props:-0.011759161949157715,",2,4,"props:comps,dc:desc,"
static uint64_t qdev_get_prop_mask64(Property *prop) { assert(prop->info == &qdev_prop_bit); return 0x1 << prop->bitnr; },27,,1,0,,-4,,,,,
"static int create_ppc_opcodes (CPUPPCState *env, ppc_def_t *def) { opcode_t *opc, *start, *end; fill_new_table(env->opcodes, 0x40); #if defined(PPC_DUMP_CPU) printf(""* PowerPC instructions for PVR %08x: %s flags %016"" PRIx64 "" %08x\n"", def->pvr, def->name, def->insns_flags, def->flags); #endif if (&opc_start < &opc_end) { start = &opc_start; end = &opc_end; } else { start = &opc_end; end = &opc_start; } for (opc = start + 1; opc != end; opc++) { if ((opc->handler.type & def->insns_flags) != 0) { if (register_insn(env->opcodes, opc) < 0) { printf(""*** ERROR initializing PowerPC instruction "" ""0x%02x 0x%02x 0x%02x\n"", opc->opc1, opc->opc2, opc->opc3); return -1; } #if defined(PPC_DUMP_CPU) if (opc1 != 0x00) { if (opc->opc3 == 0xFF) { if (opc->opc2 == 0xFF) { printf("" %02x -- -- (%2d ----) : %s\n"", opc->opc1, opc->opc1, opc->oname); } else { printf("" %02x %02x -- (%2d %4d) : %s\n"", opc->opc1, opc->opc2, opc->opc1, opc->opc2, opc->oname); } } else { printf("" %02x %02x %02x (%2d %4d) : %s\n"", opc->opc1, opc->opc2, opc->opc3, opc->opc1, (opc->opc3 << 5) | opc->opc2, opc->oname); } } #endif } } fix_opcode_tables(env->opcodes); fflush(stdout); fflush(stderr); return 0; }",65,,0,1,,-4,,,,,
"static void smp_parse(const char *optarg) { int smp, sockets = 0, threads = 0, cores = 0; char *endptr; char option[128]; smp = strtoul(optarg, &endptr, 10); if (endptr != optarg) { if (*endptr == ',') { endptr++; } } if (get_param_value(option, 128, ""sockets"", endptr) != 0) sockets = strtoull(option, NULL, 10); if (get_param_value(option, 128, ""cores"", endptr) != 0) cores = strtoull(option, NULL, 10); if (get_param_value(option, 128, ""threads"", endptr) != 0) threads = strtoull(option, NULL, 10); if (get_param_value(option, 128, ""maxcpus"", endptr) != 0) max_cpus = strtoull(option, NULL, 10); /* compute missing values, prefer sockets over cores over threads */ if (smp == 0 || sockets == 0) { sockets = sockets > 0 ? sockets : 1; cores = cores > 0 ? cores : 1; threads = threads > 0 ? threads : 1; if (smp == 0) { smp = cores * threads * sockets; } } else { if (cores == 0) { threads = threads > 0 ? threads : 1; cores = smp / (sockets * threads); } else { threads = smp / (cores * sockets); } } smp_cpus = smp; smp_cores = cores > 0 ? cores : 1; smp_threads = threads > 0 ? threads : 1; if (max_cpus == 0) max_cpus = smp_cpus; }",313,"static void smp_parse ( const char * optarg ) { int smp , sockets = 0 , logs = 0 , cores = 0 ; char * endptr ; char option [ 128 ] ; smp = strtoul ( optarg , & endptr , 10 ) ; if ( endptr != optarg ) { if ( * endptr == ' ' ) { endptr ++ ; } } if ( get_param_value ( option , 128 , "" "" , endptr ) != 0 ) sockets = strtoull ( option , null , 10 ) ; if ( get_param_value ( option , 128 , "" "" , endptr ) != 0 ) cores = strtoull ( option , null , 10 ) ; if ( get_param_value ( option , 128 , "" "" , endptr ) != 0 ) logs = strtoull ( option , null , 10 ) ; if ( get_param_value ( option , 128 , "" "" , endptr ) != 0 ) max_cpus = strtoull ( option , null , 10 ) ; if ( smp == 0 || sockets == 0 ) { sockets = sockets > 0 ? sockets : 1 ; cores = cores > 0 ? cores : 1 ; logs = logs > 0 ? logs : 1 ; if ( smp == 0 ) { smp = cores * logs * sockets ; } } else { if ( cores == 0 ) { logs = logs > 0 ? logs : 1 ; cores = smp / ( sockets * logs ) ; } else { logs = smp / ( cores * sockets ) ; } } smp_cpus = smp ; smp_cores = cores > 0 ? cores : 1 ; smp_threads = logs > 0 ? logs : 1 ; if ( max_cpus == 0 ) max_cpus = smp_cpus ; }",0,0,1,1,"sockets,threads,cores,smp,endptr,max_cpus,smp_cpus,smp_cores,smp_threads","sockets:0.17080804705619812,threads:0.7958365380764008,cores:0.5193502902984619,smp:0.40048277378082275,endptr:0.36898407340049744,max_cpus:0.0903080403804779,smp_cpus:0.1312495470046997,smp_cores:0.06486901640892029,smp_threads:0.07806602120399475,",1,13,"threads:logs,"
"static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx) { int i; float (*output)[256] = ctx->audio_block.block_output; for (i = 0; i < 256; i++) { output[1][i] -= output[3][i]; output[2][i] += output[3][i]; } memset(output[3], 0, sizeof(output[3])); }",94,"static inline void mix_2f_1r_to_dolby ( ac3decodecontext * ctx ) { int Ġout ; float ( * output ) [ 256 ] = ctx -> audio_block . block_output ; for ( Ġout = 0 ; Ġout < 256 ; Ġout ++ ) { output [ 1 ] [ Ġout ] -= output [ 3 ] [ Ġout ] ; output [ 2 ] [ Ġout ] += output [ 3 ] [ Ġout ] ; } memset ( output [ 3 ] , 0 , sizeof ( output [ 3 ] ) ) ; }",0,0,1,1,"output,256,i,1,2","output:0.00843343511223793,256:0.003130728378891945,i:0.021795698441565037,1:0.0013292115181684494,2:0.00206882506608963,",1,8,"i:Ġout,"
"static int config_props(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; AVFilterLink *inlink = outlink->src->inputs[0]; ScaleContext *scale = ctx->priv; int64_t w, h; if (!(w = scale->w)) w = inlink->w; if (!(h = scale->h)) h = inlink->h; if (w == -1) w = av_rescale(h, inlink->w, inlink->h); if (h == -1) h = av_rescale(w, inlink->h, inlink->w); if (w > INT_MAX || h > INT_MAX || (h * inlink->w) > INT_MAX || (w * inlink->h) > INT_MAX) av_log(ctx, AV_LOG_ERROR, ""Rescaled value for width or height is too big.\n""); outlink->w = w; outlink->h = h; /* TODO: make algorithm configurable */ scale->sws = sws_getContext(inlink ->w, inlink ->h, inlink ->format, outlink->w, outlink->h, outlink->format, SWS_BILINEAR, NULL, NULL, NULL); av_log(ctx, AV_LOG_INFO, ""w:%d h:%d fmt:%s\n"", outlink->w, outlink->h, av_pix_fmt_descriptors[outlink->format].name); scale->input_is_pal = inlink->format == PIX_FMT_PAL8 || inlink->format == PIX_FMT_BGR4_BYTE || inlink->format == PIX_FMT_RGB4_BYTE || inlink->format == PIX_FMT_BGR8 || inlink->format == PIX_FMT_RGB8; return !scale->sws; }",280,,0,1,,-4,"ctx,inlink,scale,w,h,outlink,sws,input_is_pal",,,,
"static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr, unsigned size) { struct omap_pwt_s *s = (struct omap_pwt_s *) opaque; int offset = addr & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_read8(opaque, addr); } switch (offset) { case 0x00: /* FRC */ return s->frc; case 0x04: /* VCR */ return s->vrc; case 0x08: /* GCR */ return s->gcr; } OMAP_BAD_REG(addr); return 0; }",89,"static uint64_t omap_pwt_read ( void * opaque , target_phys_addr_t addr , unsigned size ) { struct omap_pwt_s * Ġaddresses = ( struct omap_pwt_s * ) opaque ; int Ġaddr = addr & omap_mpui_reg_mask ; if ( size != 1 ) { return omap_badwidth_read8 ( opaque , addr ) ; } switch ( Ġaddr ) { case 0x00 : return Ġaddresses -> frc ; case 0x04 : return Ġaddresses -> vrc ; case 0x08 : return Ġaddresses -> gcr ; } omap_bad_reg ( addr ) ; return 0 ; }",0,0,0,-1,"s,offset","s:0.00014848727732896805,offset:0.0026023555546998978,",2,6,"offset:Ġaddr,s:Ġaddresses,"
"uint32_t lduw_be_phys(target_phys_addr_t addr) { return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN); }",16,,0,0,,-3,,,,,
static int find_stream_index(AVFormatContext *s) { int i; AVStream *st; if (s->nb_streams <= 0) return -1; for(i = 0; i < s->nb_streams; i++) { st = s->streams[i]; if (st->codec.codec_type == CODEC_TYPE_VIDEO) { return i; } } return 0; },72,static int find_stream_index ( avformatcontext * s ) { int Ġbi ; avstream * st ; if ( s -> nb_streams <= 0 ) return -1 ; for ( Ġbi = 0 ; Ġbi < s -> nb_streams ; Ġbi ++ ) { st = s -> streams [ Ġbi ] ; if ( st -> codec . codec_type == codec_type_video ) { return Ġbi ; } } return 0 ; },0,0,1,1,"i,st","i:0.8553094267845154,st:0.47799181938171387,",1,6,"i:Ġbi,"
"gen_intermediate_code_internal(MIPSCPU *cpu, TranslationBlock *tb, bool search_pc) { CPUState *cs = CPU(cpu); CPUMIPSState *env = &cpu->env; DisasContext ctx; target_ulong pc_start; uint16_t *gen_opc_end; CPUBreakpoint *bp; int j, lj = -1; int num_insns; int max_insns; int insn_bytes; int is_branch; if (search_pc) qemu_log(""search pc %d\n"", search_pc); pc_start = tb->pc; gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE; ctx.pc = pc_start; ctx.saved_pc = -1; ctx.singlestep_enabled = cs->singlestep_enabled; ctx.insn_flags = env->insn_flags; ctx.tb = tb; ctx.bstate = BS_NONE; /* Restore delay slot state from the tb context. */ ctx.hflags = (uint32_t)tb->flags; /* FIXME: maybe use 64 bits here? */ restore_cpu_state(env, &ctx); #ifdef CONFIG_USER_ONLY ctx.mem_idx = MIPS_HFLAG_UM; #else ctx.mem_idx = ctx.hflags & MIPS_HFLAG_KSU; #endif num_insns = 0; max_insns = tb->cflags & CF_COUNT_MASK; if (max_insns == 0) max_insns = CF_COUNT_MASK; LOG_DISAS(""\ntb %p idx %d hflags %04x\n"", tb, ctx.mem_idx, ctx.hflags); gen_tb_start(); while (ctx.bstate == BS_NONE) { if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) { QTAILQ_FOREACH(bp, &env->breakpoints, entry) { if (bp->pc == ctx.pc) { save_cpu_state(&ctx, 1); ctx.bstate = BS_BRANCH; gen_helper_0e0i(raise_exception, EXCP_DEBUG); /* Include the breakpoint location or the tb won't * be flushed when it must be. */ ctx.pc += 4; goto done_generating; } } } if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; if (lj < j) { lj++; while (lj < j) tcg_ctx.gen_opc_instr_start[lj++] = 0; } tcg_ctx.gen_opc_pc[lj] = ctx.pc; gen_opc_hflags[lj] = ctx.hflags & MIPS_HFLAG_BMASK; gen_opc_btarget[lj] = ctx.btarget; tcg_ctx.gen_opc_instr_start[lj] = 1; tcg_ctx.gen_opc_icount[lj] = num_insns; } if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) gen_io_start(); is_branch = 0; if (!(ctx.hflags & MIPS_HFLAG_M16)) { ctx.opcode = cpu_ldl_code(env, ctx.pc); insn_bytes = 4; decode_opc(env, &ctx, &is_branch); } else if (ctx.insn_flags & ASE_MICROMIPS) { ctx.opcode = cpu_lduw_code(env, ctx.pc); insn_bytes = decode_micromips_opc(env, &ctx, &is_branch); } else if (ctx.insn_flags & ASE_MIPS16) { ctx.opcode = cpu_lduw_code(env, ctx.pc); insn_bytes = decode_mips16_opc(env, &ctx, &is_branch); } else { generate_exception(&ctx, EXCP_RI); ctx.bstate = BS_STOP; break; } if (!is_branch) { handle_delay_slot(&ctx, insn_bytes); } ctx.pc += insn_bytes; num_insns++; /* Execute a branch and its delay slot as a single instruction. This is what GDB expects and is consistent with what the hardware does (e.g. if a delay slot instruction faults, the reported PC is the PC of the branch). */ if (cs->singlestep_enabled && (ctx.hflags & MIPS_HFLAG_BMASK) == 0) { break; } if ((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) break; if (tcg_ctx.gen_opc_ptr >= gen_opc_end) { break; } if (num_insns >= max_insns) break; if (singlestep) break; } if (tb->cflags & CF_LAST_IO) { gen_io_end(); } if (cs->singlestep_enabled && ctx.bstate != BS_BRANCH) { save_cpu_state(&ctx, ctx.bstate == BS_NONE); gen_helper_0e0i(raise_exception, EXCP_DEBUG); } else { switch (ctx.bstate) { case BS_STOP: gen_goto_tb(&ctx, 0, ctx.pc); break; case BS_NONE: save_cpu_state(&ctx, 0); gen_goto_tb(&ctx, 0, ctx.pc); break; case BS_EXCP: tcg_gen_exit_tb(0); break; case BS_BRANCH: default: break; } } done_generating: gen_tb_end(tb, num_insns); *tcg_ctx.gen_opc_ptr = INDEX_op_end; if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; lj++; while (lj <= j) tcg_ctx.gen_opc_instr_start[lj++] = 0; } else { tb->size = ctx.pc - pc_start; tb->icount = num_insns; } #ifdef DEBUG_DISAS LOG_DISAS(""\n""); if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log(""IN: %s\n"", lookup_symbol(pc_start)); log_target_disas(env, pc_start, ctx.pc - pc_start, 0); qemu_log(""\n""); } #endif }",877,,1,0,,-4,"cs,env,lj,pc_start,gen_opc_end,ctx,pc,saved_pc,singlestep_enabled,insn_flags,tb,bstate,hflags,mem_idx,num_insns,max_insns,j,tcg_ctx,gen_opc_instr_start,gen_opc_pc,gen_opc_hflags,gen_opc_btarget,gen_opc_icount,is_branch,opcode,insn_bytes,gen_opc_ptr,size,icount",,,,
"static void parse_type_bool(Visitor *v, const char *name, bool *obj, Error **errp) { StringInputVisitor *siv = to_siv(v); if (siv->string) { if (!strcasecmp(siv->string, ""on"") || !strcasecmp(siv->string, ""yes"") || !strcasecmp(siv->string, ""true"")) { *obj = true; return; } if (!strcasecmp(siv->string, ""off"") || !strcasecmp(siv->string, ""no"") || !strcasecmp(siv->string, ""false"")) { *obj = false; return; } } error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"", ""boolean""); }",146,"static void parse_type_bool ( visitor * v , const char * name , bool * obj , error * * errp ) { stringinputvisitor * eserv = to_siv ( v ) ; if ( eserv -> string ) { if ( ! strcasecmp ( eserv -> string , "" "" ) || ! strcasecmp ( eserv -> string , "" "" ) || ! strcasecmp ( eserv -> string , "" "" ) ) { * obj = true ; return ; } if ( ! strcasecmp ( eserv -> string , "" "" ) || ! strcasecmp ( eserv -> string , "" "" ) || ! strcasecmp ( eserv -> string , "" "" ) ) { * obj = false ; return ; } } error_setg ( errp , qerr_invalid_parameter_type , name ? name : "" "" , "" "" ) ; }",1,1,0,1,siv,"siv:0.9832558333873749,",1,8,"siv:eserv,"
"void ff_rtsp_undo_setup(AVFormatContext *s) { RTSPState *rt = s->priv_data; int i; for (i = 0; i < rt->nb_rtsp_streams; i++) { RTSPStream *rtsp_st = rt->rtsp_streams[i]; if (!rtsp_st) continue; if (rtsp_st->transport_priv) { if (s->oformat) { AVFormatContext *rtpctx = rtsp_st->transport_priv; av_write_trailer(rtpctx); if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) { uint8_t *ptr; url_close_dyn_buf(rtpctx->pb, &ptr); av_free(ptr); } else { url_fclose(rtpctx->pb); } av_metadata_free(&rtpctx->streams[0]->metadata); av_metadata_free(&rtpctx->metadata); av_free(rtpctx->streams[0]); av_free(rtpctx); } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st->transport_priv); else if (CONFIG_RTPDEC) rtp_parse_close(rtsp_st->transport_priv); } rtsp_st->transport_priv = NULL; if (rtsp_st->rtp_handle) url_close(rtsp_st->rtp_handle); rtsp_st->rtp_handle = NULL; } }",214,"void ff_rtsp_undo_setup ( avformatcontext * s ) { rtspstate * addr = s -> priv_data ; int info ; for ( info = 0 ; info < addr -> nb_rtsp_streams ; info ++ ) { rtspstream * rtsp_st = addr -> rtsp_streams [ info ] ; if ( ! rtsp_st ) continue ; if ( rtsp_st -> transport_priv ) { if ( s -> oformat ) { avformatcontext * rtpctx = rtsp_st -> transport_priv ; av_write_trailer ( rtpctx ) ; if ( addr -> lower_transport == rtsp_lower_transport_tcp ) { uint8_t * ptr ; url_close_dyn_buf ( rtpctx -> pb , & ptr ) ; av_free ( ptr ) ; } else { url_fclose ( rtpctx -> pb ) ; } av_metadata_free ( & rtpctx -> streams [ 0 ] -> metadata ) ; av_metadata_free ( & rtpctx -> metadata ) ; av_free ( rtpctx -> streams [ 0 ] ) ; av_free ( rtpctx ) ; } else if ( addr -> transport == rtsp_transport_rdt && config_rtpdec ) ff_rdt_parse_close ( rtsp_st -> transport_priv ) ; else if ( config_rtpdec ) rtp_parse_close ( rtsp_st -> transport_priv ) ; } rtsp_st -> transport_priv = null ; if ( rtsp_st -> rtp_handle ) url_close ( rtsp_st -> rtp_handle ) ; rtsp_st -> rtp_handle = null ; } }",1,1,0,1,"rt,i,rtsp_st,rtpctx,transport_priv,rtp_handle","rt:-0.10181182622909546,i:-0.1654401421546936,rtsp_st:-0.40975749492645264,rtpctx:-0.19842320680618286,transport_priv:-0.023943066596984863,rtp_handle:-0.09805643558502197,",2,10,"rt:addr,i:info,"
"static void musb_rx_req(MUSBState *s, int epnum) { MUSBEndPoint *ep = s->ep + epnum; int total; /* If we already have a packet, which didn't fit into the * 64 bytes of the FIFO, only move the FIFO start and return. (Obsolete) */ if (ep->packey[1].p.pid == USB_TOKEN_IN && ep->status[1] >= 0 && (ep->fifostart[1]) + ep->rxcount < ep->packey[1].p.len) { TRACE(""0x%08x, %d"", ep->fifostart[1], ep->rxcount ); ep->fifostart[1] += ep->rxcount; ep->fifolen[1] = 0; ep->rxcount = MIN(ep->packey[0].p.len - (ep->fifostart[1]), ep->maxp[1]); ep->csr[1] &= ~MGC_M_RXCSR_H_REQPKT; if (!epnum) ep->csr[0] &= ~MGC_M_CSR0_H_REQPKT; /* Clear all of the error bits first */ ep->csr[1] &= ~(MGC_M_RXCSR_H_ERROR | MGC_M_RXCSR_H_RXSTALL | MGC_M_RXCSR_DATAERROR); if (!epnum) ep->csr[0] &= ~(MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL | MGC_M_CSR0_H_NAKTIMEOUT | MGC_M_CSR0_H_NO_PING); ep->csr[1] |= MGC_M_RXCSR_FIFOFULL | MGC_M_RXCSR_RXPKTRDY; if (!epnum) ep->csr[0] |= MGC_M_CSR0_RXPKTRDY; musb_rx_intr_set(s, epnum, 1); return; } /* The driver sets maxp[1] to 64 or less because it knows the hardware * FIFO is this deep. Bigger packets get split in * usb_generic_handle_packet but we can also do the splitting locally * for performance. It turns out we can also have a bigger FIFO and * ignore the limit set in ep->maxp[1]. The Linux MUSB driver deals * OK with single packets of even 32KB and we avoid splitting, however * usb_msd.c sometimes sends a packet bigger than what Linux expects * (e.g. 8192 bytes instead of 4096) and we get an OVERRUN. Splitting * hides this overrun from Linux. Up to 4096 everything is fine * though. Currently this is disabled. * * XXX: mind ep->fifosize. */ total = MIN(ep->maxp[1] & 0x3ff, sizeof(s->buf)); #ifdef SETUPLEN_HACK /* Why should *we* do that instead of Linux? */ if (!epnum) { if (ep->packey[0].p.devaddr == 2) { total = MIN(s->setup_len, 8); } else { total = MIN(s->setup_len, 64); } s->setup_len -= total; } #endif return musb_packet(s, ep, epnum, USB_TOKEN_IN, total, musb_rx_packet_complete, 1); }",344,"static void musb_rx_req ( musbstate * Ġs , int epnum ) { musbendpoint * Ġe = Ġs -> Ġe + epnum ; int ptr ; if ( Ġe -> packey [ host ] . p . pid == usb_token_in && Ġe -> status [ host ] >= 9 && ( Ġe -> infostet [ host ] ) + Ġe -> rxcount < Ġe -> packey [ host ] . p . len ) { trace ( "" "" , Ġe -> infostet [ host ] , Ġe -> rxcount ) ; Ġe -> infostet [ host ] += Ġe -> rxcount ; Ġe -> fifos [ host ] = 9 ; Ġe -> rxcount = min ( Ġe -> packey [ 9 ] . p . len - ( Ġe -> infostet [ host ] ) , Ġe -> maxp [ host ] ) ; Ġe -> ccrc [ host ] &= ~ mgc_m_rxcsr_h_reqpkt ; if ( ! epnum ) Ġe -> ccrc [ 9 ] &= ~ mgc_m_csr0_h_reqpkt ; Ġe -> ccrc [ host ] &= ~ ( mgc_m_rxcsr_h_error | mgc_m_rxcsr_h_rxstall | mgc_m_rxcsr_dataerror ) ; if ( ! epnum ) Ġe -> ccrc [ 9 ] &= ~ ( mgc_m_csr0_h_error | mgc_m_csr0_h_rxstall | mgc_m_csr0_h_naktimeout | mgc_m_csr0_h_no_ping ) ; Ġe -> ccrc [ host ] |= mgc_m_rxcsr_fifofull | mgc_m_rxcsr_rxpktrdy ; if ( ! epnum ) Ġe -> ccrc [ 9 ] |= mgc_m_csr0_rxpktrdy ; musb_rx_intr_set ( Ġs , epnum , host ) ; return ; } ptr = min ( Ġe -> maxp [ host ] & 0x3ff , sizeof ( Ġs -> buf ) ) ; #ifdef setuplen_hack if ( ! epnum ) { if ( Ġe -> packey [ 9 ] . p . devaddr == 2 ) { ptr = min ( Ġs -> setup_len , 8 ) ; } else { ptr = min ( Ġs -> setup_len , 64 ) ; } Ġs -> setup_len -= ptr ; } #endif return musb_packet ( Ġs , Ġe , epnum , usb_token_in , ptr , musb_rx_packet_complete , host ) ; }",1,1,0,1,"ep,fifostart,1,fifolen,rxcount,csr,0,total,s,setup_len","ep:0.01882338523864746,fifostart:0.002552807331085205,1:0.004747331142425537,fifolen:-2.2590160369873047e-05,rxcount:0.0051811933517456055,csr:0.0014296174049377441,0:0.003639817237854004,total:0.0014497637748718262,s:0.013007402420043945,setup_len:0.0005898475646972656,",8,72,"ep:Ġe,s:Ġs,1:host,0:9,fifostart:infostet,total:ptr,csr:ccrc,fifolen:fifos,"
"static uint64_t sp804_read(void *opaque, target_phys_addr_t offset, unsigned size) { sp804_state *s = (sp804_state *)opaque; if (offset < 0x20) { return arm_timer_read(s->timer[0], offset); } if (offset < 0x40) { return arm_timer_read(s->timer[1], offset - 0x20); } /* TimerPeriphID */ if (offset >= 0xfe0 && offset <= 0xffc) { return sp804_ids[(offset - 0xfe0) >> 2]; } switch (offset) { /* Integration Test control registers, which we won't support */ case 0xf00: /* TimerITCR */ case 0xf04: /* TimerITOP (strictly write only but..) */ return 0; } hw_error(""%s: Bad offset %x\n"", __func__, (int)offset); return 0; }",126,"static uint64_t sp804_read ( void * opaque , target_phys_addr_t offset , unsigned size ) { sp804_state * Ġs = ( sp804_state * ) opaque ; if ( offset < 0x20 ) { return arm_timer_read ( Ġs -> timer [ 0 ] , offset ) ; } if ( offset < 0x40 ) { return arm_timer_read ( Ġs -> timer [ 1 ] , offset - 0x20 ) ; } if ( offset >= 0xfe0 && offset <= 0xffc ) { return sp804_ids [ ( offset - 0xfe0 ) >> 2 ] ; } switch ( offset ) { case 0xf00 : case 0xf04 : return 0 ; } hw_error ( "" \n "" , __func__ , ( int ) offset ) ; return 0 ; }",0,0,0,-1,s,"s:0.0008208607323467731,",1,3,"s:Ġs,"
static void timerlist_rearm(QEMUTimerList *timer_list) { /* Interrupt execution to force deadline recalculation. */ if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) { qemu_start_warp_timer(); } timerlist_notify(timer_list); },31,,0,0,,-3,,,,,
"CharDriverState *text_console_init(DisplayState *ds, const char *p) { CharDriverState *chr; TextConsole *s; unsigned width; unsigned height; static int color_inited; chr = qemu_mallocz(sizeof(CharDriverState)); if (!chr) return NULL; s = new_console(ds, TEXT_CONSOLE); if (!s) { free(chr); return NULL; } if (!p) p = DEFAULT_MONITOR_SIZE; chr->opaque = s; chr->chr_write = console_puts; chr->chr_send_event = console_send_event; s->chr = chr; s->out_fifo.buf = s->out_fifo_buf; s->out_fifo.buf_size = sizeof(s->out_fifo_buf); s->kbd_timer = qemu_new_timer(rt_clock, kbd_send_chars, s); if (!color_inited) { color_inited = 1; console_color_init(s->ds); } s->y_displayed = 0; s->y_base = 0; s->total_height = DEFAULT_BACKSCROLL; s->x = 0; s->y = 0; width = s->ds->width; height = s->ds->height; if (p != 0) { width = strtoul(p, (char **)&p, 10); if (*p == 'C') { p++; width *= FONT_WIDTH; } if (*p == 'x') { p++; height = strtoul(p, (char **)&p, 10); if (*p == 'C') { p++; height *= FONT_HEIGHT; } } } s->g_width = width; s->g_height = height; s->hw_invalidate = text_console_invalidate; s->hw_text_update = text_console_update; s->hw = s; /* Set text attribute defaults */ s->t_attrib_default.bold = 0; s->t_attrib_default.uline = 0; s->t_attrib_default.blink = 0; s->t_attrib_default.invers = 0; s->t_attrib_default.unvisible = 0; s->t_attrib_default.fgcol = COLOR_WHITE; s->t_attrib_default.bgcol = COLOR_BLACK; /* set current text attributes to default */ s->t_attrib = s->t_attrib_default; text_console_resize(s); qemu_chr_reset(chr); return chr; }",404,"chardriverstate * text_console_init ( displaystate * ds , const char * p ) { chardriverstate * chr ; textconsole * s ; unsigned width ; unsigned height ; static int color_inited ; chr = qemu_mallocz ( sizeof ( chardriverstate ) ) ; if ( ! chr ) return null ; s = new_console ( ds , text_console ) ; if ( ! s ) { free ( chr ) ; return null ; } if ( ! p ) p = default_monitor_size ; chr -> opaque = s ; chr -> chr_write = console_puts ; chr -> chr_send_event = console_send_event ; s -> chr = chr ; s -> out_fifo . buf = s -> out_fifo_buf ; s -> out_fifo . buf_size = sizeof ( s -> out_fifo_buf ) ; s -> kbd_clock = qemu_new_timer ( rt_clock , kbd_send_chars , s ) ; if ( ! color_inited ) { color_inited = 1 ; console_color_init ( s -> ds ) ; } s -> y_displayed = 0 ; s -> y_base = 0 ; s -> total_height = default_backscroll ; s -> x = 0 ; s -> y = 0 ; width = s -> ds -> width ; height = s -> ds -> height ; if ( p != 0 ) { width = strtoul ( p , ( char * * ) & p , 10 ) ; if ( * p == ' ' ) { p ++ ; width *= font_width ; } if ( * p == ' ' ) { p ++ ; height = strtoul ( p , ( char * * ) & p , 10 ) ; if ( * p == ' ' ) { p ++ ; height *= font_height ; } } } s -> g_width = width ; s -> g_height = height ; s -> hw_invalidate = text_console_invalidate ; s -> hw_text_update = text_console_update ; s -> hw = s ; s -> t_attrib_default . bold = 0 ; s -> t_attrib_default . uline = 0 ; s -> t_attrib_default . blink = 0 ; s -> t_attrib_default . invers = 0 ; s -> t_attrib_default . unvisible = 0 ; s -> t_attrib_default . fgcol = color_white ; s -> t_attrib_default . bgcol = color_black ; s -> t_attrib = s -> t_attrib_default ; text_console_resize ( s ) ; qemu_chr_reset ( chr ) ; return chr ; }",0,0,1,1,"chr,s,p,opaque,chr_write,chr_send_event,out_fifo,buf,buf_size,kbd_timer,color_inited,y_displayed,y_base,total_height,x,y,width,height,g_width,g_height,hw_invalidate,hw_text_update,hw,t_attrib_default,bold,uline,blink,invers,unvisible,fgcol,bgcol,t_attrib","chr:-0.08999672532081604,s:-0.4931113123893738,p:-0.04959815740585327,opaque:-0.01574331521987915,chr_write:0.009457528591156006,chr_send_event:0.04205584526062012,out_fifo:-0.03108137845993042,buf:-0.03607511520385742,buf_size:-0.06312751770019531,kbd_timer:0.06757158041000366,color_inited:-0.038775861263275146,y_displayed:0.013667702674865723,y_base:0.01598203182220459,total_height:0.041434913873672485,x:-0.01793307065963745,y:-0.021241486072540283,width:-0.10290175676345825,height:-0.11919045448303223,g_width:0.001625657081604004,g_height:0.0014361143112182617,hw_invalidate:4.3511390686035156e-05,hw_text_update:-0.0028314590454101562,hw:-0.0032712221145629883,t_attrib_default:0.002913236618041992,bold:0.010418713092803955,uline:-0.00496596097946167,blink:-0.004966020584106445,invers:-0.004965782165527344,unvisible:-0.004966080188751221,fgcol:-0.004966080188751221,bgcol:-0.004965782165527344,t_attrib:-0.005237281322479248,",1,1,"kbd_timer:kbd_clock,"
"static void tcg_liveness_analysis(TCGContext *s) { uint8_t *dead_temps, *mem_temps; int oi, oi_prev, nb_ops; nb_ops = s->gen_next_op_idx; s->op_dead_args = tcg_malloc(nb_ops * sizeof(uint16_t)); s->op_sync_args = tcg_malloc(nb_ops * sizeof(uint8_t)); dead_temps = tcg_malloc(s->nb_temps); mem_temps = tcg_malloc(s->nb_temps); tcg_la_func_end(s, dead_temps, mem_temps); for (oi = s->gen_last_op_idx; oi >= 0; oi = oi_prev) { int i, nb_iargs, nb_oargs; TCGOpcode opc_new, opc_new2; bool have_opc_new2; uint16_t dead_args; uint8_t sync_args; TCGArg arg; TCGOp * const op = &s->gen_op_buf[oi]; TCGArg * const args = &s->gen_opparam_buf[op->args]; TCGOpcode opc = op->opc; const TCGOpDef *def = &tcg_op_defs[opc]; oi_prev = op->prev; switch (opc) { case INDEX_op_call: { int call_flags; nb_oargs = op->callo; nb_iargs = op->calli; call_flags = args[nb_oargs + nb_iargs + 1]; /* pure functions can be removed if their result is unused */ if (call_flags & TCG_CALL_NO_SIDE_EFFECTS) { for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (!dead_temps[arg] || mem_temps[arg]) { goto do_not_remove_call; } } goto do_remove; } else { do_not_remove_call: /* output args are dead */ dead_args = 0; sync_args = 0; for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (dead_temps[arg]) { dead_args |= (1 << i); } if (mem_temps[arg]) { sync_args |= (1 << i); } dead_temps[arg] = 1; mem_temps[arg] = 0; } if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) { /* globals should be synced to memory */ memset(mem_temps, 1, s->nb_globals); } if (!(call_flags & (TCG_CALL_NO_WRITE_GLOBALS | TCG_CALL_NO_READ_GLOBALS))) { /* globals should go back to memory */ memset(dead_temps, 1, s->nb_globals); } /* input args are live */ for (i = nb_oargs; i < nb_iargs + nb_oargs; i++) { arg = args[i]; if (arg != TCG_CALL_DUMMY_ARG) { if (dead_temps[arg]) { dead_args |= (1 << i); } dead_temps[arg] = 0; } } s->op_dead_args[oi] = dead_args; s->op_sync_args[oi] = sync_args; } } break; case INDEX_op_debug_insn_start: break; case INDEX_op_discard: /* mark the temporary as dead */ dead_temps[args[0]] = 1; mem_temps[args[0]] = 0; break; case INDEX_op_add2_i32: opc_new = INDEX_op_add_i32; goto do_addsub2; case INDEX_op_sub2_i32: opc_new = INDEX_op_sub_i32; goto do_addsub2; case INDEX_op_add2_i64: opc_new = INDEX_op_add_i64; goto do_addsub2; case INDEX_op_sub2_i64: opc_new = INDEX_op_sub_i64; do_addsub2: nb_iargs = 4; nb_oargs = 2; /* Test if the high part of the operation is dead, but not the low part. The result can be optimized to a simple add or sub. This happens often for x86_64 guest when the cpu mode is set to 32 bit. */ if (dead_temps[args[1]] && !mem_temps[args[1]]) { if (dead_temps[args[0]] && !mem_temps[args[0]]) { goto do_remove; } /* Replace the opcode and adjust the args in place, leaving 3 unused args at the end. */ op->opc = opc = opc_new; args[1] = args[2]; args[2] = args[4]; /* Fall through and mark the single-word operation live. */ nb_iargs = 2; nb_oargs = 1; } goto do_not_remove; case INDEX_op_mulu2_i32: opc_new = INDEX_op_mul_i32; opc_new2 = INDEX_op_muluh_i32; have_opc_new2 = TCG_TARGET_HAS_muluh_i32; goto do_mul2; case INDEX_op_muls2_i32: opc_new = INDEX_op_mul_i32; opc_new2 = INDEX_op_mulsh_i32; have_opc_new2 = TCG_TARGET_HAS_mulsh_i32; goto do_mul2; case INDEX_op_mulu2_i64: opc_new = INDEX_op_mul_i64; opc_new2 = INDEX_op_muluh_i64; have_opc_new2 = TCG_TARGET_HAS_muluh_i64; goto do_mul2; case INDEX_op_muls2_i64: opc_new = INDEX_op_mul_i64; opc_new2 = INDEX_op_mulsh_i64; have_opc_new2 = TCG_TARGET_HAS_mulsh_i64; goto do_mul2; do_mul2: nb_iargs = 2; nb_oargs = 2; if (dead_temps[args[1]] && !mem_temps[args[1]]) { if (dead_temps[args[0]] && !mem_temps[args[0]]) { /* Both parts of the operation are dead. */ goto do_remove; } /* The high part of the operation is dead; generate the low. */ op->opc = opc = opc_new; args[1] = args[2]; args[2] = args[3]; } else if (have_opc_new2 && dead_temps[args[0]] && !mem_temps[args[0]]) { /* The low part of the operation is dead; generate the high. */ op->opc = opc = opc_new2; args[0] = args[1]; args[1] = args[2]; args[2] = args[3]; } else { goto do_not_remove; } /* Mark the single-word operation live. */ nb_oargs = 1; goto do_not_remove; default: /* XXX: optimize by hardcoding common cases (e.g. triadic ops) */ nb_iargs = def->nb_iargs; nb_oargs = def->nb_oargs; /* Test if the operation can be removed because all its outputs are dead. We assume that nb_oargs == 0 implies side effects */ if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) { for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (!dead_temps[arg] || mem_temps[arg]) { goto do_not_remove; } } do_remove: tcg_op_remove(s, op); } else { do_not_remove: /* output args are dead */ dead_args = 0; sync_args = 0; for (i = 0; i < nb_oargs; i++) { arg = args[i]; if (dead_temps[arg]) { dead_args |= (1 << i); } if (mem_temps[arg]) { sync_args |= (1 << i); } dead_temps[arg] = 1; mem_temps[arg] = 0; } /* if end of basic block, update */ if (def->flags & TCG_OPF_BB_END) { tcg_la_bb_end(s, dead_temps, mem_temps); } else if (def->flags & TCG_OPF_SIDE_EFFECTS) { /* globals should be synced to memory */ memset(mem_temps, 1, s->nb_globals); } /* input args are live */ for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) { arg = args[i]; if (dead_temps[arg]) { dead_args |= (1 << i); } dead_temps[arg] = 0; } s->op_dead_args[oi] = dead_args; s->op_sync_args[oi] = sync_args; } break; } } }",1137,"static void tcg_liveness_analysis ( tcgcontext * s ) { uint8_t * dead_templ , * mem_timPS ; int oi , oi_prev , nb_ops ; nb_ops = s -> gen_next_op_idx ; s -> op_dead_args = tcg_malloc ( nb_ops * sizeof ( uint16_t ) ) ; s -> op_sync_args = tcg_malloc ( nb_ops * sizeof ( uint8_t ) ) ; dead_templ = tcg_malloc ( s -> nb_temps ) ; mem_timPS = tcg_malloc ( s -> nb_temps ) ; tcg_la_func_end ( s , dead_templ , mem_timPS ) ; for ( oi = s -> gen_last_op_idx ; oi >= 0 ; oi = oi_prev ) { int m , nb_igs , nb_igs ; tcgopcode opc_new , opc_new2 ; bool have_opc_new2 ; uint16_t dead_args ; uint8_t sync_args ; tcgarg op ; tcgop * const op = & s -> gen_op_buf [ oi ] ; tcgarg * const args = & s -> gen_opparam_buf [ op -> args ] ; tcgopcode opc = op -> opc ; const tcgopdef * def = & tcg_op_defs [ opc ] ; oi_prev = op -> prev ; switch ( opc ) { case index_op_call : { int call_flags ; nb_igs = op -> callo ; nb_igs = op -> calli ; call_flags = args [ nb_igs + nb_igs + 1 ] ; if ( call_flags & tcg_call_no_side_effects ) { for ( m = 0 ; m < nb_igs ; m ++ ) { op = args [ m ] ; if ( ! dead_templ [ op ] || mem_timPS [ op ] ) { goto do_not_remove_call ; } } goto do_remove ; } else { do_not_remove_call : dead_args = 0 ; sync_args = 0 ; for ( m = 0 ; m < nb_igs ; m ++ ) { op = args [ m ] ; if ( dead_templ [ op ] ) { dead_args |= ( 1 << m ) ; } if ( mem_timPS [ op ] ) { sync_args |= ( 1 << m ) ; } dead_templ [ op ] = 1 ; mem_timPS [ op ] = 0 ; } if ( ! ( call_flags & tcg_call_no_read_globals ) ) { memset ( mem_timPS , 1 , s -> nb_globals ) ; } if ( ! ( call_flags & ( tcg_call_no_write_globals | tcg_call_no_read_globals ) ) ) { memset ( dead_templ , 1 , s -> nb_globals ) ; } for ( m = nb_igs ; m < nb_igs + nb_igs ; m ++ ) { op = args [ m ] ; if ( op != tcg_call_dummy_arg ) { if ( dead_templ [ op ] ) { dead_args |= ( 1 << m ) ; } dead_templ [ op ] = 0 ; } } s -> op_dead_args [ oi ] = dead_args ; s -> op_sync_args [ oi ] = sync_args ; } } break ; case index_op_debug_insn_start : break ; case index_op_discard : dead_templ [ args [ 0 ] ] = 1 ; mem_timPS [ args [ 0 ] ] = 0 ; break ; case index_op_add2_i32 : opc_new = index_op_add_i32 ; goto do_addsub2 ; case index_op_sub2_i32 : opc_new = index_op_sub_i32 ; goto do_addsub2 ; case index_op_add2_i64 : opc_new = index_op_add_i64 ; goto do_addsub2 ; case index_op_sub2_i64 : opc_new = index_op_sub_i64 ; do_addsub2 : nb_igs = 4 ; nb_igs = 2 ; if ( dead_templ [ args [ 1 ] ] && ! mem_timPS [ args [ 1 ] ] ) { if ( dead_templ [ args [ 0 ] ] && ! mem_timPS [ args [ 0 ] ] ) { goto do_remove ; } op -> opc = opc = opc_new ; args [ 1 ] = args [ 2 ] ; args [ 2 ] = args [ 4 ] ; nb_igs = 2 ; nb_igs = 1 ; } goto do_not_remove ; case index_op_mulu2_i32 : opc_new = index_op_mul_i32 ; opc_new2 = index_op_muluh_i32 ; have_opc_new2 = tcg_target_has_muluh_i32 ; goto do_mul2 ; case index_op_muls2_i32 : opc_new = index_op_mul_i32 ; opc_new2 = index_op_mulsh_i32 ; have_opc_new2 = tcg_target_has_mulsh_i32 ; goto do_mul2 ; case index_op_mulu2_i64 : opc_new = index_op_mul_i64 ; opc_new2 = index_op_muluh_i64 ; have_opc_new2 = tcg_target_has_muluh_i64 ; goto do_mul2 ; case index_op_muls2_i64 : opc_new = index_op_mul_i64 ; opc_new2 = index_op_mulsh_i64 ; have_opc_new2 = tcg_target_has_mulsh_i64 ; goto do_mul2 ; do_mul2 : nb_igs = 2 ; nb_igs = 2 ; if ( dead_templ [ args [ 1 ] ] && ! mem_timPS [ args [ 1 ] ] ) { if ( dead_templ [ args [ 0 ] ] && ! mem_timPS [ args [ 0 ] ] ) { goto do_remove ; } op -> opc = opc = opc_new ; args [ 1 ] = args [ 2 ] ; args [ 2 ] = args [ 3 ] ; } else if ( have_opc_new2 && dead_templ [ args [ 0 ] ] && ! mem_timPS [ args [ 0 ] ] ) { op -> opc = opc = opc_new2 ; args [ 0 ] = args [ 1 ] ; args [ 1 ] = args [ 2 ] ; args [ 2 ] = args [ 3 ] ; } else { goto do_not_remove ; } nb_igs = 1 ; goto do_not_remove ; default : nb_igs = def -> nb_igs ; nb_igs = def -> nb_igs ; if ( ! ( def -> flags & tcg_opf_side_effects ) && nb_igs != 0 ) { for ( m = 0 ; m < nb_igs ; m ++ ) { op = args [ m ] ; if ( ! dead_templ [ op ] || mem_timPS [ op ] ) { goto do_not_remove ; } } do_remove : tcg_op_remove ( s , op ) ; } else { do_not_remove : dead_args = 0 ; sync_args = 0 ; for ( m = 0 ; m < nb_igs ; m ++ ) { op = args [ m ] ; if ( dead_templ [ op ] ) { dead_args |= ( 1 << m ) ; } if ( mem_timPS [ op ] ) { sync_args |= ( 1 << m ) ; } dead_templ [ op ] = 1 ; mem_timPS [ op ] = 0 ; } if ( def -> flags & tcg_opf_bb_end ) { tcg_la_bb_end ( s , dead_templ , mem_timPS ) ; } else if ( def -> flags & tcg_opf_side_effects ) { memset ( mem_timPS , 1 , s -> nb_globals ) ; } for ( m = nb_igs ; m < nb_igs + nb_igs ; m ++ ) { op = args [ m ] ; if ( dead_templ [ op ] ) { dead_args |= ( 1 << m ) ; } dead_templ [ op ] = 0 ; } s -> op_dead_args [ oi ] = dead_args ; s -> op_sync_args [ oi ] = sync_args ; } break ; } } }",0,0,1,1,"nb_ops,s,op_dead_args,op_sync_args,dead_temps,mem_temps,oi,op,args,opc,def,oi_prev,nb_oargs,nb_iargs,call_flags,i,arg,dead_args,sync_args,0,opc_new,1,2,opc_new2,have_opc_new2","nb_ops:4.5299530029296875e-06,s:-0.10931795835494995,op_dead_args:0.018082231283187866,op_sync_args:0.004381418228149414,dead_temps:0.023274779319763184,mem_temps:0.04081535339355469,oi:-0.005479961633682251,op:-0.030938327312469482,args:0.016395777463912964,opc:-0.018987983465194702,def:-0.04327687621116638,oi_prev:-0.010370314121246338,nb_oargs:0.027791976928710938,nb_iargs:0.024925559759140015,call_flags:0.009046435356140137,i:0.026568949222564697,arg:0.03498232364654541,dead_args:-0.01437842845916748,sync_args:0.0018810629844665527,0:-0.002494722604751587,opc_new:0.0004050135612487793,1:-0.010594099760055542,2:2.4586915969848633e-05,opc_new2:-0.008803308010101318,have_opc_new2:0.0041787028312683105,",6,122,"mem_temps:mem_timPS,arg:op,nb_oargs:nb_igs,i:m,nb_iargs:nb_igs,dead_temps:dead_templ,"
"bool error_is_type(Error *err, const char *fmt) { const char *error_class; char *ptr; char *end; if (!err) { return false; } ptr = strstr(fmt, ""'class': '""); assert(ptr != NULL); ptr += strlen(""'class': '""); end = strchr(ptr, '\''); assert(end != NULL); error_class = error_get_field(err, ""class""); if (strlen(error_class) != end - ptr) { return false; } return strncmp(ptr, error_class, end - ptr) == 0; }",120,,0,1,,-4,"ptr,end,error_class",,,,
"static inline int onenand_load_main(OneNANDState *s, int sec, int secn, void *dest) { if (s->bdrv_cur) return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0; else if (sec + secn > s->secs_cur) return 1; memcpy(dest, s->current + (sec << 9), secn << 9); return 0; }",79,,0,0,,-3,,,,,
"static void generate_offset_lut(DiracGolombLUT *lut, int off) { int idx; for (idx = 0; idx < LUT_SIZE; idx++) { DiracGolombLUT *l = &lut[idx]; INIT_RESIDUE(res); SET_RESIDUE(res, idx, LUT_BITS); l->preamble = CONVERT_TO_RESIDUE(res >> (RSIZE_BITS - off), off); l->preamble_bits = off; l->sign = ((l->preamble >> (RSIZE_BITS - l->preamble_bits)) & 1) ? -1 : +1; search_for_golomb(l, res << off, LUT_BITS - off); } }",117,"static void generate_offset_lut ( diracgolomblut * lut , int off ) { int indxs ; for ( indxs = 0 ; indxs < lut_size ; indxs ++ ) { diracgolomblut * lp = & lut [ indxs ] ; init_residue ( res ) ; set_residue ( res , indxs , lut_bits ) ; lp -> prambles = convert_to_residue ( res >> ( rsize_bits - off ) , off ) ; lp -> preamble_bits = off ; lp -> angle = ( ( lp -> prambles >> ( rsize_bits - lp -> preamble_bits ) ) & 1 ) ? -1 : +1 ; search_for_golomb ( lp , res << off , lut_bits - off ) ; } }",1,1,0,1,"idx,l,preamble,preamble_bits,sign","idx:-0.10607850551605225,l:-0.5517738461494446,preamble:-0.052999794483184814,preamble_bits:-0.1309678554534912,sign:-0.057923197746276855,",4,16,"preamble:prambles,sign:angle,idx:indxs,l:lp,"
"vmxnet3_pop_next_tx_descr(VMXNET3State *s, int qidx, struct Vmxnet3_TxDesc *txd, uint32_t *descr_idx) { Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring; PCIDevice *d = PCI_DEVICE(s); vmxnet3_ring_read_curr_cell(d, ring, txd); if (txd->gen == vmxnet3_ring_curr_gen(ring)) { /* Only read after generation field verification */ smp_rmb(); /* Re-read to be sure we got the latest version */ vmxnet3_ring_read_curr_cell(d, ring, txd); VMXNET3_RING_DUMP(VMW_RIPRN, ""TX"", qidx, ring); *descr_idx = vmxnet3_ring_curr_cell_idx(ring); vmxnet3_inc_tx_consumption_counter(s, qidx); return true; } return false; }",112,"vmxnet3_pop_next_tx_descr ( vmxnet3state * s , int qidx , struct vmxnet3_txdesc * txd , uint32_t * descr_idx )  { vmxnet3ring * ring = & s -> txq_descr [ qidx ] . tx_ring ; pcidevice * ind = pci_device ( s ) ; vmxnet3_ring_read_curr_cell ( ind , ring , txd ) ; if ( txd -> gen == vmxnet3_ring_curr_gen ( ring ) ) { smp_rmb ( ) ; vmxnet3_ring_read_curr_cell ( ind , ring , txd ) ; vmxnet3_ring_dump ( vmw_riprn , "" "" , qidx , ring ) ; * descr_idx = vmxnet3_ring_curr_cell_idx ( ring ) ; vmxnet3_inc_tx_consumption_counter ( s , qidx ) ; return true ; } return false ; }",1,1,0,1,"ring,d,descr_idx","ring:-0.1011006236076355,d:0.05084657669067383,descr_idx:-0.028385460376739502,",1,3,"d:ind,"
static void init_excp_BookE (CPUPPCState *env) { #if !defined(CONFIG_USER_ONLY) env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000; env->excp_vectors[POWERPC_EXCP_MCHECK] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DSI] = 0x00000000; env->excp_vectors[POWERPC_EXCP_ISI] = 0x00000000; env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000; env->excp_vectors[POWERPC_EXCP_ALIGN] = 0x00000000; env->excp_vectors[POWERPC_EXCP_PROGRAM] = 0x00000000; env->excp_vectors[POWERPC_EXCP_FPU] = 0x00000000; env->excp_vectors[POWERPC_EXCP_SYSCALL] = 0x00000000; env->excp_vectors[POWERPC_EXCP_APU] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DECR] = 0x00000000; env->excp_vectors[POWERPC_EXCP_FIT] = 0x00000000; env->excp_vectors[POWERPC_EXCP_WDT] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DTLB] = 0x00000000; env->excp_vectors[POWERPC_EXCP_ITLB] = 0x00000000; env->excp_vectors[POWERPC_EXCP_DEBUG] = 0x00000000; env->excp_prefix = 0x00000000; env->ivor_mask = 0x0000FFE0; env->ivpr_mask = 0xFFFF0000; /* Hardware reset vector */ env->hreset_vector = 0xFFFFFFFCUL; #endif },187,static void init_excp_mom ( cpuppcstate * env ) { #if ! defined ( config_config_Only ) env - > excp_vectors [ powerpc_excp__conf ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_mcheck ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_dsi ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_isi ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_external ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_align ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_program ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_fpu ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_syscall ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_apu ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_decr ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_fit ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_wdt ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_dtlb ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_itlb ] = 0x00000000 ; env -> excp_vectors [ powerpc_excp_debug ] = 0x00000000 ; env -> excp_prefix = 0x00000000 ; env -> ivor_mask = 0x0000ffe0 ; env -> ivpr_mask = 0xffff0000 ; env -> hreset_vector = 0xfffffffcul ; #endif  } ,1,1,0,1,"init_excp_booke,cpuppcstate,env,config_user_only,excp_vectors,powerpc_excp_critical,powerpc_excp_mcheck,powerpc_excp_dsi,powerpc_excp_isi,powerpc_excp_external,powerpc_excp_align,powerpc_excp_program,powerpc_excp_fpu,powerpc_excp_syscall,powerpc_excp_apu,powerpc_excp_decr,powerpc_excp_fit,powerpc_excp_wdt,powerpc_excp_dtlb,powerpc_excp_itlb,powerpc_excp_debug,excp_prefix,ivor_mask,ivpr_mask,hreset_vector","init_excp_booke:0.10352087020874023,cpuppcstate:0.0256805419921875,env:-0.29122650623321533,config_user_only:0.16901320219039917,excp_vectors:-0.8037079870700836,powerpc_excp_critical:0.3089986741542816,powerpc_excp_mcheck:-0.07038217782974243,powerpc_excp_dsi:-0.1008002758026123,powerpc_excp_isi:-0.040239810943603516,powerpc_excp_external:-0.024582982063293457,powerpc_excp_align:-0.04298257827758789,powerpc_excp_program:-0.035676002502441406,powerpc_excp_fpu:-0.08954513072967529,powerpc_excp_syscall:-0.08677476644515991,powerpc_excp_apu:-0.06538790464401245,powerpc_excp_decr:-0.06389802694320679,powerpc_excp_fit:-0.05824083089828491,powerpc_excp_wdt:-0.10503250360488892,powerpc_excp_dtlb:-0.1319829821586609,powerpc_excp_itlb:-0.09766221046447754,powerpc_excp_debug:-0.03479951620101929,excp_prefix:-0.03082418441772461,ivor_mask:-0.05864834785461426,ivpr_mask:-0.10637545585632324,hreset_vector:-0.021477699279785156,",3,3,"powerpc_excp_critical:powerpc_excp__conf,config_user_only:config_config_Only,init_excp_booke:init_excp_mom,"
"DISAS_INSN(divw) { TCGv reg; TCGv tmp; TCGv src; int sign; sign = (insn & 0x100) != 0; reg = DREG(insn, 9); if (sign) { tcg_gen_ext16s_i32(QREG_DIV1, reg); } else { tcg_gen_ext16u_i32(QREG_DIV1, reg); } SRC_EA(env, src, OS_WORD, sign, NULL); tcg_gen_mov_i32(QREG_DIV2, src); if (sign) { gen_helper_divs(cpu_env, tcg_const_i32(1)); } else { gen_helper_divu(cpu_env, tcg_const_i32(1)); } tmp = tcg_temp_new(); src = tcg_temp_new(); tcg_gen_ext16u_i32(tmp, QREG_DIV1); tcg_gen_shli_i32(src, QREG_DIV2, 16); tcg_gen_or_i32(reg, tmp, src); set_cc_op(s, CC_OP_FLAGS); }",153,,1,0,,-4,"sign,reg,tmp,src",,,,
"static int msrle_decode_8_16_24_32(AVCodecContext *avctx, AVPicture *pic, int depth, const uint8_t *data, int srcsize) { uint8_t *output, *output_end; const uint8_t* src = data; int p1, p2, line=avctx->height, pos=0, i; uint16_t pix16; uint32_t pix32; output = pic->data[0] + (avctx->height - 1) * pic->linesize[0]; output_end = pic->data[0] + (avctx->height) * pic->linesize[0]; while(src < data + srcsize) { p1 = *src++; if(p1 == 0) { //Escape code p2 = *src++; if(p2 == 0) { //End-of-line output = pic->data[0] + (--line) * pic->linesize[0]; if (line < 0){ av_log(avctx, AV_LOG_ERROR, ""Next line is beyond picture bounds\n""); return -1; } pos = 0; continue; } else if(p2 == 1) { //End-of-picture return 0; } else if(p2 == 2) { //Skip p1 = *src++; p2 = *src++; line -= p2; if (line < 0){ av_log(avctx, AV_LOG_ERROR, ""Skip beyond picture bounds\n""); return -1; } pos += p1; output = pic->data[0] + line * pic->linesize[0] + pos * (depth >> 3); continue; } // Copy data if (output + p2 * (depth >> 3) > output_end) { src += p2 * (depth >> 3); continue; } if ((depth == 8) || (depth == 24)) { for(i = 0; i < p2 * (depth >> 3); i++) { *output++ = *src++; } // RLE8 copy is actually padded - and runs are not! if(depth == 8 && (p2 & 1)) { src++; } } else if (depth == 16) { for(i = 0; i < p2; i++) { pix16 = AV_RL16(src); src += 2; *(uint16_t*)output = pix16; output += 2; } } else if (depth == 32) { for(i = 0; i < p2; i++) { pix32 = AV_RL32(src); src += 4; *(uint32_t*)output = pix32; output += 4; } } pos += p2; } else { //Run of pixels uint8_t pix[3]; //original pixel switch(depth){ case 8: pix[0] = *src++; break; case 16: pix16 = AV_RL16(src); src += 2; break; case 24: pix[0] = *src++; pix[1] = *src++; pix[2] = *src++; break; case 32: pix32 = AV_RL32(src); src += 4; break; } if (output + p1 * (depth >> 3) > output_end) continue; for(i = 0; i < p1; i++) { switch(depth){ case 8: *output++ = pix[0]; break; case 16: *(uint16_t*)output = pix16; output += 2; break; case 24: *output++ = pix[0]; *output++ = pix[1]; *output++ = pix[2]; break; case 32: *(uint32_t*)output = pix32; output += 4; break; } } pos += p1; } } av_log(avctx, AV_LOG_WARNING, ""MS RLE warning: no End-of-picture code\n""); return 0; }",129,"static int msrle_decode_8_16_24_32 ( avcodeccontext * avctx , avpicture * pic , int depth , const uint8_t * data , int srcsize ) { uint8_t * type , * output_ends ; const uint8_t * addr = data ; int cp1 , p2 , link = avctx -> height , po = 0 , i ; uint16_t pix16 ; uint32_t pix32 ; type = pic -> data [ 0 ] + ( avctx -> height - 1 ) * pic -> linesize [ 0 ] ; output_ends = pic -> data [ 0 ] + ( avctx -> height ) * pic -> linesize [ 0 ] ; while ( addr < data + srcsize ) { cp1 = * addr ++ ; if ( cp1 == 0 ) {",1,1,0,1,"src,line,pos,output,output_end,p1","src:-0.01313638687133789,line:-0.03233569860458374,pos:-0.027529656887054443,output:-0.03649395704269409,output_end:-0.08748304843902588,p1:-0.10706967115402222,",6,12,"src:addr,pos:po,line:link,output:type,output_end:output_ends,p1:cp1,"
"static void RENAME(vertical_compose53iL0)(uint8_t *_b0, uint8_t *_b1, uint8_t *_b2, int width) { int i; TYPE *b0 = (TYPE *)_b0; TYPE *b1 = (TYPE *)_b1; TYPE *b2 = (TYPE *)_b2; for (i = 0; i < width; i++) b1[i] -= (b0[i] + b2[i] + 2) >> 2; }",91,"static void rename ( vertical_compose53il0 ) ( uint8_t * _b0 , uint8_t * _b1 , uint8_t * _b2 , int width ) { int ui ; type * h0 = ( type * ) _b0 ; type * b1 = ( type * ) _b1 ; type * a2 = ( type * ) _b2 ; for ( ui = 0 ; ui < width ; ui ++ ) b1 [ ui ] -= ( h0 [ ui ] + a2 [ ui ] + 2 ) >> 2 ; }",1,1,1,-1,"b0,b1,b2,i","b0:-0.0019797682762145996,b1:-0.0027976036071777344,b2:-0.0021615028381347656,i:-0.000723421573638916,",3,11,"i:ui,b0:h0,b2:a2,"
"static void handle_user_command(Monitor *mon, const char *cmdline) { QDict *qdict; const mon_cmd_t *cmd; qdict = qdict_new(); cmd = monitor_parse_command(mon, cmdline, 0, mon->cmd_table, qdict); if (!cmd) goto out; if (handler_is_async(cmd)) { user_async_cmd_handler(mon, cmd, qdict); } else if (handler_is_qobject(cmd)) { QObject *data = NULL; /* XXX: ignores the error code */ cmd->mhandler.cmd_new(mon, qdict, &data); assert(!monitor_has_error(mon)); if (data) { cmd->user_print(mon, data); qobject_decref(data); } } else { cmd->mhandler.cmd(mon, qdict); } out: QDECREF(qdict); }",153,,1,0,,-4,"qdict,cmd,data",,,,
"static void gen_exception_return(DisasContext *s, TCGv pc) { TCGv tmp; store_reg(s, 15, pc); tmp = load_cpu_field(spsr); gen_set_cpsr(tmp, 0xffffffff); dead_tmp(tmp); s->is_jmp = DISAS_UPDATE; }",50,"static void gen_exception_return ( disascontext * Ġs , tcgv pc ) { tcgv pkg ; store_reg ( Ġs , 15 , pc ) ; pkg = load_cpu_field ( spsr ) ; gen_set_cpsr ( pkg , 0xffffffff ) ; dead_tmp ( pkg ) ; Ġs -> is_jmp = disas_update ; }",1,1,1,-1,"tmp,s,is_jmp","tmp:-0.01556628942489624,s:-0.01247626543045044,is_jmp:-0.011454164981842041,",2,7,"s:Ġs,tmp:pkg,"
"static int fourxm_read_packet(AVFormatContext *s, AVPacket *pkt) { FourxmDemuxContext *fourxm = s->priv_data; ByteIOContext *pb = &s->pb; unsigned int fourcc_tag; unsigned int size, out_size; int ret = 0; int track_number; int packet_read = 0; unsigned char header[8]; int64_t pts_inc; int audio_frame_count; while (!packet_read) { if ((ret = get_buffer(&s->pb, header, 8)) < 0) return ret; fourcc_tag = LE_32(&header[0]); size = LE_32(&header[4]); if (url_feof(pb)) return AVERROR_IO; switch (fourcc_tag) { case LIST_TAG: /* this is a good time to bump the video pts */ fourxm->video_pts += fourxm->video_pts_inc; /* skip the LIST-* tag and move on to the next fourcc */ get_le32(pb); break; case ifrm_TAG: case pfrm_TAG: case cfrm_TAG:{ /* allocate 8 more bytes than 'size' to account for fourcc * and size */ if (av_new_packet(pkt, size + 8)) return AVERROR_IO; pkt->stream_index = fourxm->video_stream_index; pkt->pts = fourxm->video_pts; memcpy(pkt->data, header, 8); ret = get_buffer(&s->pb, &pkt->data[8], size); if (ret < 0) av_free_packet(pkt); else packet_read = 1; break; } case snd__TAG: track_number = get_le32(pb); out_size= get_le32(pb); size-=8; if (track_number == fourxm->selected_track) { if (av_new_packet(pkt, size)) return AVERROR_IO; pkt->stream_index = fourxm->tracks[fourxm->selected_track].stream_index; pkt->pts = fourxm->audio_pts; ret = get_buffer(&s->pb, pkt->data, size); if (ret < 0) av_free_packet(pkt); else packet_read = 1; /* pts accounting */ audio_frame_count = size; if (fourxm->tracks[fourxm->selected_track].adpcm) audio_frame_count -= 2 * (fourxm->tracks[fourxm->selected_track].channels); audio_frame_count /= fourxm->tracks[fourxm->selected_track].channels; if (fourxm->tracks[fourxm->selected_track].adpcm) audio_frame_count *= 2; else audio_frame_count /= (fourxm->tracks[fourxm->selected_track].bits / 8); pts_inc = audio_frame_count; pts_inc *= 90000; pts_inc /= fourxm->tracks[fourxm->selected_track].sample_rate; fourxm->audio_pts += pts_inc; } else { url_fseek(pb, size, SEEK_CUR); } break; default: url_fseek(pb, size, SEEK_CUR); break; } } return ret; }",480,,1,0,,-4,"fourxm,pb,ret,packet_read,fourcc_tag,size,video_pts,pkt,stream_index,pts,track_number,out_size,audio_pts,audio_frame_count,pts_inc",,,,
"static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin) { BdrvChild *child, *tmp; bool waited; /* Ensure any pending metadata writes are submitted to bs->file. */ bdrv_drain_invoke(bs, begin); /* Wait for drained requests to finish */ waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0); QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) { BlockDriverState *bs = child->bs; bool in_main_loop = qemu_get_current_aio_context() == qemu_get_aio_context(); assert(bs->refcnt > 0); if (in_main_loop) { /* In case the recursive bdrv_drain_recurse processes a * block_job_defer_to_main_loop BH and modifies the graph, * let's hold a reference to bs until we are done. * * IOThread doesn't have such a BH, and it is not safe to call * bdrv_unref without BQL, so skip doing it there. */ bdrv_ref(bs); } waited |= bdrv_drain_recurse(bs, begin); if (in_main_loop) { bdrv_unref(bs); } } return waited; }",125,,1,0,,-4,"waited,bs,in_main_loop",,,,
"static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) { int num_pos_channels = 0; int first_cpe = 0; int sce_parity = 0; int i; for (i = *current; i < tags; i++) { if (layout_map[i][2] != pos) break; if (layout_map[i][0] == TYPE_CPE) { if (sce_parity) { if (pos == AAC_CHANNEL_FRONT || !first_cpe) { sce_parity = 0; } else { return -1; } } num_pos_channels += 2; first_cpe = 1; } else { num_pos_channels++; sce_parity ^= 1; } } if (sce_parity && ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE)) return -1; *current = i; return num_pos_channels; }",161,"static int count_paired_channels ( uint8_t ( * layout_map ) [ 3 ] , int tags , int pos , int * current ) { int num_pos_channels = 0 ; int first_cpe = 0 ; int sce_parency = 0 ; int i ; for ( i = * current ; i < tags ; i ++ ) { if ( layout_map [ i ] [ 2 ] != pos ) break ; if ( layout_map [ i ] [ 0 ] == type_cpe ) { if ( sce_parency ) { if ( pos == aac_channel_front || ! first_cpe ) { sce_parency = 0 ; } else { return -1 ; } } num_pos_channels += 2 ; first_cpe = 1 ; } else { num_pos_channels ++ ; sce_parency ^= 1 ; } } if ( sce_parency && ( ( pos == aac_channel_front && first_cpe ) || pos == aac_channel_side ) ) return -1 ; * current = i ; return num_pos_channels ; }",0,0,1,1,"num_pos_channels,first_cpe,sce_parity,i,current","num_pos_channels:0.21557432413101196,first_cpe:0.280903697013855,sce_parity:0.5478028357028961,i:0.26633769273757935,current:0.26386788487434387,",1,5,"sce_parity:sce_parency,"
"uint64_t helper_sublv (uint64_t op1, uint64_t op2) { uint64_t tmp = op1; op1 = (uint32_t)(op1 - op2); if (unlikely(((~tmp) ^ op1 ^ (-1UL)) & ((~tmp) ^ op2) & (1UL << 31))) { helper_excp(EXCP_ARITH, EXCP_ARITH_OVERFLOW); } return op1; }",72,"uint64_t helper_sublv ( uint64_t op1 , uint64_t op2 ) { uint64_t tmp = op1 ; op1 = ( uint32_t ) ( op1 - op2 ) ; if ( unlikely ( ( ( ~ tmp ) ^ op1 ^ ( -1ul ) ) & ( ( ~ tmp ) ^ op2 ) & ( 1ul << 31 ) ) ) { helper_excp ( excp_arith , excp_arith_overflow ) ; } return op1 ; }",1,1,1,-1,"tmp,op1","tmp:-0.00045496225357055664,op1:0.0014740824699401855,",0,0,
"static int decode_slice(struct AVCodecContext *avctx, void *arg) { H264Context *h = *(void **)arg; int lf_x_start = h->mb_x; h->mb_skip_run = -1; av_assert0(h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * h->linesize * ((scan8[15] - scan8[0]) >> 3)); h->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME || avctx->codec_id != AV_CODEC_ID_H264 || (CONFIG_GRAY && (h->flags & CODEC_FLAG_GRAY)); if (!(h->avctx->active_thread_type & FF_THREAD_SLICE) && h->picture_structure == PICT_FRAME) { const int start_i = av_clip(h->resync_mb_x + h->resync_mb_y * h->mb_width, 0, h->mb_num - 1); if (start_i) { int prev_status = h->er.error_status_table[h->er.mb_index2xy[start_i - 1]]; prev_status &= ~ VP_START; if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END)) h->er.error_occurred = 1; } } if (h->pps.cabac) { /* realign */ align_get_bits(&h->gb); /* init cabac */ ff_init_cabac_decoder(&h->cabac, h->gb.buffer + get_bits_count(&h->gb) / 8, (get_bits_left(&h->gb) + 7) / 8); ff_h264_init_cabac_states(h); for (;;) { // START_TIMER int ret = ff_h264_decode_mb_cabac(h); int eos; // STOP_TIMER(""decode_mb_cabac"") if (ret >= 0) ff_h264_hl_decode_mb(h); // FIXME optimal? or let mb_decode decode 16x32 ? if (ret >= 0 && FRAME_MBAFF(h)) { h->mb_y++; ret = ff_h264_decode_mb_cabac(h); if (ret >= 0) ff_h264_hl_decode_mb(h); h->mb_y--; } eos = get_cabac_terminate(&h->cabac); if ((h->workaround_bugs & FF_BUG_TRUNCATED) && h->cabac.bytestream > h->cabac.bytestream_end + 2) { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); if (h->mb_x >= lf_x_start) loop_filter(h, lf_x_start, h->mb_x + 1); return 0; } if (h->cabac.bytestream > h->cabac.bytestream_end + 2 ) av_log(h->avctx, AV_LOG_DEBUG, ""bytestream overread %td\n"", h->cabac.bytestream_end - h->cabac.bytestream); if (ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 4) { av_log(h->avctx, AV_LOG_ERROR, ""error while decoding MB %d %d, bytestream (%td)\n"", h->mb_x, h->mb_y, h->cabac.bytestream_end - h->cabac.bytestream); er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_ERROR); return -1; } if (++h->mb_x >= h->mb_width) { loop_filter(h, lf_x_start, h->mb_x); h->mb_x = lf_x_start = 0; decode_finish_row(h); ++h->mb_y; if (FIELD_OR_MBAFF_PICTURE(h)) { ++h->mb_y; if (FRAME_MBAFF(h) && h->mb_y < h->mb_height) predict_field_decoding_flag(h); } } if (eos || h->mb_y >= h->mb_height) { tprintf(h->avctx, ""slice end %d %d\n"", get_bits_count(&h->gb), h->gb.size_in_bits); er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); if (h->mb_x > lf_x_start) loop_filter(h, lf_x_start, h->mb_x); return 0; } } } else { for (;;) { int ret = ff_h264_decode_mb_cavlc(h); if (ret >= 0) ff_h264_hl_decode_mb(h); // FIXME optimal? or let mb_decode decode 16x32 ? if (ret >= 0 && FRAME_MBAFF(h)) { h->mb_y++; ret = ff_h264_decode_mb_cavlc(h); if (ret >= 0) ff_h264_hl_decode_mb(h); h->mb_y--; } if (ret < 0) { av_log(h->avctx, AV_LOG_ERROR, ""error while decoding MB %d %d\n"", h->mb_x, h->mb_y); er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_ERROR); return -1; } if (++h->mb_x >= h->mb_width) { loop_filter(h, lf_x_start, h->mb_x); h->mb_x = lf_x_start = 0; decode_finish_row(h); ++h->mb_y; if (FIELD_OR_MBAFF_PICTURE(h)) { ++h->mb_y; if (FRAME_MBAFF(h) && h->mb_y < h->mb_height) predict_field_decoding_flag(h); } if (h->mb_y >= h->mb_height) { tprintf(h->avctx, ""slice end %d %d\n"", get_bits_count(&h->gb), h->gb.size_in_bits); if ( get_bits_left(&h->gb) == 0 || get_bits_left(&h->gb) > 0 && !(h->avctx->err_recognition & AV_EF_AGGRESSIVE)) { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); return 0; } else { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_END); return -1; } } } if (get_bits_left(&h->gb) <= 0 && h->mb_skip_run <= 0) { tprintf(h->avctx, ""slice end %d %d\n"", get_bits_count(&h->gb), h->gb.size_in_bits); if (get_bits_left(&h->gb) == 0) { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x - 1, h->mb_y, ER_MB_END); if (h->mb_x > lf_x_start) loop_filter(h, lf_x_start, h->mb_x); return 0; } else { er_add_slice(h, h->resync_mb_x, h->resync_mb_y, h->mb_x, h->mb_y, ER_MB_ERROR); return -1; } } } } }",294,,1,0,,-4,"h,lf_x_start,mb_skip_run,is_complex,start_i,prev_status,er,error_occurred",,,,
"static int img_read_packet(AVFormatContext *s1, AVPacket *pkt) { VideoData *s = s1->priv_data; char filename[1024]; int ret; ByteIOContext f1, *f; if (get_frame_filename(filename, sizeof(filename), s->path, s->img_number) < 0) return -EIO; if (!s->is_pipe) { f = &f1; if (url_fopen(f, filename, URL_RDONLY) < 0) return -EIO; } else { f = &s1->pb; if (url_feof(f)) return -EIO; } av_new_packet(pkt, s->img_size); pkt->stream_index = 0; switch(s->img_fmt) { case IMGFMT_PGMYUV: ret = pgm_read(s, f, pkt->data, pkt->size, 1); break; case IMGFMT_PGM: ret = pgm_read(s, f, pkt->data, pkt->size, 0); break; case IMGFMT_YUV: ret = yuv_read(s, filename, pkt->data, pkt->size); break; case IMGFMT_PPM: ret = ppm_read(s, f, pkt->data, pkt->size); break; default: return -EIO; } if (!s->is_pipe) { url_fclose(f); } if (ret < 0) { av_free_packet(pkt); return -EIO; /* signal EOF */ } else { s->img_number++; return 0; } }",278,,1,0,,-4,"s,f,pkt,stream_index,ret,img_number",,,,
"void configure_alarms(char const *opt) { int i; int cur = 0; int count = ARRAY_SIZE(alarm_timers) - 1; char *arg; char *name; struct qemu_alarm_timer tmp; if (!strcmp(opt, ""?"")) { show_available_alarms(); exit(0); } arg = g_strdup(opt); /* Reorder the array */ name = strtok(arg, "",""); while (name) { for (i = 0; i < count && alarm_timers[i].name; i++) { if (!strcmp(alarm_timers[i].name, name)) break; } if (i == count) { fprintf(stderr, ""Unknown clock %s\n"", name); goto next; } if (i < cur) /* Ignore */ goto next; /* Swap */ tmp = alarm_timers[i]; alarm_timers[i] = alarm_timers[cur]; alarm_timers[cur] = tmp; cur++; next: name = strtok(NULL, "",""); } g_free(arg); if (cur) { /* Disable remaining timers */ for (i = cur; i < count; i++) alarm_timers[i].name = NULL; } else { show_available_alarms(); exit(1); } }",239,,1,0,,-4,"cur,count,arg,name,i,alarm_timers,tmp",,,,
"static int motion_inter_4v_block (bit_buffer_t *bitbuf, uint8_t *current, uint8_t *previous, int pitch, svq1_pmv_t *motion,int x, int y) { uint8_t *src; uint8_t *dst; svq1_pmv_t mv; svq1_pmv_t *pmv[4]; int i, result; /* predict and decode motion vector (0) */ pmv[0] = &motion[0]; pmv[1] = &motion[(x / 8) + 2]; pmv[2] = &motion[(x / 8) + 4]; if (y == 0) { pmv[1] = pmv[0]; pmv[2] = pmv[0]; } result = decode_motion_vector (bitbuf, &mv, pmv); if (result != 0) return result; /* predict and decode motion vector (1) */ pmv[0] = &mv; pmv[1] = &motion[(x / 8) + 3]; if (y == 0) { pmv[1] = pmv[0]; pmv[2] = pmv[0]; } result = decode_motion_vector (bitbuf, &motion[0], pmv); if (result != 0) return result; /* predict and decode motion vector (2) */ pmv[1] = &motion[0]; pmv[2] = &motion[(x / 8) + 1]; result = decode_motion_vector (bitbuf, &motion[(x / 8) + 2], pmv); if (result != 0) return result; /* predict and decode motion vector (3) */ pmv[2] = &motion[(x / 8) + 2]; pmv[3] = &motion[(x / 8) + 3]; result = decode_motion_vector (bitbuf, pmv[3], pmv); if (result != 0) return result; /* form predictions */ for (i=0; i < 4; i++) { src = &previous[(x + (pmv[i]->x >> 1)) + (y + (pmv[i]->y >> 1))*pitch]; dst = current; put_pixels_tab[((pmv[i]->y & 1) << 1) | (pmv[i]->x & 1)](dst,src,pitch,8); /* select next block */ if (i & 1) { current += 8*(pitch - 1); previous += 8*(pitch - 1); } else { current += 8; previous += 8; } } return 0; }",477,"static int motion_inter_4v_block ( bit_buffer_t * bitbuf , uint8_t * current , uint8_t * previous , int pitch , svq1_pmv_t * motion , int x , int y ) { uint8_t * src ; uint8_t * dst ; svq1_pmv_t mv ; svq1_pmv_t * pmv [ 4 ] ; int i , draw ; pmv [ 0 ] = & motion [ 0 ] ; pmv [ 1 ] = & motion [ ( x / 8 ) + 2 ] ; pmv [ 2 ] = & motion [ ( x / 8 ) + 4 ] ; if ( y == 0 ) { pmv [ 1 ] = pmv [ 0 ] ; pmv [ 2 ] = pmv [ 0 ] ; } draw = decode_motion_vector ( bitbuf , & mv , pmv ) ; if ( draw != 0 ) return draw ; pmv [ 0 ] = & mv ; pmv [ 1 ] = & motion [ ( x / 8 ) + 3 ] ; if ( y == 0 ) { pmv [ 1 ] = pmv [ 0 ] ; pmv [ 2 ] = pmv [ 0 ] ; } draw = decode_motion_vector ( bitbuf , & motion [ 0 ] , pmv ) ; if ( draw != 0 ) return draw ; pmv [ 1 ] = & motion [ 0 ] ; pmv [ 2 ] = & motion [ ( x / 8 ) + 1 ] ; draw = decode_motion_vector ( bitbuf , & motion [ ( x / 8 ) + 2 ] , pmv ) ; if ( draw != 0 ) return draw ; pmv [ 2 ] = & motion [ ( x / 8 ) + 2 ] ; pmv [ 3 ] = & motion [ ( x / 8 ) + 3 ] ; draw = decode_motion_vector ( bitbuf , pmv [ 3 ] , pmv ) ; if ( draw != 0 ) return draw ; for ( i = 0 ; i < 4 ; i ++ ) { src = & previous [ ( x + ( pmv [ i ] -> x >> 1 ) ) + ( y + ( pmv [ i ] -> y >> 1 ) ) * pitch ] ; dst = current ; put_pixels_tab [ ( ( pmv [ i ] -> y & 1 ) << 1 ) | ( pmv [ i ] -> x & 1 ) ] ( dst , src , pitch , 8 ) ; if ( i & 1 ) { current += 8 * ( pitch - 1 ) ; previous += 8 * ( pitch - 1 ) ; } else { current += 8 ; previous += 8 ; } } return 0 ; }",0,0,1,1,"pmv,0,1,2,result,3,i,src,dst,current,previous","pmv:0.6805602312088013,0:0.21408158540725708,1:0.25123530626296997,2:0.21992731094360352,result:1.1291952431201935,3:0.0007341504096984863,i:-0.0023373067378997803,src:0.036987900733947754,dst:-0.009582728147506714,current:0.015558958053588867,previous:0.01823022961616516,",1,13,"result:draw,"
"void ide_sector_read(IDEState *s) { int64_t sector_num; int ret, n; s->status = READY_STAT | SEEK_STAT; s->error = 0; /* not needed by IDE spec, but needed by Windows */ sector_num = ide_get_sector(s); n = s->nsector; if (n == 0) { /* no more sector to read from disk */ ide_transfer_stop(s); } else { #if defined(DEBUG_IDE) printf(""read sector=%"" PRId64 ""\n"", sector_num); #endif if (n > s->req_nb_sectors) n = s->req_nb_sectors; bdrv_acct_start(s->bs, &s->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ); ret = bdrv_read(s->bs, sector_num, s->io_buffer, n); bdrv_acct_done(s->bs, &s->acct); if (ret != 0) { if (ide_handle_rw_error(s, -ret, BM_STATUS_PIO_RETRY | BM_STATUS_RETRY_READ)) { return; } } ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_read); ide_set_irq(s->bus); ide_set_sector(s, sector_num + n); s->nsector -= n; } }",77,"void ide_sector_read ( idestate * sv ) { int64_t sector_num ; int ret , n ; sv -> status = ready_stat | seek_stat ; sv -> error = 0 ; sector_num = ide_get_sector ( sv ) ; n = sv -> nsector ; if ( n == 0 ) { ide_transfer_stop ( sv ) ; } else { #if defined ( debug_ide ) printf ( "" "" prid64 "" \n "" , sector_num ) ; #endif  if (n > s->req_nb_sectors) n = s->req_nb_sectors; bdrv_acct_start(s->bs, &s->acct, n * bdrv_sector_size, bdrv_acct_read); ret = bdrv_read(s->bs, sector_num, s->io_buffer, n); bdrv_acct_done(s->bs, &s->acct); if (ret != 0) { if (ide_handle_rw_error(s, -ret, bm_status_pio_retry | bm_status_retry_read)) { return; } } ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_read); ide_set_irq(s->bus); ide_set_sector(s, sector_num + n); s->nsector -= n; } }",0,0,1,1,"s,status,error,sector_num,n","s:1.3424052000045776,status:0.1905672550201416,error:0.2090027928352356,sector_num:0.28472864627838135,n:0.922115683555603,",1,6,"s:sv,"
"static void cpu_ioreq_pio(ioreq_t *req) { int i; if (req->dir == IOREQ_READ) { if (!req->data_is_ptr) { req->data = do_inp(req->addr, req->size); } else { uint32_t tmp; for (i = 0; i < req->count; i++) { tmp = do_inp(req->addr, req->size); write_phys_req_item(req->data, req, i, &tmp); } } } else if (req->dir == IOREQ_WRITE) { if (!req->data_is_ptr) { do_outp(req->addr, req->size, req->data); } else { for (i = 0; i < req->count; i++) { uint32_t tmp = 0; read_phys_req_item(req->data, req, i, &tmp); do_outp(req->addr, req->size, tmp); } } } }",184,"static void cpu_ioreq_pio ( ioreq_t * req ) { int Ð¸ ; if ( req -> dir == ioreq_read ) { if ( ! req -> data_is_ptr ) { req -> data = do_inp ( req -> addr , req -> size ) ; } else { uint32_t tmp ; for ( Ð¸ = 0 ; Ð¸ < req -> count ; Ð¸ ++ ) { tmp = do_inp ( req -> addr , req -> size ) ; write_phys_req_item ( req -> data , req , Ð¸ , & tmp ) ; } } } else if ( req -> dir == ioreq_write ) { if ( ! req -> data_is_ptr ) { do_outp ( req -> addr , req -> size , req -> data ) ; } else { for ( Ð¸ = 0 ; Ð¸ < req -> count ; Ð¸ ++ ) { uint32_t tmp = 0 ; read_phys_req_item ( req -> data , req , Ð¸ , & tmp ) ; do_outp ( req -> addr , req -> size , tmp ) ; } } } }",0,0,1,1,"req,data,i,tmp","req:-0.014014174230396748,data:-0.0044404370710253716,i:0.053784809075295925,tmp:0.036967518739402294,",1,9,"i:Ð¸,"
"static void rtas_display_character(sPAPREnvironment *spapr, uint32_t token, uint32_t nargs, target_ulong args, uint32_t nret, target_ulong rets) { uint8_t c = rtas_ld(args, 0); VIOsPAPRDevice *sdev = vty_lookup(spapr, 0); if (!sdev) { rtas_st(rets, 0, -1); } else { vty_putchars(sdev, &c, sizeof(c)); rtas_st(rets, 0, 0); } }",87,,0,1,,-4,"c,sdev",,,,
"static int xmv_read_header(AVFormatContext *s) { XMVDemuxContext *xmv = s->priv_data; AVIOContext *pb = s->pb; uint32_t file_version; uint32_t this_packet_size; uint16_t audio_track; int ret; s->ctx_flags |= AVFMTCTX_NOHEADER; avio_skip(pb, 4); /* Next packet size */ this_packet_size = avio_rl32(pb); avio_skip(pb, 4); /* Max packet size */ avio_skip(pb, 4); /* ""xobX"" */ file_version = avio_rl32(pb); if ((file_version != 4) && (file_version != 2)) avpriv_request_sample(s, ""Uncommon version %""PRIu32"""", file_version); /* Video tracks */ xmv->video_width = avio_rl32(pb); xmv->video_height = avio_rl32(pb); xmv->video_duration = avio_rl32(pb); /* Audio tracks */ xmv->audio_track_count = avio_rl16(pb); avio_skip(pb, 2); /* Unknown (padding?) */ xmv->audio = av_mallocz_array(xmv->audio_track_count, sizeof(XMVAudioPacket)); if (!xmv->audio) { ret = AVERROR(ENOMEM); goto fail; } for (audio_track = 0; audio_track < xmv->audio_track_count; audio_track++) { XMVAudioPacket *packet = &xmv->audio[audio_track]; packet->compression = avio_rl16(pb); packet->channels = avio_rl16(pb); packet->sample_rate = avio_rl32(pb); packet->bits_per_sample = avio_rl16(pb); packet->flags = avio_rl16(pb); packet->bit_rate = packet->bits_per_sample * packet->sample_rate * packet->channels; packet->block_align = XMV_BLOCK_ALIGN_SIZE * packet->channels; packet->block_samples = 64; packet->codec_id = ff_wav_codec_get_id(packet->compression, packet->bits_per_sample); packet->stream_index = -1; packet->frame_size = 0; packet->block_count = 0; /* TODO: ADPCM'd 5.1 sound is encoded in three separate streams. * Those need to be interleaved to a proper 5.1 stream. */ if (packet->flags & XMV_AUDIO_ADPCM51) av_log(s, AV_LOG_WARNING, ""Unsupported 5.1 ADPCM audio stream "" ""(0x%04X)\n"", packet->flags); if (!packet->channels || !packet->sample_rate || packet->channels >= UINT16_MAX / XMV_BLOCK_ALIGN_SIZE) { av_log(s, AV_LOG_ERROR, ""Invalid parameters for audio track %""PRIu16"".\n"", audio_track); ret = AVERROR_INVALIDDATA; goto fail; } } /* Initialize the packet context */ xmv->next_packet_offset = avio_tell(pb); xmv->next_packet_size = this_packet_size - xmv->next_packet_offset; xmv->stream_count = xmv->audio_track_count + 1; return 0; fail: xmv_read_close(s); return ret; }",435,,0,1,,-4,"xmv,pb,s,ctx_flags,this_packet_size,file_version,video_width,video_height,video_duration,audio_track_count,audio,ret,audio_track,packet,compression,channels,sample_rate,bits_per_sample,flags,bit_rate,block_align,block_samples,codec_id,stream_index,frame_size,block_count,next_packet_offset,next_packet_size,stream_count",,,,
"static int bdrv_rd_badreq_sectors(BlockDriverState *bs, int64_t sector_num, int nb_sectors) { return nb_sectors < 0 || sector_num < 0 || nb_sectors > bs->total_sectors || sector_num > bs->total_sectors - nb_sectors; }",39,,1,0,,-4,,,,,
"static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp) { int fd, ret; fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW); if (fd < 0) { return fd; } ret = fchmod(fd, credp->fc_mode & 07777); if (ret < 0) { goto err_out; } ret = fchownat(fd, """", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH); err_out: close(fd); return ret; }",101,"static int handle_update_file_cred ( int dirfd , const char * name , fscred * credp ) { int exec , det ; exec = openat ( dirfd , name , o_nonblock | o_nofollow ) ; if ( exec < 0 ) { return exec ; } det = fchmod ( exec , credp -> fc_mode & 07777 ) ; if ( det < 0 ) { goto err_out ; } det = fchownat ( exec , "" "" , credp -> fc_uid , credp -> fc_gid , at_empty_path ) ; err_out : close ( exec ) ; return det ; }",1,1,1,-1,"fd,ret","fd:-0.42380785942077637,ret:-0.34778815507888794,",2,12,"ret:det,fd:exec,"
"static av_cold int ffv1_encode_init(AVCodecContext *avctx) { FFV1Context *s = avctx->priv_data; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt); int i, j, k, m, ret; ffv1_common_init(avctx); s->version = 0; if ((avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) || avctx->slices > 1) s->version = FFMAX(s->version, 2); if (avctx->level == 3) { s->version = 3; } if (s->ec < 0) { s->ec = (s->version >= 3); } if (s->version >= 2 && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log(avctx, AV_LOG_ERROR, ""Version %d requested, please set -strict experimental in "" ""order to enable it\n"", s->version); return AVERROR(ENOSYS); } s->ac = avctx->coder_type > 0 ? 2 : 0; s->plane_count = 3; switch (avctx->pix_fmt) { case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV420P9: if (!avctx->bits_per_raw_sample) s->bits_per_raw_sample = 9; case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: s->packed_at_lsb = 1; if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 10; case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV420P16: if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) { s->bits_per_raw_sample = 16; } else if (!s->bits_per_raw_sample) { s->bits_per_raw_sample = avctx->bits_per_raw_sample; } if (s->bits_per_raw_sample <= 8) { av_log(avctx, AV_LOG_ERROR, ""bits_per_raw_sample invalid\n""); return AVERROR_INVALIDDATA; } if (!s->ac && avctx->coder_type == -1) { av_log(avctx, AV_LOG_INFO, ""bits_per_raw_sample > 8, forcing coder 1\n""); s->ac = 2; } if (!s->ac) { av_log( avctx, AV_LOG_ERROR, ""bits_per_raw_sample of more than 8 needs -coder 1 currently\n""); return AVERROR_INVALIDDATA; } s->version = FFMAX(s->version, 1); case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV410P: s->chroma_planes = desc->nb_components < 3 ? 0 : 1; s->colorspace = 0; break; case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA420P: s->chroma_planes = 1; s->colorspace = 0; s->transparency = 1; break; case AV_PIX_FMT_RGB32: s->colorspace = 1; s->transparency = 1; break; case AV_PIX_FMT_GBRP9: if (!avctx->bits_per_raw_sample) s->bits_per_raw_sample = 9; case AV_PIX_FMT_GBRP10: if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 10; case AV_PIX_FMT_GBRP16: if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) s->bits_per_raw_sample = 16; else if (!s->bits_per_raw_sample) s->bits_per_raw_sample = avctx->bits_per_raw_sample; s->colorspace = 1; s->chroma_planes = 1; s->version = FFMAX(s->version, 1); break; default: av_log(avctx, AV_LOG_ERROR, ""format not supported\n""); return AVERROR_INVALIDDATA; } if (s->transparency) { av_log( avctx, AV_LOG_WARNING, ""Storing alpha plane, this will require a recent FFV1 decoder to playback!\n""); } if (avctx->context_model > 1U) { av_log(avctx, AV_LOG_ERROR, ""Invalid context model %d, valid values are 0 and 1\n"", avctx->context_model); return AVERROR(EINVAL); } if (s->ac > 1) for (i = 1; i < 256; i++) s->state_transition[i] = ffv1_ver2_state[i]; for (i = 0; i < 256; i++) { s->quant_table_count = 2; if (s->bits_per_raw_sample <= 8) { s->quant_tables[0][0][i] = ffv1_quant11[i]; s->quant_tables[0][1][i] = ffv1_quant11[i] * 11; s->quant_tables[0][2][i] = ffv1_quant11[i] * 11 * 11; s->quant_tables[1][0][i] = ffv1_quant11[i]; s->quant_tables[1][1][i] = ffv1_quant11[i] * 11; s->quant_tables[1][2][i] = ffv1_quant5[i] * 11 * 11; s->quant_tables[1][3][i] = ffv1_quant5[i] * 5 * 11 * 11; s->quant_tables[1][4][i] = ffv1_quant5[i] * 5 * 5 * 11 * 11; } else { s->quant_tables[0][0][i] = ffv1_quant9_10bit[i]; s->quant_tables[0][1][i] = ffv1_quant9_10bit[i] * 11; s->quant_tables[0][2][i] = ffv1_quant9_10bit[i] * 11 * 11; s->quant_tables[1][0][i] = ffv1_quant9_10bit[i]; s->quant_tables[1][1][i] = ffv1_quant9_10bit[i] * 11; s->quant_tables[1][2][i] = ffv1_quant5_10bit[i] * 11 * 11; s->quant_tables[1][3][i] = ffv1_quant5_10bit[i] * 5 * 11 * 11; s->quant_tables[1][4][i] = ffv1_quant5_10bit[i] * 5 * 5 * 11 * 11; } } s->context_count[0] = (11 * 11 * 11 + 1) / 2; s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2; memcpy(s->quant_table, s->quant_tables[avctx->context_model], sizeof(s->quant_table)); for (i = 0; i < s->plane_count; i++) { PlaneContext *const p = &s->plane[i]; memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table)); p->quant_table_index = avctx->context_model; p->context_count = s->context_count[p->quant_table_index]; } if ((ret = ffv1_allocate_initial_states(s)) < 0) return ret; avctx->coded_frame = av_frame_alloc(); if (!avctx->coded_frame) return AVERROR(ENOMEM); avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I; if (!s->transparency) s->plane_count = 2; av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift); s->picture_number = 0; if (avctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) { for (i = 0; i < s->quant_table_count; i++) { s->rc_stat2[i] = av_mallocz(s->context_count[i] * sizeof(*s->rc_stat2[i])); if (!s->rc_stat2[i]) return AVERROR(ENOMEM); } } if (avctx->stats_in) { char *p = avctx->stats_in; uint8_t best_state[256][256]; int gob_count = 0; char *next; av_assert0(s->version >= 2); for (;; ) { for (j = 0; j < 256; j++) for (i = 0; i < 2; i++) { s->rc_stat[j][i] = strtol(p, &next, 0); if (next == p) { av_log(avctx, AV_LOG_ERROR, ""2Pass file invalid at %d %d [%s]\n"", j, i, p); return AVERROR_INVALIDDATA; } p = next; } for (i = 0; i < s->quant_table_count; i++) for (j = 0; j < s->context_count[i]; j++) { for (k = 0; k < 32; k++) for (m = 0; m < 2; m++) { s->rc_stat2[i][j][k][m] = strtol(p, &next, 0); if (next == p) { av_log(avctx, AV_LOG_ERROR, ""2Pass file invalid at %d %d %d %d [%s]\n"", i, j, k, m, p); return AVERROR_INVALIDDATA; } p = next; } } gob_count = strtol(p, &next, 0); if (next == p || gob_count <= 0) { av_log(avctx, AV_LOG_ERROR, ""2Pass file invalid\n""); return AVERROR_INVALIDDATA; } p = next; while (*p == '\n' || *p == ' ') p++; if (p[0] == 0) break; } sort_stt(s, s->state_transition); find_best_state(best_state, s->state_transition); for (i = 0; i < s->quant_table_count; i++) { for (j = 0; j < s->context_count[i]; j++) for (k = 0; k < 32; k++) { double p = 128; if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) { p = 256.0 * s->rc_stat2[i][j][k][1] / (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]); } s->initial_states[i][j][k] = best_state[av_clip(round(p), 1, 255)][av_clip((s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1]) / gob_count, 0, 255)]; } } } if (s->version > 1) { for (s->num_v_slices = 2; s->num_v_slices < 9; s->num_v_slices++) for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2 * s->num_v_slices; s->num_h_slices++) if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= 64 || !avctx->slices) goto slices_ok; av_log(avctx, AV_LOG_ERROR, ""Unsupported number %d of slices requested, please specify a "" ""supported number with -slices (ex:4,6,9,12,16, ...)\n"", avctx->slices); return AVERROR(ENOSYS); slices_ok: write_extradata(s); } if ((ret = ffv1_init_slice_contexts(s)) < 0) return ret; if ((ret = init_slices_state(s)) < 0) return ret; #define STATS_OUT_SIZE 1024 * 1024 * 6 if (avctx->flags & CODEC_FLAG_PASS1) { avctx->stats_out = av_mallocz(STATS_OUT_SIZE); for (i = 0; i < s->quant_table_count; i++) for (j = 0; j < s->slice_count; j++) { FFV1Context *sf = s->slice_context[j]; av_assert0(!sf->rc_stat2[i]); sf->rc_stat2[i] = av_mallocz(s->context_count[i] * sizeof(*sf->rc_stat2[i])); if (!sf->rc_stat2[i]) return AVERROR(ENOMEM); } } return 0; }",2048,"static av_cold int ffv1_encode_init ( avcodeccontext * avcontext ) { ffv1context * Ġs = avcontext -> priv_data ; const avpixfmtdescriptor * desc = av_pix_fmt_desc_get ( avcontext -> pix_fmt ) ; int i , j , k , m , ret ; ffv1_common_init ( avcontext ) ; Ġs -> version = 0 ; if ( ( avcontext -> flags & ( codec_flag_pass1 | codec_flag_pass2 ) ) || avcontext -> slices > 1 ) Ġs -> version = ffmax ( Ġs -> version , 2 ) ; if ( avcontext -> level == 3 ) { Ġs -> version = 3 ; } if ( Ġs -> ec < 0 ) { Ġs -> ec = ( Ġs -> version >= 3 ) ; } if ( Ġs -> version >= 2 && avcontext -> strict_std_compliance > ff_compliance_experimental ) { av_log ( avcontext , av_log_error , "" "" "" \n "" , Ġs -> version ) ; return averror ( enosys ) ; } Ġs -> ac = avcontext -> coder_type > 0 ? 2 : 0 ; Ġs -> plane_count = 3 ; switch ( avcontext -> pix_fmt ) { case av_pix_fmt_yuv444p9 : case av_pix_fmt_yuv422p9 : case av_pix_fmt_yuv420p9 : if ( ! avcontext -> bits_per_raw_sample ) Ġs -> bits_per_raw_sample = 9 ; case av_pix_fmt_yuv444p10 : case av_pix_fmt_yuv420p10 : case av_pix_fmt_yuv422p10 : Ġs -> packed_at_lsb = 1 ; if ( ! avcontext -> bits_per_raw_sample && ! Ġs -> bits_per_raw_sample ) Ġs -> bits_per_raw_sample = 10 ; case av_pix_fmt_gray16 : case av_pix_fmt_yuv444p16 : case av_pix_fmt_yuv422p16 : case av_pix_fmt_yuv420p16 : if ( ! avcontext -> bits_per_raw_sample && ! Ġs -> bits_per_raw_sample ) { Ġs -> bits_per_raw_sample = 16 ; } else if ( ! Ġs -> bits_per_raw_sample ) { Ġs -> bits_per_raw_sample = avcontext -> bits_per_raw_sample ; } if ( Ġs -> bits_per_raw_sample <= 8 ) { av_log ( avcontext , av_log_error , "" \n "" ) ; return averror_invaliddata ; } if ( ! Ġs -> ac && avcontext -> coder_type == -1 ) { av_log ( avcontext , av_log_info , "" \n "" ) ; Ġs -> ac = 2 ; } if ( ! Ġs -> ac ) { av_log ( avcontext , av_log_error , "" \n "" ) ; return averror_invaliddata ; } Ġs -> version = ffmax ( Ġs -> version , 1 ) ; case av_pix_fmt_gray8 : case av_pix_fmt_yuv444p : case av_pix_fmt_yuv440p : case av_pix_fmt_yuv422p : case av_pix_fmt_yuv420p : case av_pix_fmt_yuv411p : case av_pix_fmt_yuv410p : Ġs -> chroma_planes = desc -> nb_components < 3 ? 0 : 1 ; Ġs -> colorspace = 0 ; break ; case av_pix_fmt_yuva444p : case av_pix_fmt_yuva422p : case av_pix_fmt_yuva420p : Ġs -> chroma_planes = 1 ; Ġs -> colorspace = 0 ; Ġs -> transparency = 1 ; break ; case av_pix_fmt_rgb32 : Ġs -> colorspace = 1 ; Ġs -> transparency = 1 ; break ; case av_pix_fmt_gbrp9 : if ( ! avcontext -> bits_per_raw_sample ) Ġs -> bits_per_raw_sample = 9 ; case av_pix_fmt_gbrp10 : if ( ! avcontext -> bits_per_raw_sample && ! Ġs -> bits_per_raw_sample ) Ġs -> bits_per_raw_sample = 10 ; case av_pix_fmt_gbrp16 : if ( ! avcontext -> bits_per_raw_sample && ! Ġs -> bits_per_raw_sample ) Ġs -> bits_per_raw_sample = 16 ; else if ( ! Ġs -> bits_per_raw_sample ) Ġs -> bits_per_raw_sample = avcontext -> bits_per_raw_sample ; Ġs -> colorspace = 1 ; Ġs -> chroma_planes = 1 ; Ġs -> version = ffmax ( Ġs -> version , 1 ) ; break ; default : av_log ( avcontext , av_log_error , "" \n "" ) ; return averror_invaliddata ; } if ( Ġs -> transparency ) { av_log ( avcontext , av_log_warning , "" \n "" ) ; } if ( avcontext -> context_model > 1u ) { av_log ( avcontext , av_log_error , "" \n "" , avcontext -> context_model ) ; return averror ( einval ) ; } if ( Ġs -> ac > 1 ) for ( i = 1 ; i < 256 ; i ++ ) Ġs -> state_transition [ i ] = ffv1_ver2_state [ i ] ; for ( i = 0 ; i < 256 ; i ++ ) { Ġs -> quant_table_count = 2 ; if ( Ġs -> bits_per_raw_sample <= 8 ) { Ġs -> quant_tables [ 0 ] [ 0 ] [ i ] = ffv1_quant11 [ i ] ; Ġs -> quant_tables [ 0 ] [ 1 ] [ i ] = ffv1_quant11 [ i ] * 11 ; Ġs -> quant_tables [ 0 ] [ 2 ] [ i ] = ffv1_quant11 [ i ] * 11 * 11 ; Ġs -> quant_tables [ 1 ] [ 0 ] [ i ] = ffv1_quant11 [ i ] ; Ġs -> quant_tables [ 1 ] [ 1 ] [ i ] = ffv1_quant11 [ i ] * 11 ; Ġs -> quant_tables [ 1 ] [ 2 ] [ i ] = ffv1_quant5 [ i ] * 11 * 11 ; Ġs -> quant_tables [ 1 ] [ 3 ] [ i ] = ffv1_quant5 [ i ] * 5 * 11 * 11 ; Ġs -> quant_tables [ 1 ] [ 4 ] [ i ] = ffv1_quant5 [ i ] * 5 * 5 * 11 * 11 ; } else { Ġs -> quant_tables [ 0 ] [ 0 ] [ i ] = ffv1_quant9_10bit [ i ] ; Ġs -> quant_tables [ 0 ] [ 1 ] [ i ] = ffv1_quant9_10bit [ i ] * 11 ; Ġs -> quant_tables [ 0 ] [ 2 ] [ i ] = ffv1_quant9_10bit [ i ] * 11 * 11 ; Ġs -> quant_tables [ 1 ] [ 0 ] [ i ] = ffv1_quant9_10bit [ i ] ; Ġs -> quant_tables [ 1 ] [ 1 ] [ i ] = ffv1_quant9_10bit [ i ] * 11 ; Ġs -> quant_tables [ 1 ] [ 2 ] [ i ] = ffv1_quant5_10bit [ i ] * 11 * 11 ; Ġs -> quant_tables [ 1 ] [ 3 ] [ i ] = ffv1_quant5_10bit [ i ] * 5 * 11 * 11 ; Ġs -> quant_tables [ 1 ] [ 4 ] [ i ] = ffv1_quant5_10bit [ i ] * 5 * 5 * 11 * 11 ; } } Ġs -> context_count [ 0 ] = ( 11 * 11 * 11 + 1 ) / 2 ; Ġs -> context_count [ 1 ] = ( 11 * 11 * 5 * 5 * 5 + 1 ) / 2 ; memcpy ( Ġs -> quant_table , Ġs -> quant_tables [ avcontext -> context_model ] , sizeof ( Ġs -> quant_table ) ) ; for ( i = 0 ; i < Ġs -> plane_count ; i ++ ) { planecontext * const p = & Ġs -> plane [ i ] ; memcpy ( p -> quant_table , Ġs -> quant_table , sizeof ( p -> quant_table ) ) ; p -> quant_table_index = avcontext -> context_model ; p -> context_count = Ġs -> context_count [ p -> quant_table_index ] ; } if ( ( ret = ffv1_allocate_initial_states ( Ġs ) ) < 0 ) return ret ; avcontext -> coded_frame = av_frame_alloc ( ) ; if ( ! avcontext -> coded_frame ) return averror ( enomem ) ; avcontext -> coded_frame -> pict_type = av_picture_type_i ; if ( ! Ġs -> transparency ) Ġs -> plane_count = 2 ; av_pix_fmt_get_chroma_sub_sample ( avcontext -> pix_fmt , & Ġs -> chroma_h_shift , & Ġs -> chroma_v_shift ) ; Ġs -> picture_number = 0 ; if ( avcontext -> flags & ( codec_flag_pass1 | codec_flag_pass2 ) ) { for ( i = 0 ; i < Ġs -> quant_table_count ; i ++ ) { Ġs -> rc_stat2 [ i ] = av_mallocz ( Ġs -> context_count [ i ] * sizeof ( * Ġs -> rc_stat2 [ i ] ) ) ; if ( ! Ġs -> rc_stat2 [ i ] ) return averror ( enomem ) ; } } if ( avcontext -> stats_in ) { char * p = avcontext -> stats_in ; uint8_t best_state [ 256 ] [ 256 ] ; int gob_count = 0 ; char * next ; av_assert0 ( Ġs -> version >= 2 ) ; for ( ; ; ) { for ( j = 0 ; j < 256 ; j ++ ) for ( i = 0 ; i < 2 ; i ++ ) { Ġs -> rc_stat [ j ] [ i ] = strtol ( p , & next , 0 ) ; if ( next == p ) { av_log ( avcontext , av_log_error , "" \n "" , j , i , p ) ; return averror_invaliddata ; } p = next ; } for ( i = 0 ; i < Ġs -> quant_table_count ; i ++ ) for ( j = 0 ; j < Ġs -> context_count [ i ] ; j ++ ) { for ( k = 0 ; k < 32 ; k ++ ) for ( m = 0 ; m < 2 ; m ++ ) { Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ m ] = strtol ( p , & next , 0 ) ; if ( next == p ) { av_log ( avcontext , av_log_error , "" \n "" , i , j , k , m , p ) ; return averror_invaliddata ; } p = next ; } } gob_count = strtol ( p , & next , 0 ) ; if ( next == p || gob_count <= 0 ) { av_log ( avcontext , av_log_error , "" \n "" ) ; return averror_invaliddata ; } p = next ; while ( * p == ' \n ' || * p == ' ' ) p ++ ; if ( p [ 0 ] == 0 ) break ; } sort_stt ( Ġs , Ġs -> state_transition ) ; find_best_state ( best_state , Ġs -> state_transition ) ; for ( i = 0 ; i < Ġs -> quant_table_count ; i ++ ) { for ( j = 0 ; j < Ġs -> context_count [ i ] ; j ++ ) for ( k = 0 ; k < 32 ; k ++ ) { double p = 128 ; if ( Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ 0 ] + Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ 1 ] ) { p = 256.0 * Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ 1 ] / ( Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ 0 ] + Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ 1 ] ) ; } Ġs -> initial_states [ i ] [ j ] [ k ] = best_state [ av_clip ( round ( p ) , 1 , 255 ) ] [ av_clip ( ( Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ 0 ] + Ġs -> rc_stat2 [ i ] [ j ] [ k ] [ 1 ] ) / gob_count , 0 , 255 ) ] ; } } } if ( Ġs -> version > 1 ) { for ( Ġs -> num_v_slices = 2 ; Ġs -> num_v_slices < 9 ; Ġs -> num_v_slices ++ ) for ( Ġs -> num_h_slices = Ġs -> num_v_slices ; Ġs -> num_h_slices < 2 * Ġs -> num_v_slices ; Ġs -> num_h_slices ++ ) if ( avcontext -> slices == Ġs -> num_h_slices * Ġs -> num_v_slices && avcontext -> slices <= 64 || ! avcontext -> slices ) goto slices_ok ; av_log ( avcontext , av_log_error , "" "" "" \n "" , avcontext -> slices ) ; return averror ( enosys ) ; slices_ok : write_extradata ( Ġs ) ; } if ( ( ret = ffv1_init_slice_contexts ( Ġs ) ) < 0 ) return ret ; if ( ( ret = init_slices_state ( Ġs ) ) < 0 ) return ret ; #define stats_out_size  1024 * 1024 * 6 if (avctx->flags & codec_flag_pass1) { avctx->stats_out = av_mallocz(stats_out_size); for (i = 0; i < s->quant_table_count; i++) for (j = 0; j < s->slice_count; j++) { ffv1context *sf = s->slice_context[j]; av_assert0(!sf->rc_stat2[i]); sf->rc_stat2[i] = av_mallocz(s->context_count[i] * sizeof(*sf->rc_stat2[i])); if (!sf->rc_stat2[i]) return averror(enomem); } } return 0; }",0,0,1,1,"s,desc,version,ec,ac,plane_count,bits_per_raw_sample,packed_at_lsb,chroma_planes,colorspace,transparency,i,state_transition,quant_table_count,quant_tables,0,1,2,3,4,context_count,p,quant_table_index,ret,avctx,coded_frame,pict_type,picture_number,rc_stat2,gob_count,j,rc_stat,k,m,initial_states,num_v_slices,num_h_slices","s:0.15481425821781158,desc:0.014904730021953583,version:0.028928667306900024,ec:-0.002117238938808441,ac:0.011770956218242645,plane_count:0.011927418410778046,bits_per_raw_sample:0.06916198879480362,packed_at_lsb:-0.011722475290298462,chroma_planes:0.02162288874387741,colorspace:0.011618554592132568,transparency:0.0067906975746154785,i:0.02727270871400833,state_transition:0.0,quant_table_count:0.0,quant_tables:0.0,0:0.022260941565036774,1:0.02277342975139618,2:0.010539345443248749,3:0.017668023705482483,4:0.0,context_count:0.0,p:0.0,quant_table_index:0.0,ret:0.005849607288837433,avctx:0.05758925527334213,coded_frame:0.0,pict_type:0.0,picture_number:0.0,rc_stat2:0.0,gob_count:0.0,j:0.030375778675079346,rc_stat:-2.3096799850463867e-07,k:0.011789597570896149,m:0.0013185739517211914,initial_states:-2.3096799850463867e-07,num_v_slices:-1.385807991027832e-06,num_h_slices:-9.238719940185547e-07,",2,162,"s:Ġs,avctx:avcontext,"
"int qemu_devtree_setprop(void *fdt, const char *node_path, const char *property, void *val_array, int size) { int offset; offset = fdt_path_offset(fdt, node_path); if (offset < 0) return offset; return fdt_setprop(fdt, offset, property, val_array, size); }",61,"int qemu_devtree_setprop ( void * fdt , const char * node_path , const char * property , void * val_array , int size ) { int usage ; usage = fdt_path_offset ( fdt , node_path ) ; if ( usage < 0 ) return usage ; return fdt_setprop ( fdt , usage , property , val_array , size ) ; }",1,1,0,1,offset,"offset:-0.20386016368865967,",1,5,"offset:usage,"
"static int mp3lame_encode_frame(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr) { LAMEContext *s = avctx->priv_data; MPADecodeHeader hdr; int len, ret, ch; int lame_result; uint32_t h; if (frame) { switch (avctx->sample_fmt) { case AV_SAMPLE_FMT_S16P: ENCODE_BUFFER(lame_encode_buffer, int16_t, frame->data); break; case AV_SAMPLE_FMT_S32P: ENCODE_BUFFER(lame_encode_buffer_int, int32_t, frame->data); break; case AV_SAMPLE_FMT_FLTP: if (frame->linesize[0] < 4 * FFALIGN(frame->nb_samples, 8)) { av_log(avctx, AV_LOG_ERROR, ""inadequate AVFrame plane padding\n""); return AVERROR(EINVAL); } for (ch = 0; ch < avctx->channels; ch++) { s->fdsp.vector_fmul_scalar(s->samples_flt[ch], (const float *)frame->data[ch], 32768.0f, FFALIGN(frame->nb_samples, 8)); } ENCODE_BUFFER(lame_encode_buffer_float, float, s->samples_flt); break; default: return AVERROR_BUG; } } else { lame_result = lame_encode_flush(s->gfp, s->buffer + s->buffer_index, s->buffer_size - s->buffer_index); } if (lame_result < 0) { if (lame_result == -1) { av_log(avctx, AV_LOG_ERROR, ""lame: output buffer too small (buffer index: %d, free bytes: %d)\n"", s->buffer_index, s->buffer_size - s->buffer_index); } return -1; } s->buffer_index += lame_result; ret = realloc_buffer(s); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, ""error reallocating output buffer\n""); return ret; } /* add current frame to the queue */ if (frame) { if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) return ret; } /* Move 1 frame from the LAME buffer to the output packet, if available. We have to parse the first frame header in the output buffer to determine the frame size. */ if (s->buffer_index < 4) return 0; h = AV_RB32(s->buffer); if (ff_mpa_check_header(h) < 0) { av_log(avctx, AV_LOG_ERROR, ""Invalid mp3 header at start of buffer\n""); return AVERROR_BUG; } if (avpriv_mpegaudio_decode_header(&hdr, h)) { av_log(avctx, AV_LOG_ERROR, ""free format output not supported\n""); return -1; } len = hdr.frame_size; ff_dlog(avctx, ""in:%d packet-len:%d index:%d\n"", avctx->frame_size, len, s->buffer_index); if (len <= s->buffer_index) { if ((ret = ff_alloc_packet(avpkt, len))) { av_log(avctx, AV_LOG_ERROR, ""Error getting output packet\n""); return ret; } memcpy(avpkt->data, s->buffer, len); s->buffer_index -= len; memmove(s->buffer, s->buffer + len, s->buffer_index); /* Get the next frame pts/duration */ ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts, &avpkt->duration); avpkt->size = len; *got_packet_ptr = 1; } return 0; }",546,"static int mp3lame_encode_frame ( avcodeccontext * avctx , avpacket * avpkt , const avframe * frame , int * got_packets_tr ) { lamecontext * s = avctx -> priv_data ; mpadecodeheader hdr ; int len , ret , Ġch ; int lame_result ; uint32_t h ; if ( frame ) { switch ( avctx -> sample_fmt ) { case av_sample_fmt_s16p : encode_buffer ( lame_encode_buffer , int16_t , frame -> data ) ; break ; case av_sample_fmt_s32p : encode_buffer ( lame_encode_buffer_int , int32_t , frame -> data ) ; break ; case av_sample_fmt_fltp : if ( frame -> linesize [ 0 ] < 4 * ffalign ( frame -> nb_samples , 8 ) ) { av_log ( avctx , av_log_error , "" \n "" ) ; return averror ( einval ) ; } for ( Ġch = 0 ; Ġch < avctx -> channels ; Ġch ++ ) { s -> fdsp . vector_fmul_scalar ( s -> samples_flt [ Ġch ] , ( const float * ) frame -> data [ Ġch ] , 32768.0f , ffalign ( frame -> nb_samples , 8 ) ) ; } encode_buffer ( lame_encode_buffer_float , float , s -> samples_flt ) ; break ; default : return averror_bug ; } } else { lame_result = lame_encode_flush ( s -> gfp , s -> buffer + s -> buffer_index , s -> buffer_size - s -> buffer_index ) ; } if ( lame_result < 0 ) { if ( lame_result == -1 ) { av_log ( avctx , av_log_error , "" \n "" , s -> buffer_index , s -> buffer_size - s -> buffer_index ) ; } return -1 ; } s -> buffer_index += lame_result ; ret = realloc_buffer ( s ) ; if ( ret < 0 ) { av_log ( avctx , av_log_error , "" \n "" ) ; return ret ; } if ( frame ) { if ( ( ret = ff_af_queue_add ( & s -> afq , frame ) ) < 0 ) return ret ; } if ( s -> buffer_index < 4 ) return 0 ; h = av_rb32 ( s -> buffer ) ; if ( ff_mpa_check_header ( h ) < 0 ) { av_log ( avctx , av_log_error , "" \n "" ) ; return averror_bug ; } if ( avpriv_mpegaudio_decode_header ( & hdr , h ) ) { av_log ( avctx , av_log_error , "" \n "" ) ; return -1 ; } len = hdr . frame_size ; ff_dlog ( avctx , "" \n "" , avctx -> frame_size , len , s -> buffer_index ) ; if ( len <= s -> buffer_index ) { if ( ( ret = ff_alloc_packet ( avpkt , len ) ) ) { av_log ( avctx , av_log_error , "" \n "" ) ; return ret ; } memcpy ( avpkt -> data , s -> buffer , len ) ; s -> buffer_index -= len ; memmove ( s -> buffer , s -> buffer + len , s -> buffer_index ) ; ff_af_queue_remove ( & s -> afq , avctx -> frame_size , & avpkt -> pts , & avpkt -> duration ) ; avpkt -> size = len ; * got_packets_tr = 1 ; } return 0 ; }",0,0,1,1,"s,ch,lame_result,buffer_index,ret,h,len,avpkt,size,got_packet_ptr","s:-0.5312821939587593,ch:0.01072172075510025,lame_result:0.024928301572799683,buffer_index:-0.14354345202445984,ret:-0.22107916325330734,h:-0.14122013002634048,len:-0.22303513437509537,avpkt:-0.05529356002807617,size:-0.02573421597480774,got_packet_ptr:-0.03946109116077423,",2,8,"ch:Ġch,got_packet_ptr:got_packets_tr,"
"static int tta_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; TTAContext *s = avctx->priv_data; int i; init_get_bits(&s->gb, buf, buf_size*8); { int32_t predictors[s->channels]; TTAFilter filters[s->channels]; TTARice rices[s->channels]; int cur_chan = 0, framelen = s->frame_length; int32_t *p; // FIXME: seeking s->total_frames--; if (!s->total_frames && s->last_frame_length) framelen = s->last_frame_length; // init per channel states for (i = 0; i < s->channels; i++) { predictors[i] = 0; ttafilter_init(&(filters[i]), ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]); rice_init(&(rices[i]), 10, 10); } for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { int32_t *predictor = &(predictors[cur_chan]); TTAFilter *filter = &(filters[cur_chan]); TTARice *rice = &(rices[cur_chan]); uint32_t unary, depth, k; int32_t value; unary = tta_get_unary(&s->gb); if (unary == 0) { depth = 0; k = rice->k0; } else { depth = 1; k = rice->k1; unary--; } if (k) value = (unary << k) + get_bits(&s->gb, k); else value = unary; // FIXME: copy paste from original switch (depth) { case 1: rice->sum1 += value - (rice->sum1 >> 4); if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1]) rice->k1--; else if(rice->sum1 > shift_16[rice->k1 + 1]) rice->k1++; value += shift_1[rice->k0]; default: rice->sum0 += value - (rice->sum0 >> 4); if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0]) rice->k0--; else if(rice->sum0 > shift_16[rice->k0 + 1]) rice->k0++; } // extract coded value #define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1)) *p = UNFOLD(value); // run hybrid filter ttafilter_process(filter, p, 0); // fixed order prediction #define PRED(x, k) (int32_t)((((uint64_t)x << k) - x) >> k) switch (s->bps) { case 1: *p += PRED(*predictor, 4); break; case 2: case 3: *p += PRED(*predictor, 5); break; case 4: *p += *predictor; break; } *predictor = *p; #if 0 // extract 32bit float from last two int samples if (s->is_float && ((p - data) & 1)) { uint32_t neg = *p & 0x80000000; uint32_t hi = *(p - 1); uint32_t lo = abs(*p) - 1; hi += (hi || lo) ? 0x3f80 : 0; // SWAP16: swap all the 16 bits *(p - 1) = (hi << 16) | SWAP16(lo) | neg; } #endif /*if ((get_bits_count(&s->gb)+7)/8 > buf_size) { av_log(NULL, AV_LOG_INFO, ""overread!!\n""); break; }*/ // flip channels if (cur_chan < (s->channels-1)) cur_chan++; else { // decorrelate in case of stereo integer if (!s->is_float && (s->channels > 1)) { int32_t *r = p - 1; for (*p += *r / 2; r > p - s->channels; r--) *r = *(r + 1) - *r; } cur_chan = 0; } } skip_bits(&s->gb, 32); // frame crc // convert to output buffer switch(s->bps) { case 2: { uint16_t *samples = data; for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { // *samples++ = (unsigned char)*p; // *samples++ = (unsigned char)(*p >> 8); *samples++ = *p; } *data_size = (uint8_t *)samples - (uint8_t *)data; break; } default: av_log(s->avctx, AV_LOG_ERROR, ""Error, only 16bit samples supported!\n""); } } // return get_bits_count(&s->gb)+7)/8; return buf_size; }",102,"static int tta_decode_frame ( avcodeccontext * avctx , void * data , int * data_size , avpacket * avpkt ) { const uint8_t * bytes = avpkt -> data ; int buf_size = avpkt -> size ; ttacontext * s = avctx -> priv_data ; int i ; init_get_bits ( & s -> gb , bytes , buf_size * 8 ) ; { int32_t predictors [ s -> channels ] ; ttafilter filters [ s -> channels ] ; ttarice rices [ s -> channels ] ; int cur_chan = 0 , framgelength = s -> frame_length ; int32_t * p ;",1,1,0,1,"buf,buf_size,s,cur_chan,framelen","buf:-0.06207716464996338,buf_size:-0.11440098285675049,s:-0.14058709144592285,cur_chan:-0.09198743104934692,framelen:-0.036033034324645996,",2,3,"framelen:framgelength,buf:bytes,"
"yuv2rgba64_2_c_template(SwsContext *c, const int32_t *buf[2], const int32_t *ubuf[2], const int32_t *vbuf[2], const int32_t *abuf[2], uint16_t *dest, int dstW, int yalpha, int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes) { const int32_t *buf0 = buf[0], *buf1 = buf[1], *ubuf0 = ubuf[0], *ubuf1 = ubuf[1], *vbuf0 = vbuf[0], *vbuf1 = vbuf[1], *abuf0 = hasAlpha ? abuf[0] : NULL, *abuf1 = hasAlpha ? abuf[1] : NULL; int yalpha1 = 4096 - yalpha; int uvalpha1 = 4096 - uvalpha; int i; int A1 = 0xffff<<14, A2 = 0xffff<<14; for (i = 0; i < ((dstW + 1) >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 14; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 14; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha + (-128 << 23)) >> 14; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha + (-128 << 23)) >> 14; int R, G, B; Y1 -= c->yuv2rgb_y_offset; Y2 -= c->yuv2rgb_y_offset; Y1 *= c->yuv2rgb_y_coeff; Y2 *= c->yuv2rgb_y_coeff; Y1 += 1 << 13; Y2 += 1 << 13; R = V * c->yuv2rgb_v2r_coeff; G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff; B = U * c->yuv2rgb_u2b_coeff; if (hasAlpha) { A1 = (abuf0[i * 2 ] * yalpha1 + abuf1[i * 2 ] * yalpha) >> 1; A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 1; A1 += 1 << 13; A2 += 1 << 13; } output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14); output_pixel(&dest[1], av_clip_uintp2( G + Y1, 30) >> 14); output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14); if (eightbytes) { output_pixel(&dest[3], av_clip_uintp2(A1 , 30) >> 14); output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14); output_pixel(&dest[5], av_clip_uintp2( G + Y2, 30) >> 14); output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14); output_pixel(&dest[7], av_clip_uintp2(A2 , 30) >> 14); dest += 8; } else { output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14); output_pixel(&dest[4], av_clip_uintp2( G + Y2, 30) >> 14); output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14); dest += 6; } } }",678,,0,1,,-4,"buf0,buf1,ubuf0,ubuf1,vbuf0,vbuf1,abuf0,abuf1,yalpha1,uvalpha1,a1,a2,i,y1,y2,u,v,r,g,b,dest",,,,
"static void backup_duplicate_context(MpegEncContext *bak, MpegEncContext *src){ #define COPY(a) bak->a= src->a COPY(allocated_edge_emu_buffer); COPY(edge_emu_buffer); COPY(me.scratchpad); COPY(me.temp); COPY(rd_scratchpad); COPY(b_scratchpad); COPY(obmc_scratchpad); COPY(me.map); COPY(me.score_map); COPY(blocks); COPY(block); COPY(start_mb_y); COPY(end_mb_y); COPY(me.map_generation); COPY(pb); COPY(dct_error_sum); COPY(dct_count[0]); COPY(dct_count[1]); COPY(ac_val_base); COPY(ac_val[0]); COPY(ac_val[1]); COPY(ac_val[2]); #undef COPY }",19,,1,0,,-4,,,,,
static av_cold void free_frame_buffers(Indeo3DecodeContext *ctx) { int p; ctx->width= ctx->height= 0; for (p = 0; p < 3; p++) { av_freep(&ctx->planes[p].buffers[0]); av_freep(&ctx->planes[p].buffers[1]); ctx->planes[p].pixels[0] = ctx->planes[p].pixels[1] = 0; } },97,,0,1,,-4,"ctx,width,height,p,planes,pixels,0,1",,,,
"static AVInputFormat *probe_input_format(AVProbeData *pd, int is_opened) { AVInputFormat *fmt1, *fmt; int score, score_max; fmt = NULL; score_max = 0; for(fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1->next) { if (!is_opened && !(fmt1->flags & AVFMT_NOFILE)) continue; score = 0; if (fmt1->extensions) { if (match_ext(pd->filename, fmt1->extensions)) { score = 50; } } else if (fmt1->read_probe) { score = fmt1->read_probe(pd); } if (score > score_max) { score_max = score; fmt = fmt1; } } return fmt; }",136,"static avinputformat * probe_input_format ( avprobedata * pd , int is_opened ) { avinputformat * ftx1 , * fmt ; int ĠScore , score_max ; fmt = null ; score_max = 0 ; for ( ftx1 = first_iformat ; ftx1 != null ; ftx1 = ftx1 -> next ) { if ( ! is_opened && ! ( ftx1 -> flags & avfmt_nofile ) ) continue ; ĠScore = 0 ; if ( ftx1 -> extensions ) { if ( match_ext ( pd -> filename , ftx1 -> extensions ) ) { ĠScore = 50 ; } } else if ( ftx1 -> read_probe ) { ĠScore = ftx1 -> read_probe ( pd ) ; } if ( ĠScore > score_max ) { score_max = ĠScore ; fmt = ftx1 ; } } return fmt ; }",0,0,1,1,"fmt,score_max,fmt1,score","fmt:0.044267088174819946,score_max:0.2462487667798996,fmt1:0.3933566063642502,score:0.48009753227233887,",2,17,"score:ĠScore,fmt1:ftx1,"
"static void pc_dimm_check_memdev_is_busy(Object *obj, const char *name, Object *val, Error **errp) { MemoryRegion *mr; mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), errp); if (memory_region_is_mapped(mr)) { char *path = object_get_canonical_path_component(val); error_setg(errp, ""can't use already busy memdev: %s"", path); g_free(path); } else { qdev_prop_allow_set_link_before_realize(obj, name, val, errp); } }",87,"static void pc_dimm_check_memdev_is_busy ( object * obj , const char * name , object * val , error * * errp ) { memoryregion * kr ; kr = host_memory_backend_get_memory ( memory_backend ( val ) , errp ) ; if ( memory_region_is_mapped ( kr ) ) { char * path = object_get_canonical_path_component ( val ) ; error_setg ( errp , "" "" , path ) ; g_free ( path ) ; } else { qdev_prop_allow_set_link_before_realize ( obj , name , val , errp ) ; } }",1,1,0,1,"mr,path","mr:0.19808635115623474,path:-0.40720097720623016,",1,3,"mr:kr,"
"int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { int ret; AVStream *st; ff_read_frame_flush(s); if(flags & AVSEEK_FLAG_BYTE) return av_seek_frame_byte(s, stream_index, timestamp, flags); if(stream_index < 0){ stream_index= av_find_default_stream_index(s); if(stream_index < 0) return -1; st= s->streams[stream_index]; /* timestamp for default must be expressed in AV_TIME_BASE units */ timestamp = av_rescale(timestamp, st->time_base.den, AV_TIME_BASE * (int64_t)st->time_base.num); } /* first, we try the format specific seek */ if (s->iformat->read_seek) ret = s->iformat->read_seek(s, stream_index, timestamp, flags); else ret = -1; if (ret >= 0) { return 0; } if(s->iformat->read_timestamp) return av_seek_frame_binary(s, stream_index, timestamp, flags); else return av_seek_frame_generic(s, stream_index, timestamp, flags); }",179,"int av_seek_frame ( avformatcontext * s , int stream_number , int64_t tminal , int flags ) { int addr ; avstream * st ; ff_read_frame_flush ( s ) ; if ( flags & avseek_flag_byte ) return av_seek_frame_byte ( s , stream_number , tminal , flags ) ; if ( stream_number < 0 ) { stream_number = av_find_default_stream_index ( s ) ; if ( stream_number < 0 ) return -1 ; st = s -> streams [ stream_number ] ; tminal = av_rescale ( tminal , st -> time_base . den , av_time_base * ( int64_t ) st -> time_base . num ) ; } if ( s -> iformat -> read_seek ) addr = s -> iformat -> read_seek ( s , stream_number , tminal , flags ) ; else addr = -1 ; if ( addr >= 0 ) { return 0 ; } if ( s -> iformat -> read_timestamp ) return av_seek_frame_binary ( s , stream_number , tminal , flags ) ; else return av_seek_frame_generic ( s , stream_number , tminal , flags ) ; }",1,1,0,1,"stream_index,st,timestamp,ret","stream_index:-0.2898678183555603,st:-0.34915411472320557,timestamp:-0.23929202556610107,ret:-0.28334707021713257,",3,20,"timestamp:tminal,ret:addr,stream_index:stream_number,"
"static int mpeg_mux_end(AVFormatContext *ctx) { StreamInfo *stream; int i; /* flush each packet */ for(i=0;i<ctx->nb_streams;i++) { stream = ctx->streams[i]->priv_data; if (stream->buffer_ptr > 0) { if (i == (ctx->nb_streams - 1)) flush_packet(ctx, i, 1); else flush_packet(ctx, i, 0); } } /* write the end header */ //put_be32(&ctx->pb, ISO_11172_END_CODE); //put_flush_packet(&ctx->pb); for(i=0;i<ctx->nb_streams;i++) av_freep(&ctx->streams[i]->priv_data); return 0; }",86,"static int mpeg_mux_end ( avformatcontext * ctx ) { streaminfo * stream ; int Ġbi ; for ( Ġbi = 0 ; Ġbi < ctx -> nb_streams ; Ġbi ++ ) { stream = ctx -> streams [ Ġbi ] -> priv_data ; if ( stream -> buffer_ptr > 0 ) { if ( Ġbi == ( ctx -> nb_streams - 1 ) ) flush_packet ( ctx , Ġbi , 1 ) ; else flush_packet ( ctx , Ġbi , 0 ) ; } } ",0,0,1,1,"i,stream","i:0.9036021381616592,stream:0.6718818545341492,",1,8,"i:Ġbi,"
"static void virtio_scsi_complete_req(VirtIOSCSIReq *req) { VirtIOSCSI *s = req->dev; VirtQueue *vq = req->vq; VirtIODevice *vdev = VIRTIO_DEVICE(s); qemu_iovec_from_buf(&req->resp_iov, 0, &req->resp, req->resp_size); virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size); if (s->dataplane_started && !s->dataplane_fenced) { virtio_scsi_dataplane_notify(vdev, req); } else { virtio_notify(vdev, vq); } if (req->sreq) { req->sreq->hba_private = NULL; scsi_req_unref(req->sreq); } virtio_scsi_free_req(req); }",134,"static void virtio_scsi_complete_req ( virtioscsireq * req ) { virtioscsi * s = req -> dev ; virtqueue * vq = req -> vq ; virtiodevice * tdevice = virtio_device ( s ) ; qemu_iovec_from_buf ( & req -> resp_iov , 0 , & req -> resp , req -> resp_size ) ; virtqueue_push ( vq , & req -> elem , req -> qsgl . size + req -> resp_iov . size ) ; if ( s -> dataplane_started && ! s -> dataplane_fenced ) { virtio_scsi_dataplane_notify ( tdevice , req ) ; } else { virtio_notify ( tdevice , vq ) ; } if ( req -> sreq ) { req -> sreq -> hba_private = null ; scsi_req_unref ( req -> sreq ) ; } virtio_scsi_free_req ( req ) ; }",1,1,0,1,"s,vq,vdev,req,sreq,hba_private","s:-0.08807146549224854,vq:-0.09560298919677734,vdev:-0.006607115268707275,req:-0.2707420587539673,sreq:-0.038257896900177,hba_private:-0.013016998767852783,",1,3,"vdev:tdevice,"
"static int inet_connect_addr(struct addrinfo *addr, bool block, bool *in_progress) { int sock, rc; if (in_progress) { *in_progress = false; } sock = qemu_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol); if (sock < 0) { fprintf(stderr, ""%s: socket(%s): %s\n"", __func__, inet_strfamily(addr->ai_family), strerror(errno)); return -1; } setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)); if (!block) { socket_set_nonblock(sock); } /* connect to peer */ do { rc = 0; if (connect(sock, addr->ai_addr, addr->ai_addrlen) < 0) { rc = -socket_error(); } } while (rc == -EINTR); if (!block && QEMU_SOCKET_RC_INPROGRESS(rc)) { if (in_progress) { *in_progress = true; } } else if (rc < 0) { closesocket(sock); return -1; } return sock; }",198,,1,0,,-4,"sock,rc,in_progress",,,,
"static void gen_rfci(DisasContext *ctx) { #if defined(CONFIG_USER_ONLY) gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); #else if (unlikely(ctx->pr)) { gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); return; } /* Restore CPU state */ gen_helper_rfci(cpu_env); gen_sync_exception(ctx); #endif }",23,,1,1,,-3,,,,,
"static int opt_new_stream(const char *opt, const char *arg) { AVFormatContext *oc; if (nb_output_files <= 0) { fprintf(stderr, ""At least one output file must be specified\n""); ffmpeg_exit(1); } oc = output_files[nb_output_files - 1]; if (!strcmp(opt, ""newvideo"" )) new_video_stream (oc); else if (!strcmp(opt, ""newaudio"" )) new_audio_stream (oc); else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc); else av_assert0(0); return 0; }",110,"static int opt_new_stream ( const char * opt , const char * arg ) { avformatcontext * soc ; if ( nb_output_files <= 0 ) { fprintf ( stderr , "" \n "" ) ; ffmpeg_exit ( 1 ) ; } soc = output_files [ nb_output_files - 1 ] ; if ( ! strcmp ( opt , "" "" ) ) new_video_stream ( soc ) ; else if ( ! strcmp ( opt , "" "" ) ) new_audio_stream ( soc ) ; else if ( ! strcmp ( opt , "" "" ) ) new_subtitle_stream ( soc ) ; else av_assert0 ( 0 ) ; return 0 ; }",1,1,0,1,oc,"oc:-0.3035532236099243,",1,5,"oc:soc,"
"void ff_vp3_v_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values) { unsigned char *end; int filter_value; const int nstride= -stride; for (end= first_pixel + 8; first_pixel < end; first_pixel++) { filter_value = (first_pixel[2 * nstride] - first_pixel[ stride]) +3*(first_pixel[0 ] - first_pixel[nstride]); filter_value = bounding_values[(filter_value + 4) >> 3]; first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value); first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value); } }",121,"void ff_vp3_v_loop_filter_c ( uint8_t * First_page , int stride , int * bounding_values ) { unsigned char * end ; int filter;key ; const int nstride = - stride ; for ( end = First_page + 8 ; First_page < end ; First_page ++ ) { filter;key = ( First_page [ 2 * nstride ] - First_page [ stride ] ) + 3 * ( First_page [ 0 ] - First_page [ nstride ] ) ; filter;key = bounding_values [ ( filter;key + 4 ) >> 3 ] ; First_page [ nstride ] = av_clip_uint8 ( First_page [ nstride ] + filter;key ) ; First_page [ 0 ] = av_clip_uint8 ( First_page [ 0 ] - filter;key ) ; } }",0,0,1,1,"nstride,end,first_pixel,filter_value,0","nstride:0.17891108989715576,end:0.2802138552069664,first_pixel:0.5746140517294407,filter_value:0.4100280702114105,0:0.1229078471660614,",2,18,"first_pixel:First_page,filter_value:filter;key,"
"void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[4]){ int w_align= 1; int h_align= 1; switch(s->pix_fmt){ case PIX_FMT_YUV420P: case PIX_FMT_YUYV422: case PIX_FMT_UYVY422: case PIX_FMT_YUV422P: case PIX_FMT_YUV440P: case PIX_FMT_YUV444P: case PIX_FMT_GRAY8: case PIX_FMT_GRAY16BE: case PIX_FMT_GRAY16LE: case PIX_FMT_YUVJ420P: case PIX_FMT_YUVJ422P: case PIX_FMT_YUVJ440P: case PIX_FMT_YUVJ444P: case PIX_FMT_YUVA420P: case PIX_FMT_YUV420P9LE: case PIX_FMT_YUV420P9BE: case PIX_FMT_YUV420P10LE: case PIX_FMT_YUV420P10BE: case PIX_FMT_YUV422P10LE: case PIX_FMT_YUV422P10BE: w_align= 16; //FIXME check for non mpeg style codecs and use less alignment h_align= 16; if(s->codec_id == CODEC_ID_MPEG2VIDEO || s->codec_id == CODEC_ID_MJPEG || s->codec_id == CODEC_ID_AMV || s->codec_id == CODEC_ID_THP || s->codec_id == CODEC_ID_H264) h_align= 32; // interlaced is rounded up to 2 MBs break; case PIX_FMT_YUV411P: case PIX_FMT_UYYVYY411: w_align=32; h_align=8; break; case PIX_FMT_YUV410P: if(s->codec_id == CODEC_ID_SVQ1){ w_align=64; h_align=64; } case PIX_FMT_RGB555: if(s->codec_id == CODEC_ID_RPZA){ w_align=4; h_align=4; } case PIX_FMT_PAL8: case PIX_FMT_BGR8: case PIX_FMT_RGB8: if(s->codec_id == CODEC_ID_SMC){ w_align=4; h_align=4; } break; case PIX_FMT_BGR24: if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){ w_align=4; h_align=4; } break; default: w_align= 1; h_align= 1; break; } *width = FFALIGN(*width , w_align); *height= FFALIGN(*height, h_align); if(s->codec_id == CODEC_ID_H264 || s->lowres) *height+=2; // some of the optimized chroma MC reads one line too much // which is also done in mpeg decoders with lowres > 0 linesize_align[0] = linesize_align[1] = linesize_align[2] = linesize_align[3] = STRIDE_ALIGN; //STRIDE_ALIGN is 8 for SSE* but this does not work for SVQ1 chroma planes //we could change STRIDE_ALIGN to 16 for x86/sse but it would increase the //picture size unneccessarily in some cases. The solution here is not //pretty and better ideas are welcome! #if HAVE_MMX if(s->codec_id == CODEC_ID_SVQ1 || s->codec_id == CODEC_ID_VP5 || s->codec_id == CODEC_ID_VP6 || s->codec_id == CODEC_ID_VP6F || s->codec_id == CODEC_ID_VP6A) { linesize_align[0] = linesize_align[1] = linesize_align[2] = 16; } #endif }",103,,1,0,,-4,"w_align,h_align",,,,
"static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl, const H2645NAL *nal) { const SPS *sps; const PPS *pps; int ret; unsigned int slice_type, tmp, i; int field_pic_flag, bottom_field_flag; int frame_num, droppable, picture_structure; int mb_aff_frame = 0; sl->first_mb_addr = get_ue_golomb(&sl->gb); if (sl->first_mb_addr == 0) { // FIXME better field boundary detection if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) { ff_h264_field_end(h, sl, 1); } h->current_slice = 0; if (!h->first_field) { if (h->cur_pic_ptr && !h->droppable) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, h->picture_structure == PICT_BOTTOM_FIELD); } h->cur_pic_ptr = NULL; } } slice_type = get_ue_golomb_31(&sl->gb); if (slice_type > 9) { av_log(h->avctx, AV_LOG_ERROR, ""slice type %d too large at %d\n"", slice_type, sl->first_mb_addr); return AVERROR_INVALIDDATA; } if (slice_type > 4) { slice_type -= 5; sl->slice_type_fixed = 1; } else sl->slice_type_fixed = 0; slice_type = ff_h264_golomb_to_pict_type[slice_type]; sl->slice_type = slice_type; sl->slice_type_nos = slice_type & 3; if (nal->type == NAL_IDR_SLICE && sl->slice_type_nos != AV_PICTURE_TYPE_I) { av_log(h->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.\n""); return AVERROR_INVALIDDATA; } sl->pps_id = get_ue_golomb(&sl->gb); if (sl->pps_id >= MAX_PPS_COUNT) { av_log(h->avctx, AV_LOG_ERROR, ""pps_id %u out of range\n"", sl->pps_id); return AVERROR_INVALIDDATA; } if (!h->ps.pps_list[sl->pps_id]) { av_log(h->avctx, AV_LOG_ERROR, ""non-existing PPS %u referenced\n"", sl->pps_id); return AVERROR_INVALIDDATA; } if (h->current_slice > 0 && h->ps.pps != (const PPS*)h->ps.pps_list[sl->pps_id]->data) { av_log(h->avctx, AV_LOG_ERROR, ""PPS changed between slices\n""); return AVERROR_INVALIDDATA; } pps = (const PPS*)h->ps.pps_list[sl->pps_id]->data; if (!h->ps.sps_list[pps->sps_id]) { av_log(h->avctx, AV_LOG_ERROR, ""non-existing SPS %u referenced\n"", pps->sps_id); return AVERROR_INVALIDDATA; } sps = (const SPS*)h->ps.sps_list[pps->sps_id]->data; frame_num = get_bits(&sl->gb, sps->log2_max_frame_num); if (!h->setup_finished) h->poc.frame_num = frame_num; sl->mb_mbaff = 0; droppable = nal->ref_idc == 0; if (sps->frame_mbs_only_flag) { picture_structure = PICT_FRAME; } else { field_pic_flag = get_bits1(&sl->gb); if (field_pic_flag) { bottom_field_flag = get_bits1(&sl->gb); picture_structure = PICT_TOP_FIELD + bottom_field_flag; } else { picture_structure = PICT_FRAME; mb_aff_frame = sps->mb_aff; } } if (!h->setup_finished) { h->mb_aff_frame = mb_aff_frame; } sl->picture_structure = picture_structure; sl->mb_field_decoding_flag = picture_structure != PICT_FRAME; if (h->current_slice != 0) { if (h->picture_structure != picture_structure || h->droppable != droppable) { av_log(h->avctx, AV_LOG_ERROR, ""Changing field mode (%d -> %d) between slices is not allowed\n"", h->picture_structure, picture_structure); return AVERROR_INVALIDDATA; } else if (!h->cur_pic_ptr) { av_log(h->avctx, AV_LOG_ERROR, ""unset cur_pic_ptr on slice %d\n"", h->current_slice + 1); return AVERROR_INVALIDDATA; } } if (picture_structure == PICT_FRAME) { h->curr_pic_num = h->poc.frame_num; h->max_pic_num = 1 << sps->log2_max_frame_num; } else { h->curr_pic_num = 2 * h->poc.frame_num + 1; h->max_pic_num = 1 << (sps->log2_max_frame_num + 1); } if (nal->type == NAL_IDR_SLICE) get_ue_golomb(&sl->gb); /* idr_pic_id */ if (sps->poc_type == 0) { int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb); if (!h->setup_finished) h->poc.poc_lsb = poc_lsb; if (pps->pic_order_present == 1 && picture_structure == PICT_FRAME) { int delta_poc_bottom = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc_bottom = delta_poc_bottom; } } if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) { int delta_poc = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc[0] = delta_poc; if (pps->pic_order_present == 1 && picture_structure == PICT_FRAME) { delta_poc = get_se_golomb(&sl->gb); if (!h->setup_finished) h->poc.delta_poc[1] = delta_poc; } } if (pps->redundant_pic_cnt_present) sl->redundant_pic_count = get_ue_golomb(&sl->gb); if (sl->slice_type_nos == AV_PICTURE_TYPE_B) sl->direct_spatial_mv_pred = get_bits1(&sl->gb); ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count, &sl->gb, pps, sl->slice_type_nos, picture_structure); if (ret < 0) return ret; if (sl->slice_type_nos != AV_PICTURE_TYPE_I) { ret = ff_h264_decode_ref_pic_list_reordering(h, sl); if (ret < 0) { sl->ref_count[1] = sl->ref_count[0] = 0; return ret; } } sl->pwt.use_weight = 0; for (i = 0; i < 2; i++) { sl->pwt.luma_weight_flag[i] = 0; sl->pwt.chroma_weight_flag[i] = 0; } if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) || (pps->weighted_bipred_idc == 1 && sl->slice_type_nos == AV_PICTURE_TYPE_B)) ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count, sl->slice_type_nos, &sl->pwt); sl->explicit_ref_marking = 0; if (nal->ref_idc) { ret = ff_h264_decode_ref_pic_marking(h, sl, &sl->gb); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) return AVERROR_INVALIDDATA; } if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) { tmp = get_ue_golomb_31(&sl->gb); if (tmp > 2) { av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow\n"", tmp); return AVERROR_INVALIDDATA; } sl->cabac_init_idc = tmp; } sl->last_qscale_diff = 0; tmp = pps->init_qp + get_se_golomb(&sl->gb); if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) { av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp); return AVERROR_INVALIDDATA; } sl->qscale = tmp; sl->chroma_qp[0] = get_chroma_qp(pps, 0, sl->qscale); sl->chroma_qp[1] = get_chroma_qp(pps, 1, sl->qscale); // FIXME qscale / qp ... stuff if (sl->slice_type == AV_PICTURE_TYPE_SP) get_bits1(&sl->gb); /* sp_for_switch_flag */ if (sl->slice_type == AV_PICTURE_TYPE_SP || sl->slice_type == AV_PICTURE_TYPE_SI) get_se_golomb(&sl->gb); /* slice_qs_delta */ sl->deblocking_filter = 1; sl->slice_alpha_c0_offset = 0; sl->slice_beta_offset = 0; if (pps->deblocking_filter_parameters_present) { tmp = get_ue_golomb_31(&sl->gb); if (tmp > 2) { av_log(h->avctx, AV_LOG_ERROR, ""deblocking_filter_idc %u out of range\n"", tmp); return AVERROR_INVALIDDATA; } sl->deblocking_filter = tmp; if (sl->deblocking_filter < 2) sl->deblocking_filter ^= 1; // 1<->0 if (sl->deblocking_filter) { sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2; sl->slice_beta_offset = get_se_golomb(&sl->gb) * 2; if (sl->slice_alpha_c0_offset > 12 || sl->slice_alpha_c0_offset < -12 || sl->slice_beta_offset > 12 || sl->slice_beta_offset < -12) { av_log(h->avctx, AV_LOG_ERROR, ""deblocking filter parameters %d %d out of range\n"", sl->slice_alpha_c0_offset, sl->slice_beta_offset); return AVERROR_INVALIDDATA; } } } return 0; }",77,,0,1,,-4,"mb_aff_frame,sl,first_mb_addr",,,,
"static inline void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile) { int i, csize = 1; void *src[3]; for (i = 1; i < 3; i++) if (tile->codsty[0].transform != tile->codsty[i].transform) { av_log(s->avctx, AV_LOG_ERROR, ""Transforms mismatch, MCT not supported\n""); return; } for (i = 0; i < 3; i++) if (tile->codsty[0].transform == FF_DWT97) src[i] = tile->comp[i].f_data; else src[i] = tile->comp[i].i_data; for (i = 0; i < 2; i++) csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0]; s->dsp.mct_decode[tile->codsty[0].transform](src[0], src[1], src[2], csize); }",213,,0,1,,-4,"csize,i,src",,,,
static inline void RENAME(rgb2rgb_init)(void) { #if !COMPILE_TEMPLATE_SSE2 #if !COMPILE_TEMPLATE_AMD3DNOW rgb15to16 = RENAME(rgb15to16); rgb15tobgr24 = RENAME(rgb15tobgr24); rgb15to32 = RENAME(rgb15to32); rgb16tobgr24 = RENAME(rgb16tobgr24); rgb16to32 = RENAME(rgb16to32); rgb16to15 = RENAME(rgb16to15); rgb24tobgr16 = RENAME(rgb24tobgr16); rgb24tobgr15 = RENAME(rgb24tobgr15); rgb24tobgr32 = RENAME(rgb24tobgr32); rgb32to16 = RENAME(rgb32to16); rgb32to15 = RENAME(rgb32to15); rgb32tobgr24 = RENAME(rgb32tobgr24); rgb24to15 = RENAME(rgb24to15); rgb24to16 = RENAME(rgb24to16); rgb24tobgr24 = RENAME(rgb24tobgr24); shuffle_bytes_2103 = RENAME(shuffle_bytes_2103); rgb32tobgr16 = RENAME(rgb32tobgr16); rgb32tobgr15 = RENAME(rgb32tobgr15); yv12toyuy2 = RENAME(yv12toyuy2); yv12touyvy = RENAME(yv12touyvy); yuv422ptoyuy2 = RENAME(yuv422ptoyuy2); yuv422ptouyvy = RENAME(yuv422ptouyvy); yuy2toyv12 = RENAME(yuy2toyv12); vu9_to_vu12 = RENAME(vu9_to_vu12); yvu9_to_yuy2 = RENAME(yvu9_to_yuy2); uyvytoyuv422 = RENAME(uyvytoyuv422); yuyvtoyuv422 = RENAME(yuyvtoyuv422); #endif /* !COMPILE_TEMPLATE_AMD3DNOW */ #if COMPILE_TEMPLATE_MMXEXT || COMPILE_TEMPLATE_AMD3DNOW planar2x = RENAME(planar2x); #endif /* COMPILE_TEMPLATE_MMXEXT || COMPILE_TEMPLATE_AMD3DNOW */ rgb24toyv12 = RENAME(rgb24toyv12); yuyvtoyuv420 = RENAME(yuyvtoyuv420); uyvytoyuv420 = RENAME(uyvytoyuv420); #endif /* !COMPILE_TEMPLATE_SSE2 */ #if !COMPILE_TEMPLATE_AMD3DNOW interleaveBytes = RENAME(interleaveBytes); #endif /* !COMPILE_TEMPLATE_AMD3DNOW */ },209,,1,0,,-4,"rename,rgb2rgb_init,void,rgb15tobgr24,rgb15to32,rgb16tobgr24,rgb16to32,rgb16to15,rgb24tobgr16,rgb24tobgr15,rgb24tobgr32,rgb32to16,rgb32to15,rgb32tobgr24,rgb24to15,rgb24to16,rgb24tobgr24,shuffle_bytes_2103,rgb32tobgr16,rgb32tobgr15,yv12toyuy2,yv12touyvy,yuv422ptoyuy2,yuv422ptouyvy,yuy2toyv12,vu9_to_vu12,yvu9_to_yuy2,uyvytoyuv422,yuyvtoyuv422",,,,
"static int hls_write_header(AVFormatContext *s) { HLSContext *hls = s->priv_data; int ret, i; char *p; const char *pattern = ""%d.ts""; int basename_size = strlen(s->filename) + strlen(pattern); hls->number = 0; hls->recording_time = hls->time * 1000000; hls->start_pts = AV_NOPTS_VALUE; for (i = 0; i < s->nb_streams; i++) hls->has_video += s->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO; if (hls->has_video > 1) av_log(s, AV_LOG_WARNING, ""More than a single video stream present, "" ""expect issues decoding it.\n""); hls->oformat = av_guess_format(""mpegts"", NULL, NULL); if (!hls->oformat) { ret = AVERROR_MUXER_NOT_FOUND; goto fail; } hls->basename = av_malloc(basename_size); if (!hls->basename) { ret = AVERROR(ENOMEM); goto fail; } strcpy(hls->basename, s->filename); p = strrchr(hls->basename, '.'); if (p) *p = '\0'; av_strlcat(hls->basename, ""%d.ts"", basename_size); if ((ret = hls_mux_init(s)) < 0) goto fail; if ((ret = hls_start(s)) < 0) goto fail; if ((ret = avformat_write_header(hls->avf, NULL)) < 0) return ret; fail: if (ret) { av_free(hls->basename); if (hls->avf) avformat_free_context(hls->avf); } return ret; }",312,"static int hls_write_header ( avformatcontext * s ) { hlscontext * hls = s -> priv_data ; int reset , i ; char * p ; const char * pattern = "" "" ; int basename_size = strlen ( s -> filename ) + strlen ( pattern ) ; hls -> number = 0 ; hls -> recording_time = hls -> time * 1000000 ; hls -> start_pts = av_nopts_value ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) hls -> has_video += s -> streams [ i ] -> codec -> codec_type == avmedia_type_video ; if ( hls -> has_video > 1 ) av_log ( s , av_log_warning , "" "" "" \n "" ) ; hls -> oformat = av_guess_format ( "" "" , null , null ) ; if ( ! hls -> oformat ) { reset = averror_muxer_not_found ; goto fail ; } hls -> basename = av_malloc ( basename_size ) ; if ( ! hls -> basename ) { reset = averror ( enomem ) ; goto fail ; } strcpy ( hls -> basename , s -> filename ) ; p = strrchr ( hls -> basename , ' ' ) ; if ( p ) * p = ' \0 ' ; av_strlcat ( hls -> basename , "" "" , basename_size ) ; if ( ( reset = hls_mux_init ( s ) ) < 0 ) goto fail ; if ( ( reset = hls_start ( s ) ) < 0 ) goto fail ; if ( ( reset = avformat_write_header ( hls -> avf , null ) ) < 0 ) return reset ; fail : if ( reset ) { av_free ( hls -> basename ) ; if ( hls -> avf ) avformat_free_context ( hls -> avf ) ; } return reset ; }",1,1,0,1,"hls,basename_size,pattern,number,recording_time,start_pts,i,has_video,oformat,ret,basename,p","hls:0.324368953704834,basename_size:9.575486183166504e-05,pattern:-0.0009054243564605713,number:0.021561473608016968,recording_time:-0.007724732160568237,start_pts:0.0041353702545166016,i:0.18777447938919067,has_video:0.0495036244392395,oformat:0.052423059940338135,ret:0.4158508777618408,basename:0.0913754403591156,p:0.35758596658706665,",1,9,"ret:reset,"
"static inline void RENAME(bgr24ToY)(uint8_t *dst, uint8_t *src, long width) { #ifdef HAVE_MMX asm volatile( ""mov %2, %%""REG_a"" \n\t"" ""movq ""MANGLE(bgr2YCoeff)"", %%mm6 \n\t"" ""movq ""MANGLE(w1111)"", %%mm5 \n\t"" ""pxor %%mm7, %%mm7 \n\t"" ""lea (%%""REG_a"", %%""REG_a"", 2), %%""REG_d""\n\t"" ASMALIGN(4) ""1: \n\t"" PREFETCH"" 64(%0, %%""REG_d"") \n\t"" ""movd (%0, %%""REG_d""), %%mm0 \n\t"" ""movd 3(%0, %%""REG_d""), %%mm1 \n\t"" ""punpcklbw %%mm7, %%mm0 \n\t"" ""punpcklbw %%mm7, %%mm1 \n\t"" ""movd 6(%0, %%""REG_d""), %%mm2 \n\t"" ""movd 9(%0, %%""REG_d""), %%mm3 \n\t"" ""punpcklbw %%mm7, %%mm2 \n\t"" ""punpcklbw %%mm7, %%mm3 \n\t"" ""pmaddwd %%mm6, %%mm0 \n\t"" ""pmaddwd %%mm6, %%mm1 \n\t"" ""pmaddwd %%mm6, %%mm2 \n\t"" ""pmaddwd %%mm6, %%mm3 \n\t"" #ifndef FAST_BGR2YV12 ""psrad $8, %%mm0 \n\t"" ""psrad $8, %%mm1 \n\t"" ""psrad $8, %%mm2 \n\t"" ""psrad $8, %%mm3 \n\t"" #endif ""packssdw %%mm1, %%mm0 \n\t"" ""packssdw %%mm3, %%mm2 \n\t"" ""pmaddwd %%mm5, %%mm0 \n\t"" ""pmaddwd %%mm5, %%mm2 \n\t"" ""packssdw %%mm2, %%mm0 \n\t"" ""psraw $7, %%mm0 \n\t"" ""movd 12(%0, %%""REG_d""), %%mm4 \n\t"" ""movd 15(%0, %%""REG_d""), %%mm1 \n\t"" ""punpcklbw %%mm7, %%mm4 \n\t"" ""punpcklbw %%mm7, %%mm1 \n\t"" ""movd 18(%0, %%""REG_d""), %%mm2 \n\t"" ""movd 21(%0, %%""REG_d""), %%mm3 \n\t"" ""punpcklbw %%mm7, %%mm2 \n\t"" ""punpcklbw %%mm7, %%mm3 \n\t"" ""pmaddwd %%mm6, %%mm4 \n\t"" ""pmaddwd %%mm6, %%mm1 \n\t"" ""pmaddwd %%mm6, %%mm2 \n\t"" ""pmaddwd %%mm6, %%mm3 \n\t"" #ifndef FAST_BGR2YV12 ""psrad $8, %%mm4 \n\t"" ""psrad $8, %%mm1 \n\t"" ""psrad $8, %%mm2 \n\t"" ""psrad $8, %%mm3 \n\t"" #endif ""packssdw %%mm1, %%mm4 \n\t"" ""packssdw %%mm3, %%mm2 \n\t"" ""pmaddwd %%mm5, %%mm4 \n\t"" ""pmaddwd %%mm5, %%mm2 \n\t"" ""add $24, %%""REG_d"" \n\t"" ""packssdw %%mm2, %%mm4 \n\t"" ""psraw $7, %%mm4 \n\t"" ""packuswb %%mm4, %%mm0 \n\t"" ""paddusb ""MANGLE(bgr2YOffset)"", %%mm0 \n\t"" ""movq %%mm0, (%1, %%""REG_a"") \n\t"" ""add $8, %%""REG_a"" \n\t"" "" js 1b \n\t"" : : ""r"" (src+width*3), ""r"" (dst+width), ""g"" (-width) : ""%""REG_a, ""%""REG_d ); #else int i; for(i=0; i<width; i++) { int b= src[i*3+0]; int g= src[i*3+1]; int r= src[i*3+2]; dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT); } #endif }",367,,1,1,,-3,,,,,
static void vvfat_close(BlockDriverState *bs) { BDRVVVFATState *s = bs->opaque; vvfat_close_current_file(s); array_free(&(s->fat)); array_free(&(s->directory)); array_free(&(s->mapping)); if(s->cluster_buffer) free(s->cluster_buffer); },66,static void vvfat_close ( blockdriverstate * bs ) { bdrvvvfatstate * qs = bs -> opaque ; vvfat_close_current_file ( qs ) ; array_free ( & ( qs -> fat ) ) ; array_free ( & ( qs -> directory ) ) ; array_free ( & ( qs -> mapping ) ) ; if ( qs -> cluster_buffer ) free ( qs -> cluster_buffer ) ; },1,1,0,1,s,"s:0.6943365782499313,",1,7,"s:qs,"
"static int ivi_mc(ivi_mc_func mc, int16_t *buf, const int16_t *ref_buf, int offs, int mv_x, int mv_y, uint32_t pitch, int mc_type) { int ref_offs = offs + mv_y * pitch + mv_x; if (offs < 0 || ref_offs < 0 || !ref_buf) return AVERROR_INVALIDDATA; mc(buf + offs, ref_buf + ref_offs, pitch, mc_type); return 0; }",78,"static int ivi_mc ( ivi_mc_func mc , int16_t * buf , const int16_t * ref_buf , int offs , int mv_x , int mv_y , uint32_t pitch , int mc_type ) { int Ref_off = offs + mv_y * pitch + mv_x ; if ( offs < 0 || Ref_off < 0 || ! ref_buf ) return averror_invaliddata ; mc ( buf + offs , ref_buf + Ref_off , pitch , mc_type ) ; return 0 ; }",0,0,1,1,ref_offs,"ref_offs:-0.2619868516921997,",1,3,"ref_offs:Ref_off,"
"static void test_io_channel_setup_sync(SocketAddressLegacy *listen_addr, SocketAddressLegacy *connect_addr, QIOChannel **src, QIOChannel **dst) { QIOChannelSocket *lioc; lioc = qio_channel_socket_new(); qio_channel_socket_listen_sync(lioc, listen_addr, &error_abort); if (listen_addr->type == SOCKET_ADDRESS_LEGACY_KIND_INET) { SocketAddressLegacy *laddr = qio_channel_socket_get_local_address( lioc, &error_abort); g_free(connect_addr->u.inet.data->port); connect_addr->u.inet.data->port = g_strdup(laddr->u.inet.data->port); qapi_free_SocketAddressLegacy(laddr); } *src = QIO_CHANNEL(qio_channel_socket_new()); qio_channel_socket_connect_sync( QIO_CHANNEL_SOCKET(*src), connect_addr, &error_abort); qio_channel_set_delay(*src, false); qio_channel_wait(QIO_CHANNEL(lioc), G_IO_IN); *dst = QIO_CHANNEL(qio_channel_socket_accept(lioc, &error_abort)); g_assert(*dst); test_io_channel_set_socket_bufs(*src, *dst); object_unref(OBJECT(lioc)); }",186,"static void test_io_channel_setup_sync ( socketaddresslegacy * listen_addr , socketaddresslegacy * connect2add , qiochannel * * Ġsrc , qiochannel * * fest ) { qiochannelsocket * loOC ; loOC = qio_channel_socket_new ( ) ; qio_channel_socket_listen_sync ( loOC , listen_addr , & error_abort ) ; if ( listen_addr -> type == socket_address_legacy_kind_inet ) { socketaddresslegacy * saddr = qio_channel_socket_get_local_address ( loOC , & error_abort ) ; g_free ( connect2add -> u . inet . group -> character ) ; connect2add -> u . inet . group -> character = g_strdup ( saddr -> u . inet . group -> character ) ; qapi_free_socketaddresslegacy ( saddr ) ; } * Ġsrc = qio_channel ( qio_channel_socket_new ( ) ) ; qio_channel_socket_connect_sync ( qio_channel_socket ( * Ġsrc ) , connect2add , & error_abort ) ; qio_channel_set_delay ( * Ġsrc , false ) ; qio_channel_wait ( qio_channel ( loOC ) , g_io_in ) ; * fest = qio_channel ( qio_channel_socket_accept ( loOC , & error_abort ) ) ; g_assert ( * fest ) ; test_io_channel_set_socket_bufs ( * Ġsrc , * fest ) ; object_unref ( object ( loOC ) ) ; }",0,0,1,1,"lioc,laddr,connect_addr,u,inet,data,port,src,dst","lioc:0.07808836922049522,laddr:0.05415350943803787,connect_addr:0.045997872948646545,u:0.04059884697198868,inet:0.02978391945362091,data:0.07867847383022308,port:0.0678611695766449,src:0.1806766428053379,dst:0.29369228333234787,",7,29,"dst:fest,src:Ġsrc,data:group,lioc:loOC,port:character,laddr:saddr,connect_addr:connect2add,"
"static void monitor_readline(const char *prompt, int is_password, char *buf, int buf_size) { readline_start(prompt, is_password, monitor_readline_cb, NULL); readline_show_prompt(); monitor_readline_buf = buf; monitor_readline_buf_size = buf_size; monitor_readline_started = 1; while (monitor_readline_started) { main_loop_wait(10); } }",59,"static void monitor_readline ( const char * prompt , int is_password , char * buf , int buf_size ) { readline_start ( prompt , is_password , monitor_readline_cb , null ) ; readline_show_prompt ( ) ; monitor_readline_buf = buf ; monitor_readline_buffer_SIZE = buf_size ; monitor_readline_started = 1 ; while ( monitor_readline_started ) { main_loop_wait ( 10 ) ; } }",0,0,0,-1,"monitor_readline_buf,monitor_readline_buf_size,monitor_readline_started","monitor_readline_buf:0.08964714407920837,monitor_readline_buf_size:0.23245835304260254,monitor_readline_started:0.06029641628265381,",1,1,"monitor_readline_buf_size:monitor_readline_buffer_SIZE,"
"static int cllc_decode_frame(AVCodecContext *avctx, void *data, int *got_picture_ptr, AVPacket *avpkt) { CLLCContext *ctx = avctx->priv_data; AVFrame *pic = data; ThreadFrame frame = { .f = data }; uint8_t *src = avpkt->data; uint32_t info_tag, info_offset; int data_size; GetBitContext gb; int coding_type, ret; if (avpkt->size < 4 + 4) { av_log(avctx, AV_LOG_ERROR, ""Frame is too small %d.\n"", avpkt->size); } info_offset = 0; info_tag = AV_RL32(src); if (info_tag == MKTAG('I', 'N', 'F', 'O')) { info_offset = AV_RL32(src + 4); if (info_offset > UINT32_MAX - 8 || info_offset + 8 > avpkt->size) { av_log(avctx, AV_LOG_ERROR, ""Invalid INFO header offset: 0x%08""PRIX32"" is too large.\n"", info_offset); } ff_canopus_parse_info_tag(avctx, src + 8, info_offset); info_offset += 8; src += info_offset; } data_size = (avpkt->size - info_offset) & ~1; /* Make sure our bswap16'd buffer is big enough */ av_fast_padded_malloc(&ctx->swapped_buf, &ctx->swapped_buf_size, data_size); if (!ctx->swapped_buf) { av_log(avctx, AV_LOG_ERROR, ""Could not allocate swapped buffer.\n""); return AVERROR(ENOMEM); } /* bswap16 the buffer since CLLC's bitreader works in 16-bit words */ ctx->bdsp.bswap16_buf((uint16_t *) ctx->swapped_buf, (uint16_t *) src, data_size / 2); if ((ret = init_get_bits8(&gb, ctx->swapped_buf, data_size)) < 0) return ret; /* * Read in coding type. The types are as follows: * * 0 - YUY2 * 1 - BGR24 (Triples) * 2 - BGR24 (Quads) * 3 - BGRA */ coding_type = (AV_RL32(src) >> 8) & 0xFF; av_log(avctx, AV_LOG_DEBUG, ""Frame coding type: %d\n"", coding_type); switch (coding_type) { case 0: avctx->pix_fmt = AV_PIX_FMT_YUV422P; avctx->bits_per_raw_sample = 8; if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) return ret; ret = decode_yuv_frame(ctx, &gb, pic); if (ret < 0) return ret; break; case 1: case 2: avctx->pix_fmt = AV_PIX_FMT_RGB24; avctx->bits_per_raw_sample = 8; if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) return ret; ret = decode_rgb24_frame(ctx, &gb, pic); if (ret < 0) return ret; break; case 3: avctx->pix_fmt = AV_PIX_FMT_ARGB; avctx->bits_per_raw_sample = 8; if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) return ret; ret = decode_argb_frame(ctx, &gb, pic); if (ret < 0) return ret; break; default: av_log(avctx, AV_LOG_ERROR, ""Unknown coding type: %d.\n"", coding_type); } pic->key_frame = 1; pic->pict_type = AV_PICTURE_TYPE_I; *got_picture_ptr = 1; return avpkt->size; }",542,"static int cllc_decode_frame ( avcodeccontext * cvcontext , void * data , int * got_picture_ptr , avpacket * avpkt ) { cllccontext * cb = cvcontext -> priv_data ; avframe * pic = data ; threadframe frame = { . f = data } ; uint8_t * addr = avpkt -> data ; uint32_t info_tag , info_offset ; int data_size ; getbitcontext gb ; int coding_type , deg ; if ( avpkt -> size < 4 + 4 ) { av_log ( cvcontext , av_log_error , "" \n "" , avpkt -> size ) ; } info_offset = 0 ; info_tag = av_rl32 ( addr ) ; if ( info_tag == mktag ( ' ' , ' ' , ' ' , ' ' ) ) { info_offset = av_rl32 ( addr + 4 ) ; if ( info_offset > uint32_max - 8 || info_offset + 8 > avpkt -> size ) { av_log ( cvcontext , av_log_error , "" "" prix32 "" \n "" , info_offset ) ; } ff_canopus_parse_info_tag ( cvcontext , addr + 8 , info_offset ) ; info_offset += 8 ; addr += info_offset ; } data_size = ( avpkt -> size - info_offset ) & ~ 1 ; av_fast_padded_malloc ( & cb -> swapped_buf , & cb -> swapped_buf_size , data_size ) ; if ( ! cb -> swapped_buf ) { av_log ( cvcontext , av_log_error , "" \n "" ) ; return averror ( enomem ) ; } cb -> bdsp . bswap16_buf ( ( uint16_t * ) cb -> swapped_buf , ( uint16_t * ) addr , data_size / 2 ) ; if ( ( deg = init_get_bits8 ( & gb , cb -> swapped_buf , data_size ) ) < 0 ) return deg ; coding_type = ( av_rl32 ( addr ) >> 8 ) & 0xff ; av_log ( cvcontext , av_log_debug , "" \n "" , coding_type ) ; switch ( coding_type ) { case 0 : cvcontext -> pix_fmt = av_pix_fmt_yuv422p ; cvcontext -> bits_per_raw_sample = 8 ; if ( ( deg = ff_thread_get_buffer ( cvcontext , & frame , 0 ) ) < 0 ) return deg ; deg = decode_yuv_frame ( cb , & gb , pic ) ; if ( deg < 0 ) return deg ; break ; case 1 : case 2 : cvcontext -> pix_fmt = av_pix_fmt_rgb24 ; cvcontext -> bits_per_raw_sample = 8 ; if ( ( deg = ff_thread_get_buffer ( cvcontext , & frame , 0 ) ) < 0 ) return deg ; deg = decode_rgb24_frame ( cb , & gb , pic ) ; if ( deg < 0 ) return deg ; break ; case 3 : cvcontext -> pix_fmt = av_pix_fmt_argb ; cvcontext -> bits_per_raw_sample = 8 ; if ( ( deg = ff_thread_get_buffer ( cvcontext , & frame , 0 ) ) < 0 ) return deg ; deg = decode_argb_frame ( cb , & gb , pic ) ; if ( deg < 0 ) return deg ; break ; default : av_log ( cvcontext , av_log_error , "" \n "" , coding_type ) ; } pic -> key_frame = 1 ; pic -> pict_type = av_picture_type_i ; * got_picture_ptr = 1 ; return avpkt -> size ; }",1,1,0,1,"ctx,pic,frame,src,info_offset,info_tag,data_size,ret,coding_type,avctx,pix_fmt,bits_per_raw_sample,key_frame,pict_type,got_picture_ptr","ctx:0.1813412308692932,pic:0.07000863552093506,frame:0.022052884101867676,src:0.15716826915740967,info_offset:0.04153883457183838,info_tag:-0.03447246551513672,data_size:0.010557174682617188,ret:0.2050156593322754,coding_type:0.058328330516815186,avctx:0.3026791214942932,pix_fmt:0.029392659664154053,bits_per_raw_sample:0.028725802898406982,key_frame:0.008255839347839355,pict_type:0.009575486183166504,got_picture_ptr:0.03961598873138428,",4,52,"avctx:cvcontext,ret:deg,ctx:cb,src:addr,"
"static av_always_inline void decode_dc_coeffs(GetBitContext *gb, int16_t *out, int blocks_per_slice) { int16_t prev_dc; int code, i, sign; OPEN_READER(re, gb); DECODE_CODEWORD(code, FIRST_DC_CB); prev_dc = TOSIGNED(code); out[0] = prev_dc; out += 64; // dc coeff for the next block code = 5; sign = 0; for (i = 1; i < blocks_per_slice; i++, out += 64) { DECODE_CODEWORD(code, dc_codebook[FFMIN(code, 6U)]); if(code) sign ^= -(code & 1); else sign = 0; prev_dc += (((code + 1) >> 1) ^ sign) - sign; out[0] = prev_dc; } CLOSE_READER(re, gb); }",60,"static av_always_inline void decode_dc_coeffs ( getbitcontext * gb , int16_t * out , int blocks_per_slice ) { int16_t prev_dc ; int code , i , sign ; open_reader ( re , gb ) ; decode_codeword ( code , first_dc_cb ) ; prev_dc = tosigned ( code ) ; out [ 0 ] = prev_dc ; out += 64 ; ",1,1,1,-1,"prev_dc,out,0","prev_dc:0.0037598013877868652,out:-0.06868487596511841,0:-0.013711690902709961,",0,0,
"static void avc_luma_midh_qrt_and_aver_dst_8w_msa(const uint8_t *src, int32_t src_stride, uint8_t *dst, int32_t dst_stride, int32_t height, uint8_t horiz_offset) { uint32_t multiple8_cnt; for (multiple8_cnt = 2; multiple8_cnt--;) { avc_luma_midh_qrt_and_aver_dst_4w_msa(src, src_stride, dst, dst_stride, height, horiz_offset); src += 4; dst += 4; } }",65,"static void avc_luma_midh_qrt_and_aver_dst_8w_msa ( const uint8_t * Ġsrc , int32_t src_stride , uint8_t * Ddest , int32_t dst_stride , int32_t height , uint8_t horiz_offset ) { uint32_t multiple8^Cust ; for ( multiple8^Cust = 2 ; multiple8^Cust -- ; ) { avc_luma_midh_qrt_and_aver_dst_4w_msa ( Ġsrc , src_stride , Ddest , dst_stride , height , horiz_offset ) ; Ġsrc += 4 ; Ddest += 4 ; } }",0,0,1,1,"multiple8_cnt,src,dst","multiple8_cnt:0.0036109350621700287,src:0.0005296189337968826,dst:0.00023262575268745422,",3,9,"multiple8_cnt:multiple8^Cust,src:Ġsrc,dst:Ddest,"
"static int mp_pacl_removexattr(FsContext *ctx, const char *path, const char *name) { int ret; char *buffer; buffer = rpath(ctx, path); ret = lremovexattr(buffer, MAP_ACL_ACCESS); if (ret == -1 && errno == ENODATA) { /* * We don't get ENODATA error when trying to remove a * posix acl that is not present. So don't throw the error * even in case of mapped security model */ errno = 0; ret = 0; } g_free(buffer); return ret; }",73,"static int mp_pacl_removexattr ( fscontext * ctx , const char * path , const char * name ) { int ret ; char * size ; size = rpath ( ctx , path ) ; ret = lremovexattr ( size , map_acl_access ) ; if ( ret == -1 && errno == enodata ) { errno = 0 ; ret = 0 ; } g_free ( size ) ; return ret ; }",1,1,0,1,"buffer,ret,errno","buffer:0.11261829733848572,ret:-0.21112185716629028,errno:-0.09646832942962646,",1,4,"buffer:size,"
"static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix) { static const char * const libnames[] = { ""libOMX_Core.so"", ""libOmxCore.so"", NULL }; const char* const* nameptr; int ret = AVERROR_ENCODER_NOT_FOUND; OMXContext *omx_context; omx_context = av_mallocz(sizeof(*omx_context)); if (!omx_context) return NULL; if (libname) { ret = omx_try_load(omx_context, logctx, libname, prefix); if (ret < 0) { av_free(omx_context); return NULL; } } else { for (nameptr = libnames; *nameptr; nameptr++) if (!(ret = omx_try_load(omx_context, logctx, *nameptr, prefix))) break; if (!*nameptr) { av_free(omx_context); return NULL; } } omx_context->ptr_Init(); return omx_context; }",172,"static av_cold omxcontext * omx_init ( void * logctx , const char * libname , const char * prefix ) { static const char * const LibNames [ ] = { "" "" , "" "" , null } ; const char * const * nameaddr ; int ret = averror_encoder_not_found ; omxcontext * omtx_init ; omtx_init = av_mallocz ( sizeof ( * omtx_init ) ) ; if ( ! omtx_init ) return null ; if ( libname ) { ret = omx_try_load ( omtx_init , logctx , libname , prefix ) ; if ( ret < 0 ) { av_free ( omtx_init ) ; return null ; } } else { for ( nameaddr = LibNames ; * nameaddr ; nameaddr ++ ) if ( ! ( ret = omx_try_load ( omtx_init , logctx , * nameaddr , prefix ) ) ) break ; if ( ! * nameaddr ) { av_free ( omtx_init ) ; return null ; } } omtx_init -> ptr_init ( ) ; return omtx_init ; }",1,1,0,1,"libnames,ret,omx_context,nameptr","libnames:-0.06145453453063965,ret:-0.46078962087631226,omx_context:-0.45918333530426025,nameptr:-0.3611995577812195,",3,18,"libnames:LibNames,nameptr:nameaddr,omx_context:omtx_init,"
int av_get_channel_layout_nb_channels(int64_t channel_layout) { int count; uint64_t x = channel_layout; for (count = 0; x; count++) x &= x-1; // unset lowest set bit return count; },33,,0,1,,-4,"x,count",,,,
"static void openpic_load_IRQ_queue(QEMUFile* f, IRQQueue *q) { unsigned int i; for (i = 0; i < BF_WIDTH(MAX_IRQ); i++) qemu_get_be32s(f, &q->queue[i]); qemu_get_sbe32s(f, &q->next); qemu_get_sbe32s(f, &q->priority); }",67,,0,1,,-4,i,,,,
"static void cs_write (void *opaque, target_phys_addr_t addr, uint64_t val64, unsigned size) { CSState *s = opaque; uint32_t saddr, iaddr, val; saddr = addr; val = val64; switch (saddr) { case Index_Address: if (!(s->regs[Index_Address] & MCE) && (val & MCE) && (s->dregs[Interface_Configuration] & (3 << 3))) s->aci_counter = conf.aci_counter; s->regs[Index_Address] = val & ~(1 << 7); break; case Index_Data: if (!(s->dregs[MODE_And_ID] & MODE2)) iaddr = s->regs[Index_Address] & 0x0f; else iaddr = s->regs[Index_Address] & 0x1f; switch (iaddr) { case RESERVED: case RESERVED_2: case RESERVED_3: lwarn (""attempt to write %#x to reserved indirect register %d\n"", val, iaddr); break; case FS_And_Playback_Data_Format: if (s->regs[Index_Address] & MCE) { cs_reset_voices (s, val); } else { if (s->dregs[Alternate_Feature_Status] & PMCE) { val = (val & ~0x0f) | (s->dregs[iaddr] & 0x0f); cs_reset_voices (s, val); } else { lwarn (""[P]MCE(%#x, %#x) is not set, val=%#x\n"", s->regs[Index_Address], s->dregs[Alternate_Feature_Status], val); break; } } s->dregs[iaddr] = val; break; case Interface_Configuration: val &= ~(1 << 5); /* D5 is reserved */ s->dregs[iaddr] = val; if (val & PPIO) { lwarn (""PIO is not supported (%#x)\n"", val); break; } if (val & PEN) { if (!s->dma_running) { cs_reset_voices (s, s->dregs[FS_And_Playback_Data_Format]); } } else { if (s->dma_running) { DMA_release_DREQ (s->dma); AUD_set_active_out (s->voice, 0); s->dma_running = 0; } } break; case Error_Status_And_Initialization: lwarn (""attempt to write to read only register %d\n"", iaddr); break; case MODE_And_ID: dolog (""val=%#x\n"", val); if (val & MODE2) s->dregs[iaddr] |= MODE2; else s->dregs[iaddr] &= ~MODE2; break; case Alternate_Feature_Enable_I: if (val & TE) lerr (""timer is not yet supported\n""); s->dregs[iaddr] = val; break; case Alternate_Feature_Status: if ((s->dregs[iaddr] & PI) && !(val & PI)) { /* XXX: TI CI */ qemu_irq_lower (s->pic); s->regs[Status] &= ~INT; } s->dregs[iaddr] = val; break; case Version_Chip_ID: lwarn (""write to Version_Chip_ID register %#x\n"", val); s->dregs[iaddr] = val; break; default: s->dregs[iaddr] = val; break; } dolog (""written value %#x to indirect register %d\n"", val, iaddr); break; case Status: if (s->regs[Status] & INT) { qemu_irq_lower (s->pic); } s->regs[Status] &= ~INT; s->dregs[Alternate_Feature_Status] &= ~(PI | CI | TI); break; case PIO_Data: lwarn (""attempt to write value %#x to PIO register\n"", val); break; } }",635,"static void cs_write ( void * opaque , target_phys_addr_t addr , uint64_t val64 , unsigned size ) { csstate * 2 = opaque ; uint32_t Sadr , maddr , dev ; Sadr = addr ; dev = val64 ; switch ( Sadr ) { case Index_address : if ( ! ( 2 -> memes [ Index_address ] & mce ) && ( dev & mce ) && ( 2 -> denges [ interface_configuration ] & ( 3 << 3 ) ) ) 2 -> clus_number = conf . clus_number ; 2 -> memes [ Index_address ] = dev & ~ ( 1 << 7 ) ; break ; case index_data : if ( ! ( 2 -> denges [ mode_and_id ] & mode2 ) ) maddr = 2 -> memes [ Index_address ] & 0x0f ; else maddr = 2 -> memes [ Index_address ] & 0x1f ; switch ( maddr ) { case reserved : case reserved_2 : case reserved_3 : lwarn ( "" \n "" , dev , maddr ) ; break ; case fs_and_playback_data_format : if ( 2 -> memes [ Index_address ] & mce ) { cs_reset_voices ( 2 , dev ) ; } else { if ( 2 -> denges [ alternate_feature_flags ] & pmce ) { dev = ( dev & ~ 0x0f ) | ( 2 -> denges [ maddr ] & 0x0f ) ; cs_reset_voices ( 2 , dev ) ; } else { lwarn ( "" \n "" , 2 -> memes [ Index_address ] , 2 -> denges [ alternate_feature_flags ] , dev ) ; break ; } } 2 -> denges [ maddr ] = dev ; break ; case interface_configuration : dev &= ~ ( 1 << 5 ) ; 2 -> denges [ maddr ] = dev ; if ( dev & ppio ) { lwarn ( "" \n "" , dev ) ; break ; } if ( dev & pen ) { if ( ! 2 -> dma_running ) { cs_reset_voices ( 2 , 2 -> denges [ fs_and_playback_data_format ] ) ; } } else { if ( 2 -> dma_running ) { dma_release_dreq ( 2 -> dma ) ; aud_set_active_out ( 2 -> voice , 0 ) ; 2 -> dma_running = 0 ; } } break ; case error_status_and_initialization : lwarn ( "" \n "" , maddr ) ; break ; case mode_and_id : dolog ( "" \n "" , dev ) ; if ( dev & mode2 ) 2 -> denges [ maddr ] |= mode2 ; else 2 -> denges [ maddr ] &= ~ mode2 ; break ; case alternate_feature_enable_i : if ( dev & te ) lerr ( "" \n "" ) ; 2 -> denges [ maddr ] = dev ; break ; case alternate_feature_flags : if ( ( 2 -> denges [ maddr ] & pi ) && ! ( dev & pi ) ) { qemu_irq_lower ( 2 -> pic ) ; 2 -> memes [ status ] &= ~ int ; } 2 -> denges [ maddr ] = dev ; break ; case version_chip_id : lwarn ( "" \n "" , dev ) ; 2 -> denges [ maddr ] = dev ; break ; default : 2 -> denges [ maddr ] = dev ; break ; } dolog ( "" \n "" , dev , maddr ) ; break ; case status : if ( 2 -> memes [ status ] & int ) { qemu_irq_lower ( 2 -> pic ) ; } 2 -> memes [ status ] &= ~ int ; 2 -> denges [ alternate_feature_flags ] &= ~ ( pi | ci | ti ) ; break ; case pio_data : lwarn ( "" \n "" , dev ) ; break ; } }",0,0,0,-1,"s,saddr,val,aci_counter,regs,index_address,iaddr,dregs,dma_running,status,alternate_feature_status","s:-0.02576424553990364,saddr:-0.00021981727331876755,val:-0.008575341198593378,aci_counter:-0.00030701514333486557,regs:-0.002487209625542164,index_address:0.000690041109919548,iaddr:-0.0007511815056204796,dregs:-0.0014822417870163918,dma_running:1.369137316942215e-05,status:-0.0005580689758062363,alternate_feature_status:0.001363246701657772,",9,122,"alternate_feature_status:alternate_feature_flags,index_address:Index_address,saddr:Sadr,aci_counter:clus_number,iaddr:maddr,dregs:denges,regs:memes,val:dev,s:2,"
"static uint64_t omap_pin_cfg_read(void *opaque, target_phys_addr_t addr, unsigned size) { struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque; if (size != 4) { return omap_badwidth_read32(opaque, addr); } switch (addr) { case 0x00: /* FUNC_MUX_CTRL_0 */ case 0x04: /* FUNC_MUX_CTRL_1 */ case 0x08: /* FUNC_MUX_CTRL_2 */ return s->func_mux_ctrl[addr >> 2]; case 0x0c: /* COMP_MODE_CTRL_0 */ return s->comp_mode_ctrl[0]; case 0x10: /* FUNC_MUX_CTRL_3 */ case 0x14: /* FUNC_MUX_CTRL_4 */ case 0x18: /* FUNC_MUX_CTRL_5 */ case 0x1c: /* FUNC_MUX_CTRL_6 */ case 0x20: /* FUNC_MUX_CTRL_7 */ case 0x24: /* FUNC_MUX_CTRL_8 */ case 0x28: /* FUNC_MUX_CTRL_9 */ case 0x2c: /* FUNC_MUX_CTRL_A */ case 0x30: /* FUNC_MUX_CTRL_B */ case 0x34: /* FUNC_MUX_CTRL_C */ case 0x38: /* FUNC_MUX_CTRL_D */ return s->func_mux_ctrl[(addr >> 2) - 1]; case 0x40: /* PULL_DWN_CTRL_0 */ case 0x44: /* PULL_DWN_CTRL_1 */ case 0x48: /* PULL_DWN_CTRL_2 */ case 0x4c: /* PULL_DWN_CTRL_3 */ return s->pull_dwn_ctrl[(addr & 0xf) >> 2]; case 0x50: /* GATE_INH_CTRL_0 */ return s->gate_inh_ctrl[0]; case 0x60: /* VOLTAGE_CTRL_0 */ return s->voltage_ctrl[0]; case 0x70: /* TEST_DBG_CTRL_0 */ return s->test_dbg_ctrl[0]; case 0x80: /* MOD_CONF_CTRL_0 */ return s->mod_conf_ctrl[0]; } OMAP_BAD_REG(addr); return 0; }",205,"static uint64_t omap_pin_cfg_read ( void * opaque , target_phys_addr_t addr , unsigned size ) { struct omap_mpu_state_s * Ġreturns = ( struct omap_mpu_state_s * ) opaque ; if ( size != 4 ) { return omap_badwidth_read32 ( opaque , addr ) ; } switch ( addr ) { case 0x00 : case 0x04 : case 0x08 : return Ġreturns -> func_mux_ctrl [ addr >> 2 ] ; case 0x0c : return Ġreturns -> comp_mode_ctrl [ 0 ] ; case 0x10 : case 0x14 : case 0x18 : case 0x1c : case 0x20 : case 0x24 : case 0x28 : case 0x2c : case 0x30 : case 0x34 : case 0x38 : return Ġreturns -> func_mux_ctrl [ ( addr >> 2 ) - 1 ] ; case 0x40 : case 0x44 : case 0x48 : case 0x4c : return Ġreturns -> pull_dwn_ctrl [ ( addr & 0xf ) >> 2 ] ; case 0x50 : return Ġreturns -> gate_inh_ctrl [ 0 ] ; case 0x60 : return Ġreturns -> voltage_ctrl [ 0 ] ; case 0x70 : return Ġreturns -> test_dbg_ctrl [ 0 ] ; case 0x80 : return Ġreturns -> mod_conf_ctrl [ 0 ] ; } omap_bad_reg ( addr ) ; return 0 ; }",0,0,0,-1,s,"s:0.0005479049868881702,",1,9,"s:Ġreturns,"
"static int decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq) { int t; if (total_freq == 0) return AVERROR_INVALIDDATA; t = rc->range * (uint64_t)cumFreq / total_freq; rc->code1 += t + 1; rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1); while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) { unsigned byte = bytestream2_get_byte(gb); rc->code = (rc->code << 8) | byte; rc->code1 <<= 8; rc->range <<= 8; } return 0; }",135,"static int decode0 ( getbytecontext * gb , rangecoder * hl , unsigned cumfreq , unsigned freq , unsigned total_freq ) { int tg ; if ( total_freq == 0 ) return averror_invaliddata ; tg = hl -> range * ( uint64_t ) cumfreq / total_freq ; hl -> Code3 += tg + 1 ; hl -> range = hl -> range * ( uint64_t ) ( freq + cumfreq ) / total_freq - ( tg + 1 ) ; while ( hl -> range < top && bytestream2_get_bytes_left ( gb ) > 0 ) { unsigned float = bytestream2_get_byte ( gb ) ; hl -> type = ( hl -> type << 8 ) | float ; hl -> Code3 <<= 8 ; hl -> range <<= 8 ; } return 0 ; }",1,1,0,1,"t,rc,code1,range,byte,code","t:-0.17854422330856323,rc:-0.8491154313087463,code1:-0.13646972179412842,range:-0.21411031484603882,byte:-0.09161001443862915,code:-0.18307113647460938,",5,20,"byte:float,code1:Code3,t:tg,code:type,rc:hl,"
"static int hevc_decode_frame(AVCodecContext *avctx, void *data, int *got_output, AVPacket *avpkt) { int ret; int new_extradata_size; uint8_t *new_extradata; HEVCContext *s = avctx->priv_data; if (!avpkt->size) { ret = ff_hevc_output_frame(s, data, 1); if (ret < 0) return ret; *got_output = ret; return 0; } new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &new_extradata_size); if (new_extradata && new_extradata_size > 0) { ret = hevc_decode_extradata(s, new_extradata, new_extradata_size); if (ret < 0) return ret; } s->ref = NULL; ret = decode_nal_units(s, avpkt->data, avpkt->size); if (ret < 0) return ret; if (avctx->hwaccel) { if (s->ref && (ret = avctx->hwaccel->end_frame(avctx)) < 0) { av_log(avctx, AV_LOG_ERROR, ""hardware accelerator failed to decode picture\n""); ff_hevc_unref_frame(s, s->ref, ~0); return ret; } } else { /* verify the SEI checksum */ if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded && s->sei.picture_hash.is_md5) { ret = verify_md5(s, s->ref->frame); if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) { ff_hevc_unref_frame(s, s->ref, ~0); return ret; } } } s->sei.picture_hash.is_md5 = 0; if (s->is_decoded) { av_log(avctx, AV_LOG_DEBUG, ""Decoded frame with POC %d.\n"", s->poc); s->is_decoded = 0; } if (s->output_frame->buf[0]) { av_frame_move_ref(data, s->output_frame); *got_output = 1; } return avpkt->size; }",344,,1,0,,-4,"s,ret,got_output,new_extradata,ref,sei,picture_hash,is_md5,is_decoded",,,,
"static void RENAME(yuv2bgr24_1)(SwsContext *c, const int16_t *buf0, const int16_t *ubuf[2], const int16_t *bguf[2], const int16_t *abuf0, uint8_t *dest, int dstW, int uvalpha, int y) { const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1]; const int16_t *buf1= buf0; //FIXME needed for RGB1/BGR1 if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster __asm__ volatile( ""mov %%""REG_b"", ""ESP_OFFSET""(%5) \n\t"" ""mov %4, %%""REG_b"" \n\t"" ""push %%""REG_BP"" \n\t"" YSCALEYUV2RGB1(%%REGBP, %5) ""pxor %%mm7, %%mm7 \n\t"" WRITEBGR24(%%REGb, 8280(%5), %%REGBP) ""pop %%""REG_BP"" \n\t"" ""mov ""ESP_OFFSET""(%5), %%""REG_b"" \n\t"" :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest), ""a"" (&c->redDither) ); } else { __asm__ volatile( ""mov %%""REG_b"", ""ESP_OFFSET""(%5) \n\t"" ""mov %4, %%""REG_b"" \n\t"" ""push %%""REG_BP"" \n\t"" YSCALEYUV2RGB1b(%%REGBP, %5) ""pxor %%mm7, %%mm7 \n\t"" WRITEBGR24(%%REGb, 8280(%5), %%REGBP) ""pop %%""REG_BP"" \n\t"" ""mov ""ESP_OFFSET""(%5), %%""REG_b"" \n\t"" :: ""c"" (buf0), ""d"" (buf1), ""S"" (ubuf0), ""D"" (ubuf1), ""m"" (dest), ""a"" (&c->redDither) ); } }",77,"static void rename ( yuv2bgr24_1 ) ( swscontext * c , const int16_t * buf0 , const int16_t * ubuf [ 2 ] , const int16_t * bguf [ 2 ] , const int16_t * abuf0 , uint8_t * dest , int dstw , int uvalpha , int y ) { const int16_t * ubff2 = ubuf [ 0 ] , * ubf3 = ubuf [ 1 ] ; const int16_t * buff2 = buf0 ; ",1,1,1,-1,"ubuf0,ubuf1,buf1","ubuf0:-0.036914050579071045,ubuf1:-0.011242270469665527,buf1:-0.030655503273010254,",3,3,"ubuf1:ubf3,buf1:buff2,ubuf0:ubff2,"
"static always_inline void gen_rldimi (DisasContext *ctx, int mbn, int shn) { uint64_t mask; uint32_t sh, mb; sh = SH(ctx->opcode) | (shn << 5); mb = MB(ctx->opcode) | (mbn << 5); if (likely(sh == 0)) { if (likely(mb == 0)) { gen_op_load_gpr_T0(rS(ctx->opcode)); goto do_store; } else if (likely(mb == 63)) { gen_op_load_gpr_T0(rA(ctx->opcode)); goto do_store; } gen_op_load_gpr_T0(rS(ctx->opcode)); gen_op_load_gpr_T1(rA(ctx->opcode)); goto do_mask; } gen_op_load_gpr_T0(rS(ctx->opcode)); gen_op_load_gpr_T1(rA(ctx->opcode)); gen_op_rotli64_T0(sh); do_mask: mask = MASK(mb, 63 - sh); gen_andi_T0_64(ctx, mask); gen_andi_T1_64(ctx, ~mask); gen_op_or(); do_store: gen_op_store_T0_gpr(rA(ctx->opcode)); if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx); }",226,"static always_inline void gen_rldimi ( disascontext * ctx , int mbn , int shn ) { uint64_t 0 ; uint32_t addr , phys ; addr = addr ( ctx -> opcode ) | ( shn << 5 ) ; phys = phys ( ctx -> opcode ) | ( mbn << 5 ) ; if ( likely ( addr == 0 ) ) { if ( likely ( phys == 0 ) ) { gen_op_load_gpr_t0 ( rs ( ctx -> opcode ) ) ; goto do_store ; } else if ( likely ( phys == 63 ) ) { gen_op_load_gpr_t0 ( ra ( ctx -> opcode ) ) ; goto do_store ; } gen_op_load_gpr_t0 ( rs ( ctx -> opcode ) ) ; gen_op_load_gpr_t1 ( ra ( ctx -> opcode ) ) ; goto do_mask ; } gen_op_load_gpr_t0 ( rs ( ctx -> opcode ) ) ; gen_op_load_gpr_t1 ( ra ( ctx -> opcode ) ) ; gen_op_rotli64_t0 ( addr ) ; do_mask : 0 = 0 ( phys , 63 - addr ) ; gen_andi_t0_64 ( ctx , 0 ) ; gen_andi_t1_64 ( ctx , ~ 0 ) ; gen_op_or ( ) ; do_store : gen_op_store_t0_gpr ( ra ( ctx -> opcode ) ) ; if ( unlikely ( rc ( ctx -> opcode ) != 0 ) ) gen_set_rc0 ( ctx ) ; }",1,1,0,1,"sh,mb,mask","sh:-0.0001024007797241211,mb:-0.0058329105377197266,mask:-0.014863312244415283,",3,17,"sh:addr,mb:phys,mask:0,"
"static int dx2_decode_slice_410(GetBitContext *gb, AVFrame *frame, int line, int left, uint8_t lru[3][8]) { int x, y, i, j; int width = frame->width; int ystride = frame->linesize[0]; int ustride = frame->linesize[1]; int vstride = frame->linesize[2]; uint8_t *Y = frame->data[0] + ystride * line; uint8_t *U = frame->data[1] + (ustride >> 2) * line; uint8_t *V = frame->data[2] + (vstride >> 2) * line; for (y = 0; y < left - 3 && get_bits_left(gb) > 16; y += 4) { for (x = 0; x < width; x += 4) { for (j = 0; j < 4; j++) for (i = 0; i < 4; i++) Y[x + i + j * ystride] = decode_sym(gb, lru[0]); U[x >> 2] = decode_sym(gb, lru[1]) ^ 0x80; V[x >> 2] = decode_sym(gb, lru[2]) ^ 0x80; } Y += ystride << 2; U += ustride; V += vstride; } return y; }",271,"static int dx2_decode_slice_410 ( getbitcontext * gb , avframe * frame , int line , int left , uint8_t lru [ 3 ] [ 8 ] ) { int act , y , ji , Ġj ; int depth = frame -> depth ; int yctrride = frame -> linesize [ 0 ] ; int astrid = frame -> linesize [ 1 ] ; int vdrride = frame -> linesize [ 2 ] ; uint8_t * y = frame -> data [ 0 ] + yctrride * line ; uint8_t * u = frame -> data [ 1 ] + ( astrid >> 2 ) * line ; uint8_t * v = frame -> data [ 2 ] + ( vdrride >> 2 ) * line ; for ( y = 0 ; y < left - 3 && get_bits_left ( gb ) > 16 ; y += 4 ) { for ( act = 0 ; act < depth ; act += 4 ) { for ( Ġj = 0 ; Ġj < 4 ; Ġj ++ ) for ( ji = 0 ; ji < 4 ; ji ++ ) y [ act + ji + Ġj * yctrride ] = decode_sym ( gb , lru [ 0 ] ) ; u [ act >> 2 ] = decode_sym ( gb , lru [ 1 ] ) ^ 0x80 ; v [ act >> 2 ] = decode_sym ( gb , lru [ 2 ] ) ^ 0x80 ; } y += yctrride << 2 ; u += astrid ; v += vdrride ; } return y ; }",1,1,0,1,"width,ystride,ustride,vstride,y,u,v,x,j,i,2","width:-0.006832480430603027,ystride:0.0104026198387146,ustride:0.02230149507522583,vstride:0.011922776699066162,y:-0.05229741334915161,u:-0.021364331245422363,v:-0.029851198196411133,x:0.006416499614715576,j:0.05684584379196167,i:0.00695723295211792,2:-0.08328521251678467,",7,30,"j:Ġj,ustride:astrid,vstride:vdrride,ystride:yctrride,i:ji,x:act,width:depth,"
"void kqemu_set_notdirty(CPUState *env, ram_addr_t ram_addr) { LOG_INT(""kqemu_set_notdirty: addr=%08lx\n"", (unsigned long)ram_addr); /* we only track transitions to dirty state */ if (phys_ram_dirty[ram_addr >> TARGET_PAGE_BITS] != 0xff) return; if (nb_ram_pages_to_update >= KQEMU_MAX_RAM_PAGES_TO_UPDATE) nb_ram_pages_to_update = KQEMU_RAM_PAGES_UPDATE_ALL; else ram_pages_to_update[nb_ram_pages_to_update++] = ram_addr; }",57,"void kqemu_set_notdirty ( cpustate * env , ram_addr_t ram_addr ) { log_int ( "" \n "" , ( unsigned long ) ram_addr ) ; if ( phys_ram_dirty [ ram_addr >> target_page_bits ] != 0xff ) return ; if ( nb_ram_pages_to?updated >= kqemu_max_ram_pages_to_update ) nb_ram_pages_to?updated = kqemu_ram_pages_update_all ; else ram_pages_to_updated [ nb_ram_pages_to?updated ++ ] = ram_addr ; }",0,0,0,-1,"nb_ram_pages_to_update,ram_pages_to_update","nb_ram_pages_to_update:0.004765896126627922,ram_pages_to_update:0.00024825427681207657,",2,4,"nb_ram_pages_to_update:nb_ram_pages_to?updated,ram_pages_to_update:ram_pages_to_updated,"
"static void put_no_rnd_pixels_y2_mmx( UINT8 *block, const UINT8 *pixels, int line_size, int h) { UINT8 *p; const UINT8 *pix; p = block; pix = pixels; MOVQ_ZERO(mm7); JUMPALIGN(); do { __asm __volatile( ""movq %1, %%mm0\n\t"" ""movq %2, %%mm1\n\t"" ""movq %%mm0, %%mm2\n\t"" ""movq %%mm1, %%mm3\n\t"" ""punpcklbw %%mm7, %%mm0\n\t"" ""punpcklbw %%mm7, %%mm1\n\t"" ""punpckhbw %%mm7, %%mm2\n\t"" ""punpckhbw %%mm7, %%mm3\n\t"" ""paddusw %%mm1, %%mm0\n\t"" ""paddusw %%mm3, %%mm2\n\t"" ""psrlw $1, %%mm0\n\t"" ""psrlw $1, %%mm2\n\t"" ""packuswb %%mm2, %%mm0\n\t"" ""movq %%mm0, %0\n\t"" :""=m""(*p) :""m""(*pix), ""m""(*(pix+line_size)) :""memory""); pix += line_size; p += line_size; } while(--h); }",153,,0,1,,-4,"p,pix,h",,,,
"static int iscsi_open(BlockDriverState *bs, const char *filename, int flags) { IscsiLun *iscsilun = bs->opaque; struct iscsi_context *iscsi = NULL; struct iscsi_url *iscsi_url = NULL; struct IscsiTask task; char *initiator_name = NULL; int ret; if ((BDRV_SECTOR_SIZE % 512) != 0) { error_report(""iSCSI: Invalid BDRV_SECTOR_SIZE. "" ""BDRV_SECTOR_SIZE(%lld) is not a multiple "" ""of 512"", BDRV_SECTOR_SIZE); return -EINVAL; } iscsi_url = iscsi_parse_full_url(iscsi, filename); if (iscsi_url == NULL) { error_report(""Failed to parse URL : %s %s"", filename, iscsi_get_error(iscsi)); ret = -EINVAL; goto out; } memset(iscsilun, 0, sizeof(IscsiLun)); initiator_name = parse_initiator_name(iscsi_url->target); iscsi = iscsi_create_context(initiator_name); if (iscsi == NULL) { error_report(""iSCSI: Failed to create iSCSI context.""); ret = -ENOMEM; goto out; } if (iscsi_set_targetname(iscsi, iscsi_url->target)) { error_report(""iSCSI: Failed to set target name.""); ret = -EINVAL; goto out; } if (iscsi_url->user != NULL) { ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user, iscsi_url->passwd); if (ret != 0) { error_report(""Failed to set initiator username and password""); ret = -EINVAL; goto out; } } /* check if we got CHAP username/password via the options */ if (parse_chap(iscsi, iscsi_url->target) != 0) { error_report(""iSCSI: Failed to set CHAP user/password""); ret = -EINVAL; goto out; } if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) { error_report(""iSCSI: Failed to set session type to normal.""); ret = -EINVAL; goto out; } iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C); /* check if we got HEADER_DIGEST via the options */ parse_header_digest(iscsi, iscsi_url->target); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun->iscsi = iscsi; iscsilun->lun = iscsi_url->lun; if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun, iscsi_connect_cb, &task) != 0) { error_report(""iSCSI: Failed to start async connect.""); ret = -EINVAL; goto out; } while (!task.complete) { iscsi_set_events(iscsilun); qemu_aio_wait(); } if (task.status != 0) { error_report(""iSCSI: Failed to connect to LUN : %s"", iscsi_get_error(iscsi)); ret = -EINVAL; goto out; } /* Medium changer or tape. We dont have any emulation for this so this must * be sg ioctl compatible. We force it to be sg, otherwise qemu will try * to read from the device to guess the image format. */ if (iscsilun->type == TYPE_MEDIUM_CHANGER || iscsilun->type == TYPE_TAPE) { bs->sg = 1; } ret = 0; out: if (initiator_name != NULL) { g_free(initiator_name); } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (ret) { if (iscsi != NULL) { iscsi_destroy_context(iscsi); } memset(iscsilun, 0, sizeof(IscsiLun)); } return ret; }",526,"static int iscsi_open ( blockdriverstate * bs , const char * filename , int flags ) { ircsilin * ircsilin = bs -> opaque ; struct iscsi_context * iscsi = null ; struct iscsi_url * iscsi_url = null ; struct iscsitask task ; char * initiator_name = null ; int ĠRET ; if ( ( bdrv_sector_size % 512 ) != 0 ) { error_report ( "" "" "" "" "" "" , bdrv_sector_size ) ; return - einval ; } iscsi_url = iscsi_parse_full_url ( iscsi , filename ) ; if ( iscsi_url == null ) { error_report ( "" "" , filename , iscsi_get_error ( iscsi ) ) ; ĠRET = - einval ; goto out ; } memset ( ircsilin , 0 , sizeof ( ircsilin ) ) ; initiator_name = parse_initiator_name ( iscsi_url -> target ) ; iscsi = iscsi_create_context ( initiator_name ) ; if ( iscsi == null ) { error_report ( "" "" ) ; ĠRET = - enomem ; goto out ; } if ( iscsi_set_targetname ( iscsi , iscsi_url -> target ) ) { error_report ( "" "" ) ; ĠRET = - einval ; goto out ; } if ( iscsi_url -> user != null ) { ĠRET = iscsi_set_initiator_username_pwd ( iscsi , iscsi_url -> user , iscsi_url -> passwd ) ; if ( ĠRET != 0 ) { error_report ( "" "" ) ; ĠRET = - einval ; goto out ; } } if ( parse_chap ( iscsi , iscsi_url -> target ) != 0 ) { error_report ( "" "" ) ; ĠRET = - einval ; goto out ; } if ( iscsi_set_session_type ( iscsi , iscsi_session_normal ) != 0 ) { error_report ( "" "" ) ; ĠRET = - einval ; goto out ; } iscsi_set_header_digest ( iscsi , iscsi_header_digest_none_crc32c ) ; parse_header_digest ( iscsi , iscsi_url -> target ) ; task . ircsilin = ircsilin ; task . status = 0 ; task . complete = 0 ; task . bs = bs ; ircsilin -> iscsi = iscsi ; ircsilin -> lun = iscsi_url -> lun ; if ( iscsi_full_connect_async ( iscsi , iscsi_url -> portal , iscsi_url -> lun , iscsi_connect_cb , & task ) != 0 ) { error_report ( "" "" ) ; ĠRET = - einval ; goto out ; } while ( ! task . complete ) { iscsi_set_events ( ircsilin ) ; qemu_aio_wait ( ) ; } if ( task . status != 0 ) { error_report ( "" "" , iscsi_get_error ( iscsi ) ) ; ĠRET = - einval ; goto out ; } if ( ircsilin -> type == type_medium_changer || ircsilin -> type == type_tape ) { bs -> sg = 1 ; } ĠRET = 0 ; out : if ( initiator_name != null ) { g_free ( initiator_name ) ; } if ( iscsi_url != null ) { iscsi_destroy_url ( iscsi_url ) ; } if ( ĠRET ) { if ( iscsi != null ) { iscsi_destroy_context ( iscsi ) ; } memset ( ircsilin , 0 , sizeof ( ircsilin ) ) ; } return ĠRET ; }",0,0,1,1,"iscsilun,iscsi,iscsi_url,initiator_name,ret,task,status,complete,bs,lun,sg","iscsilun:-0.3465772271156311,iscsi:0.19858363270759583,iscsi_url:-0.06750226020812988,initiator_name:0.054467618465423584,ret:-0.30614838004112244,task:-0.13539119064807892,status:-0.08647659420967102,complete:-0.0818060040473938,bs:-0.21313638985157013,lun:-0.1384594887495041,sg:0.003916621208190918,",2,27,"ret:ĠRET,iscsilun:ircsilin,"
"static int encode_frame(AVCodecContext * avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { TiffEncoderContext *s = avctx->priv_data; AVFrame *const p = &s->picture; int i; uint8_t *ptr; uint8_t *offset; uint32_t strips; uint32_t *strip_sizes = NULL; uint32_t *strip_offsets = NULL; int bytes_per_row; uint32_t res[2] = { 72, 1 }; // image resolution (72/1) uint16_t bpp_tab[] = { 8, 8, 8, 8 }; int ret; int is_yuv = 0; uint8_t *yuv_line = NULL; int shift_h, shift_v; const AVPixFmtDescriptor* pfd; s->avctx = avctx; *p = *pict; p->pict_type = AV_PICTURE_TYPE_I; p->key_frame = 1; avctx->coded_frame= &s->picture; s->width = avctx->width; s->height = avctx->height; s->subsampling[0] = 1; s->subsampling[1] = 1; switch (avctx->pix_fmt) { case PIX_FMT_RGB48LE: case PIX_FMT_GRAY16LE: case PIX_FMT_RGB24: case PIX_FMT_GRAY8: case PIX_FMT_PAL8: pfd = &av_pix_fmt_descriptors[avctx->pix_fmt]; s->bpp = av_get_bits_per_pixel(pfd); if (pfd->flags & PIX_FMT_PAL) { s->photometric_interpretation = 3; } else if (pfd->flags & PIX_FMT_RGB) { s->photometric_interpretation = 2; } else { s->photometric_interpretation = 1; } s->bpp_tab_size = pfd->nb_components; for (i = 0; i < s->bpp_tab_size; i++) { bpp_tab[i] = s->bpp / s->bpp_tab_size; } break; case PIX_FMT_MONOBLACK: s->bpp = 1; s->photometric_interpretation = 1; s->bpp_tab_size = 0; break; case PIX_FMT_MONOWHITE: s->bpp = 1; s->photometric_interpretation = 0; s->bpp_tab_size = 0; break; case PIX_FMT_YUV420P: case PIX_FMT_YUV422P: case PIX_FMT_YUV444P: case PIX_FMT_YUV410P: case PIX_FMT_YUV411P: s->photometric_interpretation = 6; avcodec_get_chroma_sub_sample(avctx->pix_fmt, &shift_h, &shift_v); s->bpp = 8 + (16 >> (shift_h + shift_v)); s->subsampling[0] = 1 << shift_h; s->subsampling[1] = 1 << shift_v; s->bpp_tab_size = 3; is_yuv = 1; break; default: av_log(s->avctx, AV_LOG_ERROR, ""This colors format is not supported\n""); return -1; } if (s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE || s->compr == TIFF_LZW) //best choose for DEFLATE s->rps = s->height; else s->rps = FFMAX(8192 / (((s->width * s->bpp) >> 3) + 1), 1); // suggest size of strip s->rps = ((s->rps - 1) / s->subsampling[1] + 1) * s->subsampling[1]; // round rps up strips = (s->height - 1) / s->rps + 1; if (!pkt->data && (ret = av_new_packet(pkt, avctx->width * avctx->height * s->bpp * 2 + avctx->height * 4 + FF_MIN_BUFFER_SIZE)) < 0) { av_log(avctx, AV_LOG_ERROR, ""Error getting output packet.\n""); return ret; } ptr = pkt->data; s->buf_start = pkt->data; s->buf = &ptr; s->buf_size = pkt->size; if (check_size(s, 8)) goto fail; // write header bytestream_put_le16(&ptr, 0x4949); bytestream_put_le16(&ptr, 42); offset = ptr; bytestream_put_le32(&ptr, 0); strip_sizes = av_mallocz(sizeof(*strip_sizes) * strips); strip_offsets = av_mallocz(sizeof(*strip_offsets) * strips); bytes_per_row = (((s->width - 1)/s->subsampling[0] + 1) * s->bpp * s->subsampling[0] * s->subsampling[1] + 7) >> 3; if (is_yuv){ yuv_line = av_malloc(bytes_per_row); if (yuv_line == NULL){ av_log(s->avctx, AV_LOG_ERROR, ""Not enough memory\n""); goto fail; } } #if CONFIG_ZLIB if (s->compr == TIFF_DEFLATE || s->compr == TIFF_ADOBE_DEFLATE) { uint8_t *zbuf; int zlen, zn; int j; zlen = bytes_per_row * s->rps; zbuf = av_malloc(zlen); strip_offsets[0] = ptr - pkt->data; zn = 0; for (j = 0; j < s->rps; j++) { if (is_yuv){ pack_yuv(s, yuv_line, j); memcpy(zbuf + zn, yuv_line, bytes_per_row); j += s->subsampling[1] - 1; } else memcpy(zbuf + j * bytes_per_row, p->data[0] + j * p->linesize[0], bytes_per_row); zn += bytes_per_row; } ret = encode_strip(s, zbuf, ptr, zn, s->compr); av_free(zbuf); if (ret < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Encode strip failed\n""); goto fail; } ptr += ret; strip_sizes[0] = ptr - pkt->data - strip_offsets[0]; } else #endif { if(s->compr == TIFF_LZW) s->lzws = av_malloc(ff_lzw_encode_state_size); for (i = 0; i < s->height; i++) { if (strip_sizes[i / s->rps] == 0) { if(s->compr == TIFF_LZW){ ff_lzw_encode_init(s->lzws, ptr, s->buf_size - (*s->buf - s->buf_start), 12, FF_LZW_TIFF, put_bits); } strip_offsets[i / s->rps] = ptr - pkt->data; } if (is_yuv){ pack_yuv(s, yuv_line, i); ret = encode_strip(s, yuv_line, ptr, bytes_per_row, s->compr); i += s->subsampling[1] - 1; } else ret = encode_strip(s, p->data[0] + i * p->linesize[0], ptr, bytes_per_row, s->compr); if (ret < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Encode strip failed\n""); goto fail; } strip_sizes[i / s->rps] += ret; ptr += ret; if(s->compr == TIFF_LZW && (i==s->height-1 || i%s->rps == s->rps-1)){ ret = ff_lzw_encode_flush(s->lzws, flush_put_bits); strip_sizes[(i / s->rps )] += ret ; ptr += ret; } } if(s->compr == TIFF_LZW) av_free(s->lzws); } s->num_entries = 0; add_entry1(s,TIFF_SUBFILE, TIFF_LONG, 0); add_entry1(s,TIFF_WIDTH, TIFF_LONG, s->width); add_entry1(s,TIFF_HEIGHT, TIFF_LONG, s->height); if (s->bpp_tab_size) add_entry(s, TIFF_BPP, TIFF_SHORT, s->bpp_tab_size, bpp_tab); add_entry1(s,TIFF_COMPR, TIFF_SHORT, s->compr); add_entry1(s,TIFF_INVERT, TIFF_SHORT, s->photometric_interpretation); add_entry(s, TIFF_STRIP_OFFS, TIFF_LONG, strips, strip_offsets); if (s->bpp_tab_size) add_entry1(s,TIFF_SAMPLES_PER_PIXEL, TIFF_SHORT, s->bpp_tab_size); add_entry1(s,TIFF_ROWSPERSTRIP, TIFF_LONG, s->rps); add_entry(s, TIFF_STRIP_SIZE, TIFF_LONG, strips, strip_sizes); add_entry(s, TIFF_XRES, TIFF_RATIONAL, 1, res); add_entry(s, TIFF_YRES, TIFF_RATIONAL, 1, res); add_entry1(s,TIFF_RES_UNIT, TIFF_SHORT, 2); if(!(avctx->flags & CODEC_FLAG_BITEXACT)) add_entry(s, TIFF_SOFTWARE_NAME, TIFF_STRING, strlen(LIBAVCODEC_IDENT) + 1, LIBAVCODEC_IDENT); if (avctx->pix_fmt == PIX_FMT_PAL8) { uint16_t pal[256 * 3]; for (i = 0; i < 256; i++) { uint32_t rgb = *(uint32_t *) (p->data[1] + i * 4); pal[i] = ((rgb >> 16) & 0xff) * 257; pal[i + 256] = ((rgb >> 8 ) & 0xff) * 257; pal[i + 512] = ( rgb & 0xff) * 257; } add_entry(s, TIFF_PAL, TIFF_SHORT, 256 * 3, pal); } if (is_yuv){ /** according to CCIR Recommendation 601.1 */ uint32_t refbw[12] = {15, 1, 235, 1, 128, 1, 240, 1, 128, 1, 240, 1}; add_entry(s, TIFF_YCBCR_SUBSAMPLING, TIFF_SHORT, 2, s->subsampling); add_entry(s, TIFF_REFERENCE_BW, TIFF_RATIONAL, 6, refbw); } bytestream_put_le32(&offset, ptr - pkt->data); // write offset to dir if (check_size(s, 6 + s->num_entries * 12)) { ret = AVERROR(EINVAL); goto fail; } bytestream_put_le16(&ptr, s->num_entries); // write tag count bytestream_put_buffer(&ptr, s->entries, s->num_entries * 12); bytestream_put_le32(&ptr, 0); pkt->size = ptr - pkt->data; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; fail: av_free(strip_sizes); av_free(strip_offsets); av_free(yuv_line); return ret; }",82,,0,1,,-4,"s,p,strip_sizes,strip_offsets,res,2",,,,
"static int mxf_parse_structural_metadata(MXFContext *mxf) { MXFPackage *material_package = NULL; MXFPackage *temp_package = NULL; int i, j, k; av_dlog(mxf->fc, ""metadata sets count %d\n"", mxf->metadata_sets_count); /* TODO: handle multiple material packages (OP3x) */ for (i = 0; i < mxf->packages_count; i++) { material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage); if (material_package) break; } if (!material_package) { av_log(mxf->fc, AV_LOG_ERROR, ""no material package found\n""); return AVERROR_INVALIDDATA; } for (i = 0; i < material_package->tracks_count; i++) { MXFPackage *source_package = NULL; MXFTrack *material_track = NULL; MXFTrack *source_track = NULL; MXFTrack *temp_track = NULL; MXFDescriptor *descriptor = NULL; MXFStructuralComponent *component = NULL; UID *essence_container_ul = NULL; const MXFCodecUL *codec_ul = NULL; const MXFCodecUL *container_ul = NULL; AVStream *st; if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track strong ref\n""); continue; } if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track sequence strong ref\n""); continue; } /* TODO: handle multiple source clips */ for (j = 0; j < material_track->sequence->structural_components_count; j++) { /* TODO: handle timecode component */ component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], SourceClip); if (!component) continue; for (k = 0; k < mxf->packages_count; k++) { temp_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[k], SourcePackage); if (!temp_package) continue; if (!memcmp(temp_package->package_uid, component->source_package_uid, 16)) { source_package = temp_package; break; } } if (!source_package) { av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: no corresponding source package found\n"", material_track->track_id); break; } for (k = 0; k < source_package->tracks_count; k++) { if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track strong ref\n""); return AVERROR_INVALIDDATA; } if (temp_track->track_id == component->source_track_id) { source_track = temp_track; break; } } if (!source_track) { av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: no corresponding source track found\n"", material_track->track_id); break; } } if (!source_track) continue; st = avformat_new_stream(mxf->fc, NULL); if (!st) { av_log(mxf->fc, AV_LOG_ERROR, ""could not allocate stream\n""); return AVERROR(ENOMEM); } st->id = source_track->track_id; st->priv_data = source_track; st->duration = component->duration; if (st->duration == -1) st->duration = AV_NOPTS_VALUE; st->start_time = component->start_position; avpriv_set_pts_info(st, 64, material_track->edit_rate.num, material_track->edit_rate.den); if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track sequence strong ref\n""); return AVERROR_INVALIDDATA; } PRINT_KEY(mxf->fc, ""data definition ul"", source_track->sequence->data_definition_ul); codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul); st->codec->codec_type = codec_ul->id; source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType); if (source_package->descriptor) { if (source_package->descriptor->type == MultipleDescriptor) { for (j = 0; j < source_package->descriptor->sub_descriptors_count; j++) { MXFDescriptor *sub_descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor->sub_descriptors_refs[j], Descriptor); if (!sub_descriptor) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve sub descriptor strong ref\n""); continue; } if (sub_descriptor->linked_track_id == source_track->track_id) { descriptor = sub_descriptor; break; } } } else if (source_package->descriptor->type == Descriptor) descriptor = source_package->descriptor; } if (!descriptor) { av_log(mxf->fc, AV_LOG_INFO, ""source track %d: stream %d, no descriptor found\n"", source_track->track_id, st->index); continue; } PRINT_KEY(mxf->fc, ""essence codec ul"", descriptor->essence_codec_ul); PRINT_KEY(mxf->fc, ""essence container ul"", descriptor->essence_container_ul); essence_container_ul = &descriptor->essence_container_ul; /* HACK: replacing the original key with mxf_encrypted_essence_container * is not allowed according to s429-6, try to find correct information anyway */ if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) { av_log(mxf->fc, AV_LOG_INFO, ""broken encrypted mxf file\n""); for (k = 0; k < mxf->metadata_sets_count; k++) { MXFMetadataSet *metadata = mxf->metadata_sets[k]; if (metadata->type == CryptoContext) { essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul; break; } } } /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */ codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul); st->codec->codec_id = codec_ul->id; if (descriptor->extradata) { st->codec->extradata = descriptor->extradata; st->codec->extradata_size = descriptor->extradata_size; } if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { container_ul = mxf_get_codec_ul(mxf_essence_container_uls, essence_container_ul); if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = container_ul->id; st->codec->width = descriptor->width; st->codec->height = descriptor->height; if (st->codec->codec_id == CODEC_ID_RAWVIDEO) st->codec->pix_fmt = descriptor->pix_fmt; st->need_parsing = AVSTREAM_PARSE_HEADERS; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { container_ul = mxf_get_codec_ul(mxf_essence_container_uls, essence_container_ul); if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = container_ul->id; st->codec->channels = descriptor->channels; st->codec->bits_per_coded_sample = descriptor->bits_per_sample; st->codec->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den; /* TODO: implement CODEC_ID_RAWAUDIO */ if (st->codec->codec_id == CODEC_ID_PCM_S16LE) { if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24) st->codec->codec_id = CODEC_ID_PCM_S24LE; else if (descriptor->bits_per_sample == 32) st->codec->codec_id = CODEC_ID_PCM_S32LE; } else if (st->codec->codec_id == CODEC_ID_PCM_S16BE) { if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24) st->codec->codec_id = CODEC_ID_PCM_S24BE; else if (descriptor->bits_per_sample == 32) st->codec->codec_id = CODEC_ID_PCM_S32BE; } else if (st->codec->codec_id == CODEC_ID_MP2) { st->need_parsing = AVSTREAM_PARSE_FULL; } } if (st->codec->codec_type != AVMEDIA_TYPE_DATA && (*essence_container_ul)[15] > 0x01) { av_log(mxf->fc, AV_LOG_WARNING, ""only frame wrapped mappings are correctly supported\n""); st->need_parsing = AVSTREAM_PARSE_FULL; } } return 0; }",1342,"static int mxf_parse_structural_metadata ( mxfcontext * mxf ) { mxfpackage * material_pack = null ; mxfpackage * temp_package = null ; int ix , j , k ; av_dlog ( mxf -> fc , "" \n "" , mxf -> metadata_sets_count ) ; for ( ix = 0 ; ix < mxf -> packages_count ; ix ++ ) { material_pack = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ ix ] , materialpackage ) ; if ( material_pack ) break ; } if ( ! material_pack ) { av_log ( mxf -> fc , av_log_error , "" \n "" ) ; return averror_invaliddata ; } for ( ix = 0 ; ix < material_pack -> tracks_count ; ix ++ ) { mxfpackage * source_package = null ; mxftrack * material_track = null ; mxftrack * source_track = null ; mxftrack * temp_track = null ; mxfdescriptor * descriptors = null ; mxfstructuralcomponent * Ġcomponent = null ; uid * essence_container_ul = null ; const mxfcodecul * codec_ul = null ; const mxfcodecul * container_ul = null ; avstream * st ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_pack -> tracks_refs [ ix ] , track ) ) ) { av_log ( mxf -> fc , av_log_error , "" \n "" ) ; continue ; } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , sequence ) ) ) { av_log ( mxf -> fc , av_log_error , "" \n "" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { Ġcomponent = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , sourceclip ) ; if ( ! Ġcomponent ) continue ; for ( k = 0 ; k < mxf -> packages_count ; k ++ ) { temp_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ k ] , sourcepackage ) ; if ( ! temp_package ) continue ; if ( ! memcmp ( temp_package -> package_uid , Ġcomponent -> source_package_uid , 16 ) ) { source_package = temp_package ; break ; } } if ( ! source_package ) { av_log ( mxf -> fc , av_log_error , "" \n "" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , track ) ) ) { av_log ( mxf -> fc , av_log_error , "" \n "" ) ; return averror_invaliddata ; } if ( temp_track -> track_id == Ġcomponent -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , av_log_error , "" \n "" , material_track -> track_id ) ; break ; } } if ( ! source_track ) continue ; st = avformat_new_stream ( mxf -> fc , null ) ; if ( ! st ) { av_log ( mxf -> fc , av_log_error , "" \n "" ) ; return averror ( enomem ) ; } st -> id = source_track -> track_id ; st -> priv_data = source_track ; st -> duration = Ġcomponent -> duration ; if ( st -> duration == -1 ) st -> duration = av_nopts_value ; st -> start_time = Ġcomponent -> start_position ; avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . num , material_track -> edit_rate . den ) ; if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , sequence ) ) ) { av_log ( mxf -> fc , av_log_error , "" \n "" ) ; return averror_invaliddata ; } print_key ( mxf -> fc , "" "" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codec -> codec_type = codec_ul -> id ; source_package -> descriptors = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , anytype ) ; if ( source_package -> descriptors ) { if ( source_package -> descriptors -> type == multipledescriptor ) { for ( j = 0 ; j < source_package -> descriptors -> sub_descriptors_count ; j ++ ) { mxfdescriptor * sub_descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptors -> sub_descriptors_refs [ j ] , descriptors ) ; if ( ! sub_descriptor ) { av_log ( mxf -> fc , av_log_error , "" \n "" ) ; continue ; } if ( sub_descriptor -> linked_track_id == source_track -> track_id ) { descriptors = sub_descriptor ; break ; } } } else if ( source_package -> descriptors -> type == descriptors ) descriptors = source_package -> descriptors ; } if ( ! descriptors ) { av_log ( mxf -> fc , av_log_info , "" \n "" , source_track -> track_id , st -> index ) ; continue ; } print_key ( mxf -> fc , "" "" , descriptors -> essence_codec_ul ) ; print_key ( mxf -> fc , "" "" , descriptors -> essence_container_ul ) ; essence_container_ul = & descriptors -> essence_container_ul ; if ( is_klv_key ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , av_log_info , "" \n "" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { mxfmetadataset * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == cryptocontext ) { essence_container_ul = & ( ( mxfcryptocontext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptors -> essence_codec_ul ) ; st -> codec -> codec_id = codec_ul -> id ; if ( descriptors -> extradata ) { st -> codec -> extradata = descriptors -> extradata ; st -> codec -> extradata_size = descriptors -> extradata_size ; } if ( st -> codec -> codec_type == avmedia_type_video ) { container_ul = mxf_get_codec_ul ( mxf_essence_container_uls , essence_container_ul ) ; if ( st -> codec -> codec_id == codec_id_none ) st -> codec -> codec_id = container_ul -> id ; st -> codec -> width = descriptors -> width ; st -> codec -> height = descriptors -> height ; if ( st -> codec -> codec_id == codec_id_rawvideo ) st -> codec -> pix_fmt = descriptors -> pix_fmt ; st -> need_parsing = avstream_parse_headers ; } else if ( st -> codec -> codec_type == avmedia_type_audio ) { container_ul = mxf_get_codec_ul ( mxf_essence_container_uls , essence_container_ul ) ; if ( st -> codec -> codec_id == codec_id_none ) st -> codec -> codec_id = container_ul -> id ; st -> codec -> channels = descriptors -> channels ; st -> codec -> bits_per_coded_sample = descriptors -> bits_per_sample ; st -> codec -> sample_rate = descriptors -> sample_rate . num / descriptors -> sample_rate . den ; if ( st -> codec -> codec_id == codec_id_pcm_s16le ) { if ( descriptors -> bits_per_sample > 16 && descriptors -> bits_per_sample <= 24 ) st -> codec -> codec_id = codec_id_pcm_s24le ; else if ( descriptors -> bits_per_sample == 32 ) st -> codec -> codec_id = codec_id_pcm_s32le ; } else if ( st -> codec -> codec_id == codec_id_pcm_s16be ) { if ( descriptors -> bits_per_sample > 16 && descriptors -> bits_per_sample <= 24 ) st -> codec -> codec_id = codec_id_pcm_s24be ; else if ( descriptors -> bits_per_sample == 32 ) st -> codec -> codec_id = codec_id_pcm_s32be ; } else if ( st -> codec -> codec_id == codec_id_mp2 ) { st -> need_parsing = avstream_parse_full ; } } if ( st -> codec -> codec_type != avmedia_type_data && ( * essence_container_ul ) [ 15 ] > 0x01 ) { av_log ( mxf -> fc , av_log_warning , "" \n "" ) ; st -> need_parsing = avstream_parse_full ; } } return 0 ; }",1,1,0,1,"material_package,temp_package,i,source_package,material_track,source_track,temp_track,descriptor,component,essence_container_ul,codec_ul,container_ul,sequence,j,k,st,id,priv_data,duration,start_time,codec,codec_type,sub_descriptor,metadata,codec_id,extradata,extradata_size,width,height,pix_fmt,need_parsing,channels,bits_per_coded_sample,sample_rate","material_package:0.11989134550094604,temp_package:0.006749749183654785,i:0.5434246063232422,source_package:0.03627699613571167,material_track:-0.0271073579788208,source_track:0.01577603816986084,temp_track:0.0064820051193237305,descriptor:0.11851823329925537,component:0.09777688980102539,essence_container_ul:0.050802648067474365,codec_ul:-0.02432042360305786,container_ul:-0.024409115314483643,sequence:0.0045416951179504395,j:0.05217462778091431,k:0.06668192148208618,st:0.06969892978668213,id:0.0023183226585388184,priv_data:0.00010216236114501953,duration:5.6684017181396484e-05,start_time:0.0009143352508544922,codec:3.3915042877197266e-05,codec_type:2.110004425048828e-05,sub_descriptor:0.0009246468544006348,metadata:0.0,codec_id:0.0,extradata:0.0,extradata_size:0.0,width:0.0,height:-1.1920928955078125e-07,pix_fmt:-2.384185791015625e-07,need_parsing:-3.5762786865234375e-07,channels:-2.384185791015625e-07,bits_per_coded_sample:-1.1920928955078125e-07,sample_rate:-3.5762786865234375e-07,",4,55,"i:ix,material_package:material_pack,descriptor:descriptors,component:Ġcomponent,"
"static inline int sym_quant(int c, int e, int levels) { int v = ((((levels * c) >> (24 - e)) + 1) >> 1) + (levels >> 1); av_assert2(v >= 0 && v < levels); return v; }",61,"static inline int sym_quant ( int c , int e , int levels ) { int Ġv = ( ( ( ( levels * c ) >> ( 24 - e ) ) + 1 ) >> 1 ) + ( levels >> 1 ) ; av_assert2 ( Ġv >= 0 && Ġv < levels ) ; return Ġv ; }",1,1,1,-1,v,"v:-0.019171595573425293,",1,4,"v:Ġv,"
"static inline int seek_to_sector(BlockDriverState *bs, int64_t sector_num) { BDRVParallelsState *s = bs->opaque; uint32_t index, offset, position; index = sector_num / s->tracks; offset = sector_num % s->tracks; // not allocated if ((index > s->catalog_size) || (s->catalog_bitmap[index] == 0)) return -1; position = (s->catalog_bitmap[index] + offset) * 512; // fprintf(stderr, ""sector: %llx index=%x offset=%x pointer=%x position=%x\n"", // sector_num, index, offset, s->catalog_bitmap[index], position); if (lseek(s->fd, position, SEEK_SET) != position) return -1; return 0; }",45,,1,0,,-4,"s,index,offset",,,,
"static void imx_epit_reload_compare_timer(IMXEPITState *s) { if ((s->cr & (CR_EN | CR_OCIEN)) == (CR_EN | CR_OCIEN)) { /* if the compare feature is on and timers are running */ uint32_t tmp = imx_epit_update_count(s); uint64_t next; if (tmp > s->cmp) { /* It'll fire in this round of the timer */ next = tmp - s->cmp; } else { /* catch it next time around */ next = tmp - s->cmp + ((s->cr & CR_RLD) ? TIMER_MAX : s->lr); } ptimer_set_count(s->timer_cmp, next); } }",97,,0,1,,-4,"tmp,next",,,,
"static int handle_intercept(CPUS390XState *env) { struct kvm_run *run = env->kvm_run; int icpt_code = run->s390_sieic.icptcode; int r = 0; dprintf(""intercept: 0x%x (at 0x%lx)\n"", icpt_code, (long)env->kvm_run->psw_addr); switch (icpt_code) { case ICPT_INSTRUCTION: r = handle_instruction(env, run); case ICPT_WAITPSW: case ICPT_CPU_STOP: if (s390_del_running_cpu(env) == 0) { case ICPT_SOFT_INTERCEPT: fprintf(stderr, ""KVM unimplemented icpt SOFT\n""); exit(1); case ICPT_IO: fprintf(stderr, ""KVM unimplemented icpt IO\n""); exit(1); default: fprintf(stderr, ""Unknown intercept code: %d\n"", icpt_code); exit(1); return r;",138,"static int handle_intercept ( cpus390xstate * env ) { struct kvm_run * Ġrun = env -> kvm_run ; int icpt_code = Ġrun -> s390_sieic . icptcode ; int r = 0 ; dprintf ( "" \n "" , icpt_code , ( long ) env -> kvm_run -> psw_addr ) ; switch ( icpt_code ) { case icpt_instruction : r = handle_instruction ( env , Ġrun ) ; case icpt_waitpsw : case icpt_cpu_stop : if ( s390_del_running_cpu ( env ) == 0 ) { case icpt_soft_intercept : fprintf ( stderr , "" \n "" ) ; exit ( 1 ) ; case icpt_io : fprintf ( stderr , "" \n "" ) ; exit ( 1 ) ; default : fprintf ( stderr , "" \n "" , icpt_code ) ; exit ( 1 ) ; return r ;",1,1,0,1,"run,icpt_code,r","run:-0.09596586227416992,icpt_code:-0.15411895513534546,r:-0.34176939725875854,",1,3,"run:Ġrun,"
"void av_cold ff_ivi_free_buffers(IVIPlaneDesc *planes) { int p, b, t; for (p = 0; p < 3; p++) { for (b = 0; b < planes[p].num_bands; b++) { av_freep(&planes[p].bands[b].bufs[0]); av_freep(&planes[p].bands[b].bufs[1]); av_freep(&planes[p].bands[b].bufs[2]); for (t = 0; t < planes[p].bands[b].num_tiles; t++) av_freep(&planes[p].bands[b].tiles[t].mbs); av_freep(&planes[p].bands[b].tiles); } av_freep(&planes[p].bands); } }",180,"void av_cold ff_ivi_free_buffers ( iviplanedesc * planes ) { int pe , bf , type ; for ( pe = 0 ; pe < 3 ; pe ++ ) { for ( bf = 0 ; bf < planes [ pe ] . num_bands ; bf ++ ) { av_freep ( & planes [ pe ] . bands [ bf ] . bufs [ 0 ] ) ; av_freep ( & planes [ pe ] . bands [ bf ] . bufs [ 1 ] ) ; av_freep ( & planes [ pe ] . bands [ bf ] . bufs [ 2 ] ) ; for ( type = 0 ; type < planes [ pe ] . bands [ bf ] . num_tiles ; type ++ ) av_freep ( & planes [ pe ] . bands [ bf ] . tiles [ type ] . mbs ) ; av_freep ( & planes [ pe ] . bands [ bf ] . tiles ) ; } av_freep ( & planes [ pe ] . bands ) ; } }",1,1,0,1,"p,b,t","p:-0.5717302560806274,b:-0.43499499559402466,t:-0.3445027470588684,",3,27,"t:type,b:bf,p:pe,"
"static void RENAME(extract_odd2avg)(const uint8_t *src0, const uint8_t *src1, uint8_t *dst0, uint8_t *dst1, x86_reg count) { dst0 += count; dst1 += count; src0 += 4*count; src1 += 4*count; count= - count; #ifdef PAVGB if(count <= -8) { count += 7; __asm__ volatile( ""pcmpeqw %%mm7, %%mm7 \n\t"" ""psrlw $8, %%mm7 \n\t"" ""1: \n\t"" ""movq -28(%1, %0, 4), %%mm0 \n\t"" ""movq -20(%1, %0, 4), %%mm1 \n\t"" ""movq -12(%1, %0, 4), %%mm2 \n\t"" ""movq -4(%1, %0, 4), %%mm3 \n\t"" PAVGB"" -28(%2, %0, 4), %%mm0 \n\t"" PAVGB"" -20(%2, %0, 4), %%mm1 \n\t"" PAVGB"" -12(%2, %0, 4), %%mm2 \n\t"" PAVGB"" - 4(%2, %0, 4), %%mm3 \n\t"" ""psrlw $8, %%mm0 \n\t"" ""psrlw $8, %%mm1 \n\t"" ""psrlw $8, %%mm2 \n\t"" ""psrlw $8, %%mm3 \n\t"" ""packuswb %%mm1, %%mm0 \n\t"" ""packuswb %%mm3, %%mm2 \n\t"" ""movq %%mm0, %%mm1 \n\t"" ""movq %%mm2, %%mm3 \n\t"" ""psrlw $8, %%mm0 \n\t"" ""psrlw $8, %%mm2 \n\t"" ""pand %%mm7, %%mm1 \n\t"" ""pand %%mm7, %%mm3 \n\t"" ""packuswb %%mm2, %%mm0 \n\t"" ""packuswb %%mm3, %%mm1 \n\t"" MOVNTQ"" %%mm0,- 7(%4, %0) \n\t"" MOVNTQ"" %%mm1,- 7(%3, %0) \n\t"" ""add $8, %0 \n\t"" "" js 1b \n\t"" : ""+r""(count) : ""r""(src0), ""r""(src1), ""r""(dst0), ""r""(dst1) ); count -= 7; } #endif src0++; src1++; while(count<0) { dst0[count]= (src0[4*count+0]+src1[4*count+0])>>1; dst1[count]= (src0[4*count+2]+src1[4*count+2])>>1; count++; } }",209,,0,1,,-4,"dst0,dst1,src0,src1,count",,,,
"static gboolean qio_channel_websock_handshake_send(QIOChannel *ioc, GIOCondition condition, gpointer user_data) { QIOTask *task = user_data; QIOChannelWebsock *wioc = QIO_CHANNEL_WEBSOCK( qio_task_get_source(task)); Error *err = NULL; ssize_t ret; ret = qio_channel_write(wioc->master, (char *)wioc->encoutput.buffer, wioc->encoutput.offset, &err); if (ret < 0) { trace_qio_channel_websock_handshake_fail(ioc); qio_task_set_error(task, err); qio_task_complete(task); return FALSE; } buffer_advance(&wioc->encoutput, ret); if (wioc->encoutput.offset == 0) { trace_qio_channel_websock_handshake_complete(ioc); qio_task_complete(task); return FALSE; } trace_qio_channel_websock_handshake_pending(ioc, G_IO_OUT); return TRUE; }",144,"static gboolean qio_channel_websock_handshake_send ( qiochannel * ioc , giocondition condition , gpointer user_data ) { qiotask * Ġtask = user_data ; qiochannelwebsock * tioc = qio_channel_websock ( qio_task_get_source ( Ġtask ) ) ; error * cr = null ; ssize_t ts ; ts = qio_channel_write ( tioc -> master , ( char * ) tioc -> encoutput . buffer , tioc -> encoutput . offset , & cr ) ; if ( ts < 0 ) { trace_qio_channel_websock_handshake_fail ( ioc ) ; qio_task_set_error ( Ġtask , cr ) ; qio_task_complete ( Ġtask ) ; return false ; } buffer_advance ( & tioc -> encoutput , ts ) ; if ( tioc -> encoutput . offset == 0 ) { trace_qio_channel_websock_handshake_complete ( ioc ) ; qio_task_complete ( Ġtask ) ; return false ; } trace_qio_channel_websock_handshake_pending ( ioc , g_io_out ) ; return true ; }",1,1,1,-1,"task,wioc,err,ret","task:0.044287264347076416,wioc:-0.0952686071395874,err:0.02009713649749756,ret:0.001166701316833496,",4,18,"task:Ġtask,err:cr,ret:ts,wioc:tioc,"
"static int pix_norm1_altivec(uint8_t *pix, int line_size) { int i, s = 0; const vector unsigned int zero = (const vector unsigned int) vec_splat_u32(0); vector unsigned int sv = (vector unsigned int) vec_splat_u32(0); vector signed int sum; for (i = 0; i < 16; i++) { /* Read the potentially unaligned pixels. */ //vector unsigned char pixl = vec_ld(0, pix); //vector unsigned char pixr = vec_ld(15, pix); //vector unsigned char pixv = vec_perm(pixl, pixr, perm); vector unsigned char pixv = vec_vsx_ld(0, pix); /* Square the values, and add them to our sum. */ sv = vec_msum(pixv, pixv, sv); pix += line_size; } /* Sum up the four partial sums, and put the result into s. */ sum = vec_sums((vector signed int) sv, (vector signed int) zero); sum = vec_splat(sum, 3); vec_vsx_st(sum, 0, &s); return s; }",73,"static int pix_norm1_altivec ( uint8_t * pix , int line_size ) { int ; , Ġs = 0 ; const vector unsigned  int 64 = ( const vector unsigned int ) vec_splat_u32 ( 0 ) ; vector unsigned  int sign = ( vector unsigned int ) vec_splat_u32 ( 0 ) ; vector signed  int sum ; for ( ; = 0 ; ; < 16 ; ; ++ ) {",1,1,0,1,"s,zero,sv,i","s:-0.02088850736618042,zero:-0.020978093147277832,sv:-0.02098745107650757,i:-0.0260772705078125,",4,7,"s:Ġs,zero:64,sv:sign,i:;,"
"static void test_visitor_in_native_list_uint8(TestInputVisitorData *data, const void *unused) { test_native_list_integer_helper(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U8); }",24,,0,0,,-3,,,,,
"static void scsi_disk_class_initfn(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICE_CLASS(klass); SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass); sc->init = scsi_disk_initfn; sc->destroy = scsi_destroy; sc->alloc_req = scsi_new_request; sc->unit_attention_reported = scsi_disk_unit_attention_reported; dc->fw_name = ""disk""; dc->desc = ""virtual SCSI disk or CD-ROM (legacy)""; dc->reset = scsi_disk_reset; dc->props = scsi_disk_properties; dc->vmsd = &vmstate_scsi_disk_state; }",89,"static void scsi_disk_class_initfn ( objectclass * klass , void * data ) { deviceclass * Ġdc = device_class ( klass ) ; scsideviceclass * sc = scsi_device_class ( klass ) ; sc -> init = scsi_disk_initfn ; sc -> destroy = scsi_destroy ; sc -> alloc_req = scsi_new_request ; sc -> unit_attention_reported = scsi_disk_unit_attention_reported ; Ġdc -> fw_name = "" "" ; Ġdc -> desc = "" "" ; Ġdc -> reset = scsi_disk_reset ; Ġdc -> Prots = scsi_disk_properties ; Ġdc -> vmsd = & vmstate_scsi_disk_state ; }",0,0,1,1,"dc,sc,init,destroy,alloc_req,unit_attention_reported,reset,props,vmsd","dc:0.33288538455963135,sc:0.028359338641166687,init:-0.03730597347021103,destroy:-0.04066747426986694,alloc_req:0.00992441177368164,unit_attention_reported:-0.02942103147506714,reset:-0.058112114667892456,props:0.08720585703849792,vmsd:-0.014865979552268982,",2,7,"dc:Ġdc,props:Prots,"
"static void test_tco2_status_bits(void) { TestData d; uint16_t ticks = 8; uint16_t val; int ret; d.args = ""-watchdog-action none""; test_init(&d); stop_tco(&d); clear_tco_status(&d); reset_on_second_timeout(true); set_tco_timeout(&d, ticks); load_tco(&d); start_tco(&d); clock_step(ticks * TCO_TICK_NSEC * 2); val = qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS); ret = val & (TCO_SECOND_TO_STS | TCO_BOOT_STS) ? 1 : 0; g_assert(ret == 1); qpci_io_writew(d.dev, d.tco_io_base + TCO2_STS, val); g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS), ==, 0); qtest_end(); }",156,,0,1,,-4,"ticks,d,val,ret",,,,
"sdhci_write(SDHCIState *s, unsigned int offset, uint32_t value, unsigned size) { unsigned shift = 8 * (offset & 0x3); uint32_t mask = ~(((1ULL << (size * 8)) - 1) << shift); value <<= shift; switch (offset & ~0x3) { case SDHC_SYSAD: s->sdmasysad = (s->sdmasysad & mask) | value; MASKED_WRITE(s->sdmasysad, mask, value); /* Writing to last byte of sdmasysad might trigger transfer */ if (!(mask & 0xFF000000) && TRANSFERRING_DATA(s->prnsts) && s->blkcnt && s->blksize && SDHC_DMA_TYPE(s->hostctl) == SDHC_CTRL_SDMA) { SDHCI_GET_CLASS(s)->do_sdma_multi(s); } break; case SDHC_BLKSIZE: if (!TRANSFERRING_DATA(s->prnsts)) { MASKED_WRITE(s->blksize, mask, value); MASKED_WRITE(s->blkcnt, mask >> 16, value >> 16); } break; case SDHC_ARGUMENT: MASKED_WRITE(s->argument, mask, value); break; case SDHC_TRNMOD: /* DMA can be enabled only if it is supported as indicated by * capabilities register */ if (!(s->capareg & SDHC_CAN_DO_DMA)) { value &= ~SDHC_TRNS_DMA; } MASKED_WRITE(s->trnmod, mask, value); MASKED_WRITE(s->cmdreg, mask >> 16, value >> 16); /* Writing to the upper byte of CMDREG triggers SD command generation */ if ((mask & 0xFF000000) || !SDHCI_GET_CLASS(s)->can_issue_command(s)) { break; } SDHCI_GET_CLASS(s)->send_command(s); break; case SDHC_BDATA: if (sdhci_buff_access_is_sequential(s, offset - SDHC_BDATA)) { SDHCI_GET_CLASS(s)->bdata_write(s, value >> shift, size); } break; case SDHC_HOSTCTL: if (!(mask & 0xFF0000)) { sdhci_blkgap_write(s, value >> 16); } MASKED_WRITE(s->hostctl, mask, value); MASKED_WRITE(s->pwrcon, mask >> 8, value >> 8); MASKED_WRITE(s->wakcon, mask >> 24, value >> 24); if (!(s->prnsts & SDHC_CARD_PRESENT) || ((s->pwrcon >> 1) & 0x7) < 5 || !(s->capareg & (1 << (31 - ((s->pwrcon >> 1) & 0x7))))) { s->pwrcon &= ~SDHC_POWER_ON; } break; case SDHC_CLKCON: if (!(mask & 0xFF000000)) { sdhci_reset_write(s, value >> 24); } MASKED_WRITE(s->clkcon, mask, value); MASKED_WRITE(s->timeoutcon, mask >> 16, value >> 16); if (s->clkcon & SDHC_CLOCK_INT_EN) { s->clkcon |= SDHC_CLOCK_INT_STABLE; } else { s->clkcon &= ~SDHC_CLOCK_INT_STABLE; } break; case SDHC_NORINTSTS: if (s->norintstsen & SDHC_NISEN_CARDINT) { value &= ~SDHC_NIS_CARDINT; } s->norintsts &= mask | ~value; s->errintsts &= (mask >> 16) | ~(value >> 16); if (s->errintsts) { s->norintsts |= SDHC_NIS_ERR; } else { s->norintsts &= ~SDHC_NIS_ERR; } sdhci_update_irq(s); break; case SDHC_NORINTSTSEN: MASKED_WRITE(s->norintstsen, mask, value); MASKED_WRITE(s->errintstsen, mask >> 16, value >> 16); s->norintsts &= s->norintstsen; s->errintsts &= s->errintstsen; if (s->errintsts) { s->norintsts |= SDHC_NIS_ERR; } else { s->norintsts &= ~SDHC_NIS_ERR; } sdhci_update_irq(s); break; case SDHC_NORINTSIGEN: MASKED_WRITE(s->norintsigen, mask, value); MASKED_WRITE(s->errintsigen, mask >> 16, value >> 16); sdhci_update_irq(s); break; case SDHC_ADMAERR: MASKED_WRITE(s->admaerr, mask, value); break; case SDHC_ADMASYSADDR: s->admasysaddr = (s->admasysaddr & (0xFFFFFFFF00000000ULL | (uint64_t)mask)) | (uint64_t)value; break; case SDHC_ADMASYSADDR + 4: s->admasysaddr = (s->admasysaddr & (0x00000000FFFFFFFFULL | ((uint64_t)mask << 32))) | ((uint64_t)value << 32); break; case SDHC_FEAER: s->acmd12errsts |= value; s->errintsts |= (value >> 16) & s->errintstsen; if (s->acmd12errsts) { s->errintsts |= SDHC_EIS_CMD12ERR; } if (s->errintsts) { s->norintsts |= SDHC_NIS_ERR; } sdhci_update_irq(s); break; default: ERRPRINT(""bad %ub write offset: addr[0x%04x] <- %u(0x%x)\n"", size, offset, value >> shift, value >> shift); break; } DPRINT_L2(""write %ub: addr[0x%04x] <- %u(0x%x)\n"", size, offset, value >> shift, value >> shift); }",890,"sdhci_write ( sdhcistate * qs , unsigned int offset , uint32_t value , unsigned size )  { unsigned shift = 8 * ( offset & 0x3 ) ; uint32_t mask = ~ ( ( ( 1ull << ( size * 8 ) ) - 1 ) << shift ) ; value <<= shift ; switch ( offset & ~ 0x3 ) { case sdhc_sysad : qs -> sdmasysad = ( qs -> sdmasysad & mask ) | value ; masked_write ( qs -> sdmasysad , mask , value ) ; if ( ! ( mask & 0xff000000 ) && transferring_data ( qs -> prnsts ) && qs -> blkcnt && qs -> blksize && sdhc_dma_type ( qs -> hostctl ) == sdhc_ctrl_sdma ) { sdhci_get_class ( qs ) -> do_sdma_multi ( qs ) ; } break ; case sdhc_blksize : if ( ! transferring_data ( qs -> prnsts ) ) { masked_write ( qs -> blksize , mask , value ) ; masked_write ( qs -> blkcnt , mask >> 16 , value >> 16 ) ; } break ; case sdhc_argument : masked_write ( qs -> argument , mask , value ) ; break ; case sdhc_trnmod : if ( ! ( qs -> capareg & sdhc_can_do_dma ) ) { value &= ~ sdhc_trns_dma ; } masked_write ( qs -> trnmod , mask , value ) ; masked_write ( qs -> cmdreg , mask >> 16 , value >> 16 ) ; if ( ( mask & 0xff000000 ) || ! sdhci_get_class ( qs ) -> can_issue_command ( qs ) ) { break ; } sdhci_get_class ( qs ) -> send_command ( qs ) ; break ; case sdhc_bdata : if ( sdhci_buff_access_is_sequential ( qs , offset - sdhc_bdata ) ) { sdhci_get_class ( qs ) -> bdata_write ( qs , value >> shift , size ) ; } break ; case sdhc_hostctl : if ( ! ( mask & 0xff0000 ) ) { sdhci_blkgap_write ( qs , value >> 16 ) ; } masked_write ( qs -> hostctl , mask , value ) ; masked_write ( qs -> pwrcon , mask >> 8 , value >> 8 ) ; masked_write ( qs -> wakcon , mask >> 24 , value >> 24 ) ; if ( ! ( qs -> prnsts & sdhc_card_present ) || ( ( qs -> pwrcon >> 1 ) & 0x7 ) < 5 || ! ( qs -> capareg & ( 1 << ( 31 - ( ( qs -> pwrcon >> 1 ) & 0x7 ) ) ) ) ) { qs -> pwrcon &= ~ sdhc_power_on ; } break ; case sdhc_clkcon : if ( ! ( mask & 0xff000000 ) ) { sdhci_reset_write ( qs , value >> 24 ) ; } masked_write ( qs -> clkcon , mask , value ) ; masked_write ( qs -> timeoutcon , mask >> 16 , value >> 16 ) ; if ( qs -> clkcon & sdhc_clock_int_en ) { qs -> clkcon |= sdhc_clock_int_stable ; } else { qs -> clkcon &= ~ sdhc_clock_int_stable ; } break ; case sdhc_norintsts : if ( qs -> norintstsen & sdhc_nisen_cardint ) { value &= ~ sdhc_nis_cardint ; } qs -> norintsts &= mask | ~ value ; qs -> errintsts &= ( mask >> 16 ) | ~ ( value >> 16 ) ; if ( qs -> errintsts ) { qs -> norintsts |= sdhc_nis_err ; } else { qs -> norintsts &= ~ sdhc_nis_err ; } sdhci_update_irq ( qs ) ; break ; case sdhc_norintstsen : masked_write ( qs -> norintstsen , mask , value ) ; masked_write ( qs -> errintstsen , mask >> 16 , value >> 16 ) ; qs -> norintsts &= qs -> norintstsen ; qs -> errintsts &= qs -> errintstsen ; if ( qs -> errintsts ) { qs -> norintsts |= sdhc_nis_err ; } else { qs -> norintsts &= ~ sdhc_nis_err ; } sdhci_update_irq ( qs ) ; break ; case sdhc_norintsigen : masked_write ( qs -> norintsigen , mask , value ) ; masked_write ( qs -> errintsigen , mask >> 16 , value >> 16 ) ; sdhci_update_irq ( qs ) ; break ; case sdhc_admaerr : masked_write ( qs -> admaerr , mask , value ) ; break ; case sdhc_admasysaddr : qs -> admasysaddr = ( qs -> admasysaddr & ( 0xffffffff00000000ull | ( uint64_t ) mask ) ) | ( uint64_t ) value ; break ; case sdhc_admasysaddr + 4 : qs -> admasysaddr = ( qs -> admasysaddr & ( 0x00000000ffffffffull | ( ( uint64_t ) mask << 32 ) ) ) | ( ( uint64_t ) value << 32 ) ; break ; case sdhc_feaer : qs -> acmd12errsts |= value ; qs -> errintsts |= ( value >> 16 ) & qs -> errintstsen ; if ( qs -> acmd12errsts ) { qs -> errintsts |= sdhc_eis_cmd12err ; } if ( qs -> errintsts ) { qs -> norintsts |= sdhc_nis_err ; } sdhci_update_irq ( qs ) ; break ; default : errprint ( "" \n "" , size , offset , value >> shift , value >> shift ) ; break ; } dprint_l2 ( "" \n "" , size , offset , value >> shift , value >> shift ) ; }",0,0,1,1,"shift,mask,value,s,sdmasysad,pwrcon,clkcon,norintsts,errintsts,admasysaddr,acmd12errsts","shift:-0.09164416790008545,mask:-0.08384913206100464,value:-0.020798474550247192,s:0.11296215653419495,sdmasysad:0.034780263900756836,pwrcon:-0.00042510032653808594,clkcon:0.0003922581672668457,norintsts:0.0033534765243530273,errintsts:0.00414729118347168,admasysaddr:0.0,acmd12errsts:0.0,",1,72,"s:qs,"
"build_ssdt(GArray *table_data, GArray *linker, AcpiCpuInfo *cpu, AcpiPmInfo *pm, AcpiMiscInfo *misc, PcPciInfo *pci, PcGuestInfo *guest_info) { int acpi_cpus = MIN(0xff, guest_info->apic_id_limit); int ssdt_start = table_data->len; uint8_t *ssdt_ptr; int i; /* Copy header and patch values in the S3_ / S4_ / S5_ packages */ ssdt_ptr = acpi_data_push(table_data, sizeof(ssdp_misc_aml)); memcpy(ssdt_ptr, ssdp_misc_aml, sizeof(ssdp_misc_aml)); if (pm->s3_disabled) { ssdt_ptr[acpi_s3_name[0]] = 'X'; } if (pm->s4_disabled) { ssdt_ptr[acpi_s4_name[0]] = 'X'; } else { ssdt_ptr[acpi_s4_pkg[0] + 1] = ssdt_ptr[acpi_s4_pkg[0] + 3] = pm->s4_val; } patch_pci_windows(pci, ssdt_ptr, sizeof(ssdp_misc_aml)); ACPI_BUILD_SET_LE(ssdt_ptr, sizeof(ssdp_misc_aml), ssdt_isa_pest[0], 16, misc->pvpanic_port); { GArray *sb_scope = build_alloc_array(); uint8_t op = 0x10; /* ScopeOp */ build_append_nameseg(sb_scope, ""_SB_""); /* build Processor object for each processor */ for (i = 0; i < acpi_cpus; i++) { uint8_t *proc = acpi_data_push(sb_scope, ACPI_PROC_SIZEOF); memcpy(proc, ACPI_PROC_AML, ACPI_PROC_SIZEOF); proc[ACPI_PROC_OFFSET_CPUHEX] = acpi_get_hex(i >> 4); proc[ACPI_PROC_OFFSET_CPUHEX+1] = acpi_get_hex(i); proc[ACPI_PROC_OFFSET_CPUID1] = i; proc[ACPI_PROC_OFFSET_CPUID2] = i; } /* build this code: * Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...} */ /* Arg0 = Processor ID = APIC ID */ build_append_notify_method(sb_scope, ""NTFY"", ""CP%0.02X"", acpi_cpus); /* build ""Name(CPON, Package() { One, One, ..., Zero, Zero, ... })"" */ build_append_byte(sb_scope, 0x08); /* NameOp */ build_append_nameseg(sb_scope, ""CPON""); { GArray *package = build_alloc_array(); uint8_t op = 0x12; /* PackageOp */ build_append_byte(package, acpi_cpus); /* NumElements */ for (i = 0; i < acpi_cpus; i++) { uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00; build_append_byte(package, b); } build_package(package, op, 2); build_append_array(sb_scope, package); build_free_array(package); } { AcpiBuildPciBusHotplugState hotplug_state; Object *pci_host; PCIBus *bus = NULL; bool ambiguous; pci_host = object_resolve_path_type("""", TYPE_PCI_HOST_BRIDGE, &ambiguous); if (!ambiguous && pci_host) { bus = PCI_HOST_BRIDGE(pci_host)->bus; } build_pci_bus_state_init(&hotplug_state, NULL); if (bus) { /* Scan all PCI buses. Generate tables to support hotplug. */ pci_for_each_bus_depth_first(bus, build_pci_bus_begin, build_pci_bus_end, &hotplug_state); } build_append_array(sb_scope, hotplug_state.device_table); build_pci_bus_state_cleanup(&hotplug_state); } build_package(sb_scope, op, 3); build_append_array(table_data, sb_scope); build_free_array(sb_scope); } build_header(linker, table_data, (void *)(table_data->data + ssdt_start), ACPI_SSDT_SIGNATURE, table_data->len - ssdt_start, 1); }",526,"build_ssdt ( garray * table_data , garray * linker , acpicpuinfo * cpu , acpipminfo * pm , acpimiscinfo * misc , pcpciinfo * pci , pcguestinfo * guest_info )  { int acpi2copos = min ( 0xff , guest_info -> apic_id_limit ) ; int ssdt__length = table_data -> len ; uint8_t * ssdt_pointer ; int s ; ssdt_pointer = acpi_data_push ( table_data , sizeof ( ssdp_misc_aml ) ) ; memcpy ( ssdt_pointer , ssdp_misc_aml , sizeof ( ssdp_misc_aml ) ) ; if ( pm -> s3_disabled ) { ssdt_pointer [ acpi_s3_name [ er ] ] = ' ' ; } if ( pm -> s4_disabled ) { ssdt_pointer [ acpi_s4_name [ er ] ] = ' ' ; } else { ssdt_pointer [ acpi_s4__name [ er ] + um ] = ssdt_pointer [ acpi_s4__name [ er ] + 30 ] = pm -> s4_val ; } patch_pci_windows ( pci , ssdt_pointer , sizeof ( ssdp_misc_aml ) ) ; acpi_build_set_le ( ssdt_pointer , sizeof ( ssdp_misc_aml ) , ssdt_isa_pest [ er ] , 16 , misc -> pvpanic_port ) ; { garray * sb_scope = build_alloc_array ( ) ; uint8_t op = 0x10 ; build_append_nameseg ( sb_scope , "" "" ) ; for ( s = er ; s < acpi2copos ; s ++ ) { uint8_t * proc = acpi_data_push ( sb_scope , acpi_proc_sizeof ) ; memcpy ( proc , acpi_proc_aml , acpi_proc_sizeof ) ; proc [ acpi_proc_offset_cpuhex ] = acpi_get_hex ( s >> 4 ) ; proc [ acpi_proc_offset_cpuhex + um ] = acpi_get_hex ( s ) ; proc [ acpi_proc_offset_cpuid1 ] = s ; proc [ acpi_proc_offset_cpuid2 ] = s ; } build_append_notify_method ( sb_scope , "" "" , "" "" , acpi2copos ) ; build_append_byte ( sb_scope , 0x08 ) ; build_append_nameseg ( sb_scope , "" "" ) ; { garray * package = build_alloc_array ( ) ; uint8_t op = 0x12 ; build_append_byte ( package , acpi2copos ) ; for ( s = er ; s < acpi2copos ; s ++ ) { uint8_t b = test_bit ( s , cpu -> found_cpus ) ? 0x01 : 0x00 ; build_append_byte ( package , b ) ; } build_package ( package , op , 2 ) ; build_append_array ( sb_scope , package ) ; build_free_array ( package ) ; } { acpibuildpcibushotplugstate hotplug_state ; object * pci_host ; pcibus * bus = null ; bool ambiguous ; pci_host = object_resolve_path_type ( "" "" , type_pci_host_bridge , & ambiguous ) ; if ( ! ambiguous && pci_host ) { bus = pci_host_bridge ( pci_host ) -> bus ; } build_pci_bus_state_init ( & hotplug_state , null ) ; if ( bus ) { pci_for_each_bus_depth_first ( bus , build_pci_bus_begin , build_pci_bus_end , & hotplug_state ) ; } build_append_array ( sb_scope , hotplug_state . device_table ) ; build_pci_bus_state_cleanup ( & hotplug_state ) ; } build_package ( sb_scope , op , 30 ) ; build_append_array ( table_data , sb_scope ) ; build_free_array ( sb_scope ) ; } build_header ( linker , table_data , ( void * ) ( table_data -> data + ssdt__length ) , acpi_ssdt_signature , table_data -> len - ssdt__length , um ) ; }",0,0,0,-1,"acpi_cpus,ssdt_start,ssdt_ptr,acpi_s4_pkg,0,1,3,sb_scope,op,i,proc,acpi_proc_offset_cpuhex,acpi_proc_offset_cpuid1,acpi_proc_offset_cpuid2,package,b,bus,pci_host","acpi_cpus:0.029741942882537842,ssdt_start:0.027110174298286438,ssdt_ptr:0.13546210527420044,acpi_s4_pkg:-0.024968326091766357,0:-0.12303159385919571,1:-0.022232696413993835,3:-0.0027305930852890015,sb_scope:0.04085955023765564,op:0.014894470572471619,i:0.043450191617012024,proc:-0.09533440321683884,acpi_proc_offset_cpuhex:-0.015431538224220276,acpi_proc_offset_cpuid1:-0.015432760119438171,acpi_proc_offset_cpuid2:-0.015432760119438171,package:-0.061567530035972595,b:-0.09467045217752457,bus:-0.02226400375366211,pci_host:-0.06658783555030823,",8,43,"ssdt_ptr:ssdt_pointer,i:s,acpi_cpus:acpi2copos,ssdt_start:ssdt__length,3:30,1:um,acpi_s4_pkg:acpi_s4__name,0:er,"
"int bdrv_child_check_perm(BdrvChild *c, uint64_t perm, uint64_t shared, Error **errp) { return bdrv_check_update_perm(c->bs, perm, shared, c, errp); }",36,,0,0,,-3,,,,,
"static int mxf_write_header(AVFormatContext *s) { MXFContext *mxf = s->priv_data; int i, ret; uint8_t present[FF_ARRAY_ELEMS(mxf_essence_container_uls)] = {0}; const MXFSamplesPerFrame *spf = NULL; AVDictionaryEntry *t; int64_t timestamp = 0; if (!s->nb_streams) return -1; if (s->oformat == &ff_mxf_opatom_muxer && s->nb_streams !=1){ av_log(s, AV_LOG_ERROR, ""there must be exactly one stream for mxf opatom\n""); return -1; } for (i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; MXFStreamContext *sc = av_mallocz(sizeof(*sc)); if (!sc) return AVERROR(ENOMEM); st->priv_data = sc; if (((i == 0) ^ (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)) && s->oformat != &ff_mxf_opatom_muxer) { av_log(s, AV_LOG_ERROR, ""there must be exactly one video stream and it must be the first one\n""); return -1; } if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(st->codec->pix_fmt); // TODO: should be avg_frame_rate AVRational rate, tbc = st->time_base; // Default component depth to 8 sc->component_depth = 8; sc->h_chroma_sub_sample = 2; sc->color_siting = 0xFF; if (pix_desc) { sc->component_depth = pix_desc->comp[0].depth_minus1 + 1; sc->h_chroma_sub_sample = 1 << pix_desc->log2_chroma_w; } switch (ff_choose_chroma_location(s, st)) { case AVCHROMA_LOC_TOPLEFT: sc->color_siting = 0; break; case AVCHROMA_LOC_LEFT: sc->color_siting = 6; break; case AVCHROMA_LOC_TOP: sc->color_siting = 1; break; case AVCHROMA_LOC_CENTER: sc->color_siting = 3; break; } mxf->timecode_base = (tbc.den + tbc.num/2) / tbc.num; spf = ff_mxf_get_samples_per_frame(s, tbc); if (!spf) { av_log(s, AV_LOG_ERROR, ""Unsupported video frame rate %d/%d\n"", tbc.den, tbc.num); return AVERROR(EINVAL); } mxf->time_base = spf->time_base; rate = av_inv_q(mxf->time_base); avpriv_set_pts_info(st, 64, mxf->time_base.num, mxf->time_base.den); if((ret = mxf_init_timecode(s, st, rate)) < 0) return ret; sc->video_bit_rate = st->codec->bit_rate ? st->codec->bit_rate : st->codec->rc_max_rate; if (s->oformat == &ff_mxf_d10_muxer) { if (sc->video_bit_rate == 50000000) { if (mxf->time_base.den == 25) sc->index = 3; else sc->index = 5; } else if (sc->video_bit_rate == 40000000) { if (mxf->time_base.den == 25) sc->index = 7; else sc->index = 9; } else if (sc->video_bit_rate == 30000000) { if (mxf->time_base.den == 25) sc->index = 11; else sc->index = 13; } else { av_log(s, AV_LOG_ERROR, ""error MXF D-10 only support 30/40/50 mbit/s\n""); return -1; } mxf->edit_unit_byte_count = KAG_SIZE; // system element mxf->edit_unit_byte_count += 16 + 4 + (uint64_t)sc->video_bit_rate * mxf->time_base.num / (8*mxf->time_base.den); mxf->edit_unit_byte_count += klv_fill_size(mxf->edit_unit_byte_count); mxf->edit_unit_byte_count += 16 + 4 + 4 + spf->samples_per_frame[0]*8*4; mxf->edit_unit_byte_count += klv_fill_size(mxf->edit_unit_byte_count); sc->signal_standard = 1; } } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (st->codec->sample_rate != 48000) { av_log(s, AV_LOG_ERROR, ""only 48khz is implemented\n""); return -1; } avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate); if (s->oformat == &ff_mxf_d10_muxer) { if (st->index != 1) { av_log(s, AV_LOG_ERROR, ""MXF D-10 only support one audio track\n""); return -1; } if (st->codec->codec_id != AV_CODEC_ID_PCM_S16LE && st->codec->codec_id != AV_CODEC_ID_PCM_S24LE) { av_log(s, AV_LOG_ERROR, ""MXF D-10 only support 16 or 24 bits le audio\n""); } sc->index = ((MXFStreamContext*)s->streams[0]->priv_data)->index + 1; } else if (s->oformat == &ff_mxf_opatom_muxer) { AVRational tbc = av_inv_q(mxf->audio_edit_rate); if (st->codec->codec_id != AV_CODEC_ID_PCM_S16LE && st->codec->codec_id != AV_CODEC_ID_PCM_S24LE) { av_log(s, AV_LOG_ERROR, ""Only pcm_s16le and pcm_s24le audio codecs are implemented\n""); return AVERROR_PATCHWELCOME; } if (st->codec->channels != 1) { av_log(s, AV_LOG_ERROR, ""MXF OPAtom only supports single channel audio\n""); return AVERROR(EINVAL); } spf = ff_mxf_get_samples_per_frame(s, tbc); if (!spf){ av_log(s, AV_LOG_ERROR, ""Unsupported timecode frame rate %d/%d\n"", tbc.den, tbc.num); return AVERROR(EINVAL); } mxf->time_base = st->time_base; if((ret = mxf_init_timecode(s, st, av_inv_q(spf->time_base))) < 0) return ret; mxf->timecode_base = (tbc.den + tbc.num/2) / tbc.num; mxf->edit_unit_byte_count = (av_get_bits_per_sample(st->codec->codec_id) * st->codec->channels) >> 3; sc->index = 2; } else { mxf->slice_count = 1; } } if (!sc->index) { sc->index = mxf_get_essence_container_ul_index(st->codec->codec_id); if (sc->index == -1) { av_log(s, AV_LOG_ERROR, ""track %d: could not find essence container ul, "" ""codec not currently supported in container\n"", i); return -1; } } sc->codec_ul = &mxf_essence_container_uls[sc->index].codec_ul; memcpy(sc->track_essence_element_key, mxf_essence_container_uls[sc->index].element_ul, 15); sc->track_essence_element_key[15] = present[sc->index]; PRINT_KEY(s, ""track essence element key"", sc->track_essence_element_key); if (!present[sc->index]) mxf->essence_container_count++; present[sc->index]++; } if (s->oformat == &ff_mxf_d10_muxer || s->oformat == &ff_mxf_opatom_muxer) { mxf->essence_container_count = 1; } if (!(s->flags & AVFMT_FLAG_BITEXACT)) mxf_gen_umid(s); for (i = 0; i < s->nb_streams; i++) { MXFStreamContext *sc = s->streams[i]->priv_data; // update element count sc->track_essence_element_key[13] = present[sc->index]; if (!memcmp(sc->track_essence_element_key, mxf_essence_container_uls[15].element_ul, 13)) // DV sc->order = (0x15 << 24) | AV_RB32(sc->track_essence_element_key+13); else sc->order = AV_RB32(sc->track_essence_element_key+12); } if (t = av_dict_get(s->metadata, ""creation_time"", NULL, 0)) timestamp = ff_iso8601_to_unix_time(t->value); if (timestamp) mxf->timestamp = mxf_parse_timestamp(timestamp); mxf->duration = -1; mxf->timecode_track = av_mallocz(sizeof(*mxf->timecode_track)); if (!mxf->timecode_track) return AVERROR(ENOMEM); mxf->timecode_track->priv_data = av_mallocz(sizeof(MXFStreamContext)); if (!mxf->timecode_track->priv_data) return AVERROR(ENOMEM); mxf->timecode_track->index = -1; if (!spf) spf = ff_mxf_get_samples_per_frame(s, (AVRational){ 1, 25 }); if (ff_audio_interleave_init(s, spf->samples_per_frame, mxf->time_base) < 0) return -1; return 0; }",217,,0,1,,-4,"mxf,present,ff_array_elems,mxf_essence_container_uls,spf,timestamp,i,st,sc,priv_data,pix_desc",,,,
"static void ide_flush_cb(void *opaque, int ret) { IDEState *s = opaque; s->pio_aiocb = NULL; if (ret == -ECANCELED) { return; } if (ret < 0) { /* XXX: What sector number to set here? */ if (ide_handle_rw_error(s, -ret, IDE_RETRY_FLUSH)) { return; } } if (s->bs) { block_acct_done(bdrv_get_stats(s->bs), &s->acct); } s->status = READY_STAT | SEEK_STAT; ide_cmd_done(s); ide_set_irq(s->bus); }",103,"static void ide_flush_cb ( void * opaque , int ret ) { idestate * Ġs = opaque ; Ġs -> pio_aiocb = null ; if ( ret == - ecanceled ) { return ; } if ( ret < 0 ) { if ( ide_handle_rw_error ( Ġs , - ret , ide_retry_flush ) ) { return ; } } if ( Ġs -> bs ) { block_acct_done ( bdrv_get_stats ( Ġs -> bs ) , & Ġs -> acct ) ; } Ġs -> Ġstatus = ready_stat | seek_stat ; ide_cmd_done ( Ġs ) ; ide_set_irq ( Ġs -> bus ) ; }",0,0,1,1,"s,pio_aiocb,status","s:-0.012410174123942852,pio_aiocb:0.00036244094371795654,status:-0.00129774771630764,",2,10,"status:Ġstatus,s:Ġs,"
"static int ehci_init_transfer(EHCIPacket *p) { uint32_t cpage, offset, bytes, plen; dma_addr_t page; USBBus *bus = &p->queue->ehci->bus; BusState *qbus = BUS(bus); cpage = get_field(p->qtd.token, QTD_TOKEN_CPAGE); bytes = get_field(p->qtd.token, QTD_TOKEN_TBYTES); offset = p->qtd.bufptr[0] & ~QTD_BUFPTR_MASK; qemu_sglist_init(&p->sgl, qbus->parent, 5, p->queue->ehci->as); while (bytes > 0) { if (cpage > 4) { fprintf(stderr, ""cpage out of range (%d)\n"", cpage); return -1; } page = p->qtd.bufptr[cpage] & QTD_BUFPTR_MASK; page += offset; plen = bytes; if (plen > 4096 - offset) { plen = 4096 - offset; offset = 0; cpage++; } qemu_sglist_add(&p->sgl, page, plen); bytes -= plen; } return 0; }",199,,0,1,,-4,"bus,qbus,cpage,bytes,offset,page,plen",,,,
"int av_opencl_register_kernel_code(const char *kernel_code) { int i, ret = 0; LOCK_OPENCL; if (gpu_env.kernel_code_count >= MAX_KERNEL_CODE_NUM) { av_log(&openclutils, AV_LOG_ERROR, ""Could not register kernel code, maximum number of registered kernel code %d already reached\n"", MAX_KERNEL_CODE_NUM); ret = AVERROR(EINVAL); goto end; } for (i = 0; i < gpu_env.kernel_code_count; i++) { if (gpu_env.kernel_code[i].kernel_string == kernel_code) { av_log(&openclutils, AV_LOG_WARNING, ""Same kernel code has been registered\n""); goto end; } } gpu_env.kernel_code[gpu_env.kernel_code_count].kernel_string = kernel_code; gpu_env.kernel_code[gpu_env.kernel_code_count].is_compiled = 0; gpu_env.kernel_code_count++; end: UNLOCK_OPENCL; return ret; }",138,"int av_opencl_register_kernel_code ( const char * kernel_code ) { int Ġx , ret = 0 ; lock_opencl ; if ( gpu_env . kernel_code_count >= max_kernel_code_num ) { av_log ( & openclutils , av_log_error , "" \n "" , max_kernel_code_num ) ; ret = averror ( einval ) ; goto end ; } for ( Ġx = 0 ; Ġx < gpu_env . kernel_code_count ; Ġx ++ ) { if ( gpu_env . kernel_code [ Ġx ] . kernel_string == kernel_code ) { av_log ( & openclutils , av_log_warning , "" \n "" ) ; goto end ; } } gpu_env . kernel_code [ gpu_env . kernel_code_count ] . kernel_string = kernel_code ; gpu_env . kernel_code [ gpu_env . kernel_code_count ] . is_compiled = 0 ; gpu_env . kernel_code_count ++ ; end : unlock_opencl ; return ret ; }",0,0,1,1,"ret,i,gpu_env,kernel_code,kernel_code_count,kernel_string,is_compiled","ret:0.14746228605508804,i:0.6384730041027069,gpu_env:0.2504492364823818,kernel_code:0.20927927643060684,kernel_code_count:0.10275360569357872,kernel_string:0.02595188096165657,is_compiled:-0.005802188068628311,",1,5,"i:Ġx,"
"static void compute_stats(HTTPContext *c) { HTTPContext *c1; FFStream *stream; char *p; time_t ti; int i, len; ByteIOContext pb1, *pb = &pb1; if (url_open_dyn_buf(pb) < 0) { /* XXX: return an error ? */ c->buffer_ptr = c->buffer; c->buffer_end = c->buffer; return; } url_fprintf(pb, ""HTTP/1.0 200 OK\r\n""); url_fprintf(pb, ""Content-type: %s\r\n"", ""text/html""); url_fprintf(pb, ""Pragma: no-cache\r\n""); url_fprintf(pb, ""\r\n""); url_fprintf(pb, ""<HEAD><TITLE>FFServer Status</TITLE>\n""); if (c->stream->feed_filename) url_fprintf(pb, ""<link rel=\""shortcut icon\"" href=\""%s\"">\n"", c->stream->feed_filename); url_fprintf(pb, ""</HEAD>\n<BODY>""); url_fprintf(pb, ""<H1>FFServer Status</H1>\n""); /* format status */ url_fprintf(pb, ""<H2>Available Streams</H2>\n""); url_fprintf(pb, ""<TABLE cellspacing=0 cellpadding=4>\n""); url_fprintf(pb, ""<TR><Th valign=top>Path<th align=left>Served<br>Conns<Th><br>bytes<Th valign=top>Format<Th>Bit rate<br>kbits/s<Th align=left>Video<br>kbits/s<th><br>Codec<Th align=left>Audio<br>kbits/s<th><br>Codec<Th align=left valign=top>Feed\n""); stream = first_stream; while (stream != NULL) { char sfilename[1024]; char *eosf; if (stream->feed != stream) { av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10); eosf = sfilename + strlen(sfilename); if (eosf - sfilename >= 4) { if (strcmp(eosf - 4, "".asf"") == 0) strcpy(eosf - 4, "".asx""); else if (strcmp(eosf - 3, "".rm"") == 0) strcpy(eosf - 3, "".ram""); else if (!strcmp(stream->fmt->name, ""rtp"")) { /* generate a sample RTSP director if unicast. Generate an SDP redirector if multicast */ eosf = strrchr(sfilename, '.'); if (!eosf) eosf = sfilename + strlen(sfilename); if (stream->is_multicast) strcpy(eosf, "".sdp""); else strcpy(eosf, "".rtsp""); } } url_fprintf(pb, ""<TR><TD><A HREF=\""/%s\"">%s</A> "", sfilename, stream->filename); url_fprintf(pb, ""<td align=right> %d <td align=right> "", stream->conns_served); fmt_bytecount(pb, stream->bytes_served); switch(stream->stream_type) { case STREAM_TYPE_LIVE: { int audio_bit_rate = 0; int video_bit_rate = 0; const char *audio_codec_name = """"; const char *video_codec_name = """"; const char *audio_codec_name_extra = """"; const char *video_codec_name_extra = """"; for(i=0;i<stream->nb_streams;i++) { AVStream *st = stream->streams[i]; AVCodec *codec = avcodec_find_encoder(st->codec->codec_id); switch(st->codec->codec_type) { case CODEC_TYPE_AUDIO: audio_bit_rate += st->codec->bit_rate; if (codec) { if (*audio_codec_name) audio_codec_name_extra = ""...""; audio_codec_name = codec->name; } break; case CODEC_TYPE_VIDEO: video_bit_rate += st->codec->bit_rate; if (codec) { if (*video_codec_name) video_codec_name_extra = ""...""; video_codec_name = codec->name; } break; case CODEC_TYPE_DATA: video_bit_rate += st->codec->bit_rate; break; default: abort(); } } url_fprintf(pb, ""<TD align=center> %s <TD align=right> %d <TD align=right> %d <TD> %s %s <TD align=right> %d <TD> %s %s"", stream->fmt->name, stream->bandwidth, video_bit_rate / 1000, video_codec_name, video_codec_name_extra, audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra); if (stream->feed) url_fprintf(pb, ""<TD>%s"", stream->feed->filename); else url_fprintf(pb, ""<TD>%s"", stream->feed_filename); url_fprintf(pb, ""\n""); } break; default: url_fprintf(pb, ""<TD align=center> - <TD align=right> - <TD align=right> - <td><td align=right> - <TD>\n""); break; } } stream = stream->next; } url_fprintf(pb, ""</TABLE>\n""); stream = first_stream; while (stream != NULL) { if (stream->feed == stream) { url_fprintf(pb, ""<h2>Feed %s</h2>"", stream->filename); if (stream->pid) { url_fprintf(pb, ""Running as pid %d.\n"", stream->pid); #if defined(linux) && !defined(CONFIG_NOCUTILS) { FILE *pid_stat; char ps_cmd[64]; /* This is somewhat linux specific I guess */ snprintf(ps_cmd, sizeof(ps_cmd), ""ps -o \""%%cpu,cputime\"" --no-headers %d"", stream->pid); pid_stat = popen(ps_cmd, ""r""); if (pid_stat) { char cpuperc[10]; char cpuused[64]; if (fscanf(pid_stat, ""%10s %64s"", cpuperc, cpuused) == 2) { url_fprintf(pb, ""Currently using %s%% of the cpu. Total time used %s.\n"", cpuperc, cpuused); } fclose(pid_stat); } } #endif url_fprintf(pb, ""<p>""); } url_fprintf(pb, ""<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\n""); for (i = 0; i < stream->nb_streams; i++) { AVStream *st = stream->streams[i]; AVCodec *codec = avcodec_find_encoder(st->codec->codec_id); const char *type = ""unknown""; char parameters[64]; parameters[0] = 0; switch(st->codec->codec_type) { case CODEC_TYPE_AUDIO: type = ""audio""; snprintf(parameters, sizeof(parameters), ""%d channel(s), %d Hz"", st->codec->channels, st->codec->sample_rate); break; case CODEC_TYPE_VIDEO: type = ""video""; snprintf(parameters, sizeof(parameters), ""%dx%d, q=%d-%d, fps=%d"", st->codec->width, st->codec->height, st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num); break; default: abort(); } url_fprintf(pb, ""<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\n"", i, type, st->codec->bit_rate/1000, codec ? codec->name : """", parameters); } url_fprintf(pb, ""</table>\n""); } stream = stream->next; } #if 0 { float avg; AVCodecContext *enc; char buf[1024]; /* feed status */ stream = first_feed; while (stream != NULL) { url_fprintf(pb, ""<H1>Feed '%s'</H1>\n"", stream->filename); url_fprintf(pb, ""<TABLE>\n""); url_fprintf(pb, ""<TR><TD>Parameters<TD>Frame count<TD>Size<TD>Avg bitrate (kbits/s)\n""); for(i=0;i<stream->nb_streams;i++) { AVStream *st = stream->streams[i]; FeedData *fdata = st->priv_data; enc = st->codec; avcodec_string(buf, sizeof(buf), enc); avg = fdata->avg_frame_size * (float)enc->rate * 8.0; if (enc->codec->type == CODEC_TYPE_AUDIO && enc->frame_size > 0) avg /= enc->frame_size; url_fprintf(pb, ""<TR><TD>%s <TD> %d <TD> %""PRId64"" <TD> %0.1f\n"", buf, enc->frame_number, fdata->data_count, avg / 1000.0); } url_fprintf(pb, ""</TABLE>\n""); stream = stream->next_feed; } } #endif /* connection status */ url_fprintf(pb, ""<H2>Connection Status</H2>\n""); url_fprintf(pb, ""Number of connections: %d / %d<BR>\n"", nb_connections, nb_max_connections); url_fprintf(pb, ""Bandwidth in use: %dk / %dk<BR>\n"", current_bandwidth, max_bandwidth); url_fprintf(pb, ""<TABLE>\n""); url_fprintf(pb, ""<TR><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\n""); c1 = first_http_ctx; i = 0; while (c1 != NULL) { int bitrate; int j; bitrate = 0; if (c1->stream) { for (j = 0; j < c1->stream->nb_streams; j++) { if (!c1->stream->feed) bitrate += c1->stream->streams[j]->codec->bit_rate; else if (c1->feed_streams[j] >= 0) bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate; } } i++; p = inet_ntoa(c1->from_addr.sin_addr); url_fprintf(pb, ""<TR><TD><B>%d</B><TD>%s%s<TD>%s<TD>%s<TD>%s<td align=right>"", i, c1->stream ? c1->stream->filename : """", c1->state == HTTPSTATE_RECEIVE_DATA ? ""(input)"" : """", p, c1->protocol, http_state[c1->state]); fmt_bytecount(pb, bitrate); url_fprintf(pb, ""<td align=right>""); fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8); url_fprintf(pb, ""<td align=right>""); fmt_bytecount(pb, c1->data_count); url_fprintf(pb, ""\n""); c1 = c1->next; } url_fprintf(pb, ""</TABLE>\n""); /* date */ ti = time(NULL); p = ctime(&ti); url_fprintf(pb, ""<HR size=1 noshade>Generated at %s"", p); url_fprintf(pb, ""</BODY>\n</HTML>\n""); len = url_close_dyn_buf(pb, &c->pb_buffer); c->buffer_ptr = c->pb_buffer; c->buffer_end = c->pb_buffer + len; }",870,"static void compute_stats ( httpcontext * c ) { httpcontext * c1 ; ffstream * tty ; char * p ; time_t ti ; int i , len ; byteiocontext pb1 , * pool = & pb1 ; if ( url_open_dyn_buf ( pool ) < 0 ) { c -> buffer_ptr = c -> buffer ; c -> buffer_end = c -> buffer ; return ; } url_fprintf ( pool , "" \r \n "" ) ; url_fprintf ( pool , "" \r \n "" , "" "" ) ; url_fprintf ( pool , "" \r \n "" ) ; url_fprintf ( pool , "" \r \n "" ) ; url_fprintf ( pool , "" \n "" ) ; if ( c -> tty -> feed_filename ) url_fprintf ( pool , "" \"" \"" \"" \"" \n "" , c -> tty -> feed_filename ) ; url_fprintf ( pool , "" \n "" ) ; url_fprintf ( pool , "" \n "" ) ; url_fprintf ( pool , "" \n "" ) ; url_fprintf ( pool , "" \n "" ) ; url_fprintf ( pool , "" \n "" ) ; tty = first_stream ; while ( tty != null ) { char sfilename [ 1024 ] ; char * eofl ; if ( tty -> feed != tty ) { av_strlcpy ( sfilename , tty -> filename , sizeof ( sfilename ) - 10 ) ; eofl = sfilename + strlen ( sfilename ) ; if ( eofl - sfilename >= 4 ) { if ( strcmp ( eofl - 4 , "" "" ) == 0 ) strcpy ( eofl - 4 , "" "" ) ; else if ( strcmp ( eofl - 3 , "" "" ) == 0 ) strcpy ( eofl - 3 , "" "" ) ; else if ( ! strcmp ( tty -> fmt -> name , "" "" ) ) { eofl = strrchr ( sfilename , ' ' ) ; if ( ! eofl ) eofl = sfilename + strlen ( sfilename ) ; if ( tty -> is_multicast ) strcpy ( eofl , "" "" ) ; else strcpy ( eofl , "" "" ) ; } } url_fprintf ( pool , "" \"" \"" "" , sfilename , tty -> filename ) ; url_fprintf ( pool , "" "" , tty -> conns_served ) ; fmt_bytecount ( pool , tty -> bytes_served ) ; switch ( tty -> stream_type ) { case stream_type_live : { int audio_bit_rate = 0 ; int video_bit_rate = 0 ; const char * audio_codec_name = "" "" ; const char * video_codec_name = "" "" ; const char * audio_codec_name_extra = "" "" ; const char * video_codec_name_extra = "" "" ; for ( i = 0 ; i < tty -> nb_streams ; i ++ ) { avstream * st = tty -> streams [ i ] ; avcodec * codec = avcodec_find_encoder ( st -> codec -> codec_id ) ; switch ( st -> codec -> codec_type ) { case codec_type_audio : audio_bit_rate += st -> codec -> bit_rate ; if ( codec ) { if ( * audio_codec_name ) audio_codec_name_extra = "" "" ; audio_codec_name = codec -> name ; } break ; case codec_type_video : video_bit_rate += st -> codec -> bit_rate ; if ( codec ) { if ( * video_codec_name ) video_codec_name_extra = "" "" ; video_codec_name = codec -> name ; } break ; case codec_type_data : video_bit_rate += st -> codec -> bit_rate ; break ; default : abort ( ) ; } } url_fprintf ( pool , "" "" , tty -> fmt -> name , tty -> bandwidth , video_bit_rate / 1000 , video_codec_name , video_codec_name_extra , audio_bit_rate / 1000 , audio_codec_name , audio_codec_name_extra ) ; if ( tty -> feed ) url_fprintf ( pool , "" "" , tty -> feed -> filename ) ; else url_fprintf ( pool , "" "" , tty -> feed_filename ) ; url_fprintf ( pool , "" \n "" ) ; } break ; default : url_fprintf ( pool , "" \n "" ) ; break ; } } tty = tty -> next ; } url_fprintf ( pool , "" \n "" ) ; tty = first_stream ; while ( tty != null ) { if ( tty -> feed == tty ) { url_fprintf ( pool , "" "" , tty -> filename ) ; if ( tty -> pid ) { url_fprintf ( pool , "" \n "" , tty -> pid ) ; #if defined ( linux ) && ! defined ( config_nocutils ) { file * pid_stat ; char ps_cmd [ 64 ] ; snprintf ( ps_cmd , sizeof ( ps_cmd ) , "" \"" \"" "" , tty -> pid ) ; pid_stat = popen ( ps_cmd , "" "" ) ; if ( pid_stat ) { char cpuperc [ 10 ] ; char cpuused [ 64 ] ; if ( fscanf ( pid_stat , "" "" , cpuperc , cpuused ) == 2 ) { url_fprintf ( pool , "" \n "" , cpuperc , cpuused ) ; } fclose ( pid_stat ) ; } } #endif  url_fprintf(pb, ""<p>""); } url_fprintf(pb, ""<table cellspacing=0 cellpadding=4><tr><th>stream<th>type<th>kbits/s<th align=left>codec<th align=left>parameters\n""); for (i = 0; i < stream->nb_streams; i++) { avstream *st = stream->streams[i]; avcodec *codec = avcodec_find_encoder(st->codec->codec_id); const char *type = ""unknown""; char parameters[64]; parameters[0] = 0; switch(st->codec->codec_type) { case codec_type_audio: type = ""audio""; snprintf(parameters, sizeof(parameters), ""%d channel(s), %d hz"", st->codec->channels, st->codec->sample_rate); break; case codec_type_video: type = ""video""; snprintf(parameters, sizeof(parameters), ""%dx%d, q=%d-%d, fps=%d"", st->codec->width, st->codec->height, st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num); break; default: abort(); } url_fprintf(pb, ""<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\n"", i, type, st->codec->bit_rate/1000, codec ? codec->name : """", parameters); } url_fprintf(pb, ""</table>\n""); } tty = stream->next; } #if 0 { float avg; avcodeccontext *enc; char buf[1024];   tty = first_feed; while (stream != null) { url_fprintf(pb, ""<h1>feed '%s'</h1>\n"", stream->filename); url_fprintf(pb, ""<table>\n""); url_fprintf(pb, ""<tr><td>parameters<td>frame count<td>size<td>avg bitrate (kbits/s)\n""); for(i=0;i<stream->nb_streams;i++) { avstream *st = stream->streams[i]; feeddata *fdata = st->priv_data; enc = st->codec; avcodec_string(buf, sizeof(buf), enc); avg = fdata->avg_frame_size * (float)enc->rate * 8.0; if (enc->codec->type == codec_type_audio && enc->frame_size > 0) avg /= enc->frame_size; url_fprintf(pb, ""<tr><td>%s <td> %d <td> %""prid64"" <td> %0.1f\n"", buf, enc->frame_number, fdata->data_count, avg / 1000.0); } url_fprintf(pb, ""</table>\n""); tty = stream->next_feed; } } #endif   url_fprintf(pb, ""<h2>connection status</h2>\n""); url_fprintf(pb, ""number of connections: %d / %d<br>\n"", nb_connections, nb_max_connections); url_fprintf(pb, ""bandwidth in use: %dk / %dk<br>\n"", current_bandwidth, max_bandwidth); url_fprintf(pb, ""<table>\n""); url_fprintf(pb, ""<tr><th>#<th>file<th>ip<th>proto<th>state<th>target bits/sec<th>actual bits/sec<th>bytes transferred\n""); c1 = first_http_ctx; i = 0; while (c1 != null) { int bitrate; int j; bitrate = 0; if (c1->stream) { for (j = 0; j < c1->stream->nb_streams; j++) { if (!c1->stream->feed) bitrate += c1->stream->streams[j]->codec->bit_rate; else if (c1->feed_streams[j] >= 0) bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate; } } i++; p = inet_ntoa(c1->from_addr.sin_addr); url_fprintf(pb, ""<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>"", i, c1->stream ? c1->stream->filename : """", c1->state == httpstate_receive_data ? ""(input)"" : """", p, c1->protocol, http_state[c1->state]); fmt_bytecount(pb, bitrate); url_fprintf(pb, ""<td align=right>""); fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8); url_fprintf(pb, ""<td align=right>""); fmt_bytecount(pb, c1->data_count); url_fprintf(pb, ""\n""); c1 = c1->next; } url_fprintf(pb, ""</table>\n"");   ti = time(null); p = ctime(&ti); url_fprintf(pb, ""<hr size=1 noshade>generated at %s"", p); url_fprintf(pb, ""</body>\n</html>\n""); len = url_close_dyn_buf(pb, &c->pb_buffer); c->buffer_ptr = c->pb_buffer; c->buffer_end = c->pb_buffer + len; }",1,1,0,1,"pb,c,buffer_ptr,buffer_end,stream,eosf,audio_bit_rate,video_bit_rate,i,st,codec,audio_codec_name,video_codec_name,video_codec_name_extra,audio_codec_name_extra,pid_stat","pb:0.12824398279190063,c:-0.08428138494491577,buffer_ptr:0.005247831344604492,buffer_end:0.007944941520690918,stream:0.3462836742401123,eosf:0.144961416721344,audio_bit_rate:0.04386913776397705,video_bit_rate:0.06753450632095337,i:0.03569900989532471,st:0.13288968801498413,codec:0.22231042385101318,audio_codec_name:0.06758671998977661,video_codec_name:0.06758666038513184,video_codec_name_extra:0.02262866497039795,audio_codec_name_extra:0.022628605365753174,pid_stat:0.08181750774383545,",3,71,"stream:tty,eosf:eofl,pb:pool,"
"void gen_intermediate_code(CPUState *cs, TranslationBlock *tb) { CPUM68KState *env = cs->env_ptr; DisasContext dc1, *dc = &dc1; target_ulong pc_start; int pc_offset; int num_insns; int max_insns; /* generate intermediate code */ pc_start = tb->pc; dc->tb = tb; dc->env = env; dc->is_jmp = DISAS_NEXT; dc->pc = pc_start; dc->cc_op = CC_OP_DYNAMIC; dc->cc_op_synced = 1; dc->singlestep_enabled = cs->singlestep_enabled; dc->user = (env->sr & SR_S) == 0; dc->done_mac = 0; dc->writeback_mask = 0; num_insns = 0; max_insns = tb->cflags & CF_COUNT_MASK; if (max_insns == 0) { max_insns = CF_COUNT_MASK; } if (max_insns > TCG_MAX_INSNS) { max_insns = TCG_MAX_INSNS; } gen_tb_start(tb); do { pc_offset = dc->pc - pc_start; gen_throws_exception = NULL; tcg_gen_insn_start(dc->pc, dc->cc_op); num_insns++; if (unlikely(cpu_breakpoint_test(cs, dc->pc, BP_ANY))) { gen_exception(dc, dc->pc, EXCP_DEBUG); dc->is_jmp = DISAS_JUMP; /* The address covered by the breakpoint must be included in [tb->pc, tb->pc + tb->size) in order to for it to be properly cleared -- thus we increment the PC here so that the logic setting tb->size below does the right thing. */ dc->pc += 2; break; } if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) { gen_io_start(); } dc->insn_pc = dc->pc; disas_m68k_insn(env, dc); } while (!dc->is_jmp && !tcg_op_buf_full() && !cs->singlestep_enabled && !singlestep && (pc_offset) < (TARGET_PAGE_SIZE - 32) && num_insns < max_insns); if (tb->cflags & CF_LAST_IO) gen_io_end(); if (unlikely(cs->singlestep_enabled)) { /* Make sure the pc is updated, and raise a debug exception. */ if (!dc->is_jmp) { update_cc_op(dc); tcg_gen_movi_i32(QREG_PC, dc->pc); } gen_helper_raise_exception(cpu_env, tcg_const_i32(EXCP_DEBUG)); } else { switch(dc->is_jmp) { case DISAS_NEXT: update_cc_op(dc); gen_jmp_tb(dc, 0, dc->pc); break; default: case DISAS_JUMP: case DISAS_UPDATE: update_cc_op(dc); /* indicate that the hash table must be used to find the next TB */ tcg_gen_exit_tb(0); break; case DISAS_TB_JUMP: /* nothing more to generate */ break; } } gen_tb_end(tb, num_insns); #ifdef DEBUG_DISAS if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM) && qemu_log_in_addr_range(pc_start)) { qemu_log_lock(); qemu_log(""----------------\n""); qemu_log(""IN: %s\n"", lookup_symbol(pc_start)); log_target_disas(cs, pc_start, dc->pc - pc_start, 0); qemu_log(""\n""); qemu_log_unlock(); } #endif tb->size = dc->pc - pc_start; tb->icount = num_insns; }",503,,1,0,,-4,"env,dc,pc_start,tb,is_jmp,pc,cc_op,cc_op_synced,singlestep_enabled,user,done_mac,writeback_mask,num_insns,max_insns,pc_offset,gen_throws_exception,insn_pc,size,icount",,,,
"BdrvChild *bdrv_open_child(const char *filename, QDict *options, const char *bdref_key, BlockDriverState* parent, const BdrvChildRole *child_role, bool allow_none, Error **errp) { BdrvChild *c = NULL; BlockDriverState *bs; QDict *image_options; int ret; char *bdref_key_dot; const char *reference; assert(child_role != NULL); bdref_key_dot = g_strdup_printf(""%s."", bdref_key); qdict_extract_subqdict(options, &image_options, bdref_key_dot); g_free(bdref_key_dot); reference = qdict_get_try_str(options, bdref_key); if (!filename && !reference && !qdict_size(image_options)) { if (!allow_none) { error_setg(errp, ""A block device must be specified for \""%s\"""", bdref_key); } QDECREF(image_options); goto done; } bs = NULL; ret = bdrv_open_inherit(&bs, filename, reference, image_options, 0, parent, child_role, errp); if (ret < 0) { goto done; } c = bdrv_attach_child(parent, bs, child_role); done: qdict_del(options, bdref_key); return c; }",207,"bdrvchild * bdrv_open_child ( const char * filename , qdict * options , const char * bdref_key , blockdriverstate * parent , const bdrvchildrole * child_role , bool allow_none , error * * errp ) { bdrvchild * c = null ; blockdriverstate * bs ; qdict * image_options ; int ret ; char * bdref_key_dot ; const char * Ġreference ; assert ( child_role != null ) ; bdref_key_dot = g_strdup_printf ( "" "" , bdref_key ) ; qdict_extract_subqdict ( options , & image_options , bdref_key_dot ) ; g_free ( bdref_key_dot ) ; Ġreference = qdict_get_try_str ( options , bdref_key ) ; if ( ! filename && ! Ġreference && ! qdict_size ( image_options ) ) { if ( ! allow_none ) { error_setg ( errp , "" \"" \"" "" , bdref_key ) ; } qdecref ( image_options ) ; goto done ; } bs = null ; ret = bdrv_open_inherit ( & bs , filename , Ġreference , image_options , 0 , parent , child_role , errp ) ; if ( ret < 0 ) { goto done ; } c = bdrv_attach_child ( parent , bs , child_role ) ; done : qdict_del ( options , bdref_key ) ; return c ; }",0,0,1,1,"c,bdref_key_dot,reference,bs,ret","c:0.09800827503204346,bdref_key_dot:-0.0769347995519638,reference:0.17235660552978516,bs:-0.03828491270542145,ret:0.05542007088661194,",1,4,"reference:Ġreference,"
"av_cold void ff_videodsp_init_x86(VideoDSPContext *ctx, int bpc) { #if HAVE_YASM int cpu_flags = av_get_cpu_flags(); #if ARCH_X86_32 if (EXTERNAL_MMX(cpu_flags) && bpc <= 8) { ctx->emulated_edge_mc = emulated_edge_mc_mmx; } if (EXTERNAL_AMD3DNOW(cpu_flags)) { ctx->prefetch = ff_prefetch_3dnow; } #endif /* ARCH_X86_32 */ if (EXTERNAL_MMXEXT(cpu_flags)) { ctx->prefetch = ff_prefetch_mmxext; #if ARCH_X86_32 if (bpc <= 8) ctx->emulated_edge_mc = emulated_edge_mc_mmxext; #endif /* ARCH_X86_32 */ } #if ARCH_X86_32 if (EXTERNAL_SSE(cpu_flags) && bpc <= 8) { ctx->emulated_edge_mc = emulated_edge_mc_sse; } #endif /* ARCH_X86_32 */ if (EXTERNAL_SSE2(cpu_flags) && bpc <= 8) { ctx->emulated_edge_mc = emulated_edge_mc_sse2; } #endif /* HAVE_YASM */ }",59,"av_cold void ff_videodsp_init_x86 ( videodspcontext * tmp , int bpc ) { #if have_yasm int cpu_flags = av_get_cpu_flags ( ) ; #if arch_x86_32 if ( external_mmx ( cpu_flags ) && bpc <= 8 ) { tmp -> emulated_edge_mc = emulated_edge_mc_mmx ; } if ( external_amd3dnow ( cpu_flags ) ) { tmp -> preferenceet = ff_prefetch_3dnow ; } #endif    if (external_mmxext(cpu_flags)) { ctx->prefetch = ff_prefetch_mmxext; #if arch_x86_32 if (bpc <= 8) ctx->emulated_edge_mc = emulated_edge_mc_mmxext; #endif   } #if arch_x86_32 if (external_sse(cpu_flags) && bpc <= 8) { ctx->emulated_edge_mc = emulated_edge_mc_sse; } #endif   if (external_sse2(cpu_flags) && bpc <= 8) { ctx->emulated_edge_mc = emulated_edge_mc_sse2; } #endif   }",0,0,0,-1,"cpu_flags,ctx,emulated_edge_mc,prefetch","cpu_flags:0.022728094831109047,ctx:0.0018237251788377762,emulated_edge_mc:0.007697185501456261,prefetch:0.013791719451546669,",2,4,"prefetch:preferenceet,ctx:tmp,"
"static void vapic_write(void *opaque, hwaddr addr, uint64_t data, unsigned int size) { CPUState *cs = current_cpu; X86CPU *cpu = X86_CPU(cs); CPUX86State *env = &cpu->env; hwaddr rom_paddr; VAPICROMState *s = opaque; cpu_synchronize_state(cs); /* * The VAPIC supports two PIO-based hypercalls, both via port 0x7E. * o 16-bit write access: * Reports the option ROM initialization to the hypervisor. Written * value is the offset of the state structure in the ROM. * o 8-bit write access: * Reactivates the VAPIC after a guest hibernation, i.e. after the * option ROM content has been re-initialized by a guest power cycle. * o 32-bit write access: * Poll for pending IRQs, considering the current VAPIC state. */ switch (size) { case 2: if (s->state == VAPIC_INACTIVE) { rom_paddr = (env->segs[R_CS].base + env->eip) & ROM_BLOCK_MASK; s->rom_state_paddr = rom_paddr + data; s->state = VAPIC_STANDBY; } if (vapic_prepare(s) < 0) { s->state = VAPIC_INACTIVE; s->rom_state_paddr = 0; break; } break; case 1: if (kvm_enabled()) { /* * Disable triggering instruction in ROM by writing a NOP. * * We cannot do this in TCG mode as the reported IP is not * accurate. */ pause_all_vcpus(); patch_byte(cpu, env->eip - 2, 0x66); patch_byte(cpu, env->eip - 1, 0x90); resume_all_vcpus(); } if (s->state == VAPIC_ACTIVE) { break; } if (update_rom_mapping(s, env, env->eip) < 0) { break; } if (find_real_tpr_addr(s, env) < 0) { break; } vapic_enable(s, cpu); break; default: case 4: if (!kvm_irqchip_in_kernel()) { apic_poll_irq(cpu->apic_state); } break; } }",260,,1,0,,-4,"cs,cpu,env,s,rom_paddr,rom_state_paddr,state",,,,
static bool riccb_needed(void *opaque) { #ifdef CONFIG_KVM if (kvm_enabled()) { return kvm_s390_get_ri(); } #endif return 0; },29,,0,0,,-3,,,,,
"static av_always_inline void decode_cabac_luma_residual(const H264Context *h, H264SliceContext *sl, const uint8_t *scan, const uint8_t *scan8x8, int pixel_shift, int mb_type, int cbp, int p) { static const uint8_t ctx_cat[4][3] = {{0,6,10},{1,7,11},{2,8,12},{5,9,13}}; const uint32_t *qmul; int i8x8, i4x4; int qscale = p == 0 ? sl->qscale : sl->chroma_qp[p - 1]; if( IS_INTRA16x16( mb_type ) ) { AV_ZERO128(sl->mb_luma_dc[p]+0); AV_ZERO128(sl->mb_luma_dc[p]+8); AV_ZERO128(sl->mb_luma_dc[p]+16); AV_ZERO128(sl->mb_luma_dc[p]+24); decode_cabac_residual_dc(h, sl, sl->mb_luma_dc[p], ctx_cat[0][p], LUMA_DC_BLOCK_INDEX+p, scan, 16); if( cbp&15 ) { qmul = h->dequant4_coeff[p][qscale]; for( i4x4 = 0; i4x4 < 16; i4x4++ ) { const int index = 16*p + i4x4; decode_cabac_residual_nondc(h, sl, sl->mb + (16*index << pixel_shift), ctx_cat[1][p], index, scan + 1, qmul, 15); } } else { fill_rectangle(&sl->non_zero_count_cache[scan8[16*p]], 4, 4, 8, 0, 1); } } else { int cqm = (IS_INTRA( mb_type ) ? 0:3) + p; for( i8x8 = 0; i8x8 < 4; i8x8++ ) { if( cbp & (1<<i8x8) ) { if( IS_8x8DCT(mb_type) ) { const int index = 16*p + 4*i8x8; decode_cabac_residual_nondc(h, sl, sl->mb + (16*index << pixel_shift), ctx_cat[3][p], index, scan8x8, h->dequant8_coeff[cqm][qscale], 64); } else { qmul = h->dequant4_coeff[cqm][qscale]; for( i4x4 = 0; i4x4 < 4; i4x4++ ) { const int index = 16*p + 4*i8x8 + i4x4; //START_TIMER decode_cabac_residual_nondc(h, sl, sl->mb + (16*index << pixel_shift), ctx_cat[2][p], index, scan, qmul, 16); //STOP_TIMER(""decode_residual"") } } } else { fill_rectangle(&sl->non_zero_count_cache[scan8[4*i8x8+16*p]], 2, 2, 8, 0, 1); } } } }",459,"static av_always_inline void decode_cabac_luma_residual ( const h264context * h , h264slicecontext * sl , const uint8_t * scan , const uint8_t * scan8x8 , int pixel_shift , int mb_type , int cbp , int p ) { static const uint8_t tx_Cat [ Ġ4 ] [ 12 ] = { { 0 , 6 , 10 } , { 1 , 7 , 11 } , { 2 , 8 , 12 } , { 5 , 9 , 13 } } ; const uint32_t * qMesh ; int i8x4 , i4t4 ; int bitcale = p == 0 ? sl -> bitcale : sl -> chroma_qp [ p - 1 ] ; if ( is_intra16x16 ( mb_type ) ) { av_zero128 ( sl -> mb_luma_dc [ p ] + 0 ) ; av_zero128 ( sl -> mb_luma_dc [ p ] + 8 ) ; av_zero128 ( sl -> mb_luma_dc [ p ] + 16 ) ; av_zero128 ( sl -> mb_luma_dc [ p ] + 24 ) ; decode_cabac_residual_dc ( h , sl , sl -> mb_luma_dc [ p ] , tx_Cat [ 0 ] [ p ] , luma_dc_block_index + p , scan , 16 ) ; if ( cbp & 15 ) { qMesh = h -> dequant4_coeff [ p ] [ bitcale ] ; for ( i4t4 = 0 ; i4t4 < 16 ; i4t4 ++ ) { const int index = 16 * p + i4t4 ; decode_cabac_residual_nondc ( h , sl , sl -> mb + ( 16 * index << pixel_shift ) , tx_Cat [ 1 ] [ p ] , index , scan + 1 , qMesh , 15 ) ; } } else { fill_rectangle ( & sl -> non_zero_count_cache [ scan8 [ 16 * p ] ] , Ġ4 , Ġ4 , 8 , 0 , 1 ) ; } } else { int cqm = ( is_intra ( mb_type ) ? 0 : 12 ) + p ; for ( i8x4 = 0 ; i8x4 < Ġ4 ; i8x4 ++ ) { if ( cbp & ( 1 << i8x4 ) ) { if ( is_8x8dct ( mb_type ) ) { const int index = 16 * p + Ġ4 * i8x4 ; decode_cabac_residual_nondc ( h , sl , sl -> mb + ( 16 * index << pixel_shift ) , tx_Cat [ 12 ] [ p ] , index , scan8x8 , h -> dequant8_coeff [ cqm ] [ bitcale ] , 64 ) ; } else { qMesh = h -> dequant4_coeff [ cqm ] [ bitcale ] ; for ( i4t4 = 0 ; i4t4 < Ġ4 ; i4t4 ++ ) { const int index = 16 * p + Ġ4 * i8x4 + i4t4 ;",0,0,0,-1,"ctx_cat,4,3,qscale,qmul,i4x4,index,cqm,i8x8","ctx_cat:0.03682572394609451,4:0.011029385030269623,3:-0.0024087168276309967,qscale:0.013484461233019829,qmul:0.036119572818279266,i4x4:0.1350305862724781,index:0.034900862723588943,cqm:-0.008598078042268753,i8x8:0.0357929989695549,",7,39,"i4x4:i4t4,ctx_cat:tx_Cat,qmul:qMesh,i8x8:i8x4,qscale:bitcale,4:Ġ4,3:12,"
"static int virtio_ccw_load_config(DeviceState *d, QEMUFile *f) { VirtioCcwDevice *dev = VIRTIO_CCW_DEVICE(d); CcwDevice *ccw_dev = CCW_DEVICE(d); CCWDeviceClass *ck = CCW_DEVICE_GET_CLASS(ccw_dev); SubchDev *s = ccw_dev->sch; VirtIODevice *vdev = virtio_ccw_get_vdev(s); int len; s->driver_data = dev; subch_device_load(s, f); /* Re-fill subch_id after loading the subchannel states.*/ if (ck->refill_ids) { ck->refill_ids(ccw_dev); } len = qemu_get_be32(f); if (len != 0) { dev->indicators = get_indicator(qemu_get_be64(f), len); } else { qemu_get_be64(f); dev->indicators = NULL; } len = qemu_get_be32(f); if (len != 0) { dev->indicators2 = get_indicator(qemu_get_be64(f), len); } else { qemu_get_be64(f); dev->indicators2 = NULL; } len = qemu_get_be32(f); if (len != 0) { dev->summary_indicator = get_indicator(qemu_get_be64(f), len); } else { qemu_get_be64(f); dev->summary_indicator = NULL; } qemu_get_be16s(f, &vdev->config_vector); dev->routes.adapter.ind_offset = qemu_get_be64(f); dev->thinint_isc = qemu_get_byte(f); dev->revision = qemu_get_be32(f); if (s->thinint_active) { return css_register_io_adapter(CSS_IO_ADAPTER_VIRTIO, dev->thinint_isc, true, false, &dev->routes.adapter.adapter_id); } return 0; }",293,"static int virtio_ccw_load_config ( devicestate * d , qemufile * f ) { virtioccwdevice * dev = virtio_ccw_device ( d ) ; ccwdevice * ccw_dev = ccw_device ( d ) ; ccwdeviceclass * ck = ccw_device_get_class ( ccw_dev ) ; subchdev * sv = ccw_dev -> sch ; virtiodevice * vdev = virtio_ccw_get_vdev ( sv ) ; int len ; sv -> driver_data = dev ; subch_device_load ( sv , f ) ; if ( ck -> refill_ids ) { ck -> refill_ids ( ccw_dev ) ; } len = qemu_get_be32 ( f ) ; if ( len != 0 ) { dev -> indicators = get_indicator ( qemu_get_be64 ( f ) , len ) ; } else { qemu_get_be64 ( f ) ; dev -> indicators = null ; } len = qemu_get_be32 ( f ) ; if ( len != 0 ) { dev -> indicators2 = get_indicator ( qemu_get_be64 ( f ) , len ) ; } else { qemu_get_be64 ( f ) ; dev -> indicators2 = null ; } len = qemu_get_be32 ( f ) ; if ( len != 0 ) { dev -> summary_indicator = get_indicator ( qemu_get_be64 ( f ) , len ) ; } else { qemu_get_be64 ( f ) ; dev -> summary_indicator = null ; } qemu_get_be16s ( f , & vdev -> config_vector ) ; dev -> routes . adapter . ind_offset = qemu_get_be64 ( f ) ; dev -> thinint_isc = qemu_get_byte ( f ) ; dev -> revision = qemu_get_be32 ( f ) ; if ( sv -> thinint_active ) { return css_register_io_adapter ( css_io_adapter_virtio , dev -> thinint_isc , true , false , & dev -> routes . adapter . adapter_id ) ; } return 0 ; }",0,0,1,1,"dev,ccw_dev,ck,s,vdev,driver_data,len,indicators,indicators2,summary_indicator,routes,adapter,ind_offset,thinint_isc,revision","dev:0.10279935598373413,ccw_dev:0.11609584093093872,ck:0.11964493989944458,s:0.1479286551475525,vdev:0.059553325176239014,driver_data:0.002141118049621582,len:0.09111708402633667,indicators:0.052274465560913086,indicators2:-0.04491221904754639,summary_indicator:0.028773069381713867,routes:0.022568464279174805,adapter:0.022568464279174805,ind_offset:0.060351788997650146,thinint_isc:0.026573002338409424,revision:0.007123708724975586,",1,5,"s:sv,"
"PCIBus *pci_pmac_u3_init(qemu_irq *pic, MemoryRegion *address_space_mem, MemoryRegion *address_space_io) { DeviceState *dev; SysBusDevice *s; PCIHostState *h; UNINState *d; /* Uninorth AGP bus */ dev = qdev_create(NULL, TYPE_U3_AGP_HOST_BRIDGE); qdev_init_nofail(dev); s = SYS_BUS_DEVICE(dev); h = PCI_HOST_BRIDGE(dev); d = U3_AGP_HOST_BRIDGE(dev); memory_region_init(&d->pci_mmio, OBJECT(d), ""pci-mmio"", 0x100000000ULL); memory_region_init_alias(&d->pci_hole, OBJECT(d), ""pci-hole"", &d->pci_mmio, 0x80000000ULL, 0x70000000ULL); memory_region_add_subregion(address_space_mem, 0x80000000ULL, &d->pci_hole); h->bus = pci_register_bus(dev, ""pci"", pci_unin_set_irq, pci_unin_map_irq, pic, &d->pci_mmio, address_space_io, PCI_DEVFN(11, 0), 4, TYPE_PCI_BUS); sysbus_mmio_map(s, 0, 0xf0800000); sysbus_mmio_map(s, 1, 0xf0c00000); pci_create_simple(h->bus, 11 << 3, ""u3-agp""); return h->bus; }",197,"pcibus * pci_pmac_u3_init ( qemu_irq * pic , memoryregion * address_space_mem , memoryregion * address_space_io ) { devicestate * dev ; sysbusdevice * Ġs ; pcihoststate * h ; uninstate * db ; dev = qdev_create ( null , type_u3_agp_host_bridge ) ; qdev_init_nofail ( dev ) ; Ġs = sys_bus_device ( dev ) ; h = pci_host_bridge ( dev ) ; db = u3_agp_host_bridge ( dev ) ; memory_region_init ( & db -> pci_mmio , object ( db ) , "" "" , 0x100000000ull ) ; memory_region_init_alias ( & db -> pci_hole , object ( db ) , "" "" , & db -> pci_mmio , 0x80000000ull , 0x70000000ull ) ; memory_region_add_subregion ( address_space_mem , 0x80000000ull , & db -> pci_hole ) ; h -> bus = pci_register_bus ( dev , "" "" , pci_unin_set_irq , pci_unin_map_irq , pic , & db -> pci_mmio , address_space_io , pci_devfn ( 11 , 0 ) , 4 , type_pci_bus ) ; sysbus_mmio_map ( Ġs , 0 , 0xf0800000 ) ; sysbus_mmio_map ( Ġs , 1 , 0xf0c00000 ) ; pci_create_simple ( h -> bus , 11 << 3 , "" "" ) ; return h -> bus ; }",0,0,1,1,"dev,s,h,d,bus","dev:0.2387825846672058,s:0.20539110898971558,h:0.06446540355682373,d:0.2510072886943817,bus:-0.048240333795547485,",2,13,"d:db,s:Ġs,"
"static void filter_samples(AVFilterLink *inlink, AVFilterBufferRef *samplesref) { AVFilterContext *ctx = inlink->dst; int i; for (i = 0; i < ctx->nb_outputs; i++) ff_filter_samples(inlink->dst->outputs[i], avfilter_ref_buffer(samplesref, ~AV_PERM_WRITE)); }",60,,1,0,,-4,"ctx,i",,,,
"void coroutine_fn qemu_co_mutex_lock(CoMutex *mutex) { Coroutine *self = qemu_coroutine_self(); trace_qemu_co_mutex_lock_entry(mutex, self); while (mutex->locked) { qemu_co_queue_wait(&mutex->queue); } mutex->locked = true; trace_qemu_co_mutex_lock_return(mutex, self); }",54,,1,0,,-4,"self,mutex",,,,
"void hmp_info_block(Monitor *mon, const QDict *qdict) { BlockInfoList *block_list, *info; ImageInfo *image_info; const char *device = qdict_get_try_str(qdict, ""device""); bool verbose = qdict_get_try_bool(qdict, ""verbose"", 0); block_list = qmp_query_block(NULL); for (info = block_list; info; info = info->next) { if (device && strcmp(device, info->value->device)) { continue; } if (info != block_list) { monitor_printf(mon, ""\n""); } monitor_printf(mon, ""%s"", info->value->device); if (info->value->has_inserted) { monitor_printf(mon, "": %s (%s%s%s)\n"", info->value->inserted->file, info->value->inserted->drv, info->value->inserted->ro ? "", read-only"" : """", info->value->inserted->encrypted ? "", encrypted"" : """"); } else { monitor_printf(mon, "": [not inserted]\n""); } if (info->value->has_io_status && info->value->io_status != BLOCK_DEVICE_IO_STATUS_OK) { monitor_printf(mon, "" I/O status: %s\n"", BlockDeviceIoStatus_lookup[info->value->io_status]); } if (info->value->removable) { monitor_printf(mon, "" Removable device: %slocked, tray %s\n"", info->value->locked ? """" : ""not "", info->value->tray_open ? ""open"" : ""closed""); } if (!info->value->has_inserted) { continue; } if (info->value->inserted->has_backing_file) { monitor_printf(mon, "" Backing file: %s "" ""(chain depth: %"" PRId64 "")\n"", info->value->inserted->backing_file, info->value->inserted->backing_file_depth); } if (info->value->inserted->bps || info->value->inserted->bps_rd || info->value->inserted->bps_wr || info->value->inserted->iops || info->value->inserted->iops_rd || info->value->inserted->iops_wr) { monitor_printf(mon, "" I/O throttling: bps=%"" PRId64 "" bps_rd=%"" PRId64 "" bps_wr=%"" PRId64 "" iops=%"" PRId64 "" iops_rd=%"" PRId64 "" iops_wr=%"" PRId64 ""\n"", info->value->inserted->bps, info->value->inserted->bps_rd, info->value->inserted->bps_wr, info->value->inserted->iops, info->value->inserted->iops_rd, info->value->inserted->iops_wr); } if (verbose) { monitor_printf(mon, ""\nImages:\n""); image_info = info->value->inserted->image; while (1) { bdrv_image_info_dump((fprintf_function)monitor_printf, mon, image_info); if (image_info->has_backing_image) { image_info = image_info->backing_image; } else { break; } } } } qapi_free_BlockInfoList(block_list); }",528,,1,0,,-4,"device,verbose,block_list,info,image_info",,,,
"static inline int decode_residual_inter(AVSContext *h) { int block; /* get coded block pattern */ int cbp= get_ue_golomb(&h->s.gb); if(cbp > 63){ av_log(h->s.avctx, AV_LOG_ERROR, ""illegal inter cbp\n""); return -1; } h->cbp = cbp_tab[cbp][1]; /* get quantizer */ if(h->cbp && !h->qp_fixed) h->qp = (h->qp + get_se_golomb(&h->s.gb)) & 63; for(block=0;block<4;block++) if(h->cbp & (1<<block)) decode_residual_block(h,&h->s.gb,ff_cavs_inter_dec,0,h->qp, h->cy + h->luma_scan[block], h->l_stride); decode_residual_chroma(h); return 0; }",166,,1,0,,-4,"cbp,h,qp,block",,,,
"static void fw_cfg_write(FWCfgState *s, uint8_t value) { int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL); FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK]; FW_CFG_DPRINTF(""write %d\n"", value); if (s->cur_entry & FW_CFG_WRITE_CHANNEL && s->cur_offset < e->len) { e->data[s->cur_offset++] = value; if (s->cur_offset == e->len) { e->callback(e->callback_opaque, e->data); s->cur_offset = 0; } } }",115,"static void fw_cfg_write ( fwcfgstate * s , uint8_t value ) { int arch = ! ! ( s -> cur_entry & fw_cfg_arch_local ) ; fwcfgentry * xe = & s -> entries [ arch ] [ s -> cur_entry & fw_cfg_entry_mask ] ; fw_cfg_dprintf ( "" \n "" , value ) ; if ( s -> cur_entry & fw_cfg_write_channel && s -> cur_offset < xe -> len ) { xe -> data [ s -> cur_offset ++ ] = value ; if ( s -> cur_offset == xe -> len ) { xe -> callback ( xe -> callback_opaque , xe -> data ) ; s -> cur_offset = 0 ; } } }",1,1,0,1,"arch,e,data,s,cur_offset","arch:0.17525532841682434,e:1.0744414329528809,data:0.09723442792892456,s:0.827032282948494,cur_offset:0.30730588734149933,",1,7,"e:xe,"
"int qemu_peek_buffer(QEMUFile *f, uint8_t *buf, int size, size_t offset) { int pending; int index; assert(!qemu_file_is_writable(f)); index = f->buf_index + offset; pending = f->buf_size - index; if (pending < size) { qemu_fill_buffer(f); index = f->buf_index + offset; pending = f->buf_size - index; } if (pending <= 0) { return 0; } if (size > pending) { size = pending; } memcpy(buf, f->buf + index, size); return size; }",118,"int qemu_peek_buffer ( qemufile * f , uint8_t * buf , int size , size_t offset ) { int pending ; int address ; assert ( ! qemu_file_is_writable ( f ) ) ; address = f -> buf_index + offset ; pending = f -> buf_size - address ; if ( pending < size ) { qemu_fill_buffer ( f ) ; address = f -> buf_index + offset ; pending = f -> buf_size - address ; } if ( pending <= 0 ) { return 0 ; } if ( size > pending ) { size = pending ; } memcpy ( buf , f -> buf + address , size ) ; return size ; }",1,1,0,1,"index,pending,size","index:-0.35939764976501465,pending:-0.5484068393707275,size:-0.5621235370635986,",1,6,"index:address,"
"static int ahci_dma_rw_buf(IDEDMA *dma, int is_write) { AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma); IDEState *s = &ad->port.ifs[0]; uint8_t *p = s->io_buffer + s->io_buffer_index; int l = s->io_buffer_size - s->io_buffer_index; if (ahci_populate_sglist(ad, &s->sg)) { return 0; } if (is_write) { dma_buf_read(p, l, &s->sg); } else { dma_buf_write(p, l, &s->sg); } /* update number of transferred bytes */ ad->cur_cmd->status = cpu_to_le32(le32_to_cpu(ad->cur_cmd->status) + l); s->io_buffer_index += l; DPRINTF(ad->port_no, ""len=%#x\n"", l); return 1; }",155,"static int ahci_dma_rw_buf ( idedma * dma , int is_write ) { ahcidevice * ad = do_upcast ( ahcidevice , dma , dma ) ; idestate * a = & ad -> port . ifs [ 0 ] ; uint8_t * p = a -> io_buffer + a -> io_buffer_index ; int l = a -> io_buffer_size - a -> io_buffer_index ; if ( ahci_populate_sglist ( ad , & a -> sg ) ) { return 0 ; } if ( is_write ) { dma_buf_read ( p , l , & a -> sg ) ; } else { dma_buf_write ( p , l , & a -> sg ) ; } ad -> cur_md -> status = cpu_to_le32 ( le32_to_cpu ( ad -> cur_md -> status ) + l ) ; a -> io_buffer_index += l ; dprintf ( ad -> port_no , "" \n "" , l ) ; return 1 ; }",1,1,0,1,"ad,s,p,l,cur_cmd,status,io_buffer_index","ad:-0.06608426570892334,s:-0.015164673328399658,p:-0.15957868099212646,l:-0.07342243194580078,cur_cmd:-0.00033402442932128906,status:-0.04071784019470215,io_buffer_index:-0.048173487186431885,",2,11,"cur_cmd:cur_md,s:a,"
"void cpu_save(QEMUFile *f, void *opaque) { CPUState *env = (CPUState *)opaque; unsigned int i, j; cpu_synchronize_state(env); for (i = 0; i < 32; i++) qemu_put_betls(f, &env->gpr[i]); #if !defined(TARGET_PPC64) for (i = 0; i < 32; i++) qemu_put_betls(f, &env->gprh[i]); #endif qemu_put_betls(f, &env->lr); qemu_put_betls(f, &env->ctr); for (i = 0; i < 8; i++) qemu_put_be32s(f, &env->crf[i]); qemu_put_betls(f, &env->xer); qemu_put_betls(f, &env->reserve_addr); qemu_put_betls(f, &env->msr); for (i = 0; i < 4; i++) qemu_put_betls(f, &env->tgpr[i]); for (i = 0; i < 32; i++) { union { float64 d; uint64_t l; } u; u.d = env->fpr[i]; qemu_put_be64(f, u.l); } qemu_put_be32s(f, &env->fpscr); qemu_put_sbe32s(f, &env->access_type); #if !defined(CONFIG_USER_ONLY) #if defined(TARGET_PPC64) qemu_put_betls(f, &env->asr); qemu_put_sbe32s(f, &env->slb_nr); #endif qemu_put_betls(f, &env->sdr1); for (i = 0; i < 32; i++) qemu_put_betls(f, &env->sr[i]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemu_put_betls(f, &env->DBAT[i][j]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemu_put_betls(f, &env->IBAT[i][j]); qemu_put_sbe32s(f, &env->nb_tlb); qemu_put_sbe32s(f, &env->tlb_per_way); qemu_put_sbe32s(f, &env->nb_ways); qemu_put_sbe32s(f, &env->last_way); qemu_put_sbe32s(f, &env->id_tlbs); qemu_put_sbe32s(f, &env->nb_pids); if (env->tlb) { // XXX assumes 6xx for (i = 0; i < env->nb_tlb; i++) { qemu_put_betls(f, &env->tlb[i].tlb6.pte0); qemu_put_betls(f, &env->tlb[i].tlb6.pte1); qemu_put_betls(f, &env->tlb[i].tlb6.EPN); } } for (i = 0; i < 4; i++) qemu_put_betls(f, &env->pb[i]); #endif for (i = 0; i < 1024; i++) qemu_put_betls(f, &env->spr[i]); qemu_put_be32s(f, &env->vscr); qemu_put_be64s(f, &env->spe_acc); qemu_put_be32s(f, &env->spe_fscr); qemu_put_betls(f, &env->msr_mask); qemu_put_be32s(f, &env->flags); qemu_put_sbe32s(f, &env->error_code); qemu_put_be32s(f, &env->pending_interrupts); #if !defined(CONFIG_USER_ONLY) qemu_put_be32s(f, &env->irq_input_state); for (i = 0; i < POWERPC_EXCP_NB; i++) qemu_put_betls(f, &env->excp_vectors[i]); qemu_put_betls(f, &env->excp_prefix); qemu_put_betls(f, &env->hreset_excp_prefix); qemu_put_betls(f, &env->ivor_mask); qemu_put_betls(f, &env->ivpr_mask); qemu_put_betls(f, &env->hreset_vector); #endif qemu_put_betls(f, &env->nip); qemu_put_betls(f, &env->hflags); qemu_put_betls(f, &env->hflags_nmsr); qemu_put_sbe32s(f, &env->mmu_idx); qemu_put_sbe32s(f, &env->power_mode); }",93,,1,0,,-4,"env,i",,,,
"static DeviceState *sun4c_intctl_init(target_phys_addr_t addr, qemu_irq *parent_irq) { DeviceState *dev; SysBusDevice *s; unsigned int i; dev = qdev_create(NULL, ""sun4c_intctl""); qdev_init(dev); s = sysbus_from_qdev(dev); for (i = 0; i < MAX_PILS; i++) { sysbus_connect_irq(s, i, parent_irq[i]); } sysbus_mmio_map(s, 0, addr); return dev; }",87,"static devicestate * sun4c_intctl_init ( target_phys_addr_t addr , qemu_irq * parent_irq ) { devicestate * s ; sysbusdevice * s ; unsigned int i ; s = qdev_create ( null , "" "" ) ; qdev_init ( s ) ; s = sysbus_from_qdev ( s ) ; for ( i = 0 ; i < max_pils ; i ++ ) { sysbus_connect_irq ( s , i , parent_irq [ i ] ) ; } sysbus_mmio_map ( s , 0 , addr ) ; return s ; }",1,1,0,1,"dev,s,i","dev:-0.010430574417114258,s:-0.12787526845932007,i:-0.019494593143463135,",1,5,"dev:s,"
"static int gif_image_write_header(AVFormatContext *s, int width, int height, int loop_count, uint32_t *palette) { AVIOContext *pb = s->pb; AVRational sar = s->streams[0]->codec->sample_aspect_ratio; int i, aspect = 0; if (sar.num > 0 && sar.den > 0) { aspect = sar.num * 64 / sar.den - 15; if (aspect < 0 || aspect > 255) aspect = 0; } avio_write(pb, ""GIF"", 3); avio_write(pb, ""89a"", 3); avio_wl16(pb, width); avio_wl16(pb, height); if (palette) { avio_w8(pb, 0xf7); /* flags: global clut, 256 entries */ avio_w8(pb, 0x1f); /* background color index */ avio_w8(pb, aspect); for (i = 0; i < 256; i++) { const uint32_t v = palette[i] & 0xffffff; avio_wb24(pb, v); } } else { avio_w8(pb, 0); /* flags */ avio_w8(pb, 0); /* background color index */ avio_w8(pb, aspect); } if (loop_count >= 0 ) { /* ""NETSCAPE EXTENSION"" for looped animation GIF */ avio_w8(pb, 0x21); /* GIF Extension code */ avio_w8(pb, 0xff); /* Application Extension Label */ avio_w8(pb, 0x0b); /* Length of Application Block */ avio_write(pb, ""NETSCAPE2.0"", sizeof(""NETSCAPE2.0"") - 1); avio_w8(pb, 0x03); /* Length of Data Sub-Block */ avio_w8(pb, 0x01); avio_wl16(pb, (uint16_t)loop_count); avio_w8(pb, 0x00); /* Data Sub-block Terminator */ } return 0; }",293,,1,0,,-4,"pb,sar,aspect,i,v",,,,
"static int ipvideo_decode_block_opcode_0xA(IpvideoContext *s) { int x, y; unsigned char P[4]; int flags = 0; /* 4-color encoding for each 4x4 quadrant, or 4-color encoding on * either top and bottom or left and right halves */ CHECK_STREAM_PTR(24); if (s->stream_ptr[0] <= s->stream_ptr[1]) { /* 4-color encoding for each quadrant; need 32 bytes */ CHECK_STREAM_PTR(32); for (y = 0; y < 16; y++) { // new values for each 4x4 block if (!(y & 3)) { memcpy(P, s->stream_ptr, 4); s->stream_ptr += 4; flags = bytestream_get_le32(&s->stream_ptr); } for (x = 0; x < 4; x++, flags >>= 2) *s->pixel_ptr++ = P[flags & 0x03]; s->pixel_ptr += s->stride - 4; // switch to right half if (y == 7) s->pixel_ptr -= 8 * s->stride - 4; } } else { // vertical split? int vert = s->stream_ptr[12] <= s->stream_ptr[13]; uint64_t flags = 0; /* 4-color encoding for either left and right or top and bottom * halves */ for (y = 0; y < 16; y++) { // load values for each half if (!(y & 7)) { memcpy(P, s->stream_ptr, 4); s->stream_ptr += 4; flags = bytestream_get_le64(&s->stream_ptr); } for (x = 0; x < 4; x++, flags >>= 2) *s->pixel_ptr++ = P[flags & 0x03]; if (vert) { s->pixel_ptr += s->stride - 4; // switch to right half if (y == 7) s->pixel_ptr -= 8 * s->stride - 4; } else if (y & 1) s->pixel_ptr += s->line_inc; } } /* report success */ return 0; }",67,"static int ipvideo_decode_block_opcode_0xa ( ipvideocontext * s ) { int x , Ġy ; unsigned char p [ 4 ] ; int flags = 0 ; check_stream_ptr ( 24 ) ; if ( s -> stream_ptr [ 0 ] <= s -> stream_ptr [ 1 ] ) { check_stream_ptr ( 32 ) ; for ( Ġy = 0 ; Ġy < 16 ; Ġy ++ ) {",0,0,1,1,"flags,y","flags:0.07671341300010681,y:0.6758344024419785,",1,4,"y:Ġy,"
"static inline void dv_decode_video_segment(DVVideoContext *s, const uint8_t *buf_ptr1, const uint16_t *mb_pos_ptr) { int quant, dc, dct_mode, class1, j; int mb_index, mb_x, mb_y, v, last_index; int y_stride, i; DCTELEM *block, *block1; int c_offset; uint8_t *y_ptr; const uint8_t *buf_ptr; PutBitContext pb, vs_pb; GetBitContext gb; BlockInfo mb_data[5 * DV_MAX_BPM], *mb, *mb1; DECLARE_ALIGNED_16(DCTELEM, sblock[5*DV_MAX_BPM][64]); DECLARE_ALIGNED_8(uint8_t, mb_bit_buffer[80 + 4]); /* allow some slack */ DECLARE_ALIGNED_8(uint8_t, vs_bit_buffer[5 * 80 + 4]); /* allow some slack */ const int log2_blocksize= 3-s->avctx->lowres; int is_field_mode[5]; assert((((int)mb_bit_buffer)&7)==0); assert((((int)vs_bit_buffer)&7)==0); memset(sblock, 0, sizeof(sblock)); /* pass 1 : read DC and AC coefficients in blocks */ buf_ptr = buf_ptr1; block1 = &sblock[0][0]; mb1 = mb_data; init_put_bits(&vs_pb, vs_bit_buffer, 5 * 80); for(mb_index = 0; mb_index < 5; mb_index++, mb1 += s->sys->bpm, block1 += s->sys->bpm * 64) { /* skip header */ quant = buf_ptr[3] & 0x0f; buf_ptr += 4; init_put_bits(&pb, mb_bit_buffer, 80); mb = mb1; block = block1; is_field_mode[mb_index] = 0; for(j = 0;j < s->sys->bpm; j++) { last_index = s->sys->block_sizes[j]; init_get_bits(&gb, buf_ptr, last_index); /* get the dc */ dc = get_sbits(&gb, 9); dct_mode = get_bits1(&gb); class1 = get_bits(&gb, 2); if (DV_PROFILE_IS_HD(s->sys)) { mb->idct_put = s->idct_put[0]; mb->scan_table = s->dv_zigzag[0]; mb->factor_table = s->dv100_idct_factor[((s->sys->height == 720)<<1)|(j >= 4)][class1][quant]; is_field_mode[mb_index] |= !j && dct_mode; } else { mb->idct_put = s->idct_put[dct_mode && log2_blocksize==3]; mb->scan_table = s->dv_zigzag[dct_mode]; mb->factor_table = s->dv_idct_factor[class1 == 3][dct_mode] [quant + dv_quant_offset[class1]]; } dc = dc << 2; /* convert to unsigned because 128 is not added in the standard IDCT */ dc += 1024; block[0] = dc; buf_ptr += last_index >> 3; mb->pos = 0; mb->partial_bit_count = 0; #ifdef VLC_DEBUG printf(""MB block: %d, %d "", mb_index, j); #endif dv_decode_ac(&gb, mb, block); /* write the remaining bits in a new buffer only if the block is finished */ if (mb->pos >= 64) bit_copy(&pb, &gb); block += 64; mb++; } /* pass 2 : we can do it just after */ #ifdef VLC_DEBUG printf(""***pass 2 size=%d MB#=%d\n"", put_bits_count(&pb), mb_index); #endif block = block1; mb = mb1; init_get_bits(&gb, mb_bit_buffer, put_bits_count(&pb)); flush_put_bits(&pb); for(j = 0;j < s->sys->bpm; j++, block += 64, mb++) { if (mb->pos < 64 && get_bits_left(&gb) > 0) { dv_decode_ac(&gb, mb, block); /* if still not finished, no need to parse other blocks */ if (mb->pos < 64) break; } } /* all blocks are finished, so the extra bytes can be used at the video segment level */ if (j >= s->sys->bpm) bit_copy(&vs_pb, &gb); } /* we need a pass other the whole video segment */ #ifdef VLC_DEBUG printf(""***pass 3 size=%d\n"", put_bits_count(&vs_pb)); #endif block = &sblock[0][0]; mb = mb_data; init_get_bits(&gb, vs_bit_buffer, put_bits_count(&vs_pb)); flush_put_bits(&vs_pb); for(mb_index = 0; mb_index < 5; mb_index++) { for(j = 0;j < s->sys->bpm; j++) { if (mb->pos < 64) { #ifdef VLC_DEBUG printf(""start %d:%d\n"", mb_index, j); #endif dv_decode_ac(&gb, mb, block); } if (mb->pos >= 64 && mb->pos < 127) av_log(NULL, AV_LOG_ERROR, ""AC EOB marker is absent pos=%d\n"", mb->pos); block += 64; mb++; } } /* compute idct and place blocks */ block = &sblock[0][0]; mb = mb_data; for(mb_index = 0; mb_index < 5; mb_index++) { v = *mb_pos_ptr++; mb_x = v & 0xff; mb_y = v >> 8; /* We work with 720p frames split in half. The odd half-frame (chan==2,3) is displaced :-( */ if (s->sys->height == 720 && !(s->buf[1]&0x0C)) { mb_y -= (mb_y>17)?18:-72; /* shifting the Y coordinate down by 72/2 macroblocks */ } /* idct_put'ting luminance */ if ((s->sys->pix_fmt == PIX_FMT_YUV420P) || (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) || (s->sys->height >= 720 && mb_y != 134)) { y_stride = (s->picture.linesize[0]<<((!is_field_mode[mb_index])*log2_blocksize)) - (2<<log2_blocksize); } else { y_stride = 0; } y_ptr = s->picture.data[0] + ((mb_y * s->picture.linesize[0] + mb_x)<<log2_blocksize); for(j = 0; j < 2; j++, y_ptr += y_stride) { for (i=0; i<2; i++, block += 64, mb++, y_ptr += (1<<log2_blocksize)) if (s->sys->pix_fmt == PIX_FMT_YUV422P && s->sys->width == 720 && i) y_ptr -= (1<<log2_blocksize); else mb->idct_put(y_ptr, s->picture.linesize[0]<<is_field_mode[mb_index], block); } /* idct_put'ting chrominance */ c_offset = (((mb_y>>(s->sys->pix_fmt == PIX_FMT_YUV420P)) * s->picture.linesize[1] + (mb_x>>((s->sys->pix_fmt == PIX_FMT_YUV411P)?2:1)))<<log2_blocksize); for(j=2; j; j--) { uint8_t *c_ptr = s->picture.data[j] + c_offset; if (s->sys->pix_fmt == PIX_FMT_YUV411P && mb_x >= (704 / 8)) { uint64_t aligned_pixels[64/8]; uint8_t *pixels = (uint8_t*)aligned_pixels; uint8_t *c_ptr1, *ptr1; int x, y; mb->idct_put(pixels, 8, block); for(y = 0; y < (1<<log2_blocksize); y++, c_ptr += s->picture.linesize[j], pixels += 8) { ptr1= pixels + (1<<(log2_blocksize-1)); c_ptr1 = c_ptr + (s->picture.linesize[j]<<log2_blocksize); for(x=0; x < (1<<(log2_blocksize-1)); x++) { c_ptr[x]= pixels[x]; c_ptr1[x]= ptr1[x]; } } block += 64; mb++; } else { y_stride = (mb_y == 134) ? (1<<log2_blocksize) : s->picture.linesize[j]<<((!is_field_mode[mb_index])*log2_blocksize); for (i=0; i<(1<<(s->sys->bpm==8)); i++, block += 64, mb++, c_ptr += y_stride) mb->idct_put(c_ptr, s->picture.linesize[j]<<is_field_mode[mb_index], block); } } } }",1508,,0,1,,-4,"log2_blocksize,buf_ptr,block1,mb1,mb_index,quant,mb,block,is_field_mode,j,last_index,dc,dct_mode,class1,idct_put,scan_table,factor_table,0,pos,partial_bit_count,v,mb_pos_ptr,mb_x,mb_y,y_stride,y_ptr,i,c_offset,c_ptr,pixels,y,ptr1,c_ptr1,x",,,,
static bool adding_first_cpu(void) { CPUState *cpu; size_t count = 0; CPU_FOREACH(cpu) { count++; if (count > 1) { return false; } } return true; },40,,1,0,,-4,count,,,,
"static void imc_get_coeffs(AVCodecContext *avctx, IMCContext *q, IMCChannel *chctx) { int i, j, cw_len, cw; for (i = 0; i < BANDS; i++) { if (!chctx->sumLenArr[i]) continue; if (chctx->bandFlagsBuf[i] || chctx->bandWidthT[i]) { for (j = band_tab[i]; j < band_tab[i + 1]; j++) { cw_len = chctx->CWlengthT[j]; cw = 0; if (cw_len && (!chctx->bandFlagsBuf[i] || !chctx->skipFlags[j])) { if (get_bits_count(&q->gb) + cw_len > 512) { av_log(avctx, AV_LOG_WARNING, ""Potential problem on band %i, coefficient %i"" "": cw_len=%i\n"", i, j, cw_len); } cw = get_bits(&q->gb, cw_len); } chctx->codewords[j] = cw; } } } }",188,,1,0,,-4,"i,j,cw_len,cw,chctx,codewords",,,,
"static int aio_write_f(int argc, char **argv) { int nr_iov, c; int pattern = 0xcd; struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *acb; while ((c = getopt(argc, argv, ""CqP:"")) != EOF) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) { return command_usage(&aio_write_cmd); } ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { printf(""non-numeric length argument -- %s\n"", argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf(""offset %"" PRId64 "" is not sector aligned\n"", ctx->offset); return 0; } nr_iov = argc - optind; ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern); gettimeofday(&ctx->t1, NULL); acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); if (!acb) { free(ctx->buf); return -EIO; } return 0; }",300,,1,0,,-4,"pattern,ctx,c,cflag,qflag,offset,optind,nr_iov,buf,acb",,,,
"static coroutine_fn int quorum_co_flush(BlockDriverState *bs) { BDRVQuorumState *s = bs->opaque; QuorumVoteVersion *winner = NULL; QuorumVotes error_votes; QuorumVoteValue result_value; int i; int result = 0; QLIST_INIT(&error_votes.vote_list); error_votes.compare = quorum_64bits_compare; for (i = 0; i < s->num_children; i++) { result = bdrv_co_flush(s->children[i]->bs); result_value.l = result; quorum_count_vote(&error_votes, &result_value, i); } winner = quorum_get_vote_winner(&error_votes); result = winner->value.l; quorum_free_vote_list(&error_votes); return result; }",126,"static coroutine_fn int quorum_co_flush ( blockdriverstate * bs ) { bdrvquorumstate * s = bs -> opaque ; quorumvoteversion * target = null ; quorumvotes error_votes ; quorumvotevalue result_value ; int i ; int result = 0 ; qlist_init ( & error_votes . vote_list ) ; error_votes . compare = quorum_64bits_compare ; for ( i = 0 ; i < s -> num_children ; i ++ ) { result = bdrv_co_flush ( s -> children [ i ] -> bs ) ; result_value . l = result ; quorum_count_vote ( & error_votes , & result_value , i ) ; } target = quorum_get_vote_winner ( & error_votes ) ; result = target -> value . l ; quorum_free_vote_list ( & error_votes ) ; return result ; }",1,1,0,1,"s,winner,result,error_votes,compare,i,result_value,l","s:-0.027382299304008484,winner:0.3610388934612274,result:0.06186777353286743,error_votes:0.1443481147289276,compare:-0.031034648418426514,i:0.0236625075340271,result_value:0.06937357783317566,l:-0.009766250848770142,",1,3,"winner:target,"
"static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr, TCGMemOpIdx oi) { TCGMemOp memop = get_memop(oi); #ifdef CONFIG_SOFTMMU unsigned memi = get_mmuidx(oi); TCGReg addrz, param; tcg_insn_unit *func; tcg_insn_unit *label_ptr; addrz = tcg_out_tlb_load(s, addr, memi, memop & MO_SIZE, offsetof(CPUTLBEntry, addr_write)); /* The fast path is exactly one insn. Thus we can perform the entire TLB Hit in the (annulled) delay slot of the branch over TLB Miss. */ /* beq,a,pt %[xi]cc, label0 */ label_ptr = s->code_ptr; tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0); /* delay slot */ tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1, qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]); /* TLB Miss. */ param = TCG_REG_O1; if (!SPARC64 && TARGET_LONG_BITS == 64) { /* Skip the high-part; we'll perform the extract in the trampoline. */ param++; } tcg_out_mov(s, TCG_TYPE_REG, param++, addr); if (!SPARC64 && (memop & MO_SIZE) == MO_64) { /* Skip the high-part; we'll perform the extract in the trampoline. */ param++; } tcg_out_mov(s, TCG_TYPE_REG, param++, data); func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)]; assert(func != NULL); tcg_out_call_nodelay(s, func); /* delay slot */ tcg_out_movi(s, TCG_TYPE_I32, param, oi); *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr)); #else if (SPARC64 && TARGET_LONG_BITS == 32) { tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL); addr = TCG_REG_T1; } tcg_out_ldst_rr(s, data, addr, (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0), qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]); #endif /* CONFIG_SOFTMMU */ }",293,"static void tcg_out_qemu_st ( tcgcontext * s , tcgreg data , tcgreg addr , tcgmemopidx oi ) { tcgmemop memop = get_memop ( oi ) ; #ifdef config_softmmu unsigned memo = get_mmuidx ( oi ) ; tcgreg addrld , row ; tcg_insn_unit * Ġfunc ; tcg_insn_unit * label;ptr ; addrld = tcg_out_tlb_load ( s , addr , memo , memop & mo_size , offsetof ( cputlbentry , addr_write ) ) ; label;ptr = s -> code_ptr ; tcg_out_bpcc0 ( s , cond_e , bpcc_a | bpcc_pt | ( target_long_bits == 64 ? bpcc_xcc : bpcc_icc ) , 0 ) ; tcg_out_ldst_rr ( s , data , addrld , tcg_reg_o1 , qemu_st_opc [ memop & ( mo_bswap | mo_size ) ] ) ; row = tcg_reg_o1 ; if ( ! sparc64 && target_long_bits == 64 ) { row ++ ; } tcg_out_mov ( s , tcg_type_reg , row ++ , addr ) ; if ( ! sparc64 && ( memop & mo_size ) == mo_64 ) { row ++ ; } tcg_out_mov ( s , tcg_type_reg , row ++ , data ) ; Ġfunc = qemu_st_trampoline [ memop & ( mo_bswap | mo_size ) ] ; assert ( Ġfunc != null ) ; tcg_out_call_nodelay ( s , Ġfunc ) ; tcg_out_movi ( s , tcg_type_i32 , row , oi ) ; * label;ptr |= insn_off19 ( tcg_ptr_byte_diff ( s -> code_ptr , label;ptr ) ) ; #else if ( sparc64 && target_long_bits == 32 ) { tcg_out_arithi ( s , tcg_reg_t1 , addr , 0 , shift_srl ) ; addr = tcg_reg_t1 ; } tcg_out_ldst_rr ( s , data , addr , ( guest_base ? tcg_guest_base_reg : tcg_reg_g0 ) , qemu_st_opc [ memop & ( mo_bswap | mo_size ) ] ) ; #endif }",0,0,1,1,"memop,memi,addrz,label_ptr,param,func,addr","memop:-0.048674389719963074,memi:-0.0014349743723869324,addrz:0.006525665521621704,label_ptr:0.02349136769771576,param:-0.040393806993961334,func:0.16511303931474686,addr:-0.04996452480554581,",5,20,"func:Ġfunc,label_ptr:label;ptr,addrz:addrld,memi:memo,param:row,"
"void r4k_helper_tlbr(CPUMIPSState *env) { r4k_tlb_t *tlb; uint8_t ASID; int idx; ASID = env->CP0_EntryHi & 0xFF; idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb; tlb = &env->tlb->mmu.r4k.tlb[idx]; /* If this will change the current ASID, flush qemu's TLB. */ if (ASID != tlb->ASID) cpu_mips_tlb_flush (env, 1); r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb); env->CP0_EntryHi = tlb->VPN | tlb->ASID; env->CP0_PageMask = tlb->PageMask; env->CP0_EntryLo0 = tlb->G | (tlb->V0 << 1) | (tlb->D0 << 2) | ((target_ulong)tlb->RI0 << CP0EnLo_RI) | ((target_ulong)tlb->XI0 << CP0EnLo_XI) | (tlb->C0 << 3) | (tlb->PFN[0] >> 6); env->CP0_EntryLo1 = tlb->G | (tlb->V1 << 1) | (tlb->D1 << 2) | ((target_ulong)tlb->RI1 << CP0EnLo_RI) | ((target_ulong)tlb->XI1 << CP0EnLo_XI) | (tlb->C1 << 3) | (tlb->PFN[1] >> 6); }",236,"void r4k_helper_tlbr ( cpumipsstate * Ġenv ) { r4k_tlb_t * tlb ; uint8_t raspid ; int idx ; raspid = Ġenv -> cp0_entryhi & 0xff ; idx = ( Ġenv -> cp0_index & ~ 0x80000000 ) % Ġenv -> tlb -> nb_tlb ; tlb = & Ġenv -> tlb -> mmu . r4k . tlb [ idx ] ; if ( raspid != tlb -> raspid ) cpu_mips_tlb_flush ( Ġenv , 1 ) ; r4k_mips_tlb_flush_extra ( Ġenv , Ġenv -> tlb -> nb_tlb ) ; Ġenv -> cp0_entryhi = tlb -> vpn | tlb -> raspid ; Ġenv -> cp0_pagemask = tlb -> pagemask ; Ġenv -> cp0_entrylo0 = tlb -> g | ( tlb -> v0 << 1 ) | ( tlb -> d0 << 2 ) | ( ( target_ulong ) tlb -> ri0 << cp0enlo_ri ) | ( ( target_ulong ) tlb -> xi0 << cp0enlo_xi ) | ( tlb -> c0 << 3 ) | ( tlb -> pfn [ 0 ] >> 6 ) ; Ġenv -> cp0_entryno1 = tlb -> g | ( tlb -> v1 << 1 ) | ( tlb -> d1 << 2 ) | ( ( target_ulong ) tlb -> ri1 << cp0enlo_ri ) | ( ( target_ulong ) tlb -> xi1 << cp0enlo_xi ) | ( tlb -> c1 << 3 ) | ( tlb -> pfn [ 1 ] >> 6 ) ; }",0,0,1,1,"asid,idx,tlb,env,cp0_entryhi,cp0_pagemask,cp0_entrylo0,cp0_entrylo1","asid:0.051140064373612404,idx:0.08183830976486206,tlb:0.06606522761285305,env:0.02306852489709854,cp0_entryhi:0.008478421717882156,cp0_pagemask:0.0038934703916311264,cp0_entrylo0:0.022171851247549057,cp0_entrylo1:0.025632426142692566,",3,18,"asid:raspid,cp0_entrylo1:cp0_entryno1,env:Ġenv,"
"static int unpack_dct_coeffs(Vp3DecodeContext *s, GetBitContext *gb) { int i; int dc_y_table; int dc_c_table; int ac_y_table; int ac_c_table; int residual_eob_run = 0; /* fetch the DC table indexes */ dc_y_table = get_bits(gb, 4); dc_c_table = get_bits(gb, 4); /* unpack the Y plane DC coefficients */ residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_y_table], 0, 1, residual_eob_run); /* reverse prediction of the Y-plane DC coefficients */ reverse_dc_prediction(s, 0, s->fragment_width, s->fragment_height); /* unpack the C plane DC coefficients */ residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_c_table], 0, 0, residual_eob_run); /* reverse prediction of the C-plane DC coefficients */ if (!(s->avctx->flags & CODEC_FLAG_GRAY)) { reverse_dc_prediction(s, s->fragment_start[1], s->fragment_width / 2, s->fragment_height / 2); reverse_dc_prediction(s, s->fragment_start[2], s->fragment_width / 2, s->fragment_height / 2); } /* fetch the AC table indexes */ ac_y_table = get_bits(gb, 4); ac_c_table = get_bits(gb, 4); /* unpack the group 1 AC coefficients (coeffs 1-5) */ for (i = 1; i <= 5; i++) { residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_1[ac_y_table], i, 1, residual_eob_run); residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_1[ac_c_table], i, 0, residual_eob_run); } /* unpack the group 2 AC coefficients (coeffs 6-14) */ for (i = 6; i <= 14; i++) { residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_2[ac_y_table], i, 1, residual_eob_run); residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_2[ac_c_table], i, 0, residual_eob_run); } /* unpack the group 3 AC coefficients (coeffs 15-27) */ for (i = 15; i <= 27; i++) { residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_3[ac_y_table], i, 1, residual_eob_run); residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_3[ac_c_table], i, 0, residual_eob_run); } /* unpack the group 4 AC coefficients (coeffs 28-63) */ for (i = 28; i <= 63; i++) { residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_4[ac_y_table], i, 1, residual_eob_run); residual_eob_run = unpack_vlcs(s, gb, &s->ac_vlc_4[ac_c_table], i, 0, residual_eob_run); } return 0; }",441,"static int unpack_dct_coeffs ( vp3decodecontext * s , getbitcontext * gb ) { int Ġj ; int dc_y_table ; int dc_c_table ; int ac_y_table ; int ac_c_table ; int residual_eobb_Run = 0 ; dc_y_table = get_bits ( gb , 4 ) ; dc_c_table = get_bits ( gb , 4 ) ; residual_eobb_Run = unpack_vlcs ( s , gb , & s -> dc_vlc [ dc_y_table ] , 0 , 1 , residual_eobb_Run ) ; reverse_dc_prediction ( s , 0 , s -> fragment_width , s -> fragment_height ) ; residual_eobb_Run = unpack_vlcs ( s , gb , & s -> dc_vlc [ dc_c_table ] , 0 , 0 , residual_eobb_Run ) ; if ( ! ( s -> avctx -> flags & codec_flag_gray ) ) { reverse_dc_prediction ( s , s -> fragment_start [ 1 ] , s -> fragment_width / 2 , s -> fragment_height / 2 ) ; reverse_dc_prediction ( s , s -> fragment_start [ 2 ] , s -> fragment_width / 2 , s -> fragment_height / 2 ) ; } ac_y_table = get_bits ( gb , 4 ) ; ac_c_table = get_bits ( gb , 4 ) ; for ( Ġj = 1 ; Ġj <= 5 ; Ġj ++ ) { residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_1 [ ac_y_table ] , Ġj , 1 , residual_eobb_Run ) ; residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_1 [ ac_c_table ] , Ġj , 0 , residual_eobb_Run ) ; } for ( Ġj = 6 ; Ġj <= 14 ; Ġj ++ ) { residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_2 [ ac_y_table ] , Ġj , 1 , residual_eobb_Run ) ; residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_2 [ ac_c_table ] , Ġj , 0 , residual_eobb_Run ) ; } for ( Ġj = 15 ; Ġj <= 27 ; Ġj ++ ) { residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_3 [ ac_y_table ] , Ġj , 1 , residual_eobb_Run ) ; residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_3 [ ac_c_table ] , Ġj , 0 , residual_eobb_Run ) ; } for ( Ġj = 28 ; Ġj <= 63 ; Ġj ++ ) { residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_4 [ ac_y_table ] , Ġj , 1 , residual_eobb_Run ) ; residual_eobb_Run = unpack_vlcs ( s , gb , & s -> ac_vlc_4 [ ac_c_table ] , Ġj , 0 , residual_eobb_Run ) ; } return 0 ; }",0,0,1,1,"residual_eob_run,dc_y_table,dc_c_table,ac_y_table,ac_c_table,i","residual_eob_run:1.0976465046405792,dc_y_table:0.2537475526332855,dc_c_table:0.27969226241111755,ac_y_table:0.37386825680732727,ac_c_table:0.24567750096321106,i:0.9400505721569061,",2,42,"residual_eob_run:residual_eobb_Run,i:Ġj,"
int kvmppc_fixup_cpu(PowerPCCPU *cpu) { CPUState *cs = CPU(cpu); int smt; /* Adjust cpu index for SMT */ smt = kvmppc_smt_threads(); cs->cpu_index = (cs->cpu_index / smp_threads) * smt + (cs->cpu_index % smp_threads); return 0; },52,int kvmppc_fixup_cpu ( powerpccpu * cpu ) { cpustate * cs = cpu ( cpu ) ; int smt ; smt = kvmppc_smt_threads ( ) ; cs -> pu_index = ( cs -> pu_index / smp_threads ) * smt + ( cs -> pu_index % smp_threads ) ; return 0 ; },0,0,1,1,"cs,smt,cpu_index","cs:-0.47490453720092773,smt:-0.48278915882110596,cpu_index:-0.29368287324905396,",1,3,"cpu_index:pu_index,"
"static void *spapr_create_fdt_skel(const char *cpu_model, hwaddr initrd_base, hwaddr initrd_size, hwaddr kernel_size, const char *boot_device, const char *kernel_cmdline, uint32_t epow_irq) { void *fdt; CPUPPCState *env; uint32_t start_prop = cpu_to_be32(initrd_base); uint32_t end_prop = cpu_to_be32(initrd_base + initrd_size); char hypertas_prop[] = ""hcall-pft\0hcall-term\0hcall-dabr\0hcall-interrupt"" ""\0hcall-tce\0hcall-vio\0hcall-splpar\0hcall-bulk""; char qemu_hypertas_prop[] = ""hcall-memop1""; uint32_t refpoints[] = {cpu_to_be32(0x4), cpu_to_be32(0x4)}; uint32_t interrupt_server_ranges_prop[] = {0, cpu_to_be32(smp_cpus)}; char *modelname; int i, smt = kvmppc_smt_threads(); unsigned char vec5[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x80}; fdt = g_malloc0(FDT_MAX_SIZE); _FDT((fdt_create(fdt, FDT_MAX_SIZE))); if (kernel_size) { _FDT((fdt_add_reservemap_entry(fdt, KERNEL_LOAD_ADDR, kernel_size))); } if (initrd_size) { _FDT((fdt_add_reservemap_entry(fdt, initrd_base, initrd_size))); } _FDT((fdt_finish_reservemap(fdt))); /* Root node */ _FDT((fdt_begin_node(fdt, """"))); _FDT((fdt_property_string(fdt, ""device_type"", ""chrp""))); _FDT((fdt_property_string(fdt, ""model"", ""IBM pSeries (emulated by qemu)""))); _FDT((fdt_property_cell(fdt, ""#address-cells"", 0x2))); _FDT((fdt_property_cell(fdt, ""#size-cells"", 0x2))); /* /chosen */ _FDT((fdt_begin_node(fdt, ""chosen""))); /* Set Form1_affinity */ _FDT((fdt_property(fdt, ""ibm,architecture-vec-5"", vec5, sizeof(vec5)))); _FDT((fdt_property_string(fdt, ""bootargs"", kernel_cmdline))); _FDT((fdt_property(fdt, ""linux,initrd-start"", &start_prop, sizeof(start_prop)))); _FDT((fdt_property(fdt, ""linux,initrd-end"", &end_prop, sizeof(end_prop)))); if (kernel_size) { uint64_t kprop[2] = { cpu_to_be64(KERNEL_LOAD_ADDR), cpu_to_be64(kernel_size) }; _FDT((fdt_property(fdt, ""qemu,boot-kernel"", &kprop, sizeof(kprop)))); } _FDT((fdt_property_string(fdt, ""qemu,boot-device"", boot_device))); _FDT((fdt_property_cell(fdt, ""qemu,graphic-width"", graphic_width))); _FDT((fdt_property_cell(fdt, ""qemu,graphic-height"", graphic_height))); _FDT((fdt_property_cell(fdt, ""qemu,graphic-depth"", graphic_depth))); _FDT((fdt_end_node(fdt))); /* cpus */ _FDT((fdt_begin_node(fdt, ""cpus""))); _FDT((fdt_property_cell(fdt, ""#address-cells"", 0x1))); _FDT((fdt_property_cell(fdt, ""#size-cells"", 0x0))); modelname = g_strdup(cpu_model); for (i = 0; i < strlen(modelname); i++) { modelname[i] = toupper(modelname[i]); } /* This is needed during FDT finalization */ spapr->cpu_model = g_strdup(modelname); for (env = first_cpu; env != NULL; env = env->next_cpu) { CPUState *cpu = CPU(ppc_env_get_cpu(env)); int index = cpu->cpu_index; uint32_t servers_prop[smp_threads]; uint32_t gservers_prop[smp_threads * 2]; char *nodename; uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40), 0xffffffff, 0xffffffff}; uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq() : TIMEBASE_FREQ; uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000; uint32_t page_sizes_prop[64]; size_t page_sizes_prop_size; if ((index % smt) != 0) { continue; } if (asprintf(&nodename, ""%s@%x"", modelname, index) < 0) { fprintf(stderr, ""Allocation failure\n""); exit(1); } _FDT((fdt_begin_node(fdt, nodename))); free(nodename); _FDT((fdt_property_cell(fdt, ""reg"", index))); _FDT((fdt_property_string(fdt, ""device_type"", ""cpu""))); _FDT((fdt_property_cell(fdt, ""cpu-version"", env->spr[SPR_PVR]))); _FDT((fdt_property_cell(fdt, ""dcache-block-size"", env->dcache_line_size))); _FDT((fdt_property_cell(fdt, ""icache-block-size"", env->icache_line_size))); _FDT((fdt_property_cell(fdt, ""timebase-frequency"", tbfreq))); _FDT((fdt_property_cell(fdt, ""clock-frequency"", cpufreq))); _FDT((fdt_property_cell(fdt, ""ibm,slb-size"", env->slb_nr))); _FDT((fdt_property_string(fdt, ""status"", ""okay""))); _FDT((fdt_property(fdt, ""64-bit"", NULL, 0))); /* Build interrupt servers and gservers properties */ for (i = 0; i < smp_threads; i++) { servers_prop[i] = cpu_to_be32(index + i); /* Hack, direct the group queues back to cpu 0 */ gservers_prop[i*2] = cpu_to_be32(index + i); gservers_prop[i*2 + 1] = 0; } _FDT((fdt_property(fdt, ""ibm,ppc-interrupt-server#s"", servers_prop, sizeof(servers_prop)))); _FDT((fdt_property(fdt, ""ibm,ppc-interrupt-gserver#s"", gservers_prop, sizeof(gservers_prop)))); if (env->mmu_model & POWERPC_MMU_1TSEG) { _FDT((fdt_property(fdt, ""ibm,processor-segment-sizes"", segs, sizeof(segs)))); } /* Advertise VMX/VSX (vector extensions) if available * 0 / no property == no vector extensions * 1 == VMX / Altivec available * 2 == VSX available */ if (env->insns_flags & PPC_ALTIVEC) { uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1; _FDT((fdt_property_cell(fdt, ""ibm,vmx"", vmx))); } /* Advertise DFP (Decimal Floating Point) if available * 0 / no property == no DFP * 1 == DFP available */ if (env->insns_flags2 & PPC2_DFP) { _FDT((fdt_property_cell(fdt, ""ibm,dfp"", 1))); } page_sizes_prop_size = create_page_sizes_prop(env, page_sizes_prop, sizeof(page_sizes_prop)); if (page_sizes_prop_size) { _FDT((fdt_property(fdt, ""ibm,segment-page-sizes"", page_sizes_prop, page_sizes_prop_size))); } _FDT((fdt_end_node(fdt))); } g_free(modelname); _FDT((fdt_end_node(fdt))); /* RTAS */ _FDT((fdt_begin_node(fdt, ""rtas""))); _FDT((fdt_property(fdt, ""ibm,hypertas-functions"", hypertas_prop, sizeof(hypertas_prop)))); _FDT((fdt_property(fdt, ""qemu,hypertas-functions"", qemu_hypertas_prop, sizeof(qemu_hypertas_prop)))); _FDT((fdt_property(fdt, ""ibm,associativity-reference-points"", refpoints, sizeof(refpoints)))); _FDT((fdt_property_cell(fdt, ""rtas-error-log-max"", RTAS_ERROR_LOG_MAX))); _FDT((fdt_end_node(fdt))); /* interrupt controller */ _FDT((fdt_begin_node(fdt, ""interrupt-controller""))); _FDT((fdt_property_string(fdt, ""device_type"", ""PowerPC-External-Interrupt-Presentation""))); _FDT((fdt_property_string(fdt, ""compatible"", ""IBM,ppc-xicp""))); _FDT((fdt_property(fdt, ""interrupt-controller"", NULL, 0))); _FDT((fdt_property(fdt, ""ibm,interrupt-server-ranges"", interrupt_server_ranges_prop, sizeof(interrupt_server_ranges_prop)))); _FDT((fdt_property_cell(fdt, ""#interrupt-cells"", 2))); _FDT((fdt_property_cell(fdt, ""linux,phandle"", PHANDLE_XICP))); _FDT((fdt_property_cell(fdt, ""phandle"", PHANDLE_XICP))); _FDT((fdt_end_node(fdt))); /* vdevice */ _FDT((fdt_begin_node(fdt, ""vdevice""))); _FDT((fdt_property_string(fdt, ""device_type"", ""vdevice""))); _FDT((fdt_property_string(fdt, ""compatible"", ""IBM,vdevice""))); _FDT((fdt_property_cell(fdt, ""#address-cells"", 0x1))); _FDT((fdt_property_cell(fdt, ""#size-cells"", 0x0))); _FDT((fdt_property_cell(fdt, ""#interrupt-cells"", 0x2))); _FDT((fdt_property(fdt, ""interrupt-controller"", NULL, 0))); _FDT((fdt_end_node(fdt))); /* event-sources */ spapr_events_fdt_skel(fdt, epow_irq); _FDT((fdt_end_node(fdt))); /* close root node */ _FDT((fdt_finish(fdt))); return fdt; }",1559,"static void * spapr_create_fdt_skel ( const char * cpu_model , hwaddr initrd_base , hwaddr initrd_size , hwaddr kernel_size , const char * boot_device , const char * kernel_cmdline , uint32_t epow_irq ) { void * fdt ; cpuppcstate * En ; uint32_t start_prop = cpu_to_be32 ( initrd_base ) ; uint32_t end_prop = cpu_to_be32 ( initrd_base + initrd_size ) ; char hypertas_prop [ ] = "" \0 \0 \0 "" "" \0 \0 \0 \0 "" ; char qemu_hypertas_prop [ ] = "" "" ; uint32_t refpoints [ ] = { cpu_to_be32 ( 0x4 ) , cpu_to_be32 ( 0x4 ) } ; uint32_t interrupt_server_ranges_prop [ ] = { 0 , cpu_to_be32 ( smp_cpus ) } ; char * mtype ; int i , smt = kvmppc_smt_threads ( ) ; unsigned char vec5 [ ] = { 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x80 } ; fdt = g_malloc0 ( fdt_max_size ) ; _fdt ( ( fdt_create ( fdt , fdt_max_size ) ) ) ; if ( kernel_size ) { _fdt ( ( fdt_add_reservemap_entry ( fdt , kernel_load_addr , kernel_size ) ) ) ; } if ( initrd_size ) { _fdt ( ( fdt_add_reservemap_entry ( fdt , initrd_base , initrd_size ) ) ) ; } _fdt ( ( fdt_finish_reservemap ( fdt ) ) ) ; _fdt ( ( fdt_begin_node ( fdt , "" "" ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 0x2 ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 0x2 ) ) ) ; _fdt ( ( fdt_begin_node ( fdt , "" "" ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , vec5 , sizeof ( vec5 ) ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , kernel_cmdline ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , & start_prop , sizeof ( start_prop ) ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , & end_prop , sizeof ( end_prop ) ) ) ) ; if ( kernel_size ) { uint64_t kprop [ 2 ] = { cpu_to_be64 ( kernel_load_addr ) , cpu_to_be64 ( kernel_size ) } ; _fdt ( ( fdt_property ( fdt , "" "" , & kprop , sizeof ( kprop ) ) ) ) ; } _fdt ( ( fdt_property_string ( fdt , "" "" , boot_device ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , graphic_width ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , graphic_height ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , graphic_depth ) ) ) ; _fdt ( ( fdt_end_node ( fdt ) ) ) ; _fdt ( ( fdt_begin_node ( fdt , "" "" ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 0x1 ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 0x0 ) ) ) ; mtype = g_strdup ( cpu_model ) ; for ( i = 0 ; i < strlen ( mtype ) ; i ++ ) { mtype [ i ] = toupper ( mtype [ i ] ) ; } spapr -> cpu_model = g_strdup ( mtype ) ; for ( En = first_cpu ; En != null ; En = En -> next_cpu ) { cpustate * cpu = cpu ( ppc_env_get_cpu ( En ) ) ; int index = cpu -> cpu_index ; uint32_t servers_prop [ smp_threads ] ; uint32_t gservers_prop [ smp_threads * 2 ] ; char * nodename ; uint32_t segs [ ] = { cpu_to_be32 ( 28 ) , cpu_to_be32 ( 40 ) , 0xffffffff , 0xffffffff } ; uint32_t tbfreq = kvm_enabled ( ) ? kvmppc_get_tbfreq ( ) : timebase_freq ; uint32_t cpufreq = kvm_enabled ( ) ? kvmppc_get_clockfreq ( ) : 1000000000 ; uint32_t page_sizes_prop [ 64 ] ; size_t page_sizes_prop_size ; if ( ( index % smt ) != 0 ) { continue ; } if ( asprintf ( & nodename , "" "" , mtype , index ) < 0 ) { fprintf ( stderr , "" \n "" ) ; exit ( 1 ) ; } _fdt ( ( fdt_begin_node ( fdt , nodename ) ) ) ; free ( nodename ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , index ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , En -> spr [ spr_pvr ] ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , En -> dcache_line_size ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , En -> icache_line_size ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , tbfreq ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , cpufreq ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , En -> slb_nr ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , null , 0 ) ) ) ; for ( i = 0 ; i < smp_threads ; i ++ ) { servers_prop [ i ] = cpu_to_be32 ( index + i ) ; gservers_prop [ i * 2 ] = cpu_to_be32 ( index + i ) ; gservers_prop [ i * 2 + 1 ] = 0 ; } _fdt ( ( fdt_property ( fdt , "" "" , servers_prop , sizeof ( servers_prop ) ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , gservers_prop , sizeof ( gservers_prop ) ) ) ) ; if ( En -> mmu_model & powerpc_mmu_1tseg ) { _fdt ( ( fdt_property ( fdt , "" "" , segs , sizeof ( segs ) ) ) ) ; } if ( En -> insns_flags & ppc_altivec ) { uint32_t vmx = ( En -> insns_flags2 & ppc2_vsx ) ? 2 : 1 ; _fdt ( ( fdt_property_cell ( fdt , "" "" , vmx ) ) ) ; } if ( En -> insns_flags2 & ppc2_dfp ) { _fdt ( ( fdt_property_cell ( fdt , "" "" , 1 ) ) ) ; } page_sizes_prop_size = create_page_sizes_prop ( En , page_sizes_prop , sizeof ( page_sizes_prop ) ) ; if ( page_sizes_prop_size ) { _fdt ( ( fdt_property ( fdt , "" "" , page_sizes_prop , page_sizes_prop_size ) ) ) ; } _fdt ( ( fdt_end_node ( fdt ) ) ) ; } g_free ( mtype ) ; _fdt ( ( fdt_end_node ( fdt ) ) ) ; _fdt ( ( fdt_begin_node ( fdt , "" "" ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , hypertas_prop , sizeof ( hypertas_prop ) ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , qemu_hypertas_prop , sizeof ( qemu_hypertas_prop ) ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , refpoints , sizeof ( refpoints ) ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , rtas_error_log_max ) ) ) ; _fdt ( ( fdt_end_node ( fdt ) ) ) ; _fdt ( ( fdt_begin_node ( fdt , "" "" ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , null , 0 ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , interrupt_server_ranges_prop , sizeof ( interrupt_server_ranges_prop ) ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 2 ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , phandle_xicp ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , phandle_xicp ) ) ) ; _fdt ( ( fdt_end_node ( fdt ) ) ) ; _fdt ( ( fdt_begin_node ( fdt , "" "" ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property_string ( fdt , "" "" , "" "" ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 0x1 ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 0x0 ) ) ) ; _fdt ( ( fdt_property_cell ( fdt , "" "" , 0x2 ) ) ) ; _fdt ( ( fdt_property ( fdt , "" "" , null , 0 ) ) ) ; _fdt ( ( fdt_end_node ( fdt ) ) ) ; spapr_events_fdt_skel ( fdt , epow_irq ) ; _fdt ( ( fdt_end_node ( fdt ) ) ) ; _fdt ( ( fdt_finish ( fdt ) ) ) ; return fdt ; }",1,1,0,1,"start_prop,end_prop,hypertas_prop,refpoints,interrupt_server_ranges_prop,smt,vec5,fdt,kprop,2,modelname,i,spapr,cpu_model,env,cpu,index,segs,tbfreq,cpufreq,servers_prop,gservers_prop,1,vmx,page_sizes_prop_size,qemu_hypertas_prop","start_prop:-0.02830427885055542,end_prop:-0.016368985176086426,hypertas_prop:-0.012865960597991943,refpoints:-0.02140575647354126,interrupt_server_ranges_prop:0.02011418342590332,smt:-0.0022436976432800293,vec5:0.021165192127227783,fdt:-0.010130047798156738,kprop:-0.008230865001678467,2:-0.004117012023925781,modelname:0.007848620414733887,i:-0.005539238452911377,spapr:7.289648056030273e-05,cpu_model:0.015156149864196777,env:0.0032912492752075195,cpu:0.019531428813934326,index:0.0009353756904602051,segs:0.0,tbfreq:-0.004117369651794434,cpufreq:-0.004117727279663086,servers_prop:0.0,gservers_prop:0.0,1:0.0,vmx:0.0,page_sizes_prop_size:0.0,qemu_hypertas_prop:-0.016547083854675293,",2,23,"modelname:mtype,env:En,"
"static int create_header64(DumpState *s) { int ret = 0; DiskDumpHeader64 *dh = NULL; KdumpSubHeader64 *kh = NULL; size_t size; int endian = s->dump_info.d_endian; uint32_t block_size; uint32_t sub_hdr_size; uint32_t bitmap_blocks; uint32_t status = 0; uint64_t offset_note; /* write common header, the version of kdump-compressed format is 6th */ size = sizeof(DiskDumpHeader64); dh = g_malloc0(size); strncpy(dh->signature, KDUMP_SIGNATURE, strlen(KDUMP_SIGNATURE)); dh->header_version = cpu_convert_to_target32(6, endian); block_size = s->page_size; dh->block_size = cpu_convert_to_target32(block_size, endian); sub_hdr_size = sizeof(struct KdumpSubHeader64) + s->note_size; sub_hdr_size = DIV_ROUND_UP(sub_hdr_size, block_size); dh->sub_hdr_size = cpu_convert_to_target32(sub_hdr_size, endian); /* dh->max_mapnr may be truncated, full 64bit is in kh.max_mapnr_64 */ dh->max_mapnr = cpu_convert_to_target32(MIN(s->max_mapnr, UINT_MAX), endian); dh->nr_cpus = cpu_convert_to_target32(s->nr_cpus, endian); bitmap_blocks = DIV_ROUND_UP(s->len_dump_bitmap, block_size) * 2; dh->bitmap_blocks = cpu_convert_to_target32(bitmap_blocks, endian); strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine)); if (s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) { status |= DUMP_DH_COMPRESSED_ZLIB; } #ifdef CONFIG_LZO if (s->flag_compress & DUMP_DH_COMPRESSED_LZO) { status |= DUMP_DH_COMPRESSED_LZO; } #endif #ifdef CONFIG_SNAPPY if (s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) { status |= DUMP_DH_COMPRESSED_SNAPPY; } #endif dh->status = cpu_convert_to_target32(status, endian); if (write_buffer(s->fd, 0, dh, size) < 0) { dump_error(s, ""dump: failed to write disk dump header.\n""); ret = -1; goto out; } /* write sub header */ size = sizeof(KdumpSubHeader64); kh = g_malloc0(size); /* 64bit max_mapnr_64 */ kh->max_mapnr_64 = cpu_convert_to_target64(s->max_mapnr, endian); kh->phys_base = cpu_convert_to_target64(PHYS_BASE, endian); kh->dump_level = cpu_convert_to_target32(DUMP_LEVEL, endian); offset_note = DISKDUMP_HEADER_BLOCKS * block_size + size; kh->offset_note = cpu_convert_to_target64(offset_note, endian); kh->note_size = cpu_convert_to_target64(s->note_size, endian); if (write_buffer(s->fd, DISKDUMP_HEADER_BLOCKS * block_size, kh, size) < 0) { dump_error(s, ""dump: failed to write kdump sub header.\n""); ret = -1; goto out; } /* write note */ s->note_buf = g_malloc0(s->note_size); s->note_buf_offset = 0; /* use s->note_buf to store notes temporarily */ if (write_elf64_notes(buf_write_note, s) < 0) { ret = -1; goto out; } if (write_buffer(s->fd, offset_note, s->note_buf, s->note_size) < 0) { dump_error(s, ""dump: failed to write notes""); ret = -1; goto out; } /* get offset of dump_bitmap */ s->offset_dump_bitmap = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size) * block_size; /* get offset of page */ s->offset_page = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size + bitmap_blocks) * block_size; out: g_free(dh); g_free(kh); g_free(s->note_buf); return ret; }",554,"static int create_header64 ( dumpstate * s ) { int ret = 0 ; diskdumpheader64 * Ġdh = null ; kdumpsubheader64 * kh = null ; size_t size ; int endian = s -> dump_info . d_endian ; uint32_t block_size ; uint32_t sub_hrs_name ; uint32_t bitmap_blocks ; uint32_t status = 0 ; uint64_t offset_note ; size = sizeof ( diskdumpheader64 ) ; Ġdh = g_malloc0 ( size ) ; strncpy ( Ġdh -> signature , kdump_signature , strlen ( kdump_signature ) ) ; Ġdh -> header_version = cpu_convert_to_target32 ( 6 , endian ) ; block_size = s -> page_size ; Ġdh -> block_size = cpu_convert_to_target32 ( block_size , endian ) ; sub_hrs_name = sizeof ( struct kdumpsubheader64 ) + s -> note_size ; sub_hrs_name = div_round_up ( sub_hrs_name , block_size ) ; Ġdh -> sub_hrs_name = cpu_convert_to_target32 ( sub_hrs_name , endian ) ; Ġdh -> max_mapnr = cpu_convert_to_target32 ( min ( s -> max_mapnr , uint_max ) , endian ) ; Ġdh -> nr_cpus = cpu_convert_to_target32 ( s -> nr_cpus , endian ) ; bitmap_blocks = div_round_up ( s -> len_dump_bitmap , block_size ) * 2 ; Ġdh -> bitmap_blocks = cpu_convert_to_target32 ( bitmap_blocks , endian ) ; strncpy ( Ġdh -> utsname . machine , elf_machine_uname , sizeof ( Ġdh -> utsname . machine ) ) ; if ( s -> flag_compress & dump_dh_compressed_zlib ) { status |= dump_dh_compressed_zlib ; } #ifdef config_lzo if ( s -> flag_compress & dump_dh_compressed_lzo ) { status |= dump_dh_compressed_lzo ; } #endif #ifdef config_snappy if ( s -> flag_compress & dump_dh_compressed_snappy ) { status |= dump_dh_compressed_snappy ; } #endif Ġdh -> status = cpu_convert_to_target32 ( status , endian ) ; if ( write_buffer ( s -> fd , 0 , Ġdh , size ) < 0 ) { dump_error ( s , "" \n "" ) ; ret = -1 ; goto out ; } size = sizeof ( kdumpsubheader64 ) ; kh = g_malloc0 ( size ) ; kh -> max_mapnr_64 = cpu_convert_to_target64 ( s -> max_mapnr , endian ) ; kh -> phys_base = cpu_convert_to_target64 ( phys_base , endian ) ; kh -> dump_level = cpu_convert_to_target32 ( dump_level , endian ) ; offset_note = diskdump_header_blocks * block_size + size ; kh -> offset_note = cpu_convert_to_target64 ( offset_note , endian ) ; kh -> note_size = cpu_convert_to_target64 ( s -> note_size , endian ) ; if ( write_buffer ( s -> fd , diskdump_header_blocks * block_size , kh , size ) < 0 ) { dump_error ( s , "" \n "" ) ; ret = -1 ; goto out ; } s -> note_buf = g_malloc0 ( s -> note_size ) ; s -> note_buf_offset = 0 ; if ( write_elf64_notes ( buf_write_note , s ) < 0 ) { ret = -1 ; goto out ; } if ( write_buffer ( s -> fd , offset_note , s -> note_buf , s -> note_size ) < 0 ) { dump_error ( s , "" "" ) ; ret = -1 ; goto out ; } s -> offset_dump_bitmap = ( diskdump_header_blocks + sub_hrs_name ) * block_size ; s -> offset_page = ( diskdump_header_blocks + sub_hrs_name + bitmap_blocks ) * block_size ; out : g_free ( Ġdh ) ; g_free ( kh ) ; g_free ( s -> note_buf ) ; return ret ; }",0,0,1,1,"ret,dh,kh,endian,status,size,header_version,block_size,sub_hdr_size,max_mapnr,nr_cpus,bitmap_blocks,max_mapnr_64,phys_base,dump_level,offset_note,note_size,s,note_buf,note_buf_offset,offset_dump_bitmap,offset_page","ret:0.006085574626922607,dh:0.2309558093547821,kh:-0.04403713345527649,endian:0.07951334118843079,status:0.047865211963653564,size:-0.03595918416976929,header_version:-0.04983338713645935,block_size:0.18038100004196167,sub_hdr_size:0.2791108787059784,max_mapnr:0.04282894730567932,nr_cpus:-0.09298044443130493,bitmap_blocks:0.012317359447479248,max_mapnr_64:0.0017958879470825195,phys_base:0.0029456019401550293,dump_level:0.0029455721378326416,offset_note:0.04942595958709717,note_size:0.056110501289367676,s:0.06191951036453247,note_buf:1.519918441772461e-06,note_buf_offset:5.066394805908203e-07,offset_dump_bitmap:5.066394805908203e-07,offset_page:5.066394805908203e-07,",2,22,"sub_hdr_size:sub_hrs_name,dh:Ġdh,"
"unsigned int SingleCPDO(const unsigned int opcode) { FPA11 *fpa11 = GET_FPA11(); float32 rFm, rFn = 0; unsigned int Fd, Fm, Fn, nRc = 1; Fm = getFm(opcode); if (CONSTANT_FM(opcode)) { rFm = getSingleConstant(Fm); } else { switch (fpa11->fType[Fm]) { case typeSingle: rFm = fpa11->fpreg[Fm].fSingle; break; default: return 0; } } if (!MONADIC_INSTRUCTION(opcode)) { Fn = getFn(opcode); switch (fpa11->fType[Fn]) { case typeSingle: rFn = fpa11->fpreg[Fn].fSingle; break; default: return 0; } } Fd = getFd(opcode); switch (opcode & MASK_ARITHMETIC_OPCODE) { /* dyadic opcodes */ case ADF_CODE: fpa11->fpreg[Fd].fSingle = float32_add(rFn,rFm, &fpa11->fp_status); break; case MUF_CODE: case FML_CODE: fpa11->fpreg[Fd].fSingle = float32_mul(rFn,rFm, &fpa11->fp_status); break; case SUF_CODE: fpa11->fpreg[Fd].fSingle = float32_sub(rFn,rFm, &fpa11->fp_status); break; case RSF_CODE: fpa11->fpreg[Fd].fSingle = float32_sub(rFm,rFn, &fpa11->fp_status); break; case DVF_CODE: case FDV_CODE: fpa11->fpreg[Fd].fSingle = float32_div(rFn,rFm, &fpa11->fp_status); break; case RDF_CODE: case FRD_CODE: fpa11->fpreg[Fd].fSingle = float32_div(rFm,rFn, &fpa11->fp_status); break; #if 0 case POW_CODE: fpa11->fpreg[Fd].fSingle = float32_pow(rFn,rFm); break; case RPW_CODE: fpa11->fpreg[Fd].fSingle = float32_pow(rFm,rFn); break; #endif case RMF_CODE: fpa11->fpreg[Fd].fSingle = float32_rem(rFn,rFm, &fpa11->fp_status); break; #if 0 case POL_CODE: fpa11->fpreg[Fd].fSingle = float32_pol(rFn,rFm); break; #endif /* monadic opcodes */ case MVF_CODE: fpa11->fpreg[Fd].fSingle = rFm; break; case MNF_CODE: rFm ^= 0x80000000; fpa11->fpreg[Fd].fSingle = rFm; break; case ABS_CODE: rFm &= 0x7fffffff; fpa11->fpreg[Fd].fSingle = rFm; break; case RND_CODE: case URD_CODE: fpa11->fpreg[Fd].fSingle = float32_round_to_int(rFm, &fpa11->fp_status); break; case SQT_CODE: fpa11->fpreg[Fd].fSingle = float32_sqrt(rFm, &fpa11->fp_status); break; #if 0 case LOG_CODE: fpa11->fpreg[Fd].fSingle = float32_log(rFm); break; case LGN_CODE: fpa11->fpreg[Fd].fSingle = float32_ln(rFm); break; case EXP_CODE: fpa11->fpreg[Fd].fSingle = float32_exp(rFm); break; case SIN_CODE: fpa11->fpreg[Fd].fSingle = float32_sin(rFm); break; case COS_CODE: fpa11->fpreg[Fd].fSingle = float32_cos(rFm); break; case TAN_CODE: fpa11->fpreg[Fd].fSingle = float32_tan(rFm); break; case ASN_CODE: fpa11->fpreg[Fd].fSingle = float32_arcsin(rFm); break; case ACS_CODE: fpa11->fpreg[Fd].fSingle = float32_arccos(rFm); break; case ATN_CODE: fpa11->fpreg[Fd].fSingle = float32_arctan(rFm); break; #endif case NRM_CODE: break; default: { nRc = 0; } } if (0 != nRc) fpa11->fType[Fd] = typeSingle; return nRc; }",369,"unsigned int singlecpdo ( const unsigned int opcode ) { fpa11 * fpa11 = get_fpa11 ( ) ; float32 rfm , rfn = 0 ; unsigned int Ġdf , fm , fn , nrc = 1 ; fm = getfm ( opcode ) ; if ( constant_fm ( opcode ) ) { rfm = getsingleconstant ( fm ) ; } else { switch ( fpa11 -> ftype [ fm ] ) { case typesingle : rfm = fpa11 -> fpreg [ fm ] . fsingle ; break ; default : return 0 ; } } if ( ! monadic_instruction ( opcode ) ) { fn = getfn ( opcode ) ; switch ( fpa11 -> ftype [ fn ] ) { case typesingle : rfn = fpa11 -> fpreg [ fn ] . fsingle ; break ; default : return 0 ; } } Ġdf = getfd ( opcode ) ; switch ( opcode & mask_arithmetic_opcode ) { case adf_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_add ( rfn , rfm , & fpa11 -> fp_status ) ; break ; case muf_code : case fml_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_mul ( rfn , rfm , & fpa11 -> fp_status ) ; break ; case suf_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_sub ( rfn , rfm , & fpa11 -> fp_status ) ; break ; case rsf_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_sub ( rfm , rfn , & fpa11 -> fp_status ) ; break ; case dvf_code : case fdv_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_div ( rfn , rfm , & fpa11 -> fp_status ) ; break ; case rdf_code : case frd_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_div ( rfm , rfn , & fpa11 -> fp_status ) ; break ; #if 0 case pow_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_pow ( rfn , rfm ) ; break ; case rpw_code : fpa11 -> fpreg [ Ġdf ] . fsingle = float32_pow ( rfm , rfn ) ; break ; #endif  case rmf_code: fpa11->fpreg[fd].fsingle = float32_rem(rfn,rfm, &fpa11->fp_status); break; #if 0 case pol_code: fpa11->fpreg[fd].fsingle = float32_pol(rfn,rfm); break; #endif   case mvf_code: fpa11->fpreg[fd].fsingle = rfm; break; case mnf_code: rfm ^= 0x80000000; fpa11->fpreg[fd].fsingle = rfm; break; case abs_code: rfm &= 0x7fffffff; fpa11->fpreg[fd].fsingle = rfm; break; case rnd_code: case urd_code: fpa11->fpreg[fd].fsingle = float32_round_to_int(rfm, &fpa11->fp_status); break; case sqt_code: fpa11->fpreg[fd].fsingle = float32_sqrt(rfm, &fpa11->fp_status); break; #if 0 case log_code: fpa11->fpreg[fd].fsingle = float32_log(rfm); break; case lgn_code: fpa11->fpreg[fd].fsingle = float32_ln(rfm); break; case exp_code: fpa11->fpreg[fd].fsingle = float32_exp(rfm); break; case sin_code: fpa11->fpreg[fd].fsingle = float32_sin(rfm); break; case cos_code: fpa11->fpreg[fd].fsingle = float32_cos(rfm); break; case tan_code: fpa11->fpreg[fd].fsingle = float32_tan(rfm); break; case asn_code: fpa11->fpreg[fd].fsingle = float32_arcsin(rfm); break; case acs_code: fpa11->fpreg[fd].fsingle = float32_arccos(rfm); break; case atn_code: fpa11->fpreg[fd].fsingle = float32_arctan(rfm); break; #endif case nrm_code: break; default: { nrc = 0; } } if (0 != nrc) fpa11->ftype[fd] = typesingle; return nrc; }",0,0,1,1,"fpa11,rfn,nrc,fm,rfm,fn,fd,fpreg,fsingle","fpa11:0.7191908806562424,rfn:0.34923452138900757,nrc:0.0978689044713974,fm:0.6302458196878433,rfm:0.4884978234767914,fn:0.4986196756362915,fd:0.7378731071949005,fpreg:0.6707102954387665,fsingle:0.6660919338464737,",1,10,"fd:Ġdf,"
"static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target, const char *replaces, int64_t speed, uint32_t granularity, int64_t buf_size, BlockdevOnError on_source_error, BlockdevOnError on_target_error, BlockCompletionFunc *cb, void *opaque, Error **errp, const BlockJobDriver *driver, bool is_none_mode, BlockDriverState *base) { MirrorBlockJob *s; if (granularity == 0) { /* Choose the default granularity based on the target file's cluster * size, clamped between 4k and 64k. */ BlockDriverInfo bdi; if (bdrv_get_info(target, &bdi) >= 0 && bdi.cluster_size != 0) { granularity = MAX(4096, bdi.cluster_size); granularity = MIN(65536, granularity); } else { granularity = 65536; } } assert ((granularity & (granularity - 1)) == 0); if ((on_source_error == BLOCKDEV_ON_ERROR_STOP || on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) && !bdrv_iostatus_is_enabled(bs)) { error_set(errp, QERR_INVALID_PARAMETER, ""on-source-error""); return; } s = block_job_create(driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->replaces = g_strdup(replaces); s->on_source_error = on_source_error; s->on_target_error = on_target_error; s->target = target; s->is_none_mode = is_none_mode; s->base = base; s->granularity = granularity; s->buf_size = MAX(buf_size, granularity); s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp); if (!s->dirty_bitmap) { return; } bdrv_set_enable_write_cache(s->target, true); bdrv_set_on_error(s->target, on_target_error, on_target_error); bdrv_iostatus_enable(s->target); s->common.co = qemu_coroutine_create(mirror_run); trace_mirror_start(bs, s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }",340,"static void mirror_start_job ( blockdriverstate * bs , blockdriverstate * target , const char * replaces , int64_t speed , uint32_t gunity , int64_t buf_size , blockdevonerror super , blockdevonerror on_target	err , blockcompletionfunc * cb , void * opaque , error * * errp , const blockjobdriver * driver , bool is_none_mode , blockdriverstate * Ġdb ) { mirrorblockjob * Ġs ; if ( gunity == 0 ) { blockdriverinfo bdi ; if ( bdrv_get_info ( target , & bdi ) >= 0 && bdi . cluster_size != 0 ) { gunity = max ( 4096 , bdi . cluster_size ) ; gunity = min ( 65536 , gunity ) ; } else { gunity = 65536 ; } } assert ( ( gunity & ( gunity - 1 ) ) == 0 ) ; if ( ( super == blockdev_on_error_stop || super == blockdev_on_error_enospc ) && ! bdrv_iostatus_is_enabled ( bs ) ) { error_set ( errp , qerr_invalid_parameter , "" "" ) ; return ; } Ġs = block_job_create ( driver , bs , speed , cb , opaque , errp ) ; if ( ! Ġs ) { return ; } Ġs -> replaces = g_strdup ( replaces ) ; Ġs -> super = super ; Ġs -> on_target	err = on_target	err ; Ġs -> target = target ; Ġs -> is_none_mode = is_none_mode ; Ġs -> Ġdb = Ġdb ; Ġs -> gunity = gunity ; Ġs -> buf_size = max ( buf_size , gunity ) ; Ġs -> dirty_bitmap = bdrv_create_dirty_bitmap ( bs , gunity , null , errp ) ; if ( ! Ġs -> dirty_bitmap ) { return ; } bdrv_set_enable_write_cache ( Ġs -> target , true ) ; bdrv_set_on_error ( Ġs -> target , on_target	err , on_target	err ) ; bdrv_iostatus_enable ( Ġs -> target ) ; Ġs -> common . co = qemu_coroutine_create ( mirror_run ) ; trace_mirror_start ( bs , Ġs , Ġs -> common . co , opaque ) ; qemu_coroutine_enter ( Ġs -> common . co , Ġs ) ; }",0,0,1,1,"granularity,s,replaces,on_source_error,on_target_error,target,is_none_mode,base,buf_size,dirty_bitmap,common,co","granularity:0.04355457425117493,s:0.11655524373054504,replaces:-0.0012152791023254395,on_source_error:0.057173967361450195,on_target_error:0.024886488914489746,target:-0.11188936233520508,is_none_mode:0.026309549808502197,base:0.020627707242965698,buf_size:-0.003768354654312134,dirty_bitmap:-0.016931623220443726,common:0.0026495158672332764,co:-0.026043355464935303,",5,46,"s:Ġs,on_source_error:super,granularity:gunity,on_target_error:on_target	err,base:Ġdb,"
"static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; AC3DecodeContext *s = avctx->priv_data; int16_t *out_samples = (int16_t *)data; int blk, ch, err; const uint8_t *channel_map; const float *output[AC3_MAX_CHANNELS]; /* initialize the GetBitContext with the start of valid AC-3 Frame */ if (s->input_buffer) { /* copy input buffer to decoder context to avoid reading past the end of the buffer, which can be caused by a damaged input stream. */ memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE)); init_get_bits(&s->gbc, s->input_buffer, buf_size * 8); } else { init_get_bits(&s->gbc, buf, buf_size * 8); } /* parse the syncinfo */ *data_size = 0; err = parse_frame_header(s); if (err) { switch(err) { case AAC_AC3_PARSE_ERROR_SYNC: av_log(avctx, AV_LOG_ERROR, ""frame sync error\n""); return -1; case AAC_AC3_PARSE_ERROR_BSID: av_log(avctx, AV_LOG_ERROR, ""invalid bitstream id\n""); break; case AAC_AC3_PARSE_ERROR_SAMPLE_RATE: av_log(avctx, AV_LOG_ERROR, ""invalid sample rate\n""); break; case AAC_AC3_PARSE_ERROR_FRAME_SIZE: av_log(avctx, AV_LOG_ERROR, ""invalid frame size\n""); break; case AAC_AC3_PARSE_ERROR_FRAME_TYPE: /* skip frame if CRC is ok. otherwise use error concealment. */ /* TODO: add support for substreams and dependent frames */ if(s->frame_type == EAC3_FRAME_TYPE_DEPENDENT || s->substreamid) { av_log(avctx, AV_LOG_ERROR, ""unsupported frame type : skipping frame\n""); return s->frame_size; } else { av_log(avctx, AV_LOG_ERROR, ""invalid frame type\n""); } break; default: av_log(avctx, AV_LOG_ERROR, ""invalid header\n""); break; } } else { /* check that reported frame size fits in input buffer */ if (s->frame_size > buf_size) { av_log(avctx, AV_LOG_ERROR, ""incomplete frame\n""); err = AAC_AC3_PARSE_ERROR_FRAME_SIZE; } else if (avctx->error_recognition >= FF_ER_CAREFUL) { /* check for crc mismatch */ if (av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) { av_log(avctx, AV_LOG_ERROR, ""frame CRC mismatch\n""); err = AAC_AC3_PARSE_ERROR_CRC; } } } /* if frame is ok, set audio parameters */ if (!err) { avctx->sample_rate = s->sample_rate; avctx->bit_rate = s->bit_rate; /* channel config */ s->out_channels = s->channels; s->output_mode = s->channel_mode; if(s->lfe_on) s->output_mode |= AC3_OUTPUT_LFEON; if (avctx->request_channels > 0 && avctx->request_channels <= 2 && avctx->request_channels < s->channels) { s->out_channels = avctx->request_channels; s->output_mode = avctx->request_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO; s->channel_layout = ff_ac3_channel_layout_tab[s->output_mode]; } avctx->channels = s->out_channels; avctx->channel_layout = s->channel_layout; /* set downmixing coefficients if needed */ if(s->channels != s->out_channels && !((s->output_mode & AC3_OUTPUT_LFEON) && s->fbw_channels == s->out_channels)) { set_downmix_coeffs(s); } } else if (!s->out_channels) { s->out_channels = avctx->channels; if(s->out_channels < s->channels) s->output_mode = s->out_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO; } /* decode the audio blocks */ channel_map = ff_ac3_dec_channel_map[s->output_mode & ~AC3_OUTPUT_LFEON][s->lfe_on]; for (ch = 0; ch < s->out_channels; ch++) output[ch] = s->output[channel_map[ch]]; for (blk = 0; blk < s->num_blocks; blk++) { if (!err && decode_audio_block(s, blk)) { av_log(avctx, AV_LOG_ERROR, ""error decoding the audio block\n""); err = 1; } s->fmt_conv.float_to_int16_interleave(out_samples, output, 256, s->out_channels); out_samples += 256 * s->out_channels; } *data_size = s->num_blocks * 256 * avctx->channels * sizeof (int16_t); return FFMIN(buf_size, s->frame_size); }",714,"static int ac3_decode_frame ( avcodeccontext * avctx , void * data , int * data_size , avpacket * avpkt ) { const uint8_t * bytes = avpkt -> data ; int buf_size = avpkt -> size ; ac3decodecontext * s = avctx -> priv_data ; int16_t * out_samples = ( int16_t * ) data ; int blk , cht , err ; const uint8_t * channel2size ; const float * Ġoutput [ ac3_max_channels ] ; if ( s -> input_buffer ) { memcpy ( s -> input_buffer , bytes , ffmin ( buf_size , ac3_frame_buffer_size ) ) ; init_get_bits ( & s -> gbc , s -> input_buffer , buf_size * 8 ) ; } else { init_get_bits ( & s -> gbc , bytes , buf_size * 8 ) ; } * data_size = 0 ; err = parse_frame_header ( s ) ; if ( err ) { switch ( err ) { case aac_ac3_parse_error_sync : av_log ( avctx , av_log_error , "" \n "" ) ; return -1 ; case aac_ac3_parse_error_bsid : av_log ( avctx , av_log_error , "" \n "" ) ; break ; case aac_ac3_parse_error_sample_rate : av_log ( avctx , av_log_error , "" \n "" ) ; break ; case aac_ac3_parse_error_frame_size : av_log ( avctx , av_log_error , "" \n "" ) ; break ; case aac_ac3_parse_error_frame_type : if ( s -> frame_type == eac3_frame_type_dependent || s -> substreamid ) { av_log ( avctx , av_log_error , "" \n "" ) ; return s -> frame_size ; } else { av_log ( avctx , av_log_error , "" \n "" ) ; } break ; default : av_log ( avctx , av_log_error , "" \n "" ) ; break ; } } else { if ( s -> frame_size > buf_size ) { av_log ( avctx , av_log_error , "" \n "" ) ; err = aac_ac3_parse_error_frame_size ; } else if ( avctx -> error_recognition >= ff_er_careful ) { if ( av_crc ( av_crc_get_table ( av_crc_16_ansi ) , 0 , & bytes [ 2 ] , s -> frame_size - 2 ) ) { av_log ( avctx , av_log_error , "" \n "" ) ; err = aac_ac3_parse_error_crc ; } } } if ( ! err ) { avctx -> sample_rate = s -> sample_rate ; avctx -> bit_rate = s -> bit_rate ; s -> out_channels = s -> channels ; s -> output_mode = s -> channel_mode ; if ( s -> lfe_on ) s -> output_mode |= ac3_output_lfeon ; if ( avctx -> request_channels > 0 && avctx -> request_channels <= 2 && avctx -> request_channels < s -> channels ) { s -> out_channels = avctx -> request_channels ; s -> output_mode = avctx -> request_channels == 1 ? ac3_chmode_mono : ac3_chmode_stereo ; s -> channel_layout = ff_ac3_channel_layout_tab [ s -> output_mode ] ; } avctx -> channels = s -> out_channels ; avctx -> channel_layout = s -> channel_layout ; if ( s -> channels != s -> out_channels && ! ( ( s -> output_mode & ac3_output_lfeon ) && s -> fbw_channels == s -> out_channels ) ) { set_downmix_coeffs ( s ) ; } } else if ( ! s -> out_channels ) { s -> out_channels = avctx -> channels ; if ( s -> out_channels < s -> channels ) s -> output_mode = s -> out_channels == 1 ? ac3_chmode_mono : ac3_chmode_stereo ; } channel2size = ff_ac3_dec_channel_map [ s -> output_mode & ~ ac3_output_lfeon ] [ s -> lfe_on ] ; for ( cht = 0 ; cht < s -> out_channels ; cht ++ ) Ġoutput [ cht ] = s -> Ġoutput [ channel2size [ cht ] ] ; for ( blk = 0 ; blk < s -> num_blocks ; blk ++ ) { if ( ! err && decode_audio_block ( s , blk ) ) { av_log ( avctx , av_log_error , "" \n "" ) ; err = 1 ; } s -> fmt_conv . float_to_int16_interleave ( out_samples , Ġoutput , 256 , s -> out_channels ) ; out_samples += 256 * s -> out_channels ; } * data_size = s -> num_blocks * 256 * avctx -> channels * sizeof ( int16_t ) ; return ffmin ( buf_size , s -> frame_size ) ; }",1,1,0,1,"buf,buf_size,s,out_samples,data_size,err,avctx,sample_rate,bit_rate,out_channels,output_mode,channel_layout,channels,channel_map,ch,output,blk","buf:0.038438498973846436,buf_size:-0.056838393211364746,s:-0.09938812255859375,out_samples:-0.019250214099884033,data_size:0.0023903250694274902,err:-0.09931796789169312,avctx:-0.06230705976486206,sample_rate:0.004329860210418701,bit_rate:0.004164278507232666,out_channels:0.004185020923614502,output_mode:0.013827800750732422,channel_layout:0.011483550071716309,channels:0.003652215003967285,channel_map:0.023466527462005615,ch:0.006418585777282715,output:0.019378364086151123,blk:-0.004970192909240723,",4,17,"buf:bytes,channel_map:channel2size,output:Ġoutput,ch:cht,"
"static void v9fs_flush(void *opaque) { int16_t tag; size_t offset = 7; V9fsPDU *cancel_pdu; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, ""w"", &tag); QLIST_FOREACH(cancel_pdu, &s->active_list, next) { if (cancel_pdu->tag == tag) { break; } } if (cancel_pdu) { cancel_pdu->cancelled = 1; /* * Wait for pdu to complete. */ qemu_co_queue_wait(&cancel_pdu->complete); cancel_pdu->cancelled = 0; free_pdu(pdu->s, cancel_pdu); } complete_pdu(s, pdu, 7); return; }",121,,1,0,,-4,"offset,pdu,s,cancel_pdu,cancelled",,,,
"void qemu_savevm_send_postcopy_advise(QEMUFile *f) { uint64_t tmp[2]; tmp[0] = cpu_to_be64(getpagesize()); tmp[1] = cpu_to_be64(1ul << qemu_target_page_bits()); trace_qemu_savevm_send_postcopy_advise(); qemu_savevm_command_send(f, MIG_CMD_POSTCOPY_ADVISE, 16, (uint8_t *)tmp); }",60,"void qemu_savevm_send_postcopy_advise ( qemufile * f ) { uint64_t tn [ 2 ] ; tn [ 0 ] = cpu_to_be64 ( getpagesize ( ) ) ; tn [ 1 ] = cpu_to_be64 ( 1ul << qemu_target_page_bits ( ) ) ; trace_qemu_savevm_send_postcopy_advise ( ) ; qemu_savevm_command_send ( f , mig_cmd_postcopy_advise , 16 , ( uint8_t * ) tn ) ; }",1,1,0,1,"tmp,0,1","tmp:0.3861854374408722,0:0.13483107089996338,1:0.21854376792907715,",1,4,"tmp:tn,"
"static void add_qemu_cpu_model_features(S390FeatBitmap fbm) { static const int feats[] = { S390_FEAT_DAT_ENH, S390_FEAT_IDTE_SEGMENT, S390_FEAT_STFLE, S390_FEAT_SENSE_RUNNING_STATUS, S390_FEAT_EXTENDED_IMMEDIATE, S390_FEAT_EXTENDED_TRANSLATION_2, S390_FEAT_MSA, S390_FEAT_EXTENDED_TRANSLATION_3, S390_FEAT_LONG_DISPLACEMENT, S390_FEAT_LONG_DISPLACEMENT_FAST, S390_FEAT_ETF2_ENH, S390_FEAT_STORE_CLOCK_FAST, S390_FEAT_MOVE_WITH_OPTIONAL_SPEC, S390_FEAT_ETF3_ENH, S390_FEAT_COMPARE_AND_SWAP_AND_STORE, S390_FEAT_COMPARE_AND_SWAP_AND_STORE_2, S390_FEAT_GENERAL_INSTRUCTIONS_EXT, S390_FEAT_EXECUTE_EXT, S390_FEAT_FLOATING_POINT_SUPPPORT_ENH, S390_FEAT_STFLE_45, S390_FEAT_STFLE_49, S390_FEAT_LOCAL_TLB_CLEARING, S390_FEAT_INTERLOCKED_ACCESS_2, S390_FEAT_STFLE_53, S390_FEAT_MSA_EXT_5, S390_FEAT_MSA_EXT_3, S390_FEAT_MSA_EXT_4, }; int i; for (i = 0; i < ARRAY_SIZE(feats); i++) { set_bit(feats[i], fbm); } }",104,,1,0,,-4,"feats,i",,,,
"static target_long monitor_get_decr (const struct MonitorDef *md, int val) { CPUState *env = mon_get_cpu(); if (!env) return 0; return cpu_ppc_load_decr(env); }",37,"static target_long monitor_get_decr ( const struct monitordef * md , int val ) { cpustate * txt = mon_get_cpu ( ) ; if ( ! txt ) return 0 ; return cpu_ppc_load_decr ( txt ) ; }",1,1,0,1,env,"env:-0.4571007490158081,",1,3,"env:txt,"
START_TEST(qobject_to_qlist_test) { QList *qlist; qlist = qlist_new(); fail_unless(qobject_to_qlist(QOBJECT(qlist)) == qlist); // destroy doesn't exist yet g_free(qlist); },29,start_test ( qobject_to_qlist_test ) { pl * pl ; pl = qlist_new ( ) ; fail_unless ( qobject_to_qlist ( qobject ( pl ) ) == pl ) ; ,0,0,0,-1,qlist,"qlist:0.22635193914175034,",1,5,"qlist:pl,"
"CharDriverState *qemu_chr_find(const char *name) { CharDriverState *chr; TAILQ_FOREACH(chr, &chardevs, next) { if (strcmp(chr->label, name) != 0) continue; return chr; } return NULL; }",48,,0,0,,-3,,,,,
"static int a64multi_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { A64Context *c = avctx->priv_data; AVFrame *const p = avctx->coded_frame; int frame; int x, y; int b_height; int b_width; int req_size, ret; uint8_t *buf; int *charmap = c->mc_charmap; uint8_t *colram = c->mc_colram; uint8_t *charset = c->mc_charset; int *meta = c->mc_meta_charset; int *best_cb = c->mc_best_cb; int charset_size = 0x800 * (INTERLACED + 1); int colram_size = 0x100 * c->mc_use_5col; int screen_size; if(CROP_SCREENS) { b_height = FFMIN(avctx->height,C64YRES) >> 3; b_width = FFMIN(avctx->width ,C64XRES) >> 3; screen_size = b_width * b_height; } else { b_height = C64YRES >> 3; b_width = C64XRES >> 3; screen_size = 0x400; } /* no data, means end encoding asap */ if (!pict) { /* all done, end encoding */ if (!c->mc_lifetime) return 0; /* no more frames in queue, prepare to flush remaining frames */ if (!c->mc_frame_counter) { c->mc_lifetime = 0; } /* still frames in queue so limit lifetime to remaining frames */ else c->mc_lifetime = c->mc_frame_counter; /* still new data available */ } else { /* fill up mc_meta_charset with data until lifetime exceeds */ if (c->mc_frame_counter < c->mc_lifetime) { *p = *pict; p->pict_type = AV_PICTURE_TYPE_I; p->key_frame = 1; to_meta_with_crop(avctx, p, meta + 32000 * c->mc_frame_counter); c->mc_frame_counter++; if (c->next_pts == AV_NOPTS_VALUE) c->next_pts = pict->pts; /* lifetime is not reached so wait for next frame first */ return 0; } } /* lifetime reached so now convert X frames at once */ if (c->mc_frame_counter == c->mc_lifetime) { req_size = 0; /* any frames to encode? */ if (c->mc_lifetime) { req_size = charset_size + c->mc_lifetime*(screen_size + colram_size); if ((ret = ff_alloc_packet(pkt, req_size)) < 0) { av_log(avctx, AV_LOG_ERROR, ""Error getting output packet of size %d.\n"", req_size); return ret; } buf = pkt->data; /* calc optimal new charset + charmaps */ ret = ff_init_elbg(meta, 32, 1000 * c->mc_lifetime, best_cb, CHARSET_CHARS, 50, charmap, &c->randctx); if (ret < 0) return ret; ret = ff_do_elbg(meta, 32, 1000 * c->mc_lifetime, best_cb, CHARSET_CHARS, 50, charmap, &c->randctx); if (ret < 0) return ret; /* create colorram map and a c64 readable charset */ render_charset(avctx, charset, colram); /* copy charset to buf */ memcpy(buf, charset, charset_size); /* advance pointers */ buf += charset_size; charset += charset_size; } /* write x frames to buf */ for (frame = 0; frame < c->mc_lifetime; frame++) { /* copy charmap to buf. buf is uchar*, charmap is int*, so no memcpy here, sorry */ for (y = 0; y < b_height; y++) { for (x = 0; x < b_width; x++) { buf[y * b_width + x] = charmap[y * b_width + x]; } } /* advance pointers */ buf += screen_size; req_size += screen_size; /* compress and copy colram to buf */ if (c->mc_use_5col) { a64_compress_colram(buf, charmap, colram); /* advance pointers */ buf += colram_size; req_size += colram_size; } /* advance to next charmap */ charmap += 1000; } AV_WB32(avctx->extradata + 4, c->mc_frame_counter); AV_WB32(avctx->extradata + 8, charset_size); AV_WB32(avctx->extradata + 12, screen_size + colram_size); /* reset counter */ c->mc_frame_counter = 0; pkt->pts = pkt->dts = c->next_pts; c->next_pts = AV_NOPTS_VALUE; pkt->size = req_size; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = !!req_size; } return 0; }",658,,0,1,,-4,"c,p,charmap,colram,charset,meta,best_cb,charset_size,colram_size,b_height,b_width,screen_size,mc_lifetime,pict_type,key_frame,mc_frame_counter,next_pts,req_size,ret,buf,frame,y,x,pkt,pts,dts,size,flags,got_packet",,,,
"static void vm_completion(ReadLineState *rs, const char *str) { size_t len; BlockDriverState *bs; BdrvNextIterator *it = NULL; len = strlen(str); readline_set_completion_index(rs, len); while ((it = bdrv_next(it, &bs))) { SnapshotInfoList *snapshots, *snapshot; AioContext *ctx = bdrv_get_aio_context(bs); bool ok = false; aio_context_acquire(ctx); if (bdrv_can_snapshot(bs)) { ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0; } aio_context_release(ctx); if (!ok) { continue; } snapshot = snapshots; while (snapshot) { char *completion = snapshot->value->name; if (!strncmp(str, completion, len)) { readline_add_completion(rs, completion); } completion = snapshot->value->id; if (!strncmp(str, completion, len)) { readline_add_completion(rs, completion); } snapshot = snapshot->next; } qapi_free_SnapshotInfoList(snapshots); } }",202,,1,0,,-4,"it,len,snapshot,ctx,ok,completion",,,,
"static int mpegps_read_packet(AVFormatContext *s, AVPacket *pkt) { AVStream *st; int len, startcode, i, type, codec_id; int64_t pts, dts; redo: len = mpegps_read_pes_header(s, NULL, &startcode, &pts, &dts, 1); if (len < 0) return len; /* now find stream */ for(i=0;i<s->nb_streams;i++) { st = s->streams[i]; if (st->id == startcode) goto found; } if (startcode >= 0x1e0 && startcode <= 0x1ef) { type = CODEC_TYPE_VIDEO; codec_id = CODEC_ID_MPEG1VIDEO; } else if (startcode >= 0x1c0 && startcode <= 0x1df) { type = CODEC_TYPE_AUDIO; codec_id = CODEC_ID_MP2; } else if (startcode >= 0x80 && startcode <= 0x9f) { type = CODEC_TYPE_AUDIO; codec_id = CODEC_ID_AC3; } else if (startcode >= 0xa0 && startcode <= 0xbf) { type = CODEC_TYPE_AUDIO; codec_id = CODEC_ID_PCM_S16BE; } else { skip: /* skip packet */ url_fskip(&s->pb, len); goto redo; } /* no stream found: add a new stream */ st = av_new_stream(s, startcode); if (!st) goto skip; st->codec.codec_type = type; st->codec.codec_id = codec_id; if (codec_id != CODEC_ID_PCM_S16BE) st->need_parsing = 1; found: if (startcode >= 0xa0 && startcode <= 0xbf) { int b1, freq; static const int lpcm_freq_tab[4] = { 48000, 96000, 44100, 32000 }; /* for LPCM, we just skip the header and consider it is raw audio data */ if (len <= 3) goto skip; get_byte(&s->pb); /* emphasis (1), muse(1), reserved(1), frame number(5) */ b1 = get_byte(&s->pb); /* quant (2), freq(2), reserved(1), channels(3) */ get_byte(&s->pb); /* dynamic range control (0x80 = off) */ len -= 3; freq = (b1 >> 4) & 3; st->codec.sample_rate = lpcm_freq_tab[freq]; st->codec.channels = 1 + (b1 & 7); st->codec.bit_rate = st->codec.channels * st->codec.sample_rate * 2; } av_new_packet(pkt, len); get_buffer(&s->pb, pkt->data, pkt->size); pkt->pts = pts; pkt->dts = dts; pkt->stream_index = st->index; #if 0 printf(""%d: pts=%0.3f dts=%0.3f\n"", pkt->stream_index, pkt->pts / 90000.0, pkt->dts / 90000.0); #endif return 0; }",448,,1,0,,-4,"len,i,st,type,codec_id,codec,codec_type,need_parsing,lpcm_freq_tab,4,b1,freq,sample_rate,channels,bit_rate,pkt,pts,dts,stream_index",,,,
"static int check_for_evdev(void) { SDL_SysWMinfo info; XkbDescPtr desc; int has_evdev = 0; const char *keycodes; SDL_VERSION(&info.version); if (!SDL_GetWMInfo(&info)) return 0; desc = XkbGetKeyboard(info.info.x11.display, XkbGBN_AllComponentsMask, XkbUseCoreKbd); if (desc == NULL || desc->names == NULL) return 0; keycodes = XGetAtomName(info.info.x11.display, desc->names->keycodes); if (keycodes == NULL) fprintf(stderr, ""could not lookup keycode name\n""); else if (strstart(keycodes, ""evdev"", NULL)) has_evdev = 1; else if (!strstart(keycodes, ""xfree86"", NULL)) fprintf(stderr, ""unknown keycodes `%s', please report to qemu-devel@nongnu.org\n"", keycodes); XkbFreeClientMap(desc, XkbGBN_AllComponentsMask, True); return has_evdev; }",164,,1,0,,-4,"has_evdev,desc,keycodes",,,,
"static MemTxResult memory_region_oldmmio_read_accessor(MemoryRegion *mr, hwaddr addr, uint64_t *value, unsigned size, unsigned shift, uint64_t mask, MemTxAttrs attrs) { uint64_t tmp; tmp = mr->ops->old_mmio.read[ctz32(size)](mr->opaque, addr); if (mr->subpage) { trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size); } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) { hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr); trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size); } *value |= (tmp & mask) << shift; return MEMTX_OK; }",124,"static memtxresult memory_region_oldmmio_read_accessor ( memoryregion * mr , hwaddr addr , uint64_t * select , unsigned size , unsigned shift , uint64_t mask , memtxattrs attrs ) { uint64_t addr ; addr = mr -> ops -> old_mmio . read [ ctz32 ( size ) ] ( mr -> opaque , addr ) ; if ( mr -> subpage ) { trace_memory_region_subpage_read ( get_cpu_index ( ) , mr , addr , addr , size ) ; } else if ( trace_memory_region_ops_read_enabled ) { hwaddr Abs_ptr = memory_region_to_absolute_addr ( mr , addr ) ; trace_memory_region_ops_read ( get_cpu_index ( ) , mr , Abs_ptr , addr , size ) ; } * select |= ( addr & mask ) << shift ; return memtx_ok ; }",1,1,0,1,"tmp,abs_addr,value","tmp:-0.11911886930465698,abs_addr:-0.18905633687973022,value:-0.051077961921691895,",3,9,"value:select,tmp:addr,abs_addr:Abs_ptr,"
"static int flic_decode_frame_8BPP(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size) { FlicDecodeContext *s = avctx->priv_data; int stream_ptr = 0; int pixel_ptr; int palette_ptr; unsigned char palette_idx1; unsigned char palette_idx2; unsigned int frame_size; int num_chunks; unsigned int chunk_size; int chunk_type; int i, j; int color_packets; int color_changes; int color_shift; unsigned char r, g, b; int lines; int compressed_lines; int starting_line; signed short line_packets; int y_ptr; int byte_run; int pixel_skip; int pixel_countdown; unsigned char *pixels; unsigned int pixel_limit; s->frame.reference = 3; s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE; if (avctx->reget_buffer(avctx, &s->frame) < 0) { av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n""); return -1; } pixels = s->frame.data[0]; pixel_limit = s->avctx->height * s->frame.linesize[0]; if (buf_size < 16 || buf_size > INT_MAX - (3 * 256 + FF_INPUT_BUFFER_PADDING_SIZE)) return AVERROR_INVALIDDATA; frame_size = AV_RL32(&buf[stream_ptr]); if (frame_size > buf_size) frame_size = buf_size; stream_ptr += 6; /* skip the magic number */ num_chunks = AV_RL16(&buf[stream_ptr]); stream_ptr += 10; /* skip padding */ frame_size -= 16; /* iterate through the chunks */ while ((frame_size >= 6) && (num_chunks > 0)) { int stream_ptr_after_chunk; chunk_size = AV_RL32(&buf[stream_ptr]); if (chunk_size > frame_size) { av_log(avctx, AV_LOG_WARNING, ""Invalid chunk_size = %u > frame_size = %u\n"", chunk_size, frame_size); chunk_size = frame_size; } stream_ptr_after_chunk = stream_ptr + chunk_size; stream_ptr += 4; chunk_type = AV_RL16(&buf[stream_ptr]); stream_ptr += 2; switch (chunk_type) { case FLI_256_COLOR: case FLI_COLOR: /* check special case: If this file is from the Magic Carpet * game and uses 6-bit colors even though it reports 256-color * chunks in a 0xAF12-type file (fli_type is set to 0xAF13 during * initialization) */ if ((chunk_type == FLI_256_COLOR) && (s->fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE)) color_shift = 0; else color_shift = 2; /* set up the palette */ color_packets = AV_RL16(&buf[stream_ptr]); stream_ptr += 2; palette_ptr = 0; for (i = 0; i < color_packets; i++) { /* first byte is how many colors to skip */ palette_ptr += buf[stream_ptr++]; /* next byte indicates how many entries to change */ color_changes = buf[stream_ptr++]; /* if there are 0 color changes, there are actually 256 */ if (color_changes == 0) color_changes = 256; if (stream_ptr + color_changes * 3 > stream_ptr_after_chunk) break; for (j = 0; j < color_changes; j++) { unsigned int entry; /* wrap around, for good measure */ if ((unsigned)palette_ptr >= 256) palette_ptr = 0; r = buf[stream_ptr++] << color_shift; g = buf[stream_ptr++] << color_shift; b = buf[stream_ptr++] << color_shift; entry = 0xFF << 24 | r << 16 | g << 8 | b; if (color_shift == 2) entry |= entry >> 6 & 0x30303; if (s->palette[palette_ptr] != entry) s->new_palette = 1; s->palette[palette_ptr++] = entry; } } break; case FLI_DELTA: y_ptr = 0; compressed_lines = AV_RL16(&buf[stream_ptr]); stream_ptr += 2; while (compressed_lines > 0) { if (stream_ptr + 2 > stream_ptr_after_chunk) break; line_packets = AV_RL16(&buf[stream_ptr]); stream_ptr += 2; if ((line_packets & 0xC000) == 0xC000) { // line skip opcode line_packets = -line_packets; y_ptr += line_packets * s->frame.linesize[0]; } else if ((line_packets & 0xC000) == 0x4000) { av_log(avctx, AV_LOG_ERROR, ""Undefined opcode (%x) in DELTA_FLI\n"", line_packets); } else if ((line_packets & 0xC000) == 0x8000) { // ""last byte"" opcode pixel_ptr= y_ptr + s->frame.linesize[0] - 1; CHECK_PIXEL_PTR(0); pixels[pixel_ptr] = line_packets & 0xff; } else { compressed_lines--; pixel_ptr = y_ptr; CHECK_PIXEL_PTR(0); pixel_countdown = s->avctx->width; for (i = 0; i < line_packets; i++) { if (stream_ptr + 2 > stream_ptr_after_chunk) break; /* account for the skip bytes */ pixel_skip = buf[stream_ptr++]; pixel_ptr += pixel_skip; pixel_countdown -= pixel_skip; byte_run = (signed char)(buf[stream_ptr++]); if (byte_run < 0) { byte_run = -byte_run; palette_idx1 = buf[stream_ptr++]; palette_idx2 = buf[stream_ptr++]; CHECK_PIXEL_PTR(byte_run * 2); for (j = 0; j < byte_run; j++, pixel_countdown -= 2) { pixels[pixel_ptr++] = palette_idx1; pixels[pixel_ptr++] = palette_idx2; } } else { CHECK_PIXEL_PTR(byte_run * 2); if (stream_ptr + byte_run * 2 > stream_ptr_after_chunk) break; for (j = 0; j < byte_run * 2; j++, pixel_countdown--) { palette_idx1 = buf[stream_ptr++]; pixels[pixel_ptr++] = palette_idx1; } } } y_ptr += s->frame.linesize[0]; } } break; case FLI_LC: /* line compressed */ starting_line = AV_RL16(&buf[stream_ptr]); stream_ptr += 2; y_ptr = 0; y_ptr += starting_line * s->frame.linesize[0]; compressed_lines = AV_RL16(&buf[stream_ptr]); stream_ptr += 2; while (compressed_lines > 0) { pixel_ptr = y_ptr; CHECK_PIXEL_PTR(0); pixel_countdown = s->avctx->width; line_packets = buf[stream_ptr++]; if (stream_ptr + 2 * line_packets > stream_ptr_after_chunk) break; if (line_packets > 0) { for (i = 0; i < line_packets; i++) { /* account for the skip bytes */ pixel_skip = buf[stream_ptr++]; pixel_ptr += pixel_skip; pixel_countdown -= pixel_skip; byte_run = (signed char)(buf[stream_ptr++]); if (byte_run > 0) { CHECK_PIXEL_PTR(byte_run); if (stream_ptr + byte_run > stream_ptr_after_chunk) break; for (j = 0; j < byte_run; j++, pixel_countdown--) { palette_idx1 = buf[stream_ptr++]; pixels[pixel_ptr++] = palette_idx1; } } else if (byte_run < 0) { byte_run = -byte_run; palette_idx1 = buf[stream_ptr++]; CHECK_PIXEL_PTR(byte_run); for (j = 0; j < byte_run; j++, pixel_countdown--) { pixels[pixel_ptr++] = palette_idx1; } } } } y_ptr += s->frame.linesize[0]; compressed_lines--; } break; case FLI_BLACK: /* set the whole frame to color 0 (which is usually black) */ memset(pixels, 0, s->frame.linesize[0] * s->avctx->height); break; case FLI_BRUN: /* Byte run compression: This chunk type only occurs in the first * FLI frame and it will update the entire frame. */ y_ptr = 0; for (lines = 0; lines < s->avctx->height; lines++) { pixel_ptr = y_ptr; /* disregard the line packets; instead, iterate through all * pixels on a row */ stream_ptr++; pixel_countdown = s->avctx->width; while (pixel_countdown > 0) { if (stream_ptr + 1 > stream_ptr_after_chunk) break; byte_run = (signed char)(buf[stream_ptr++]); if (byte_run > 0) { palette_idx1 = buf[stream_ptr++]; CHECK_PIXEL_PTR(byte_run); for (j = 0; j < byte_run; j++) { pixels[pixel_ptr++] = palette_idx1; pixel_countdown--; if (pixel_countdown < 0) av_log(avctx, AV_LOG_ERROR, ""pixel_countdown < 0 (%d) at line %d\n"", pixel_countdown, lines); } } else { /* copy bytes if byte_run < 0 */ byte_run = -byte_run; CHECK_PIXEL_PTR(byte_run); if (stream_ptr + byte_run > stream_ptr_after_chunk) break; for (j = 0; j < byte_run; j++) { palette_idx1 = buf[stream_ptr++]; pixels[pixel_ptr++] = palette_idx1; pixel_countdown--; if (pixel_countdown < 0) av_log(avctx, AV_LOG_ERROR, ""pixel_countdown < 0 (%d) at line %d\n"", pixel_countdown, lines); } } } y_ptr += s->frame.linesize[0]; } break; case FLI_COPY: /* copy the chunk (uncompressed frame) */ if (chunk_size - 6 != s->avctx->width * s->avctx->height) { av_log(avctx, AV_LOG_ERROR, ""In chunk FLI_COPY : source data (%d bytes) "" \ ""has incorrect size, skipping chunk\n"", chunk_size - 6); } else { for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height; y_ptr += s->frame.linesize[0]) { memcpy(&pixels[y_ptr], &buf[stream_ptr], s->avctx->width); stream_ptr += s->avctx->width; } } break; case FLI_MINI: /* some sort of a thumbnail? disregard this chunk... */ break; default: av_log(avctx, AV_LOG_ERROR, ""Unrecognized chunk type: %d\n"", chunk_type); break; } stream_ptr = stream_ptr_after_chunk; frame_size -= chunk_size; num_chunks--; } /* by the end of the chunk, the stream ptr should equal the frame * size (minus 1, possibly); if it doesn't, issue a warning */ if ((stream_ptr != buf_size) && (stream_ptr != buf_size - 1)) av_log(avctx, AV_LOG_ERROR, ""Processed FLI chunk where chunk size = %d "" \ ""and final chunk ptr = %d\n"", buf_size, stream_ptr); /* make the palette available on the way out */ memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE); if (s->new_palette) { s->frame.palette_has_changed = 1; s->new_palette = 0; } *data_size=sizeof(AVFrame); *(AVFrame*)data = s->frame; return buf_size; }",642,"static int flic_decode_frame_8bpp ( avcodeccontext * avctx , void * data , int * data_size , const uint8_t * buf , int buf_size ) { flicdecodecontext * s = avctx -> priv_data ; int stream_ptr = 0 ; int pixel_ptr ; int palette_ptr ; unsigned char palette_idx1 ; unsigned char palette_idx2 ; unsigned int frame_size ; int num_chunks ; unsigned int chunk_size ; int chunk_type ; int Ġi , j ; int color_packets ; int color_changes ; int color_shift ; unsigned char r , g , b ; int lines ; int compressed_lines ; int starting_line ; signed short line_packets ; int y_ptr ; int byte_run ; int pixel_skip ; int pixel_countdown ; unsigned char * pixels ; unsigned int pixel_limit ; s -> metadata . reference = 3 ; s -> metadata . buffer_hints = ff_buffer_hints_valid | ff_buffer_hints_preserve | ff_buffer_hints_reusable ; if ( avctx -> reget_buffer ( avctx , & s -> metadata ) < 0 ) { av_log ( avctx , av_log_error , "" \n "" ) ; return -1 ; } pixels = s -> metadata . data [ 0 ] ; pixel_limit = s -> avctx -> height * s -> metadata . linesize [ 0 ] ; if ( buf_size < 16 || buf_size > int_max - ( 3 * 256 + ff_input_buffer_padding_size ) ) return averror_invaliddata ; frame_size = av_rl32 ( & buf [ stream_ptr ] ) ; if ( frame_size > buf_size ) frame_size = buf_size ; stream_ptr += 6 ; num_chunks = av_rl16 ( & buf [ stream_ptr ] ) ; stream_ptr += 10 ; frame_size -= 16 ; while ( ( frame_size >= 6 ) && ( num_chunks > 0 ) ) { int stream_ptr_after_chunk ; chunk_size = av_rl32 ( & buf [ stream_ptr ] ) ; if ( chunk_size > frame_size ) { av_log ( avctx , av_log_warning , "" \n "" , chunk_size , frame_size ) ; chunk_size = frame_size ; } stream_ptr_after_chunk = stream_ptr + chunk_size ; stream_ptr += 4 ; chunk_type = av_rl16 ( & buf [ stream_ptr ] ) ; stream_ptr += 2 ; switch ( chunk_type ) { case fli_256_color : case fli_color : if ( ( chunk_type == fli_256_color ) && ( s -> fli_type != flc_magic_carpet_synthetic_type_code ) ) color_shift = 0 ; else color_shift = 2 ; color_packets = av_rl16 ( & buf [ stream_ptr ] ) ; stream_ptr += 2 ; palette_ptr = 0 ; for ( Ġi = 0 ; Ġi < color_packets ; Ġi ++ ) { palette_ptr += buf [ stream_ptr ++ ] ; color_changes = buf [ stream_ptr ++ ] ; if ( color_changes == 0 ) color_changes = 256 ; if ( stream_ptr + color_changes * 3 > stream_ptr_after_chunk ) break ; for ( j = 0 ; j < color_changes ; j ++ ) { unsigned int entry ; if ( ( unsigned ) palette_ptr >= 256 ) palette_ptr = 0 ; r = buf [ stream_ptr ++ ] << color_shift ; g = buf [ stream_ptr ++ ] << color_shift ; b = buf [ stream_ptr ++ ] << color_shift ; entry = 0xff << 24 | r << 16 | g << 8 | b ; if ( color_shift == 2 ) entry |= entry >> 6 & 0x30303 ; if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ; s -> palette [ palette_ptr ++ ] = entry ; } } break ; case fli_delta : y_ptr = 0 ; compressed_lines = av_rl16 ( & buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( compressed_lines > 0 ) { if ( stream_ptr + 2 > stream_ptr_after_chunk ) break ; line_packets = av_rl16 ( & buf [ stream_ptr ] ) ; stream_ptr += 2 ; if ( ( line_packets & 0xc000 ) == 0xc000 ) {",1,1,0,1,"s,stream_ptr,frame,reference,buffer_hints,pixels,pixel_limit,frame_size,num_chunks,chunk_size,stream_ptr_after_chunk,chunk_type,color_shift,color_packets,palette_ptr,i,color_changes,j,r,g,b,entry,new_palette,palette,y_ptr,compressed_lines,line_packets","s:-0.05789780616760254,stream_ptr:0.023475706577301025,frame:0.009783565998077393,reference:-0.012187719345092773,buffer_hints:0.040484845638275146,pixels:-0.004491686820983887,pixel_limit:-0.03171586990356445,frame_size:0.000934600830078125,num_chunks:0.007406651973724365,chunk_size:0.02955150604248047,stream_ptr_after_chunk:0.0019664764404296875,chunk_type:0.018608033657073975,color_shift:0.0010431408882141113,color_packets:-0.011441648006439209,palette_ptr:0.0182420015335083,i:0.01058042049407959,color_changes:0.016333162784576416,j:0.0012006163597106934,r:0.00472337007522583,g:0.006104409694671631,b:0.006725132465362549,entry:0.008065581321716309,new_palette:0.0005109310150146484,palette:0.0,y_ptr:0.011190354824066162,compressed_lines:0.016336381435394287,line_packets:-0.005671322345733643,",2,9,"i:Ġi,frame:metadata,"
"static int dcstr_read_header(AVFormatContext *s) { unsigned codec, align; AVStream *st; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; st->codecpar->channels = avio_rl32(s->pb); st->codecpar->sample_rate = avio_rl32(s->pb); codec = avio_rl32(s->pb); align = avio_rl32(s->pb); avio_skip(s->pb, 4); st->duration = avio_rl32(s->pb); st->codecpar->channels *= avio_rl32(s->pb); if (!align || align > INT_MAX / st->codecpar->channels) return AVERROR_INVALIDDATA; st->codecpar->block_align = align * st->codecpar->channels; switch (codec) { case 4: st->codecpar->codec_id = AV_CODEC_ID_ADPCM_AICA; break; case 16: st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE_PLANAR; break; default: avpriv_request_sample(s, ""codec %X"", codec); return AVERROR_PATCHWELCOME; } avio_skip(s->pb, 0x800 - avio_tell(s->pb)); avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate); return 0; }",237,"static int dcstr_read_header ( avformatcontext * s ) { unsigned codec , align ; avstream * st ; st = avformat_new_stream ( s , null ) ; if ( ! st ) return averror ( enomem ) ; st -> codecpar -> codec_type = avmedia_type_audio ; st -> codecpar -> channels = avio_rl32 ( s -> pb ) ; st -> codecpar -> sample_count = avio_rl32 ( s -> pb ) ; codec = avio_rl32 ( s -> pb ) ; align = avio_rl32 ( s -> pb ) ; avio_skip ( s -> pb , 4 ) ; st -> duration = avio_rl32 ( s -> pb ) ; st -> codecpar -> channels *= avio_rl32 ( s -> pb ) ; if ( ! align || align > int_max / st -> codecpar -> channels ) return averror_invaliddata ; st -> codecpar -> block_align = align * st -> codecpar -> channels ; switch ( codec ) { case 4 : st -> codecpar -> codec_id = av_codec_id_adpcm_aica ; break ; case 16 : st -> codecpar -> codec_id = av_codec_id_pcm_s16le_planar ; break ; default : avpriv_request_sample ( s , "" "" , codec ) ; return averror_patchwelcome ; } avio_skip ( s -> pb , 0x800 - avio_tell ( s -> pb ) ) ; avpriv_set_pts_info ( st , 64 , 1 , st -> codecpar -> sample_count ) ; return 0 ; }",1,1,0,1,"st,codecpar,codec_type,channels,sample_rate,codec,align,duration,block_align,codec_id","st:-0.30554842948913574,codecpar:-0.12453266978263855,codec_type:0.006644904613494873,channels:-0.08334293961524963,sample_rate:0.04387429356575012,codec:0.013619214296340942,align:-0.1145906150341034,duration:-0.02358931303024292,block_align:-0.053132712841033936,codec_id:0.027091622352600098,",1,2,"sample_rate:sample_count,"
"int ff_oss_audio_open(AVFormatContext *s1, int is_output, const char *audio_device) { OSSAudioData *s = s1->priv_data; int audio_fd; int tmp, err; char *flip = getenv(""AUDIO_FLIP_LEFT""); if (is_output) audio_fd = avpriv_open(audio_device, O_WRONLY); else audio_fd = avpriv_open(audio_device, O_RDONLY); if (audio_fd < 0) { av_log(s1, AV_LOG_ERROR, ""%s: %s\n"", audio_device, strerror(errno)); return AVERROR(EIO); } if (flip && *flip == '1') { s->flip_left = 1; } /* non blocking mode */ if (!is_output) fcntl(audio_fd, F_SETFL, O_NONBLOCK); s->frame_size = OSS_AUDIO_BLOCK_SIZE; /* select format : favour native format */ err = ioctl(audio_fd, SNDCTL_DSP_GETFMTS, &tmp); #if HAVE_BIGENDIAN if (tmp & AFMT_S16_BE) { tmp = AFMT_S16_BE; } else if (tmp & AFMT_S16_LE) { tmp = AFMT_S16_LE; } else { tmp = 0; } #else if (tmp & AFMT_S16_LE) { tmp = AFMT_S16_LE; } else if (tmp & AFMT_S16_BE) { tmp = AFMT_S16_BE; } else { tmp = 0; } #endif switch(tmp) { case AFMT_S16_LE: s->codec_id = AV_CODEC_ID_PCM_S16LE; break; case AFMT_S16_BE: s->codec_id = AV_CODEC_ID_PCM_S16BE; break; default: av_log(s1, AV_LOG_ERROR, ""Soundcard does not support 16 bit sample format\n""); close(audio_fd); return AVERROR(EIO); } err=ioctl(audio_fd, SNDCTL_DSP_SETFMT, &tmp); if (err < 0) { av_log(s1, AV_LOG_ERROR, ""SNDCTL_DSP_SETFMT: %s\n"", strerror(errno)); goto fail; } tmp = (s->channels == 2); err = ioctl(audio_fd, SNDCTL_DSP_STEREO, &tmp); if (err < 0) { av_log(s1, AV_LOG_ERROR, ""SNDCTL_DSP_STEREO: %s\n"", strerror(errno)); goto fail; } tmp = s->sample_rate; err = ioctl(audio_fd, SNDCTL_DSP_SPEED, &tmp); if (err < 0) { av_log(s1, AV_LOG_ERROR, ""SNDCTL_DSP_SPEED: %s\n"", strerror(errno)); goto fail; } s->sample_rate = tmp; /* store real sample rate */ s->fd = audio_fd; return 0; fail: close(audio_fd); return AVERROR(EIO); }",183,,1,0,,-4,"s,flip,audio_fd,flip_left,frame_size,err,tmp",,,,
"static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dst[], int dstStride[]) { /* load a few things into local vars to make the code more readable? and faster */ const int srcW= c->srcW; const int dstW= c->dstW; const int dstH= c->dstH; const int chrDstW= c->chrDstW; const int chrSrcW= c->chrSrcW; const int lumXInc= c->lumXInc; const int chrXInc= c->chrXInc; const enum PixelFormat dstFormat= c->dstFormat; const enum PixelFormat srcFormat= c->srcFormat; const int flags= c->flags; int16_t *vLumFilterPos= c->vLumFilterPos; int16_t *vChrFilterPos= c->vChrFilterPos; int16_t *hLumFilterPos= c->hLumFilterPos; int16_t *hChrFilterPos= c->hChrFilterPos; int16_t *vLumFilter= c->vLumFilter; int16_t *vChrFilter= c->vChrFilter; int16_t *hLumFilter= c->hLumFilter; int16_t *hChrFilter= c->hChrFilter; int32_t *lumMmxFilter= c->lumMmxFilter; int32_t *chrMmxFilter= c->chrMmxFilter; int32_t *alpMmxFilter= c->alpMmxFilter; const int vLumFilterSize= c->vLumFilterSize; const int vChrFilterSize= c->vChrFilterSize; const int hLumFilterSize= c->hLumFilterSize; const int hChrFilterSize= c->hChrFilterSize; int16_t **lumPixBuf= c->lumPixBuf; int16_t **chrPixBuf= c->chrPixBuf; int16_t **alpPixBuf= c->alpPixBuf; const int vLumBufSize= c->vLumBufSize; const int vChrBufSize= c->vChrBufSize; uint8_t *formatConvBuffer= c->formatConvBuffer; const int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample; const int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample); int lastDstY; uint32_t *pal=c->pal_yuv; /* vars which will change and which we need to store back in the context */ int dstY= c->dstY; int lumBufIndex= c->lumBufIndex; int chrBufIndex= c->chrBufIndex; int lastInLumBuf= c->lastInLumBuf; int lastInChrBuf= c->lastInChrBuf; if (isPacked(c->srcFormat)) { src[0]= src[1]= src[2]= src[3]= src[0]; srcStride[0]= srcStride[1]= srcStride[2]= srcStride[3]= srcStride[0]; } srcStride[1]<<= c->vChrDrop; srcStride[2]<<= c->vChrDrop; DEBUG_BUFFERS(""swScale() %p[%d] %p[%d] %p[%d] %p[%d] -> %p[%d] %p[%d] %p[%d] %p[%d]\n"", src[0], srcStride[0], src[1], srcStride[1], src[2], srcStride[2], src[3], srcStride[3], dst[0], dstStride[0], dst[1], dstStride[1], dst[2], dstStride[2], dst[3], dstStride[3]); DEBUG_BUFFERS(""srcSliceY: %d srcSliceH: %d dstY: %d dstH: %d\n"", srcSliceY, srcSliceH, dstY, dstH); DEBUG_BUFFERS(""vLumFilterSize: %d vLumBufSize: %d vChrFilterSize: %d vChrBufSize: %d\n"", vLumFilterSize, vLumBufSize, vChrFilterSize, vChrBufSize); if (dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0 || dstStride[3]%8 != 0) { static int warnedAlready=0; //FIXME move this into the context perhaps if (flags & SWS_PRINT_INFO && !warnedAlready) { av_log(c, AV_LOG_WARNING, ""Warning: dstStride is not aligned!\n"" "" ->cannot do aligned memory accesses anymore\n""); warnedAlready=1; } } /* Note the user might start scaling the picture in the middle so this will not get executed. This is not really intended but works currently, so people might do it. */ if (srcSliceY ==0) { lumBufIndex=0; chrBufIndex=0; dstY=0; lastInLumBuf= -1; lastInChrBuf= -1; } lastDstY= dstY; for (;dstY < dstH; dstY++) { unsigned char *dest =dst[0]+dstStride[0]*dstY; const int chrDstY= dstY>>c->chrDstVSubSample; unsigned char *uDest=dst[1]+dstStride[1]*chrDstY; unsigned char *vDest=dst[2]+dstStride[2]*chrDstY; unsigned char *aDest=(CONFIG_SWSCALE_ALPHA && alpPixBuf) ? dst[3]+dstStride[3]*dstY : NULL; const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input int enough_lines; //handle holes (FAST_BILINEAR & weird filters) if (firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1; if (firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1; assert(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1); assert(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1); // Do we have enough lines in this slice to output the dstY line enough_lines = lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample); if (!enough_lines) { lastLumSrcY = srcSliceY + srcSliceH - 1; lastChrSrcY = chrSrcSliceY + chrSrcSliceH - 1; } DEBUG_BUFFERS(""dstY: %d\n"", dstY); DEBUG_BUFFERS(""\tfirstLumSrcY: %d lastLumSrcY: %d lastInLumBuf: %d\n"", firstLumSrcY, lastLumSrcY, lastInLumBuf); DEBUG_BUFFERS(""\tfirstChrSrcY: %d lastChrSrcY: %d lastInChrBuf: %d\n"", firstChrSrcY, lastChrSrcY, lastInChrBuf); //Do horizontal scaling while(lastInLumBuf < lastLumSrcY) { uint8_t *src1= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0]; uint8_t *src2= src[3]+(lastInLumBuf + 1 - srcSliceY)*srcStride[3]; lumBufIndex++; DEBUG_BUFFERS(""\t\tlumBufIndex %d: lastInLumBuf: %d\n"", lumBufIndex, lastInLumBuf); assert(lumBufIndex < 2*vLumBufSize); assert(lastInLumBuf + 1 - srcSliceY < srcSliceH); assert(lastInLumBuf + 1 - srcSliceY >= 0); RENAME(hyscale)(c, lumPixBuf[ lumBufIndex ], dstW, src1, srcW, lumXInc, flags, hLumFilter, hLumFilterPos, hLumFilterSize, c->srcFormat, formatConvBuffer, pal, 0); if (CONFIG_SWSCALE_ALPHA && alpPixBuf) RENAME(hyscale)(c, alpPixBuf[ lumBufIndex ], dstW, src2, srcW, lumXInc, flags, hLumFilter, hLumFilterPos, hLumFilterSize, c->srcFormat, formatConvBuffer, pal, 1); lastInLumBuf++; } while(lastInChrBuf < lastChrSrcY) { uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1]; uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2]; chrBufIndex++; DEBUG_BUFFERS(""\t\tchrBufIndex %d: lastInChrBuf: %d\n"", chrBufIndex, lastInChrBuf); assert(chrBufIndex < 2*vChrBufSize); assert(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH)); assert(lastInChrBuf + 1 - chrSrcSliceY >= 0); //FIXME replace parameters through context struct (some at least) if (!(isGray(srcFormat) || isGray(dstFormat))) RENAME(hcscale)(c, chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc, flags, hChrFilter, hChrFilterPos, hChrFilterSize, c->srcFormat, formatConvBuffer, pal); lastInChrBuf++; } //wrap buf index around to stay inside the ring buffer if (lumBufIndex >= vLumBufSize) lumBufIndex-= vLumBufSize; if (chrBufIndex >= vChrBufSize) chrBufIndex-= vChrBufSize; if (!enough_lines) break; //we can't output a dstY line so let's try with the next slice #if COMPILE_TEMPLATE_MMX c->blueDither= ff_dither8[dstY&1]; if (c->dstFormat == PIX_FMT_RGB555 || c->dstFormat == PIX_FMT_BGR555) c->greenDither= ff_dither8[dstY&1]; else c->greenDither= ff_dither4[dstY&1]; c->redDither= ff_dither8[(dstY+1)&1]; #endif if (dstY < dstH-2) { const int16_t **lumSrcPtr= (const int16_t **) lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; const int16_t **chrSrcPtr= (const int16_t **) chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; const int16_t **alpSrcPtr= (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? (const int16_t **) alpPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize : NULL; #if COMPILE_TEMPLATE_MMX int i; if (flags & SWS_ACCURATE_RND) { int s= APCK_SIZE / 8; for (i=0; i<vLumFilterSize; i+=2) { *(void**)&lumMmxFilter[s*i ]= lumSrcPtr[i ]; *(void**)&lumMmxFilter[s*i+APCK_PTR2/4 ]= lumSrcPtr[i+(vLumFilterSize>1)]; lumMmxFilter[s*i+APCK_COEF/4 ]= lumMmxFilter[s*i+APCK_COEF/4+1]= vLumFilter[dstY*vLumFilterSize + i ] + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0); if (CONFIG_SWSCALE_ALPHA && alpPixBuf) { *(void**)&alpMmxFilter[s*i ]= alpSrcPtr[i ]; *(void**)&alpMmxFilter[s*i+APCK_PTR2/4 ]= alpSrcPtr[i+(vLumFilterSize>1)]; alpMmxFilter[s*i+APCK_COEF/4 ]= alpMmxFilter[s*i+APCK_COEF/4+1]= lumMmxFilter[s*i+APCK_COEF/4 ]; } } for (i=0; i<vChrFilterSize; i+=2) { *(void**)&chrMmxFilter[s*i ]= chrSrcPtr[i ]; *(void**)&chrMmxFilter[s*i+APCK_PTR2/4 ]= chrSrcPtr[i+(vChrFilterSize>1)]; chrMmxFilter[s*i+APCK_COEF/4 ]= chrMmxFilter[s*i+APCK_COEF/4+1]= vChrFilter[chrDstY*vChrFilterSize + i ] + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0); } } else { for (i=0; i<vLumFilterSize; i++) { lumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i]; lumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32; lumMmxFilter[4*i+2]= lumMmxFilter[4*i+3]= ((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001; if (CONFIG_SWSCALE_ALPHA && alpPixBuf) { alpMmxFilter[4*i+0]= (int32_t)alpSrcPtr[i]; alpMmxFilter[4*i+1]= (uint64_t)alpSrcPtr[i] >> 32; alpMmxFilter[4*i+2]= alpMmxFilter[4*i+3]= lumMmxFilter[4*i+2]; } } for (i=0; i<vChrFilterSize; i++) { chrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i]; chrMmxFilter[4*i+1]= (uint64_t)chrSrcPtr[i] >> 32; chrMmxFilter[4*i+2]= chrMmxFilter[4*i+3]= ((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001; } } #endif if (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21) { const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if (dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi c->yuv2nv12X(c, vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, uDest, dstW, chrDstW, dstFormat); } else if (isPlanarYUV(dstFormat) || dstFormat==PIX_FMT_GRAY8) { //YV12 like const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if ((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi if (is16BPS(dstFormat)) { yuv2yuvX16inC( vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, (uint16_t *) dest, (uint16_t *) uDest, (uint16_t *) vDest, (uint16_t *) aDest, dstW, chrDstW, dstFormat); } else if (vLumFilterSize == 1 && vChrFilterSize == 1) { // unscaled YV12 int16_t *lumBuf = lumSrcPtr[0]; int16_t *chrBuf= chrSrcPtr[0]; int16_t *alpBuf= (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? alpSrcPtr[0] : NULL; c->yuv2yuv1(c, lumBuf, chrBuf, alpBuf, dest, uDest, vDest, aDest, dstW, chrDstW); } else { //General YV12 c->yuv2yuvX(c, vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, uDest, vDest, aDest, dstW, chrDstW); } } else { assert(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); assert(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); if (vLumFilterSize == 1 && vChrFilterSize == 2) { //unscaled RGB int chrAlpha= vChrFilter[2*dstY+1]; if(flags & SWS_FULL_CHR_H_INT) { yuv2rgbXinC_full(c, //FIXME write a packed1_full function vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, dstW, dstY); } else { c->yuv2packed1(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1), alpPixBuf ? *alpSrcPtr : NULL, dest, dstW, chrAlpha, dstFormat, flags, dstY); } } else if (vLumFilterSize == 2 && vChrFilterSize == 2) { //bilinear upscale RGB int lumAlpha= vLumFilter[2*dstY+1]; int chrAlpha= vChrFilter[2*dstY+1]; lumMmxFilter[2]= lumMmxFilter[3]= vLumFilter[2*dstY ]*0x10001; chrMmxFilter[2]= chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001; if(flags & SWS_FULL_CHR_H_INT) { yuv2rgbXinC_full(c, //FIXME write a packed2_full function vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, dstW, dstY); } else { c->yuv2packed2(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1), alpPixBuf ? *alpSrcPtr : NULL, alpPixBuf ? *(alpSrcPtr+1) : NULL, dest, dstW, lumAlpha, chrAlpha, dstY); } } else { //general RGB if(flags & SWS_FULL_CHR_H_INT) { yuv2rgbXinC_full(c, vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, dstW, dstY); } else { c->yuv2packedX(c, vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, dstW, dstY); } } } } else { // hmm looks like we can't use MMX here without overwriting this array's tail const int16_t **lumSrcPtr= (const int16_t **)lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; const int16_t **chrSrcPtr= (const int16_t **)chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; const int16_t **alpSrcPtr= (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? (const int16_t **)alpPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize : NULL; if (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21) { const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if (dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi yuv2nv12XinC( vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, dest, uDest, dstW, chrDstW, dstFormat); } else if (isPlanarYUV(dstFormat) || dstFormat==PIX_FMT_GRAY8) { //YV12 const int chrSkipMask= (1<<c->chrDstVSubSample)-1; if ((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi if (is16BPS(dstFormat)) { yuv2yuvX16inC( vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, (uint16_t *) dest, (uint16_t *) uDest, (uint16_t *) vDest, (uint16_t *) aDest, dstW, chrDstW, dstFormat); } else { yuv2yuvXinC( vLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, uDest, vDest, aDest, dstW, chrDstW); } } else { assert(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); assert(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); if(flags & SWS_FULL_CHR_H_INT) { yuv2rgbXinC_full(c, vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, dstW, dstY); } else { yuv2packedXinC(c, vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, alpSrcPtr, dest, dstW, dstY); } } } } if ((dstFormat == PIX_FMT_YUVA420P) && !alpPixBuf) fillPlane(dst[3], dstStride[3], dstW, dstY-lastDstY, lastDstY, 255); #if COMPILE_TEMPLATE_MMX if (flags & SWS_CPU_CAPS_MMX2 ) __asm__ volatile(""sfence"":::""memory""); /* On K6 femms is faster than emms. On K7 femms is directly mapped to emms. */ if (flags & SWS_CPU_CAPS_3DNOW) __asm__ volatile(""femms"" :::""memory""); else __asm__ volatile(""emms"" :::""memory""); #endif /* store changed local vars back in the context */ c->dstY= dstY; c->lumBufIndex= lumBufIndex; c->chrBufIndex= chrBufIndex; c->lastInLumBuf= lastInLumBuf; c->lastInChrBuf= lastInChrBuf; return dstY - lastDstY; }",606,"static int rename ( swscale ) ( swscontext * c , uint8_t * src [ ] , int srcstride [ ] , int srcslicey , int srcsliceh , uint8_t * dst [ ] , int dststride [ ] ) { const int srcw = c -> srcw ; const int dstw = c -> dstw ; const int dsth = c -> dsth ; const int chrdstw = c -> chrdstw ; const int chrsrcw = c -> chrsrcw ; const int lumxInc = c -> lumxInc ; const int chrxinc = c -> chrxinc ; const enum pixelformat dstformat = c -> dstformat ; const enum pixelformat srcformat = c -> srcformat ; const int flags = c -> flags ; int16_t * vlumfilterpos = c -> vlumfilterpos ; int16_t * vchrfilterpos = c -> vchrfilterpos ; int16_t * hlumfilterpos = c -> hlumfilterpos ; int16_t * hchrfilterpos = c -> hchrfilterpos ; int16_t * vlumfilter = c -> vlumfilter ; int16_t * vchrfilter = c -> vchrfilter ; int16_t * hlumfilter = c -> hlumfilter ; int16_t * hchrfilter = c -> hchrfilter ; int32_t * lummmxfilter = c -> lummmxfilter ; int32_t * chrmmxfilter = c -> chrmmxfilter ; int32_t * alpmmxfilter = c -> alpmmxfilter ; const int vlumfiltersize = c -> vlumfiltersize ; const int vchrfiltersize = c -> vchrfiltersize ; const int hlumfiltersize = c -> hlumfiltersize ; const int hchrfiltersize = c -> hchrfiltersize ; int16_t * * lumpixbuf = c -> lumpixbuf ; int16_t * * chrpixbuf = c -> chrpixbuf ; int16_t * * alppixbuf = c -> alppixbuf ; const int vlumbufsize = c -> vlumbufsize ; const int vchrbufsize = c -> vchrbufsize ; uint8_t * formatconvbuffer = c -> formatconvbuffer ; const int chrsrcslicey = srcslicey >> c -> chrsrcvsubsample ; const int chrsrcsliceh = - ( ( - srcsliceh ) >> c -> chrsrcvsubsample ) ; int lastdsty ; uint32_t * pal = c -> pal_yuv ; int dsty = c -> dsty ; int lumbufindex = c -> lumbufindex ; int chrbufindex = c -> chrbufindex ; int lastinlumbuf = c -> lastinlumbuf ; int lastinchrbuf = c -> lastinchrbuf ; if ( ispacked ( c -> srcformat ) ) { src [ 0 ] = src [ 1 ] = src [ 2 ] = src [ 3 ] = src [ 0 ] ; srcstride [ 0 ] = srcstride [ 1 ] = srcstride [ 2 ] = srcstride [ 3 ] = srcstride [ 0 ] ; } srcstride [ 1 ] <<= c -> vchrdrop ; srcstride [ 2 ] <<= c -> vchrdrop ; debug_buffers ( "" \n "" , src [ 0 ] , srcstride [ 0 ] , src [ 1 ] , srcstride [ 1 ] , src [ 2 ] , srcstride [ 2 ] , src [ 3 ] , srcstride [ 3 ] , dst [ 0 ] , dststride [ 0 ] , dst [ 1 ] , dststride [ 1 ] , dst [ 2 ] , dststride [ 2 ] , dst [ 3 ] , dststride [ 3 ] ) ; debug_buffers ( "" \n "" , srcslicey , srcsliceh , dsty , dsth ) ; debug_buffers ( "" \n "" , vlumfiltersize , vlumbufsize , vchrfiltersize , vchrbufsize ) ; if ( dststride [ 0 ] % 8 != 0 || dststride [ 1 ] % 8 != 0 || dststride [ 2 ] % 8 != 0 || dststride [ 3 ] % 8 != 0 ) { static int warnedalready = 0 ;",0,0,1,1,"srcw,dstw,dsth,chrdstw,chrsrcw,lumxinc,chrxinc,dstformat,srcformat,flags,vlumfilterpos,vchrfilterpos,hlumfilterpos,hchrfilterpos,vlumfilter,vchrfilter,hlumfilter,hchrfilter,lummmxfilter,chrmmxfilter,alpmmxfilter,vlumfiltersize,vchrfiltersize,hlumfiltersize,hchrfiltersize,lumpixbuf,chrpixbuf,alppixbuf,vlumbufsize,vchrbufsize,formatconvbuffer,chrsrcslicey,chrsrcsliceh,pal,dsty,lumbufindex,chrbufindex,lastinlumbuf,lastinchrbuf,src,0,1,2,3,srcstride,warnedalready","srcw:-0.12753599882125854,dstw:-0.11083590984344482,dsth:-0.11700457334518433,chrdstw:-0.06202256679534912,chrsrcw:-0.03586834669113159,lumxinc:-0.0001779794692993164,chrxinc:-0.0863807201385498,dstformat:-0.04899877309799194,srcformat:-0.08214950561523438,flags:-0.14491158723831177,vlumfilterpos:-0.08211261034011841,vchrfilterpos:-0.1244269609451294,hlumfilterpos:-0.05331307649612427,hchrfilterpos:-0.07563060522079468,vlumfilter:-0.073178231716156,vchrfilter:-0.1187288761138916,hlumfilter:-0.12872159481048584,hchrfilter:-0.1516551375389099,lummmxfilter:-0.07741272449493408,chrmmxfilter:-0.08532124757766724,alpmmxfilter:0.0,vlumfiltersize:0.0,vchrfiltersize:0.0,hlumfiltersize:0.0,hchrfiltersize:0.0,lumpixbuf:0.0,chrpixbuf:0.0,alppixbuf:0.0,vlumbufsize:0.0,vchrbufsize:0.0,formatconvbuffer:0.0,chrsrcslicey:0.0,chrsrcsliceh:0.0,pal:0.0,dsty:0.0,lumbufindex:0.0,chrbufindex:0.0,lastinlumbuf:0.0,lastinchrbuf:0.0,src:-0.06907671689987183,0:0.0036423802375793457,1:0.003642261028289795,2:0.0036422014236450195,3:0.0036377906799316406,srcstride:-0.0562061071395874,warnedalready:-2.3245811462402344e-06,",1,2,"lumxinc:lumxInc,"
